[
    {
        "name": "Alternating Bit Protocol",
        "tags": [
            "Protocol"
        ],
        "use_non_container_lib": false,
        "description": "Simple model of some basic protocol for communication over loosy channel (alternating bit protocol). \n \n  Messages are sent from sender A to receiver B. Assume that the channel \n  from A to B is initialized and that there are no messages in transit. \n  Each message from A to B contains a data part and a one-bit sequence number, \n  i.e., a value that is 0 or 1. B has two acknowledge characters that it can send to \n  A: ACK0 and ACK1. We assume that the channel may corrupt a message and that there \n  is a way in which A and B can decide whether or not they have received a correct message. \n  How and to which extent that is possible is the subject of coding theory. When A sends \n  a message, it sends it continuously, with the same sequence number, until it receives \n  an acknowledgment from B that contains the same sequence number. When that happens, \n  A complements (flips) the sequence number and starts transmitting the next message. \n  When B receives a message that is not corrupted and has sequence number 0, it starts \n  sending ACK0 and keeps doing so until it receives a valid message with number 1. \n  Then it starts sending ACK1, etc. This means that A may still receive ACK0 when \n  it is already transmitting messages with sequence number one. (And vice-versa.) \n  It treats such messages as negative-acknowledge characters (NAKs). \n  The simplest behaviour is to ignore them all and continue transmitting.",
        "content": "channel K_in 0 ;\nchannel K_out 0 ;\nchannel L_in 0 ;\nchannel L_out 0 ;\nchannel send 0 ;\nchannel receive 0 ;\n\n/*-----------------------------------------------------Channel K & Channel L-------------------------------------------------------------------------------------*/\n \nvar v_fake;\n \nChanK() = ReadyK(); \nReadyK() = K_in?v{v_fake = v} -> ( ReadyK() [] K_out!v -> ReadyK());\n\nvar u_fake;\n\nChanL() = ReadyL(); \nReadyL() = L_in?u{u_fake = u} -> ( ReadyL() [] L_out!u -> ReadyL());\n\n\n/*-----------------------------------------------------Producer & Consumer-------------------------------------------------------------------------------------*/\n\nhvar pready_flag = 1;\nhvar produce0_flag = 0;\n\n\nProducer() = pready{ pready_flag = 1; produce0_flag = 0 } -> Produce0() [] \n\t\t\t pready{ pready_flag = 1; produce0_flag = 0 } -> Produce1();\nProduce0() = send!0{ produce0_flag = 1; pready_flag = 0 } -> Producer();\nProduce1() = send!1{ pready_flag = 0 } -> Producer();\n\n\n\nhvar consume0_flag = 0;\nhvar consume1_flag = 0;\nhvar cready_flag = 1;\n\nvar valuec_fake;\n\nConsumer() = ReadyC();\nReadyC() = cready{ cready_flag = 1;consume0_flag = 0; consume1_flag = 0} -> receive?value{valuec_fake = value} -> GotmsgC(value);\nGotmsgC(value) = ([ value == 0 ]consume0{ consume0_flag = 1;cready_flag = 0} -> ReadyC() [] [ value == 1 ]consume1{ consume1_flag = 1;cready_flag = 0 } ->  ReadyC());\n\n\n/*-----------------------------------------------------Sender & Receiver-------------------------------------------------------------------------------------*/\n\nvar sab = 0;\nvar rab = 1;\n\nvar values_fake;\n\nSender1() = ReadyS1();\nReadyS1() = send?value{values_fake = value} -> Sending1(value);\nSending1(value) = K_in!value -> Sending1(value) []\n\t\t\t\t  L_out?ack -> Waitack1(ack);\nWaitack1(ack) = [ ack != sab ]waitack1.0 -> Sending1(values_fake) []\n\t\t\t\t[ ack == sab ]waitack1.1{ sab = 1 - sab } -> ReadyS1();\n\nvar valuer_fake;\n\nReceiver1() = Waitmsg1();\nWaitmsg1() = L_in!rab -> Waitmsg1() []\n\t\t\t K_out?value{valuer_fake = value} -> GotmsgR1(value);\nGotmsgR1(value) = receive!value{ rab = 1 - rab } -> Waitmsg1();\t\n\n\nProtocol1() = ChanK() ||| ChanL() ||| Producer() ||| Consumer() ||| Sender1() ||| Receiver1();",
        "property_desc": [
            "The protocol is deadlock-free",
            "Consumer can get message",
            "Consumer will eventually get message",
            "Consumer will get message infinitely often",
            "If the first produced value is 0, then the first consumed value is 0"
        ],
        "properties": [
            "#assert Protocol1() deadlockfree;",
            "#define consume_got (consume0_flag == 1 || consume1_flag == 1);\n#assert Protocol1() reaches consume_got;",
            "#assert Protocol1() |=<> consume_got;",
            "#assert Protocol1() |=[]<> consume_got;",
            "#define pready_pro (pready_flag == 1);\n#define cready_pro (cready_flag == 1);\n#define produce0_pro (produce0_flag == 1);\n#define consume0_pro (consume0_flag == 1);\n#assert Protocol1() |=  (pready_pro U produce0_pro) -> ((cready_pro U consume0_pro) || ([] cready_pro)) ;"
        ],
        "path": "pat_examples/beem/Communication Protocols/Alternating Bit Protocol.csp"
    },
    {
        "name": "Bounded Retransmission Protocol(without timing aspects)",
        "tags": [
            "Protocol"
        ],
        "use_non_container_lib": false,
        "description": "The Bounded Retransmission Protocol is a protocol used in one of the Philips' products. \n  It is based on the well-known alternating bit protocol. It allows only bounded number of retransmissions of each frame (piece of a file). \n \n  The protocol works as follows: Messages are sent from a sender to a receiver. \n  Each message is assigned a sequence number to maintain order and track retransmissions. \n  The receiver acknowledges each successfully received message using an ACK. \n  If a message is lost or corrupted during transmission, the sender retransmits the message \n  until either an ACK is received or a maximum retransmission limit is reached. \n \n  The process begins with the sender transmitting the first packet. It starts a timer \n  and waits for an acknowledgment from the receiver. If the receiver successfully \n  receives the packet, it sends an ACK with the corresponding sequence number back to the sender. \n  The sender, upon receiving the ACK, moves on to the next packet. \n \n  If the sender does not receive an ACK within the timeout period, it retransmits the \n  same packet. This process continues until the packet is acknowledged or the \n  retransmission count exceeds the maximum limit. If the limit is exceeded, \n  the sender abandons the transmission of that packet and signals a failure to the \n  higher-level application.\n \n  This model does not include timing aspects.",
        "content": "#define SIZE 0;\t\t\t\t/* size of the channel*/\n#define REPEAT 3;\t\t\t/* maximal number of retransmissions*/\n#define MAX_FRAMES 5;\t\t/* maximal number of frames*/\n\n#define I_OK \t1;\t\t\t/**/\n#define I_NOK \t2;\t\t\t/**/\n#define I_DK \t3;\t\t\t/**/\n#define I_FST \t4;\t\t\t/**/\n#define I_INC \t5;\t\t\t/**/\n\n\nchannel Sin SIZE;\nchannel Sout SIZE;\nchannel toK SIZE;\t\t\t//F\nchannel fromK SIZE;\t\t\t//G\nchannel toL SIZE;\t\t\t//A\nchannel fromL SIZE;\t\t\t//B\nchannel timeout SIZE;\nchannel Rout SIZE;\nchannel shake SIZE;\nchannel shakePC SIZE;\n\nvar prod_n;\t\t\t\t\t\t\t\t\t\t\t\t/* How many chunks in a list*/\nvar sys_error = false;\t\t\t\t\t\t\t\t\t/* Consumer gets a wrong number of frames?*/\nvar res_pro;\nProducer() = []i:{1..MAX_FRAMES}@ready2send.i{ prod_n = i; } -> ProducerSend();\t\t/* Send MAX_FRAMES frames*/\nProducerSend() = Sin!prod_n -> Sout?result{res_pro = result;} -> (\n\t\t\t\t\t\t\t\t\t\t\t\t[result == I_OK] shakePC!0 -> Producer()\t\t\t\t/* success*/\n\t\t\t\t\t\t\t\t\t\t\t\t[]\t\n\t\t\t\t\t\t\t\t\t\t\t\t[result == I_NOK || result == I_DK]check2send -> ProducerSend()\t\t/* fail*/\n\t\t\t\t\t\t\t\t\t\t\t);\n\nvar c_m;\nvar c_n;\nConsumer() = Rout?m{c_m = m; c_n++;} -> GetMessage();\n\nGetMessage() = [c_m == I_FST || c_m == I_INC] get2ready.0 -> Consumer()\n\t\t\t\t[][c_m == I_NOK] get2ready.1{c_n = 0;} -> Consumer()\n\t\t\t\t[][c_m == I_OK] check -> (\n\t\t\t\t\t\t\t\t\t\t[c_n == prod_n]shakePC?0{c_n = 0;} -> Consumer()\n\t\t\t\t\t\t\t\t\t\t[] \n\t\t\t\t\t\t\t\t\t\t[c_n != prod_n] st_error{sys_error = true;} -> Stop\t\t\t\t\t\t/* Error*/\n\t\t\t\t\t\t\t\t\t);\n\nvar ab;\t\t\t//ab: alternating bit\nvar s_n;\t\t//n : number of chunks in the list \nvar s_i;\t\t//i : current chunk in the list \nvar counter;\t//counter : the retry number\n// we get the data from Producer (due to abstraction we are interested only in length)\nSender() = Sin?n{s_n = n; s_i = 1;} -> SenderIdle();\t\t\t//idle -> next_frame\n\nSenderIdle() = frame2send{counter = 0;} -> StartSending();\t//next_frame -> send\t\t\t\n\n/**\n *StartSending ()\n * toK : [I_FST][I_OK || I_NOK][AB]\n */\n \n //we send one frame to K -- no data, but we have to say whether it is first and/or last package\nStartSending() = [s_i == 1 && s_i == s_n] toK!(4+2+ab) ->  WaitAck()\n\t\t\t\t[][s_i  > 1 && s_i == s_n] toK!(2+ab) ->  WaitAck()\n\t\t\t\t[][s_i == 1 && s_i  < s_n] toK!(4+ab) ->  WaitAck()\n\t\t\t\t[][s_i  > 1 && s_i  < s_n] toK!ab ->  WaitAck();\n//now we wait for acknowledge\nWaitAck() = (fromL?0{ ab = 1 - ab;} -> ([s_i < s_n] success2frame{ s_i++;} -> SenderIdle()\t/* continue for the next chunk*/\n\t\t\t\t\t\t\t\t\t\t\t[]\t[s_i ==s_n] Sout!I_OK -> shake!0 -> Sender()\n\t\t\t\t\t\t\t\t\t\t  )\t\t/* Completed! Reset for next producer*/\n\t\t\t)\n\t\t\t[]\t[counter == REPEAT] timeout?0 -> (\t[s_i<s_n] Sout!I_NOK -> shake!0 -> Sender()\t/* failure in the transmission*/\n\t\t\t\t\t\t\t\t\t\t\t\t\t[][s_i==s_n] Sout!I_DK -> shake!0 -> Sender())\t/* Don't know about the transmission*/\n\t\t\t[]\t[counter < REPEAT] timeout?0{ counter++;} -> StartSending();\n\nvar r_v;\nvar exp_ab;\n//value & 4 == first, value & 2 == last, value & 1 == rab\nReceiver() = fromK?value{ r_v = value;} -> safe2received{exp_ab = r_v & 1;} -> FrameReceived()\n\t\t\t[] shake?0 -> Receiver();\n\n\nFrameReceived() =  [(r_v & 1) == exp_ab && (r_v & 2) == 2] Rout!I_OK -> toL!0{ exp_ab = 1 - exp_ab;} -> ReceiverIdle()\t\t\t/* Last chunk*/\n\t\t\t\t[]\t[(r_v & 1) == exp_ab && (r_v & 2) == 0 && (r_v & 4) == 0] Rout!I_INC -> toL!0{ exp_ab = 1 - exp_ab;} -> ReceiverIdle()\t/* middle chunk*/\n\t\t\t\t[]\t[(r_v & 1) == exp_ab && (r_v & 2) == 0 && (r_v & 4) == 4] Rout!I_FST -> toL!0{ exp_ab = 1 - exp_ab;} -> ReceiverIdle()\t/* first chunk*/\n\t\t\t\t[]\t[exp_ab != (r_v & 1)] toL!0 -> ReceiverIdle();\n//Idle status of receiver\nReceiverIdle() = (fromK?value{r_v = value;} -> FrameReceived())\t/* Not completed, continue receiving*/      /*!!!!IMPORTANT: change fromK?value to fromK?t_value to avoid cannot read datum from channel fromK */\n\t\t\t\t[][(r_v & 2) == 2] idle2ret -> shake?0 -> Receiver()\t\t/* Last chunk is received*/\n\t\t\t\t[]Rout!I_NOK -> shake?0 -> Receiver();\t\t\t\t\t\t// no guards?\n\nvar k_value;\t\t\t\t\nK() = toK?value{k_value = value;} -> (fromK!value -> K() [] timeout!0 -> K());\nL() = toL?0 -> (fromL!0 -> L()  [] timeout!0 -> L() );\n\n\nBRP() = Producer() ||| Consumer() ||| Sender() ||| Receiver() ||| K() ||| L ();",
        "property_desc": [
            "The protocol is deadlock-free",
            "Consumer gets a wrong number of frames (an error)",
            "If the producer sends message, it will eventually get some acknowledgement from the Sender process.",
            "If the producer sends message, it will eventually get positive acknowledgement (=send ok) from the Sender process."
        ],
        "properties": [
            "#assert BRP() deadlockfree;",
            "#define goal sys_error == true;\n#assert BRP() reaches goal;",
            "#assert BRP() |= ([](Sin.1 -> <>(Sout.I_OK || Sout.I_NOK || Sout.I_DK)));",
            "#assert BRP() |= ([](Sin.1 -> []<>(Sout.I_OK)));"
        ],
        "path": "pat_examples/beem/Communication Protocols/Bounded Retransmission Protocol.csp"
    },
    {
        "name": "Cambridge Ring Protocol",
        "tags": [
            "Protocol"
        ],
        "use_non_container_lib": false,
        "description": "The Cambridge Ring Protocol is a communication protocol for message passing between a Sender and a Receiver over a ring structure. \n  The Sender is responsible for sending messages or control signals to the Receiver. \n  - The Sender ensures that sequence numbers match before advancing.\n  - If sequence mismatches occur, the error is raised.\n  - The Sender reacts to errors or resets by transitioning to the SReset.\n  The Receiver process is responsible for receiving messages or control signals from the Sender and reacts to incoming signals.\n  - When the receiver is ready, it sends RDY signal to the buffer channel.\n  - The Receiver ensures that sequence numbers match before advancing.\n  - If sequence mismatches occur, the error is raised.\n  - The Receiver can transition to the RReset state when a reset signal is received.\n  And there is a buffer storing messages from the sender and the receiver and from the receiver to the sender:\n  - The buffer has potential message loss.\n  - Messages are removed from the buffer and sent to the other in FIFO order.\n  - The buffer must have space available for new messages before accepting them.\n  The protocol ensures reliable communication despite potential issues like data loss, synchronization errors, or channel faults.",
        "content": "// size of buffer K:\n#define K 3;\n// loosy channels\n#define LOSS 1;\n// error type 0,1,2,3\n#define ERROR 1;\n\nenum { RESET, RDY, NOTRDY, DATA, NODATA }; \n\n#define tr 8;\n\nchannel sRESET1 0;\nchannel sRESET2 0;\nchannel rRESET1 0;\nchannel rRESET2 0;\nchannel\tsRDY1 0;\nchannel sRDY2 0;\nchannel\tsNOTRDY1 0;\nchannel sNOTRDY2 0;\nchannel\trDATA1 0;\nchannel rDATA2 0;\nchannel\trNODATA1 0;\nchannel rNODATA2 0;\n\n\n/*-----------------------------------------------Sender & Receiver---------------------------------------------------------------------*/\nvar n = [-1,0]; \n\nhvar sqerror_flag = 0;\n\nvar sm_fake;\n\nSender() = SIdle();\n\nSIdle() = sRESET1?0 -> rRESET1!0{ n[0] = -1 } -> SIdle() []\n\t      sNOTRDY1?m{sm_fake = m} -> SQI(m) []\n\t\t  sRDY1?m{sm_fake = m} -> SQA(m) []\n\t\t  rRESET1!0 -> SReset();\n\nSQI(m) = [ m == (n[0] + 1)%4 ]sqi.0 -> SIdle() []\n\t\t [ m != (n[0] + 1)%4 ]sqi.1{ sqerror_flag = 1 } -> Skip;\n\t\t\t \nSReset() = sNOTRDY1?m{sm_fake = m} -> SReset() []\n\t\t   sRDY1?m{sm_fake = m} -> SReset() []\n\t\t   sRESET1?0{ n[0] = -1 } -> SIdle();\n\nSQA(m) = [ m == (n[0] + 1)%4 ]sqa.0{ n[0] = (n[0] + 1)%4 } -> SAdvance() []\n\t\t [ m != (n[0] + 1)%4 ]sqa.1{ sqerror_flag = 1 } -> Skip;\n\nSAdvance() = rNODATA1!n[0] -> SN() []\n          rDATA1!n[0] -> SE();\n\nSN() = rRESET1!0 -> SReset() []\n\t   sRESET1?0 -> rRESET1!0{ n[0] = -1 } -> SIdle() []\n\t   rDATA1!n[0] -> SE() []\n\t   sRDY1?m{sm_fake = m} -> SQN(m);\n\nSQN(m) = [ ERROR == 1 && m == n[0] ]rDATA1!n[0] -> SN() []\n\t\t [ ERROR != 1 && m == n[0] ]rNODATA1!n[0] -> SN() []\n\t\t [ m != n[0] ]sqn{ sqerror_flag = 1 } -> Skip;\n\nSE() = rRESET1!0 -> SReset() []\n\t   sRESET1?0 -> rRESET1!0{ n[0] = -1 } -> SIdle() []\n\t   [ ERROR == 2 ]sNOTRDY1?m{sm_fake = m} -> SQI(m) []\n\t   [ ERROR != 2 ]sNOTRDY1?m{sm_fake = m} -> SQE(m) []\n\t   sRDY1?m{sm_fake = m} -> SQE(m);\n\nSQE(m) =  [ m == n[0] ]rDATA1!n[0] -> SE() []\n\t\t  [ m == (n[0] + 1)%4 ]sqe{ n[0] = (n[0] + 1)%4 } -> SAdvance();\n\n\n\n\nhvar rqerror_flag = 0;\n\nReceiver() = RIdle();\n\nvar rm_fake;\n\nRIdle() = rRESET2?0 -> sRESET2!0{ n[1] = 0 } -> RIdle() []\n\t      rNODATA2?m{rm_fake = m} -> RQI(m) []\n\t\t  rDATA2?m{rm_fake = m} -> RQA(m) []\n\t\t  sRESET2!0 -> RReset() []\n\t\t  sRDY2!n[1] -> RE();\n\n \nRQI(m) = [ m == n[1] ]rqi.0 -> RIdle() []\n\t\t [ m != n[1] ]rqi.1{ rqerror_flag = 1 } -> Skip;\n\t\t \nRReset() = rDATA2?m{rm_fake = m} -> RReset() []\n\t\t   rNODATA2?m{rm_fake = m} -> RReset() []\n\t\t   rRESET2?0{ n[1] = 0 } -> RIdle();\n\nRQA(m) = [ m == n[1] ]rqa.0{ n[1] = (n[1] + 1)%4 } -> RAdvance() []\n\t\t [ m != n[1] ]rqa.1{ rqerror_flag = 1 } -> Skip;\n\t\t  \nRAdvance() = sNOTRDY2!n[1] -> RN() []\n\t\t\t sRDY2!n[1] -> RE();\n\nRN() = sRESET2!0 -> RReset() []\n\t   rRESET2?0 -> sRESET2!0{ n[1] = 0 } -> RIdle() []\n\t   sRDY2!n[1] -> RE() []\n\t   rDATA2?m{rm_fake = m} -> RQN(m);\n\nRQN(m) = ([ (m + 1)%4 == n[1] ]sNOTRDY2!n[1] -> RN()) []\n\t      [ (m + 1)%4 != n[1] ]rqn -> RN();\n \nRE() = sRESET2!0 -> RReset() []\n    rRESET2?0 -> sRESET2!0{ n[1] = 0 } -> RIdle() []\n    sRDY2!n[1] -> RE() []\n    rDATA2?m{rm_fake = m} -> RQE(m) []\n\t   rNODATA2?m{rm_fake = m} -> RQE2(m);\n \nRQE(m) = ([ (m + 1)%4 == n[1] ]sRDY2!n[1] -> RE()) []\n\t\t  [ ERROR == 3 && m == n[1] ]rqe.0 -> RAdvance() [] \n\t\t  [ ERROR != 3 && m == n[1] ]rqe.1{ n[1] = (n[1] + 1)%4 } -> RAdvance();\n\n\nRQE2(m) = [ m == n[1] ]rqe2.0 -> RIdle() []\n\t\t  [ m != n[1] ]rqe2.1{ rqerror_flag = 1 } -> Skip; \n\n\n\n/*------------------------------------------------StoR & RtoS-----------------------------------------------------------------------------*/\n\nvar sbuf[K];\nvar sbuf_act = 0;\n\nvar r_fake;\n\nStoR() = Q();\nQ() =  ([ sbuf_act != K ]rRESET1?0{ sbuf[sbuf_act] = RESET; sbuf_act = sbuf_act + 1 } -> Q()) []\n\t   ([ sbuf_act != K ]rDATA1?r{ sbuf[sbuf_act] = DATA + tr * r ; sbuf_act = sbuf_act + 1; r_fake = r } -> Q()) []\n\t   ([ sbuf_act != K ]rNODATA1?r{ sbuf[sbuf_act] = NODATA + tr * r ; sbuf_act = sbuf_act + 1; r_fake = r } -> Q()) []\n\t   ([ LOSS != 0 && sbuf_act != 0 ]pop_front{ \n\t   \t\t\t\t\t\t\t\t\t\t\t\tvar index = 0;\n\t   \t\t\t\t\t\t\t\t\t\t\t\twhile( index < sbuf_act - 1 )\n\t   \t\t\t\t\t\t\t\t\t\t\t\t{\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\tsbuf[index] = sbuf[index+1];\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\tindex = index + 1;\n\t   \t\t\t\t\t\t\t\t\t\t\t\t}\n\t   \t\t\t\t\t\t\t\t\t\t\t\tsbuf[index] = 0;\n\t   \t\t\t\t\t\t\t\t\t\t\t\tsbuf_act = sbuf_act - 1;\t   \n\t   \t   \t\t\t\t\t\t\t\t\t   } -> Q()) []\t   \t   \t\t\t\t\t\t\t\t\t  \t   \t   \t\t\t\t\t\t\t\t\t   \n\t   ([ sbuf_act != 0 && sbuf[0] == RESET]rRESET2!0{\n\t   \t\t   \t\t\t\t\t\t\t\t\t\t\t\tvar index = 0;\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\twhile( index < sbuf_act - 1 )\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsbuf[index] = sbuf[index+1];\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\tindex = index + 1;\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\tsbuf[index] = 0;\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\tsbuf_act = sbuf_act - 1;\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t } -> Q()) []\t\t\t\t\t\t\t\t\t\t\t  \n    ([ sbuf_act != 0 && (sbuf[0] % tr) == DATA ]rDATA2!(sbuf[0]/tr){\n\t   \t\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar index = 0;\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile( index < sbuf_act - 1 )\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsbuf[index] = sbuf[index+1];\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tindex = index + 1;\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsbuf[index] = 0;\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsbuf_act = sbuf_act - 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} -> Q()) []\n       ([ sbuf_act != 0 && (sbuf[0] % tr) == NODATA ]rNODATA2!(sbuf[0]/tr){\n\t   \t\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar index = 0;\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile( index < sbuf_act - 1 )\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsbuf[index] = sbuf[index+1];\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tindex = index + 1;\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsbuf[index] = 0;\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsbuf_act = sbuf_act - 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} -> Q());\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t \t\t\t\t\t\t\t\t\t\t\t\t\t\t \nvar rbuf[K];\nvar rbuf_act = 0;\n\nvar s_fake;\n\nRtoS() = P();\n\nP() =  ([ rbuf_act != K ]sRESET2?0{ rbuf[rbuf_act] = RESET; rbuf_act = rbuf_act + 1 } -> P()) []\n\t   ([ rbuf_act != K ]sRDY2?s{ rbuf[rbuf_act] = RDY + tr * s ; rbuf_act = rbuf_act + 1; s_fake = s } -> P()) []\n\t   ([ rbuf_act != K ]sNOTRDY2?s{ rbuf[rbuf_act] = NOTRDY + tr * s ; rbuf_act = rbuf_act + 1; s_fake = s } -> P()) []\n\t   ([ LOSS != 0 && rbuf_act != 0 ]pop_front{\n\t   \t\t\t\t\t\t\t\t\t\t\t\tvar index = 0;\n\t   \t\t\t\t\t\t\t\t\t\t\t\twhile( index < rbuf_act - 1 )\n\t   \t\t\t\t\t\t\t\t\t\t\t\t{\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\trbuf[index] = rbuf[index+1];\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\tindex = index + 1;\n\t   \t\t\t\t\t\t\t\t\t\t\t\t}\n\t   \t\t\t\t\t\t\t\t\t\t\t\trbuf[index] = 0;\n\t   \t\t\t\t\t\t\t\t\t\t\t\trbuf_act = rbuf_act - 1;\t   \n\t   \t   \t\t\t\t\t\t\t\t\t   } -> P()) []\n       ([ rbuf_act != 0 && rbuf[0] == RESET ]sRESET1!0{\n\t   \t\t   \t\t\t\t\t\t\t\t\t\t\t\tvar index = 0;\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\twhile( index < rbuf_act - 1 )\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\trbuf[index] = rbuf[index+1];\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tindex = index + 1;\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\trbuf[index] = 0;\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\trbuf_act = rbuf_act - 1;\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t} -> P()) []\t\t\t\t\t\t\t\t\t\t\t  \n\t   ([ rbuf_act != 0 && (rbuf[0] % tr) == RDY ]sRDY1!(rbuf[0]/tr){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar index = 0;\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile( index < rbuf_act - 1 )\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\trbuf[index] = rbuf[index+1];\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tindex = index + 1;\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\trbuf[index] = 0;\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\trbuf_act = rbuf_act - 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t } -> P()) []\n\t   ([ rbuf_act != 0 && (rbuf[0] % tr) == NOTRDY ]sNOTRDY1!(rbuf[0]/tr){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar index = 0;\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile( index < rbuf_act - 1 )\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\trbuf[index] = rbuf[index+1];\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tindex = index + 1;\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\trbuf[index] = 0;\n\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\trbuf_act = rbuf_act - 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} -> P());\n\n\n\n/*-----------------------------------------------------------------------------------------------------------------------------*/\n\nCambridge() = Sender() ||| Receiver() ||| StoR() ||| RtoS();\t\n\n/*-----------------------------------------------------------------------------------------------------------------------------*/",
        "property_desc": [
            "The protocol is deadlock-free",
            "Sender can get into an error state",
            "Receiver can get into an error state"
        ],
        "properties": [
            "#assert Cambridge() deadlockfree;",
            "#define goal_0 sqerror_flag == 1;\n#assert Cambridge() reaches goal_0;",
            "#define goal_1 rqerror_flag == 1;\n#assert Cambridge() reaches goal_1;"
        ],
        "path": "pat_examples/beem/Communication Protocols/Cambridge Ring Protocol.csp"
    },
    {
        "name": "Collision avoidance protocol",
        "tags": [
            "Protocol"
        ],
        "use_non_container_lib": false,
        "description": "We assume that a number of stations are connected on an Ethernet-like medium. \n  On top of this basic protocol we want to design a protocol without collisions. \n  In the protocol's operation, the master station begins by sending out queries to the slave stations, asking if they have any data to transmit. \n  This is done in a round-robin manner, ensuring that each slave station has the opportunity to respond without overlapping transmission attempts. \n  The slave stations listen for these requests and indicate their status by waiting for the master's turn. \n  If a slave station has data to send, it will respond accordingly, allowing the channel to be utilized efficiently and without conflict. \n  The provided model is rather simple, because it does not take the time aspects into consideration.",
        "content": "#define SIZE 0;\n#define N 2; // number of slave stations\n\nchannel to_medium\t\t\t\tSIZE;\nchannel from_medium[N+1]\t\tSIZE;\nchannel in[N+1]\t\t\t\t\tSIZE;\nchannel out[N+1]\t\t\t\tSIZE;\n\nvar wait[N+1] = [1(N+1)];\nhvar collision_occur = false;\t\n\n//temporary variables storing the channel read\nvar curr[N+1];\nvar t_i;\nvar t_m;\n\n//Data Fomate : [data][receiver][sender], data = {0,1}, receiver,sender = {0..N}, 0 indicates master\n//Example\t  \n//\t020:\tEnquery from Master to 2nd Slave\n//\t132:\tSend data from 2nd o 3rd slave\n\t\t\t\t\nMedium() = to_medium?m{ curr[0] = m;} -> Medium()\t\t\t\t\t\t\t\t\t\t/* Lost incoming message*/\n\t\t[] to_medium?m{ wait[0] = 0; curr[0] = m;} -> \n\t\t\t(\n\t\t\t\tto_medium?m2{ curr[0] = m2; collision_occur = true;} -> Stop\n\t\t\t\t[] got2cast{ t_i = 0;} -> BroadCast()\n\t\t\t);\n\t\t\n//BroadCast using round-robin fashion\n\nBroadCast() = []x:{0..N}@([x != curr[0]%10 && x == t_i]from_medium[x]!curr[0]{t_i++;} -> BroadCast())\n\t\t\t[][t_i == curr[0]%10]broad.1{ t_i++; } -> BroadCast()\n\t\t\t[][t_i != curr[0]%10 && t_i <= N]broad.2{ t_i++; } -> BroadCast()\n\t\t\t[][0 != curr[0]%10 && 0 == t_i]from_medium[0]!curr[0]{ t_i++; } -> BroadCast()\n\t\t\t[][t_i == N + 1]broad2wait{ wait[0] = 1;} -> Medium();\n\t\t\t\t\nSlave(i) = from_medium[i]?m{ wait[i] = 0; curr[i] = m; } -> \n\t\t(\n\t\t\t[(curr[i] % (10 * 10)) / 10 != i]got2wait.i.1{ wait[i] = 1; } -> Slave(i)\t\t\t\t\t\t\t\t/* The receiver is not 1*/\n\t\t[]\t[(curr[i] % (10 * 10)) / 10 == i && (curr[i] / (10 * 10)) != 0] out[i]!(curr[i]/(10*10)){ wait[i] = 1; } -> Slave(i)\t\t/*The receiver is 1 and it is a data transmission*/\n\t\t[] \t[(curr[i] % (10 * 10)) / 10 == i && (curr[i] / (10 * 10)) == 0] in[i]?m_in{curr[i] = m_in;} -> \n\t\t\t(\t\t\t\t\t\t\t/*The receiver is 1 and it is an enquery*/\n\t\t\t\t[m_in == 0] enq2wait.i.1{ wait[i] = 1; } -> Slave(i)\t/*User1 has not data to send*/\n\t\t\t[]\t[m_in != 0] to_medium!(i + (m_in%10) * 10 + ((m_in%100)/10)*100){ wait[i] = 1; } -> Slave(i) \n\t\t\t)\n\t\t);\nvar u_m[N];\nUser(i) = in[i]!0 -> User(i)\t\t\t\t\t\t/*Not interesting*/\n\t\t[]in[i]!(i%N+1 + (i%N+1) * 10 + (0) * 100) -> User(i)\n\t\t[]out[i]?m{u_m[i-1] = m;} -> ([i == m] got2wait.i -> User(i) [] [i != m] wrong_data.i -> Stop);\n\nvar next = 1;\nMaster() = to_medium!((0)+(next)*10+(0*10*10)) -> MasterWait();\nMasterWait() = [&&x:{0..N}@(wait[x] == 1)] wait2send{ next = next % N + 1;} -> Master() \n\t\t\t\t[] from_medium[0]?m{ t_m = m;} -> MasterWait();\n\nCollision() = (|||x:{1..N}@(Slave(x) ||| User(x))) ||| Medium() ||| Master();",
        "property_desc": [
            "A collision can occur",
            "The protocol is deadlock-free"
        ],
        "properties": [
            "#define goal collision_occur == true;\n#assert Collision() reaches goal;",
            "#assert Collision() deadlockfree;"
        ],
        "path": "pat_examples/beem/Communication Protocols/Collision Avoidance Protocol.csp"
    },
    {
        "name": "Optimized sliding window protocol",
        "tags": [
            "Protocol",
            "Timing"
        ],
        "use_non_container_lib": false,
        "description": "The i-protocol is a part of protocol stack; its purpose is to ensure ordered reliable duplex communication between sites. \n  At its lower interface it assumes unreliable (lossy) packet-based FIFO connectivity. To its upper interface it provides reliable packet-based FIFO connectivity. \n  A distinguished feature of the i-protocol is the rather sophisticated manner in which it attempts to minimize control-messages and retransmission overhead. \n  \n  The sender maintains a window of packets that can be sent without requiring an acknowledgment for each individual packet. And each packet is uniquely identified using sequence numbers which allows the receiver to detect any missing packets. When a packet is sent, the sender updates its state based on the responses it receives. \n  - If an ACK for a packet is received, the sender can slide the window to include new packets. \n  - If a NAK is received for a missing packet, the sender will retransmit the necessary packets to ensure that the receiver can assemble the complete message. \n  Additionally, a timeout mechanism is integrated; if the sender does not receive any acknowledgment for a predefined period, it will also retransmit packets based on the last acknowledged sequence to ensure the continuity of data flow.\n  The receiver validats incoming packets against expected sequence numbers. If a packet arrives out of order, the receiver will buffer it and send a NAK for the expected packet. Or, it sends ACK back to the sender.",
        "content": "#define SIZE 0;\n// W: Size of a window\n#define W    2; \n// SEQ: How many numbers are used to distinguish packets\n#define SEQ  3;\n\nchannel Get\t\t\tSIZE;\nchannel Put\t\t\tSIZE;\nchannel SAck\t\tSIZE;\nchannel SNak\t\tSIZE;\nchannel SData\t\tSIZE;\nchannel RAck\t\tSIZE;\nchannel RNak\t\tSIZE;\nchannel RData\t\tSIZE;\nchannel RCorrData\tSIZE;\nchannel Timeout\t\tSIZE;\n\nvar i;\nvar sent = 0;\nvar recseq = 0;\nvar lack = 0;\nvar recbuf[SEQ];\nvar nakd[SEQ];\n\nhvar get_message = false;\n\nvar t_m;\nvar t_send;\nvar t_recv;\n\nTimer = Timeout!0 -> Timer;\n\nProducer = ProducerWait(0);\n\nProducerWait(message) = wait2produce -> Get!message -> ProducerWait((message + 1) % SEQ);\n\nConsumer() = Put?message{get_message = true;} -> con2wait -> Consumer;\n\nMedium = //wait -> data\n\t\tSData?value{t_m = value} -> (\n\t\t\t\t\t\t\tRData!value -> dataOk2wait -> Medium\n\t\t\t\t\t\t[]\tdata2wait -> Medium\n\t\t\t\t\t\t[]\tRCorrData!value -> Medium\n\t\t\t\t\t\t)\n\t//wait -> ack\n\t[] RAck?value{t_m = value} -> \t(\n\t\t\t\t\t\t\tSAck!value -> ackOk2wait -> Medium\n\t\t\t\t\t\t[]\tack2wait -> Medium\n\t\t\t\t\t\t)\n\t//wait -> nak\n\t[]\tRNak?value{t_m = value} ->\t(\n\t\t\t\t\t\t\tSNak!value -> nakOk2wait -> Medium\n\t\t\t\t\t\t[]\tnak2wait -> Medium\n\t\t\t\t\t\t);\n\nSender = Ready2Send(1,0);\n\nReady2Send(sendseq, rack) = \n\t\t//wait -> ack\n\t\tSAck?value{t_send = value;} -> \t(\n\t\t\t\t\t\t\t//ack -> wait\n\t\t\t\t\t\t\t[(rack < sendseq && rack < value && value < sendseq) || (rack > sendseq && sendseq < value && value < rack)]ack2wait.1 -> Ready2Send(sendseq, value)\n\t\t\t\t\t\t[]\t//ack -> wait\n\t\t\t\t\t\t\t[(rack >= sendseq || rack >= value || value >= sendseq) && (rack <= sendseq || sendseq >= value || value >= rack)]ack2wait.2 -> Ready2Send(sendseq, rack)\n\t\t\t\t\t\t)\n\t[]\t//wait -> nak\n\t\tSNak?value{t_send = value;} ->\t(\n\t\t\t\t\t\t\t//nak -> wait\n\t\t\t\t\t\t\t[(rack < sendseq && rack < value && value < sendseq) || (rack > sendseq && sendseq < value && value < rack)]SData!value -> Ready2Send(sendseq, rack)\n\t\t\t\t\t\t[]\t//nak -> wait\n\t\t\t\t\t\t\t[(rack >= sendseq || rack >= value || value >= sendseq) && (rack<=sendseq || sendseq >= value || value >= rack)]nak2wait -> Ready2Send(sendseq, rack)\n\t\t\t\t\t\t)\n\t[]\t//wait -> timeout\n\t\tTimeout?0 ->\t(\n\t\t\t\t\t\t\t//timeout -> wait\n\t\t\t\t\t\t\t[(rack + 1) % SEQ != sendseq]SData!(rack+1)%SEQ -> Ready2Send(sendseq, rack)\n\t\t\t\t\t\t[]\t//timeout -> wait\n\t\t\t\t\t\t\t[(rack + 1) % SEQ == sendseq]timeout2wait -> Ready2Send(sendseq, rack)\n\t\t\t\t\t\t)\n\t[]\t//wait -> data && data -> wait\n\t\t[(rack + W) % SEQ > sendseq] Get?value{t_send = value;} -> SData!sendseq -> Ready2Send((sendseq+1)%SEQ, rack);\n\n\nReceiver = \t//wait -> data\n\t\t\tRData?value{t_recv = value;} -> \t(\n\t\t\t\t\t\t\t\t//data -> send_naks\n\t\t\t\t\t\t\t\t[value != (recseq + 1) % SEQ]rec_update.1{recbuf[value] = 1; i = (recseq+1)%SEQ;} -> SendNaks(value)\n\t\t\t\t\t\t\t\t//data -> put_data\n\t\t\t\t\t\t\t[]\t[value == (recseq + 1) % SEQ] Put!value{ recseq = (recseq + 1) % SEQ; sent = (sent + 1) % SEQ; } -> PutData()\n\t\t\t\t\t\t\t)\n\t\t[]\t//wait -> corr_data\n\t\t\tRCorrData?value{t_recv = value;} -> ( [nakd[value] == 0]RNak!value -> Receiver [] [nakd[value] == 1]corr2wait -> Receiver)\n\t\t[]\t//wait -> on_timeout\n\t\t\tTimeout?0{i = 0;} -> ReceiverTimeout();\n\t\t\t\nReceiverTimeout() =\t//on_timeout -> on_timeout\n\t\t\t\t\t[i < SEQ]time_update.1{nakd[i] = 0; i++;} -> ReceiverTimeout()\n\t\t\t\t\t//on_timeout -> timeout_ack\n\t\t\t\t[]\t[i == SEQ]RNak!(recseq+1)%SEQ{ nakd[(recseq + 1) % SEQ] = 1; } -> RAck!lack -> Receiver;\n\nSendNaks(value) = //send_naks -> send_naks\n\t\t\t\t\t[i != value && nakd[i] == 1]send_update.1{i = (i+1)%SEQ;} -> SendNaks(value)\n\t\t\t\t\t//send_naks -> send_naks\n\t\t\t\t[]\t[i != value && nakd[i] == 0]RNak!i{ nakd[i] = 1; i = (i+1)%SEQ;} -> SendNaks(value)\n\t\t\t\t\t//send_naks -> wait\n\t\t\t\t[]\t[i == value] naks2wait -> Receiver;\n\nPutData() =//put_data -> put_data\n\t\t\t[sent == W/2]RAck!recseq{ lack = recseq; sent = 0; } -> PutData() \n\t\t\t//put_data -> put_data\n\t\t[]\t[sent != W/2 && recbuf[(recseq+1)%SEQ]==1]Put!(recseq+1)%SEQ{ recseq = (recseq+1)%SEQ ; recbuf[recseq]=0; } -> PutData()\n\t\t\t//put_data -> wait\n\t\t[]\t[sent != W/2 && recbuf[(recseq+1)%SEQ] == 0] put2wait -> Receiver;\n\nIProtocol = Timer ||| Producer ||| Consumer ||| Medium ||| Sender ||| Receiver;",
        "property_desc": [
            "The consumer can get message",
            "The consumer will eventually get message",
            "The consumer will get message infinitely often",
            "If the medium transmits both data and acknowledgement correctly infinitelly often then the consumer will get message infinitely often",
            "The protocol is deadlock-free"
        ],
        "properties": [
            "#define goal1 get_message == true;\n#assert IProtocol reaches goal1;",
            "#define goal2 get_message == true;\t\t\n#assert IProtocol |= []<> goal2;",
            "#assert IProtocol |= (([]<>dataOk2wait && []<>nakOk2wait) -> []<>goal2);",
            "#assert IProtocol deadlockfree;"
        ],
        "path": "pat_examples/beem/Communication Protocols/Optimized Sliding Window Protocol.csp"
    },
    {
        "name": "Bopdp(Bang & Olufsen Power Down Protocol)",
        "tags": [
            "Protocol",
            "Controller"
        ],
        "use_non_container_lib": false,
        "description": "This protocol controls the transitions between stand-by mode and power on mode in the company's new series of products, where power consumption minimization is an important feature.\n \n  A typical B&O configuration consists of multiple components interconnected by links. Each component has two processors that can be in active or standby mode. The protocol ensures consistent standby operation and timely response to data and interrupts\n \n  The power down protocol entity communicates with its environment (AP processor, link drivers and interrupt handlers) via the protocol commands in the set: \n  {ap_down, ap_active, ap_down_ack, ap_down_nack, data, no_data, interrupt, noJnterrupt}. \n  - The ap_down command is sent from the AP processor and commands the IOP processor to enter stand by operation. \n  - The data command is sent from a link driver and indicates that meaningful input has been detected on the link, whereas the\n  - no_data command indicates that there is no input from the link.\n  - Likewise, the interrupt (no_interrupt) command is sent from from the link interrupt handler and indicates that an interrupt (or no interrupt) has been received at the link interrupt interface.\n  - ap_nctive is sent when the I0P3212 processor becomes active\n  - ap_down_ack is sent when it accepts to enter stand by mode\n  - ap_down_nack is sent when stand by cannot be entered. \n \n  Four major phases of the entity:\n  - Active rule: In the active phase, the IOP protocol entity must enter the check driver phase, whenever a ap_down command is received from the AP processor.\n  - Check driver rule: In the check driver phase, the IOP protocol entity commands the drivers to check whether or not meaningful data are received from the links. \n  - Stand by rule: Whenever an interrupt is received in the stand by phase, the IOP protocol entity must enter the check driver phase.\n  - Check interrupts rule: In the check interrupts phase, the protocol entity commands the interrupt handlers to check for pending interrupts. If no interrupts are pending, the stand by phase can safely be entered. Otherwise, the check driver phase is entered.",
        "content": "// Maximal number of aplication interrupts (255=unbounded).\n#define MAX_AP_INTS 7;\n// Maximal number of LSL interrupts (255=unbounded)\n#define MAX_LSL_INTS 7;\nvar cur = 0;\nvar sleeping = 0;\nvar sleep_op = 0;\nvar sw_stand_by = 0;\nvar generated_ap_interrupt = 0;\nvar lsl_command = 0;\nvar lsl_running = 0;\nvar lsl_data = 0;\nvar ap_interrupt = 0;\nvar enabled_lsl_interrupt = 0;\nvar lsl_interrupt = 0;\nvar lsl_interrupt_ex = 0;\nvar generated_lsl_interrupt = 0;\nvar some_running = 0;\nvar some_data = 0;\nvar some_interrupt = 0;\nvar no_lsl_ints = 0;\nchannel ap_down 0;\nchannel ap_actv 0;\nchannel ap_down_ack 0;\nchannel ap_down_nack 0;\nchannel calc 0;\n/*Process: AP   */\nActv(no_ap_ints)=ap_actv?0->Actv(no_ap_ints)[][no_ap_ints < MAX_AP_INTS]{generated_ap_interrupt = 1;}->Actv(no_ap_ints+1)[]ap_down!0->Prepare_ack(no_ap_ints);\nPrepare_ack(no_ap_ints)=ap_down!0->Prepare_ack(no_ap_ints)[]ap_down_nack?0->Actv(no_ap_ints)[]ap_down_ack?0->Stand_by(no_ap_ints);\nStand_by(no_ap_ints)=standby->Actv(no_ap_ints)[]ap_actv?0->Actv(no_ap_ints);\n\n/*Process:LSL_Interrupt_Handler   */\nLSL_int_service()=[cur==0 && enabled_lsl_interrupt==1 && generated_lsl_interrupt == 1]{cur =1; lsl_interrupt_ex =1;}->LSL_Interrupt_received();\nLSL_Interrupt_received()=[cur==1 && sleeping ==0]lsl_received_wake->LSL_Awake()[][cur==1 && sleeping==1]{sleeping =0;}->LSL_Awake();\nLSL_Awake()=[cur==1]{enabled_lsl_interrupt = 0; generated_lsl_interrupt = 0; lsl_interrupt = 1; lsl_interrupt_ex =0; some_interrupt = 1;}->LSL_Check_stand_by();\nLSL_Check_stand_by()=[cur==1 && sw_stand_by==0]{cur = 0;}->LSL_int_service()[][cur == 1 && sw_stand_by==1]lsl_stand_noop->LSL_Insert_noop();\nLSL_Insert_noop()= [ cur == 1]{sleep_op = 0;}->LSL_Clear_stand_by();\nLSL_Clear_stand_by()=[cur ==1]{sw_stand_by=0; cur =0;}->LSL_int_service();\n\n/*Process:AP_Interrupt_Handler   */\nAp_int_service(old_cur)=[generated_ap_interrupt == 1 && lsl_interrupt_ex == 0]{generated_ap_interrupt = 0;}->AP_Set_cur(old_cur);\nAP_Set_cur(old_cur)= [cur==0]{cur=2;}->AP_Interrupt_received(0)[][cur==1]{ cur=2;}->AP_Interrupt_received(1);\nAP_Interrupt_received(old_cur)=[sleeping==0]AP_re_awake->AP_Awake(old_cur)[][sleeping==1]{sleeping=0;}->AP_Awake(old_cur);\nAP_Awake(old_cur)={enabled_lsl_interrupt =0; generated_lsl_interrupt=0; ap_interrupt =1; some_interrupt=1;}->AP_Check_stand_by(old_cur);\nAP_Check_stand_by(old_cur)=[sw_stand_by==0]ap_by_cr->AP_Reset_cur(old_cur)[][sw_stand_by==1]ap_by_noop->AP_Insert_noop(old_cur);\nAP_Insert_noop(old_cur)={sleep_op=0;}->AP_Clear_stand_by(old_cur);\nAP_Clear_stand_by(old_cur)={sw_stand_by = 0;}->AP_Reset_cur(old_cur);\nAP_Reset_cur(old_cur)=[old_cur == 0]{cur=0;}->Ap_int_service(old_cur)[][old_cur == 1]{cur=1;}->Ap_int_service(old_cur);\n\n/*Process:Interrrupt_Generator         */\nInterrupt_Generator()=[enabled_lsl_interrupt==1 && no_lsl_ints< MAX_LSL_INTS]{generated_lsl_interrupt =1; no_lsl_ints = no_lsl_ints+1;}->Interrupt_Generator();\n\n/*process:LSL_Driver()        */\nLSL_Driver_Stand_by()=[cur==0 && lsl_command==3]{lsl_command=0;}->LSL_Driver_Stand_by()[][cur==0 && lsl_command==1]{lsl_command=0;}->LSL_Driver_Up_down_received()[][cur==0 && lsl_command==2]{lsl_command=0;}->LSL_Driver_Up_down_received();\nLSL_Driver_Up_down_received()=[cur==0]lsl_diver_re->LSL_Driver_React();\nLSL_Driver_React()=[cur==0]{lsl_running=0; lsl_data=0;}->LSL_Driver_Call()[][cur==0]{lsl_running=1; lsl_data=1; some_running=1; some_data=1;}->LSL_Driver_Stand_by();\nLSL_Driver_Call()=calc!0->LSL_Driver_Stand_by();\n\n/*process:Calc      */\nCalc()=calc?0->Calc_data();\nCalc_data()=[lsl_data==1]cal_data->Calc_running()[][lsl_data==0]{some_data = 0;}->Calc_running();\nCalc_running()=[lsl_running==1]cal_run->Calc()[][lsl_running==0]{some_running =0;}->Calc();\n\n/*process:IOP     */\nIOP_Active()=[cur==0]ap_down?0->IOP_down_received();\nIOP_down_received()= IOP_active->IOP_Going_down();\nIOP_Going_down()=[cur==0]{lsl_data=0; some_data=0; lsl_running=1; some_running=1;}->IOP_Clear_interrupts();\nIOP_Clear_interrupts()=[cur==0]{ap_interrupt=0; lsl_interrupt =0; some_interrupt =0;}->IOP_Enable_lsl_interrupt();\nIOP_Enable_lsl_interrupt()=[cur==0]{enabled_lsl_interrupt=1; generated_lsl_interrupt=0;}->IOP_Issue_down_lsl();\nIOP_Issue_down_lsl()=[cur==0]{lsl_command=2;}->IOP_Wait_for_down();\nIOP_Wait_for_down()=[cur==0 && some_running==0]IOP_down_exe->IOP_Down_expected()[][cur==0 && some_data==1]IOP_down_ex->IOP_Down_expected();\nIOP_Down_expected()=[cur==0 && some_data==1]IOP_down_int->IOP_Disable_lsl_interrupt()[][cur==0 && some_data==0]IOP_down_ver->IOP_Down_verified();\nIOP_Down_verified()=ap_down_ack!0->IOP_Insert_noop();\nIOP_Disable_lsl_interrupt()=[cur==0]{ enabled_lsl_interrupt = 0; generated_lsl_interrupt = 0;}->IOP_Issue_active_commands();\nIOP_Issue_active_commands()=[cur==0]{lsl_command=3;}->IOP_Send_nack();\nIOP_Send_nack()=ap_down_nack!0->IOP_Enter_active();\nIOP_Enter_active()=[cur==0]IOP_Ac->IOP_Active();\nIOP_Insert_noop()=[cur==0]{sleep_op = 1;}->IOP_Set_stand_by();\nIOP_Set_stand_by()=[cur==0]{sw_stand_by=1;}->IOP_Check_interrupts();\nIOP_Check_interrupts()=[cur==0 && some_interrupt == 0]IOP_inter_noop->IOP_Check_noop()[][cur==0 && some_interrupt ==1]IOP_inter_wake_up->IOP_Wake_up();\nIOP_Check_noop()=[cur==0 && sleep_op==0]IOP_noop_wake_up->IOP_Wake_up()[][cur==0 && sleep_op==1]{sleeping = 1;}->IOP_W_stand_by();\nIOP_W_stand_by()=[cur==0]IOP_standby->IOP_Stand_by();\nIOP_Stand_by()=[cur==0 && some_interrupt==1]IOP_by_Wake->IOP_Wake_up();\nIOP_Wake_up()=[cur==0]{sw_stand_by=0; lsl_data=0; some_data=0; lsl_running = 1; some_running = 1;}->IOP_Clear_int();\nIOP_Clear_int()=[cur==0]{ap_interrupt=0; lsl_interrupt = 0; some_interrupt = 0;}->IOP_Issue_lsl_up();\nIOP_Issue_lsl_up()=[cur==0]{lsl_command=1;}->IOP_Wait_init_response();\nIOP_Wait_init_response()=[cur==0 && some_running == 0]IOP_ini_exep->IOP_Data_expected()[][cur==0 && some_data == 1]IOP_ini_ex->IOP_Data_expected();\nIOP_Data_expected()=[cur==0 && some_data == 1]IOP_data_act->IOP_S_active()[][cur==0 && some_data == 0]IOP_Data_noise->IOP_Noise();\nIOP_S_active()=ap_actv!0->IOP_Now_wait();\nIOP_Now_wait()=[cur==0]IOP_now_wait->IOP_Active();\nIOP_Noise()=[cur==0]IOP_noise{ lsl_data=0; some_data=0; lsl_running=1; some_running=1;}->IOP_Re_enable_lsl_interrupt();\nIOP_Re_enable_lsl_interrupt()=[cur==0]{enabled_lsl_interrupt=1;}->IOP_Re_issue_lsl_down();\nIOP_Re_issue_lsl_down()=[cur==0]{lsl_command=2;}->IOP_Wait_response();\nIOP_Wait_response()=[cur==0 && some_running == 0]IOP_wait_sta->IOP_Observe_status()[][cur==0 && some_data == 1]IOP_b->IOP_Observe_status();\nIOP_Observe_status()= [cur==0 && some_data == 0]IOP_status_noop->IOP_Insert_noop()[][ cur==0 && some_data == 1]IOP_ober_in->IOP_Clear_lsl_interrupt();\nIOP_Clear_lsl_interrupt()= [cur==0]{enabled_lsl_interrupt = 0; generated_lsl_interrupt = 0;}->IOP_Send_active_command();\nIOP_Send_active_command()= ap_actv!0{lsl_command=3;}->IOP_Back_to_active();\nIOP_Back_to_active()= [cur==0]IOP_back_to_active->IOP_Active();\n\nBopdp()=Actv(0)|||IOP_Active()|||LSL_Driver_Stand_by()|||LSL_int_service()|||Ap_int_service(0)|||Interrupt_Generator()|||Calc();",
        "property_desc": [
            "Sleeping must not change from 0 to 1 while sleep op has the value 0.",
            "Every path from active to noise must pass through stand by.",
            "The variable sleeping must not change from 0 to 1 while lsl interrupt is 1 or ap interrupt is 1.",
            "It should not be possible to come from the node stand by to the node active without synchronizing on the channel ap active (The IOP cannot get from stand by mode to active mode without activating the AP.)",
            "The protocol is deadlock-free."
        ],
        "properties": [
            "#define interruptPre ((sleeping==0) && (sleep_op==0));\n#define notSleepGoal ((sleeping==0) ||(!(sleep_op==0)));\n#define sleepOP (!(sleep_op==0));\n#assert Bopdp() |= [] (interruptPre->sleepOP R notSleepGoal);",
            "#assert Bopdp() |= [] (IOP_active -> (IOP_standby R ( (! IOP_noise) || IOP_standby)));",
            "#define untreatedInterruptPre  ((sleeping==0) && (lsl_interrupt==1 || ap_interrupt==1));\n#define stillNotSleepGoal  ((sleeping==0) ||!((lsl_interrupt==1 || ap_interrupt==1)));\n#define interrupton (!(lsl_interrupt==1 || ap_interrupt==1));\n#assert Bopdp() |= [](untreatedInterruptPre->interrupton R stillNotSleepGoal);",
            "#assert Bopdp() |= [] (IOP_standby -> ((IOP_now_wait || IOP_back_to_active) R ( (! IOP_active) || (IOP_now_wait || IOP_back_to_active))));",
            "#assert Bopdp() deadlockfree;"
        ],
        "path": "pat_examples/beem/Controllers/Bopdp.csp"
    },
    {
        "name": "Elevator",
        "tags": [
            "Real World",
            "Controller"
        ],
        "use_non_container_lib": false,
        "description": "This model simulates a simple elevator system with a clever controller.\n  Under the control of a clever controller, the elevator cabin is moved between floors, while interacting with the environment (representing operation of people).\n  - If there's a request to serve, the cabin starts moving\n  - If the controller indicates a floor below the current cabin level, the cabin moves down one floor.\n  - If the controller indicates a floor above, the cabin moves up one floor.\n  - If the cabin is already at the desired floor, it does nothing\n  Clever controller chooses the next floor to be served to be the next requested one in the direction of the last cab movement, if there is no such floor then in direction oposite to the direction of the last cab movement.\n  - The clever controller records the current floor the elevator at.\n  - If the elevator reaches the bottom or the top, it changes the direction and goes back to searching.\n  - If there's a request at current floor, it does nothing.\n  - If there's no request at the current floor, it continues checking in the current direction.",
        "content": "// Number of served floors\n#define N 4;\n\nvar req[N];\nvar ctl_level;\nvar cab_level;\nvar flag;\nvar direction;\n\nCabin()=[flag>0]startup->Move();open{req[cab_level]=0;flag=0;}->Cabin();\n\nMove()=[ctl_level<cab_level]movedown{cab_level=cab_level-1;}->Move()\n       [][ctl_level>cab_level]moveup{cab_level=cab_level+1;}->Move()\n       [][ctl_level==cab_level]Skip;\n\nEnvironment()=[]x:{0..N-1}@([req[x]==0]read.x{req[x]=1;}->Environment());\n\nCleverController()=SearchClever();done1{flag=1;}->CleverController();\n\nSearchClever()=[flag==0]wait{ctl_level=ctl_level+(2*direction)-1;}->WorkClever();\n\nWorkClever()=([ctl_level<0||ctl_level==N]changedir{direction=1-direction;}->SearchClever())\n             [][ctl_level>=0&&ctl_level<N&&req[ctl_level]==1]Skip\n             []([ctl_level>=0&&ctl_level<N&&req[ctl_level]==0]keepcheck{ctl_level=ctl_level+(2*direction)-1;}->WorkClever());\n\nCleverElevator2()=Cabin()|||Environment()|||CleverController();",
        "property_desc": [
            "If level 1 is requested, it is served eventually.",
            "If level 1 is requested, it is served as soon as the cab passes the level 1.",
            "If level 1 is requested, the cab passes the level without serving it at most once.",
            "If level 0 is requested, the cab passes the level without serving it at most once.",
            "The cab will remain at level 1 forever from some moment.",
            "The system is deadlock-free."
        ],
        "properties": [
            "#define r0 (req[0]==1);\n#define r1 (req[1]==1);\n#define v0 (cab_level==0);\n#define v1 (cab_level==1);\n\n#assert CleverElevator2()|=[](r1->(<>(v1&&open)));",
            "#assert CleverElevator2()|=[](r1->(!v1 U(v1 U(v1&&open))));",
            "#assert CleverElevator2()|=[](r1->(!v1 U(v1 U(!v1 U(v1 U(v1&&open))))));",
            "#assert CleverElevator2()|=[](r0->(!v0 U(v0 U(!v0 U(v0 U(v0&&open))))));",
            "#assert CleverElevator2()|=<>([]v1);",
            "#assert CleverElevator2() deadlockfree;"
        ],
        "path": "pat_examples/beem/Controllers/Elevator2.csp"
    },
    {
        "name": "Gear Controller",
        "tags": [
            "Real World",
            "Controller",
            "Timing"
        ],
        "use_non_container_lib": false,
        "description": "The gear controller is a component in the real-time embedded system that operates in a modern vehicle. \n  The gear-requests from the driver are delivered over a communication network to the gear controller. \n  The controller implements the actual gear change by actuating the lower level components of the system, such as the clutch, the engine and the gear-box. \n  \n  The clutch receives inputs from two channels to instruct the clutch to open and close respectively. \n  If the clutch fails to open or close in given time, it raises errors. \n\n  The gearbox receives inputs from channel to request a gear set and sends signals if the gear is successfully set. \n  Similarly, the channel ReqNeu requests the neutral gear and sends signals if the gear is successfully released. \n  If the gearbox fails to set or release a gear, the errors arised. \n\n  The engine accepts incoming requests for synchronous speed, a specified torque level or zero torque on different channels. \n  The actual torque level or requested speed is not modeled since it does not affect the design of the gear controller. \n  The engine responds on the channels when the services have been completed. \n  Requests for specific torque levels (i.e. signal ReqTorque) are not answered, instead torque is assumed to increase immediately after the request. \n  If the engine fails to deliver zero torque or synchronous speed in time, it enters a specific state without responding to the request. \n  Similarly, if the engine regulates on synchronous speed in too long time, an error arises. \n\n  The interface receives service requests and keeps information about the current status of the gear controller and is responsible for requesting new gears.\n \n  The controller measures response times from the components to detect errors (as failures are not signaled).",
        "content": "//MAX\n#define MAX 5;\n\nvar tGB = 255;\nvar tC = 255;\nvar tE = 255;\nvar tGC = 255;\n\nvar toGear = 0;\nvar currentGear = 0;\n\nchannel OpenClutch 0;\nchannel CloseClutch 0;\nchannel ClutchIsOpen 0;\nchannel ClutchIsClosed 0;\nchannel ReqSet 0;\nchannel ReqNeu 0;\nchannel GearSet 0;\nchannel GearNeu 0;\nchannel ReqSpeed 0;\nchannel ReqTorque 0;\nchannel ReqZeroTorque 0;\nchannel TorqueZero 0;\nchannel SpeedSet 0;\nchannel ReqNewGear 0;\nchannel NewGear 0;\n\n/*------------------------------------------------------------------------------------------------------------------------------------------------------*/\n\nTimer() = [ tGB != 0 && tC != 0 && tE != 0 && tGC != 0 ]tick{ \n\t\t\tif( tGB != 255 ){ tGB = tGB - 1 }\n\t\t\tif( tC != 255){ tC = tC - 1 }\n\t\t\tif( tE != 255){ tE = tE - 1 }\n\t\t\tif( tGC != 255){ tGC = tGC - 1}\n\t\t\t} -> Timer();\n\n/*------------------------------------------------------------------------------------------------------------------------------------------------------*/\n\nhvar erroropen_flag;\nhvar errorclose_flag;\n\n//Clutch\nClutch() = CClosed(); \n \nCClosed() = OpenClutch?0{ tC = 3 } -> COpening();\n\nCOpening() = ([ tC <= 1 ]ClutchIsOpen!0{ tC = 255 } -> COpen()) []\n \t\t\t [ tC == 0 ]copening{ tC = 255; erroropen_flag = 1 } -> Skip;\n \t\t\t \nCOpen() = CloseClutch?0{ tC = 3 } -> CClosing();\n\nCClosing() = ([ tC <= 1 ]ClutchIsClosed!0{ tC = 255 } -> CClosed()) []\n \t\t\t [ tC == 0 ]cclosing{ tC = 255; errorclose_flag = 1 } -> Skip;\n\t\n\n\nhvar erroridle_flag;\nhvar errorneu_flag;\n\n//Gearbox\nGearbox() = Neutral(); \n\nNeutral() = ReqSet?0{ tGB = 6 } -> GClosing();\n\nGClosing() = ([ tGB == 0 ]gclosing{ tGB = 255; erroridle_flag = 1 } -> Skip) []\n\t\t\t ([ tGB <= 4 ]GearSet!0{ tGB = 255 } -> GIdle());\n\t\t\t \nGIdle() = ReqNeu?0{ tGB = 4 } -> GOpening();\n\nGOpening() = ([ tGB == 0 ]gopening{ tGB = 255; errorneu_flag = 1 } -> Skip) []\n\t\t\t ([ tGB <= 2 ]GearNeu!0{ tGB = 255 } -> Neutral());\n\n\nhvar errorspeed_flag;\n\n//Engine\nEngine() = EInitial();\n\nEInitial() = ReqSpeed?0{ tE = 4 } -> FindSpeed();\n\nETorque() = ReqZeroTorque?0{ tE = 8 } -> DecTorque();\n\nDecTorque() = [ tE == 0 ]dectorque -> ClutchOpen() []\n\t\t\t  ([ tE <= 5 ]TorqueZero!0{ tE = 255 } -> EZero());\n\t\t\t  \nClutchClose() = ([ tE == 0 ]clutchclose{ tE = 255; errorspeed_flag = 1 } -> Skip) []\n\t\t\t\t([ tE < 17 ]ReqTorque?0{ tE = 255 } -> ETorque());\n\t\t\t\t\nClutchOpen() = [ toGear == 0 ]clutchopen0 -> EInitial() []\n\t\t\t   ([ toGear != 0 ]clutchoepn1{ tE = 18 } -> ClutchClose());\n\t\t\t   \nESpeed() = [ tE == 0 ]espeed{ tE = 255 } -> ClutchOpen() []\n\t\t   ([ tE > 0 ]ReqTorque?0{ tE = 255 } -> ETorque());\n\t\t   \nFindSpeed() = [ tE == 0 ]findspeed -> ClutchOpen() []\n\t\t\t  ([ tE <= 3 ]SpeedSet!0{ tE = 10 } -> ESpeed());\n\t\t\t  \nEZero() = [ toGear == 0 ]ezero -> EInitial() []\n\t\t  ([ toGear != 0 ]ReqSpeed?0{ tE = 4 } -> FindSpeed());\n\n\n//Interface\nInterface() = IGear();\n\nIGear() = ([ currentGear < MAX ]ReqNewGear!1 -> GoUp()) []\n\t\t  ([ currentGear > -1 ]ReqNewGear!-1 -> GoDown());\n\t\t  \nGoUp() = NewGear?0{ currentGear = currentGear + 1 } -> IGear();\n\nGoDown() = NewGear?0{ currentGear = currentGear - 1 } -> IGear();\n\nhvar copenerror_flag;\nhvar gneuerror_flag;\nhvar gseterror_flag;\nhvar ccloseerror_flag;\n\n//Gear Control\nGearControl() = GCGear(); \n\nvar dir_fake;\nGCGear() = ReqNewGear?dir{ toGear =toGear + dir; dir_fake = dir } -> GCInitial();\n\nGCInitial() = ([ currentGear != 0 ]ReqZeroTorque!0{ tGC = 5 } -> CheckTorque()) []\n\t\t\t  ([ currentGear == 0 ]gcinitial -> ReqSyncSpeed());\n\t\t\t  \nCheckTorque() = ([ tGC > 0 ]TorqueZero?0 -> ReqNeuGear()) []\n\t\t\t\t([ tGC == 0 ]OpenClutch!0{ tGC = 4 } -> CheckClutch2());\n\t\t\t\t\nReqNeuGear() = ReqNeu!0{ tGC = 5 } -> CheckGearNeu();\n\nCheckGearNeu() = (GearNeu?0 -> ReqSyncSpeed()) []\n\t\t\t\t [ tGC == 0 ]checkgearneu{ tGC = 255; gneuerror_flag = 1 } -> Skip;\n\t\t\t\t \nGCClutchOpen2() = ReqNeu!0{ tGC = 5 } -> CheckGearNeu2();\n\nCheckGearNeu2() = ([ tGC == 0 ]checkgearneu2{ tGC = 255; gneuerror_flag = 1 } -> Skip) []\n\t\t\t\t  (GearNeu?0{ tGC = 0 } -> ReqSetGear2());\n\t\t\t\t  \nReqSyncSpeed() = ([ toGear == 0 ]reqsyncspeed -> GearChnlged()) []\n\t\t\t\t ([ toGear != 0 ]ReqSpeed!0{ tGC = 3 } -> CheckSyncSpeed());\t\t\n\t\t\t\t \nCheckClutch() = [ tGC == 0 ]checkclutch{ copenerror_flag = 1 } -> Skip []\n\t\t\t\t(ClutchIsOpen?0{ tGC = 0 } -> GCClutchOpen());\n\t\t\t\t\nReqSetGear2() = ([ toGear!= 0 ]ReqSet!0{ tGC = 7 } -> CheckGearSet2()) []\n\t\t\t\t([ toGear == 0 ]CloseClutch!0{ tGC = 4 } -> CheckClutchClosed2());\n\t\t\t\t\nCheckSyncSpeed() = ([ tGC > 0 ]SpeedSet?0 -> ReqSetGear()) []\n\t\t\t\t   ([ tGC == 0 ]OpenClutch!0{ tGC = 4 } -> CheckClutch());\n\t\t\t\t   \nReqSetGear() = ReqSet!0{ tGC = 7 } -> CheckGearSet1();\n\nGCClutchOpen() = ReqSet!0{ tGC = 7 } -> CheckGearSet2();\n\nCheckGearSet1() = (GearSet?0{ tGC = 0 } -> GCReqTorque()) []\n\t\t\t\t  ([ tGC == 0 ]checkgearset1{ tGC = 255; gseterror_flag = 1 } -> Skip);\n\t\t\t\t  \nCheckGearSet2() = ([ tGC == 0 ]checkgearset2{ tGC = 255; gseterror_flag = 1 } -> Skip) []\n\t\t\t\t  (GearSet?0{ tGC = 0 } -> GCClutchClose());\n\t\t\t\t  \nGCReqTorque() = ReqTorque!0 -> GearChnlged();\n\nCheckClutchClosed() = ( ClutchIsClosed?0{ tGC = 0 } -> GCReqTorque()) []\n\t\t\t\t\t  ([ tGC == 0 ]checkclutchclosed{ tGC = 255; ccloseerror_flag = 1 } -> Skip);\n\t\t\t\t\t  \nGCClutchClose() = CloseClutch!0{ tGC = 4 } -> CheckClutchClosed();\n\nGearChnlged() = NewGear!0{ tGC = 255 } -> GCGear();\n\nCheckClutchClosed2() = ([ tGC == 0 ]checkclutchclosed2{ tGC = 255; ccloseerror_flag = 1 } -> Skip) []\n\t\t\t\t\t   (ClutchIsClosed?0{ tGC = 0 } -> GearChnlged());\n\t\t\t\t\t   \nCheckClutch2() = ([ tGC == 0 ]checkclutch2{ tGC = 255; copenerror_flag = 1 } -> Skip) []\n\t\t\t\t ( ClutchIsOpen?0{ tGC = 0 } -> GCClutchOpen2());\n\t\t\t\t \n\n/*------------------------------------------------------------------------------------------------------------------------------------------------------*/\n\nGear() = Timer() ||| Clutch() ||| Gearbox() ||| Engine() ||| Interface() ||| GearControl();\n\n/*------------------------------------------------------------------------------------------------------------------------------------------------------*/",
        "property_desc": [
            "The system is deadlock-free.",
            "It is possible use MAX gear.",
            "Clutch open error.",
            "Clutch close error.",
            "Clutch speed error."
        ],
        "properties": [
            "#assert Gear() deadlockfree;",
            "#define maxgear currentGear == MAX;\n#assert Gear() reaches maxgear;",
            "#define error_open erroropen_flag == 1;\n#assert Gear() reaches error_open;",
            "#define error_close errorclose_flag == 1;\n#assert Gear() reaches error_close;",
            "#define error_speed errorspeed_flag == 1;\n#assert Gear() reaches error_speed;"
        ],
        "path": "pat_examples/beem/Controllers/Gear Controller.csp"
    },
    {
        "name": "Lego Brick Sorter",
        "tags": [
            "Real World",
            "Controller",
            "Timing"
        ],
        "use_non_container_lib": false,
        "description": "The example is a model of a sorter of bricks built using a Lego Mindstorms systems. \n  The Sorter consists of the following parts: 2 belts which are used to transport bricks, a light sensor which can detect passing bricks, an arm which can kick bricks from the belt, a button which is used to \"order\" bricks for processing. \n  The intended behaviour of the system is the following. \n  - Bricks are placed by the user on the first belt. \n  - Bricks which are too long (length is detected with the use of light sensor) are kicked out from the belt by the arm. \n  - Short bricks are transported to the second belt. \n  - The second belt transports them either to a \"processing\" side or to a \"not-processing\" side depending on whether a brick has been ordered by pressing the button. \n  Although the system is rather simple and artificial, it has several features typical for embedded systems. \n  The token is used in this model to ensure the sequential execution of components. The model is discrete time.",
        "content": "////Scenario 1\n#define NUM_SHORT \t\t\t1;\nvar short[NUM_SHORT][2] = [6,0];\n#define NUM_LONG \t\t\t0;\n\n#define FWD\t\t\t\t \t1;\n#define\tREV\t\t\t\t\t2;\n#define SHORT\t\t\t\t3;\n#define LONG\t\t\t\t4;\n\n// artificial bounds\n#define MAX_REQ\t\t\t\t5;\n#define MAX_TIMER\t\t\t8;\n\n#define NOT_USED\t\t\t0;\n#define ON_BELT1 \t\t\t1;\n#define ON_BELT2 \t\t\t2;\n#define OUT_KICKED \t\t\t3;\n#define OUT_NOT_SELECTED \t4;\n#define OUT_SELECTED \t\t5;\n\n// Ensures sequential execution of processes\nvar token = 0;\nvar belt1_moving = FWD;\nvar belt2_moving = 0;\n\nvar arm_kicking = 0;\nvar light_sensor_level = 0;\nvar button_pressed = 0;\nvar put_short_brick = 0;\nvar put_long_brick = 0;\nvar requests = 0;\nvar timer = 0;\nvar brick = 0;\n\nButtonController() = [token == 0 && button_pressed == 0]button_update.1{token = 1;} -> ButtonController()\n\t\t\t\t\t[][token == 0 && button_pressed == 1 && requests < MAX_REQ]button_update.2{button_pressed = 0 ; requests = requests + 1; token = 1} -> ButtonController()\n\t\t\t\t\t[][token == 0 && button_pressed == 1 && requests == MAX_REQ]button_update.3{button_pressed = 0 ; token = 1;} -> ButtonController();\n\t\t\t\t\t\nArmController() = [token == 1 && !(brick == LONG && timer > 3)]arm_update.1{token=2;} -> ArmController()\n\t\t\t\t[][token == 1 && brick == LONG && timer > 3]arm_update.2{brick = 0; arm_kicking = 1; belt1_moving = 0; token = 2;} -> ([token == 1]arm_update.3{arm_kicking = 0; belt1_moving = 1; token = 2;} -> ArmController());\n\t\t\t\t\nvar t1 = 0;\nBelt2Controller() = [token == 2 && !(brick == SHORT && timer > 7)] b2_update.1{token = 3} -> Belt2Controller()\n\t\t\t\t [] [token == 2 && brick == SHORT && timer > 7] ready_temp{t1 = 0;} -> ([requests > 0] b2_update.2{belt2_moving = REV; token = 3;} -> Temp()\n\t\t\t\t \t\t\t\t\t\t\t\t\t\t\t\t\t\t[] [requests == 0] b2_update.3{belt2_moving = FWD; token = 3;} -> Temp());\n\nTemp() = [token == 2 && t1 < 4] temp_update.1{token = 3; t1++; } -> Temp()\n\t\t[][token == 2 && t1 == 4] temp_update.2{token = 3} -> Belt2Controller();\n\nvar light_x;\nLightController() = [token == 3 && light_sensor_level == 0] light_update.1{token = 4;} -> LightController()\n\t\t\t\t[] [token == 3 && light_sensor_level == 1] light_update.2{token = 4; light_x = 1;} -> LightChange();\n\nLightChange() =  [token == 3 && light_sensor_level == 1] lc1_update.1{token = 4; light_x++;} -> LightChange()\n\t\t\t\t[][token == 3 && light_sensor_level == 0] lc1_update.2{timer = 0;} -> ([light_x <= 2] lc1_update.3{brick = SHORT; token = 4;} -> LightController()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t[][light_x > 2] lc1_update.4{brick = LONG; token = 4;} -> LightController());\n\n\nTimerStep() = [token == 4 && timer < MAX_TIMER] timer_update.1{timer++; token = 5;} -> TimerStep()\n\t\t\t[][token == 4 && timer == MAX_TIMER] timer_update.2{token = 5;} -> TimerStep();\n\n// Simulates user actions, such as placing bricks or pressing the button.\nUser() =  [token == 5] user_update.1{token = 6;} -> User()\n\t\t[][token == 5] user_update.2{button_pressed = 1; token = 6;} -> User()\n\t\t[][token == 5] user_update.3{put_short_brick = 1; token = 6;} -> Wait(1)\n\t\t[][token == 5] user_update.4{put_long_brick = 1; token = 6;} -> Wait(3);\n\nWait(i) = [token == 5 && i > 0]wait_update.1{token = 6;} -> Wait(i-1)\n\t\t[][token == 5 && i == 0]wait_update.2{token = 6;} -> User();\n\nvar s_location[NUM_SHORT];\nvar s_position[NUM_SHORT];\nShortBrick(i) = [token == short[i][0] && s_location[i] == NOT_USED && put_short_brick == 0] short_update.1{token = short[i][1];} -> ShortBrick(i)\n\t\t\t[] [token == short[i][0] && s_location[i] == NOT_USED && put_short_brick == 1] short_update.2{put_short_brick =0;  token = short[i][1]; s_location[i] = 1; } -> ShortBrick(i)\n\t\t\t//moving forward\n  \t\t \t[] [token == short[i][0] && s_location[i] == ON_BELT1 && belt1_moving == FWD &&\t( \n  \t\t \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ts_position[i] < 3 || s_position[i] == 4 || \n  \t\t \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(\n  \t\t \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ts_position[i] > 5 && s_position[i] < 10\n  \t\t \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n  \t\t \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t) ]short_update.3{token = short[i][1]; s_position[i]++; } -> ShortBrick(i)\n  \t\t \t[] [token == short[i][0] && s_location[i] == ON_BELT1 && belt1_moving == FWD && s_position[i] == 3] short_update.4{light_sensor_level = 1; token = short[i][1]; s_position[i]++; } -> ShortBrick(i)\n  \t\t \t[] [token == short[i][0] && s_location[i] == ON_BELT1 && belt1_moving == FWD && s_position[i] == 5] short_update.5{light_sensor_level = 0; token = short[i][1]; s_position[i]++; } -> ShortBrick(i)\n  \t\t \t[] [token == short[i][0] && s_location[i] == ON_BELT1 && s_position[i] == 10 && arm_kicking == 0 && belt1_moving == FWD] short_update.6{ token = short[i][1]; s_position[i]++; } -> ShortBrick(i)\n  \t\t \t[] [token == short[i][0] && s_location[i] == ON_BELT1 && s_position[i] == 11 && arm_kicking == 0  && belt1_moving == FWD] short_update.7{ token = short[i][1]; s_location[i] = ON_BELT2; s_position[i] = 3; } -> ShortBrick(i)\n  \t\t \t// staying\n  \t\t \t[] [token == short[i][0] && s_location[i] == ON_BELT1 && belt1_moving == 0 && s_position[i] < 10] short_update.8{ token = short[i][1]; } -> ShortBrick(i)\n  \t\t \t[] [token == short[i][0] && s_location[i] == ON_BELT1 && belt1_moving == 0 && (s_position[i] == 10 || s_position[i] == 11) && arm_kicking == 0] short_update.9{ token = short[i][1]; } -> ShortBrick(i)\n  \t\t \t// arm kicking\n  \t\t \t[] [token == short[i][0] && s_location[i] == ON_BELT1 && (s_position[i] == 10 || s_position[i] == 11) && arm_kicking == 1] short_update.10{ token = short[i][1]; s_location[i] = OUT_KICKED; } -> ShortBrick(i)\n  \t\t \t//Belt2 moving\n  \t\t \t[] [token == short[i][0] && s_location[i] == ON_BELT2 && belt2_moving == FWD && s_position[i] < 5] short_update.11{ token = short[i][1]; s_position[i]++; } -> ShortBrick(i)\n  \t\t \t[] [token == short[i][0] && s_location[i] == ON_BELT2 && belt2_moving == REV && s_position[i] > 0] long_upadte.12{ token = short[i][1]; s_position[i]--; } -> ShortBrick(i)\n  \t\t \t[] [token == short[i][0] && s_location[i] == ON_BELT2 && belt2_moving == 0] short_update.13{ token = short[i][1]; } -> ShortBrick(i)\n  \t\t \t[] [token == short[i][0] && s_location[i] == ON_BELT2 && belt2_moving == FWD && s_position[i] == 5] short_update.13{ token = short[i][1]; s_location[i] = OUT_NOT_SELECTED; } -> ShortBrick(i)\n  \t\t \t[] [token == short[i][0] && s_location[i] == ON_BELT2 && belt2_moving == REV && s_position[i] == 0] short_update.14{ token = short[i][1]; s_location[i] = OUT_SELECTED; } -> ShortBrick(i)\n  \t\t \t//Out - just pass token\n  \t\t \t[] [s_location[i] == OUT_SELECTED || s_location[i] == OUT_NOT_SELECTED || s_location[i] == OUT_KICKED] short_update.15{ token = short[i][1]; } -> ShortBrick(i);\n  \t\t \t\nSorter() = \t(|||x:{0..NUM_SHORT-1}@ShortBrick(x))\n\t\t||| ButtonController() ||| ArmController() ||| Belt2Controller()\n\t\t||| LightController() ||| TimerStep() ||| User();",
        "property_desc": [
            "The system is dedalock-free."
        ],
        "properties": [
            "#assert Sorter() deadlockfree;"
        ],
        "path": "pat_examples/beem/Controllers/Lego Brick Sorter.csp"
    },
    {
        "name": "Production Cell",
        "tags": [
            "Real World",
            "Controller"
        ],
        "use_non_container_lib": false,
        "description": "The production cell processes metal blanks which are conveyed to a press by a feed belt. A sensor is installed indicating whether a blank has entered the belt. A robot takes each blank from the feed belt and places it into the press. The task of the press is to forge metal blanks. \n  The robot arm withdraws from the press, the press processes the metal blank and opens again. Finally, the robot takes the forged metal plate out of the press and puts it on a deposit belt. \n  The deposit belt will transport the work pieces unloaded by the second robot arm to the travelling crane. \n  The general sequence (from the perspective of a metal plate) is the following:\n  1. The feed belt conveys the metal plate to the elevating rotary table.\n  2. The elevating rotary table is moved to a position adequate for unloading by the first robot arm.\n  3. The first robot arm picks up the metal plate.\n  4. The robot rotates counterclockwise so that arm 1 points to the open press, places the metal plate into it and then withdraws from the press.\n  5. The press forges the metal blank and opens again.\n  6. The robot retrieves the metal plate with its second arm, rotates further and unloads the plate on the deposit belt.\n  7. The deposit belt transports the plate to the travelling crane.\n  8. The travelling crane picks up the metal plate, moves to the feed belt, and unloads the metal plate on it.",
        "content": "// Number of plates\n#define N  3;\n// Number of plates to process (0=not specified)\n#define MAX  1;\n#define EMPTY  255;\n\n#define UNDEF  -1;\n\nchannel plt_belt_0 0;\nchannel plt_table_0 0;\nchannel plt_press_0 0;\nchannel plt_deposit_0 0;\nchannel plt_belt_1 0;\nchannel plt_table_1 0;\nchannel plt_press_1 0;\nchannel plt_deposit_1 0;\nchannel plt_belt_2 0;\nchannel plt_table_2 0;\nchannel plt_press_2 0;\nchannel plt_deposit_2 0;\nchannel new_plate 0;\nchannel sen 0;\nchannel read 0;\nchannel put_table 0;\nchannel get_table 0;\nchannel put_press 0;\nchannel get_press 0;\nchannel put_deposit 0;\n\nvar done=0;\n// Plates will be transfered through the belt, the rotary table, the press and finally be deposited.\n//Process: Plate_0\nPlate_0()=new_plate!0->Plate_0_wait_belt();\n\nPlate_0_wait_belt()=plt_belt_0!UNDEF->Plate_0_wait_table();\n\nPlate_0_wait_table()=plt_table_0!UNDEF->Plate_0_wait_press();\n\nPlate_0_wait_press()=plt_press_0!UNDEF->Plate_0_wait_deposit();\n\nPlate_0_wait_deposit()=[done< MAX]plt_deposit_0!UNDEF{done=done+1;}->Plate_0();\n\n//Process: Plate_1\nPlate_1()=new_plate!1->Plate_1_wait_belt();\n\nPlate_1_wait_belt()=plt_belt_1!UNDEF->Plate_1_wait_table();\n\nPlate_1_wait_table()=plt_table_1!UNDEF->Plate_1_wait_press();\n\nPlate_1_wait_press()=plt_press_1!UNDEF->Plate_1_wait_deposit();\n\nPlate_1_wait_deposit()=[done< MAX]plt_deposit_1!UNDEF{done=done+1;}->Plate_1();\n\n//Process: Plate_2\nPlate_2()=new_plate!2->Plate_2_wait_belt();\n\nPlate_2_wait_belt()=plt_belt_2!UNDEF->Plate_2_wait_table();\n\nPlate_2_wait_table()=plt_table_2!UNDEF->Plate_2_wait_press();\n\nPlate_2_wait_press()=plt_press_2!UNDEF->Plate_2_wait_deposit();\n\nPlate_2_wait_deposit()=[done< MAX]plt_deposit_2!UNDEF{done=done+1;}->Plate_2();\n\n//Process: Belt\nBelt(m)=new_plate?k->Got_new(k);\n\nGot_new(k)=sen!UNDEF->Q1(k);\n\nQ1(k)=[k==0]plt_belt_0?UNDEF->Q2(k)\n   [][k==1]plt_belt_1?UNDEF->Q2(k)\n   [][k==2]plt_belt_2?UNDEF->Q2(k);\n\nQ2(k)=put_table!k->Belt(k);\n\n//Process: Sensor\nSensor(count)=sen?UNDEF->Sensor(count+1)\n       [][count>0]read!UNDEF->Sensor(count-1);\n\n//Process: Table\nTable(m)=put_table?k->Down_full(k);\n\nDown_full(k)=[k==0]plt_table_0?UNDEF->Up_full(k)\n        [][k==1]plt_table_1?UNDEF->Up_full(k)\n        [][k==2]plt_table_2?UNDEF->Up_full(k);\n\nUp_full(k)=get_table!k->Up_empty(k);\n\nUp_empty(k)=up_empty->Table(k);\n\n//Process: Press\nPress(m)=put_press?k->Pressing(k);\n\nPressing(k)=[k==0]plt_press_0?UNDEF->Done(k)\n         [][k==1]plt_press_1?UNDEF->Done(k)\n         [][k==2]plt_press_2?UNDEF->Done(k);\n\nDone(k)=get_press!k->Press(k);\n\n//Process: Deposit\nDeposit(m)=put_deposit?k->Loaded(k);\n\nLoaded(k)=[k==0]plt_deposit_0?UNDEF->Deposit(k)\n       [][k==1]plt_deposit_1?UNDEF->Deposit(k)\n       [][k==2]plt_deposit_2?UNDEF->Deposit(k);\n\n//Process: Robot\n// The robot comprises two orthogonal arms. \n// The robot's task consists in:\n// - taking metal blanks from the elevating rotary table to the press;\n// - transporting forged plates from the press to the deposit belt.\nRobot(A,B,at_press,at_table)=[(B==EMPTY && at_press==1) || (A==EMPTY && at_table==1)]robot_bpress->Bpress(A,B,at_press,at_table)\n         [][at_table==0]read?UNDEF->Robot(A,B,at_press,1)\n         [][(A!=EMPTY && at_press==0) || B!=EMPTY]robot_apress->Apress(A,B,at_press,at_table);\n\nBpress(A,B,at_press,at_table)=[B==EMPTY && at_press==1]get_press?k->Bpress(A,k,0,at_table)\n          [][A==EMPTY && at_table==1]bpress_atable->Atable(A,B,at_press,at_table)\n          [][(A!=EMPTY && at_press==0) || (B!=EMPTY && (A!=EMPTY || at_table==0))]bpress_wait->Robot(A,B,at_press,at_table);\n\nAtable(A,B,at_press,at_table)=[at_table==1 && A==EMPTY]get_table?k->Atable(k,B,at_press,0)\n          [][A !=EMPTY]atable_bpress->Bpress(A,B,at_press,at_table);\n\nApress(A,B,at_press,at_table)=[A!=EMPTY && at_press==0]put_press!A->Apress(EMPTY,B,1,at_table)\n          [][B!=EMPTY]apress_bdeposit->Bdeposit(A,B,at_press,at_table)\n          [][(A==EMPTY || at_press==1) && B==EMPTY]apress_robot->Robot(A,B,at_press,at_table);\n\nBdeposit(A,B,at_press,at_table)=[B!=EMPTY]put_deposit!B->Bdeposit(A,EMPTY,at_press,at_table)\n            [][B==EMPTY]bdep_apress->Apress(A,B,at_press,at_table);\n\n\nProduction_Cell()=Plate_0()|||Plate_1()|||Plate_2()|||Belt(0)|||Sensor(0)|||Table(0)|||Press(0)|||Deposit(0)|||Robot(EMPTY,EMPTY,0,0);",
        "property_desc": [
            "The system is deadlock-free.",
            "The requested number of plates has been processed. (meaningful only for MAX != 0)"
        ],
        "properties": [
            "#assert Production_Cell() deadlockfree;",
            "#define goal(MAX==done);\n#assert Production_Cell() reaches goal;"
        ],
        "path": "pat_examples/beem/Controllers/Production Cell.csp"
    },
    {
        "name": "Simple Controller of a Train Gate",
        "tags": [
            "Real World",
            "Controller"
        ],
        "use_non_container_lib": false,
        "description": "We consider a railway control system to automatically control trains passing a critical point such as a bridge. \n  The idea is to use a computer to guide trains from several tracks crossing a single bridge instead of building many bridges.\n  Assume that the whole system consists of n trains and a simple controller.\n  The controller manages the state of the bridge(free or occupied):\n  - When a train approaches the bridge, the controller checks if the bridge is empty.\n  - If the bridge is empty, the controller adds the train to the queue.\n  - If the bridge is occupied, the controller sends a stop signal to the approaching train.\n  Train:\n  - When a train approaches the bridge it sends a signal to the controller within a certain distance. \n  - If the bridge is occupied the controller sends a stop signal within 10 time units to prevent the train from entering the bridge. \n  - Otherwise, if the approaching train does not receive a stop signal within 10 time units, it will start to cross the bridge within certain time units. \n  - The crossing train is assumed to leave the bridge within 3 to 5 time units; a stopped train will slow down and eventually stop after some delay. \n  - When the bridge is free again and the controller signals (by sending `go`) the first train in the waiting list to cross.",
        "content": "//N, The number of trains + 1\n#define N 3;\n//An artificial error in the model (wrong bound)\n//#define ERROR 1;\n\nvar max_x = [0(N-1)];\n\n// x: the local time of the controller\nvar x = 0;\n\n//var e[N];\nvar e;\n\n\nchannel appr 0;\nchannel stop 0;\nchannel go 0;\nchannel leave 0;\nchannel is_empty 0;\nchannel notempty 0;\nchannel hd 0;\nchannel add 0;\nchannel rem 0;\n\n\n/*----------------------------------------------Clock----------------------------------------------------------*/\n\n\n//  The clock x were modeled by new process Clock and byte x is from 0 to 25.\nClock() = [ x <= max_x[0] && x <= max_x[1] ]\n\t\t\ttick{ x = x + 1 } -> Clock();\n\n\n\n/*-----------------------------------------Controller = Gate ||| INITQ-----------------------------------------------------------*/\n\nController() = Gate() ||| InitQ() ;\n\n\nGate() = Free();\n\nFree() = notempty?0 -> hd!0 -> go!0 -> Occ() [] is_empty?0 -> appr?0 -> add!0 -> Occ();\nS1() = rem?0 -> Free();\nS2() = add!0 -> Occ();\nS6() = stop!0 -> S2();\nOcc() = appr?0 -> S6() [] leave?0 -> S1();\n\n\n//InitQ manages a queue of trains waiting to cross the bridge.\nvar list[N];\nvar ln = 0;\nvar index = 0;\n\nInitQ() = Start();\n\nStart() = [ ln >= 1 ]rem!0{ ln = ln - 1; index = 0 } -> Shiftdown() []\n\t\t  [ ln == 0 ]is_empty!0 -> Start() []\n\t\t  ( add?0{ list[ln] = e; ln = ln + 1 } -> Start()) []\n\t\t  ( hd?0{e = list[0] } -> Start()) []\n \t\t  [ ln > 0 ]notempty!0 -> Start() ;\n\nShiftdown() = [ index < ln ]shiftdown.0{ list[index] = list[index+1]; index = index + 1 } -> Shiftdown() []\n\t\t      [ ln == index ]shiftdown.1{ list[index] = 0; index = 0 } -> Start() ;\n\t\t      \n/*------------------------------------------------------Train--------------------------------------------------------------*/\n\nhvar cross_flag =[0(N-1)];\n\nTrain(i) = SafeT(i);\n\nSafeT(i) = appr!0{ e = i; x = 0; max_x[i] = 20; } -> ApprT(i);\n\nStopT(i) = [e == i]go?0{ x = 0; max_x[i] = 15 } -> StarT(i);\t\t\t\t\n\nCrossT(i) = [x >= 3]leave!0{ e = i; x = 0; max_x[i] = 25; cross_flag[i] = 0 } -> SafeT(i);\n\nApprT(i) = ([x >= 10]apprT.0.i{ x = 0; max_x[i] = 5; if(x >= 3){ cross_flag[i] = 1 } } -> CrossT(i) []\n           ([x < 10 && e == i] stop?0{ x = 0; max_x[i] = 25 } -> StopT(i)));\n\nStarT(i) = [ x >= 5 ]starT.i{ x = 0; max_x[i] = 5; } -> CrossT(i);\n\n/*-----------------------------------------------------------------------------------------*/\n\nTrainGate() = Clock() ||| Controller() ||| (||| i:{0..N-2} @ Train(i)) ;\n\n/*-----------------------------------------------------------------------------------------*/",
        "property_desc": [
            "The system is deadlock-free.",
            "Collision on the cross (train 1 and train 2)",
            "Response property (whenever a train approaches the bridge, it will eventually cross) for the train 1."
        ],
        "properties": [
            "#assert TrainGate() deadlockfree;",
            "#define CROSS (cross_flag[0] == 1 && cross_flag[1] == 1);\n#assert TrainGate() reaches CROSS;",
            "#assert TrainGate() |= [] (appr.0 -> <> leave.0);"
        ],
        "path": "pat_examples/beem/Controllers/Simple Controller of a Train Gate.csp"
    },
    {
        "name": "Extinction",
        "tags": [
            "Algorithm",
            "Leader Election"
        ],
        "use_non_container_lib": true,
        "description": "Leader election algorithm for arbitrary networks based on echo wave algorithm and extinction technique. The model uses a fixed topology.\n  The echo algorithm is a centralized wave algorithm for undirected networks. The initiator starts by sending a message to all its neighbors. \nWhen a noninitiator receives a message for the first time, it makes the sender its parent, and sends a message to all neighbors except its parent. \nWhen a noninitiator has received messages from all its neighbors, it sends a message to its parent. Finally, when the initiator has received\nmessages from all its neighbors, it decides.\n  The idea is to let each initiator start a run of the echo algorithm, tagged with its ID. Only the wave started by the initiator with the largest\nID completes, after which this initiator becomes the leader. Noninitiators join the first wave that hits them. At any time, each process takes part \nin at most one wave. Suppose a process p that is participating in a wave tagged with q is hit by a wave tagged with r.\n  - If q<r, then p makes the sender its parent, changes to the wave tagged with r (it abandons all the wave messages it received earlier), and treats the incoming message accordingly.\n  - If q>r, then p continues with the wave tagged with q (it purges the incoming message).\n  - If q = r, then p treats the incoming message according to the echo algorithm of the wave tagged with q.\n  If the wave tagged with p completes, by executing a decide event at p, then p becomes the leader.",
        "content": "#import \"PAT.Lib.Extinction\";\n\n// The topology of the network (1 = line with 3 nodes, 2= line with 4 nodes, 3 = network of 4 nodes)\n#define TOPOLOGY 1;\n// Size of communication buffers\n#define K 2;\n#define N 3;\n\n#define UNDEF 255;\n#define TR 10;\n#define TOK 0;\n#define LDR 1;\n\nchannel ch[N] K;\n\nvar leaders_num = 0;\n\nstart(id, caw, rec, father, lrec, win, j) = ( [] x:{0..call(get_NC, id)-1} @ [j == x]ch[call(get_NCN, id, x)]!call(triple, TOK, id, id) -> start(id, caw, rec, father, lrec, win, j + 1) )\n\t\t\t\t\t\t\t\t\t            [] [j == call(get_NC, id)]START_WAIT.id -> wait(id, caw, rec, father, lrec, win, j);\n\nwait(id, caw, rec, father, lrec, win, j) = ch[id]?msg -> got_msg(id, caw, rec, father, lrec, win, j, msg)\n\t\t\t\t\t\t\t\t            [] [lrec == call(get_NC, id) && win == id]ELECT{leaders_num = leaders_num + 1;} -> leader(id, caw, rec, father, lrec, win, j)\n\t\t\t\t\t\t\t\t            [] [lrec == call(get_NC, id) && win != id]LOST.id -> lost(id, caw, rec, father, lrec, win, j);\n\nleader(id, caw, rec, father, lrec, win, j) = LEADER -> Skip;\n\nlost(id, caw, rec, father, lrec, win, j) = LOST -> Skip;\n\ngot_msg(id, caw, rec, father, lrec, win, j, m) = [call(first, m) == LDR]GOT_LDR_MSG.id -> ldr_msg(id, caw, rec, father, lrec, win, j, m)\n\t\t\t\t\t\t\t\t\t\t            [] [call(first, m) == TOK]GOT_TOK_MSG.id -> tok_msg(id, caw, rec, father, lrec, win, j, m);\n\ntok_msg(id, caw, rec, father, lrec, win, j, m) = [call(second, m) < caw]TOK_REIN.id -> reinicialize(id, call(second, m), 0, call(third, m), lrec, win, 0)\n\t\t\t\t\t\t\t\t\t\t            [] [call(second, m) == caw]TOK_SAME.id -> same(id, caw, rec + 1, father, lrec, win, j)\n\t\t\t\t\t\t\t\t\t\t            [] [call(second, m) > caw]TOK_WAIT.id -> wait(id, caw, rec, father, lrec, win, j);\n\nreinicialize(id, caw, rec, father, lrec, win, j) = ([] x:{0..call(get_NC, id)-1} @ [j == x]ch[call(get_NCN, id, x)]!call(triple, TOK, caw, id) -> reinicialize(id, caw, rec, father, lrec, win, j + 1))\n\t\t\t\t\t\t\t\t\t\t\t            [] [j == call(get_NC, id)]REIN_WAIT.id -> wait(id, caw, rec, father, lrec, win, j);\n\nsame(id, caw, rec, father, lrec, win, j) = [rec < call(get_NC, id)]SAME_WAIT.id -> wait(id, caw, rec, father, lrec, win, j)\n\t\t\t\t\t\t\t\t            [] [rec == call(get_NC, id)]SAME_ALL.id -> all(id, caw, rec, father, lrec, win, j);\n\nall(id, caw, rec, father, lrec, win, j) = ([] x:{0..N-1} @ [caw != id && father == x]ch[x]!call(triple, TOK, caw, id) -> wait(id, caw, rec, father, lrec, win, j))\n\t\t\t\t\t\t\t\t            [] [caw == id]ALL_BECOME_LEADER.id -> become_leader(id, caw, rec, father, lrec, win, 0);\n\nbecome_leader(id, caw, rec, father, lrec, win, j) = ([] x:{0..call(get_NC, id)-1} @ [j == x]ch[call(get_NCN, id, x)]!call(triple, LDR, id, id) -> become_leader(id, caw, rec, father, lrec, win, j + 1))\n\t\t\t\t\t\t\t\t\t\t\t            [] [j == call(get_NC, id)]BECOME_LEADER_WAIT.id -> wait(id, caw, rec, father, lrec, win, j);\n\nldr_msg(id, caw, rec, father, lrec, win, j, m) = [lrec == 0]LDR_MSG_ALL.id -> ldr_to_all(id, caw, rec, father, lrec, win, 0, m)\n\t\t\t\t\t\t\t\t\t\t            [] [lrec > 0]LDR_L2.id -> l2(id, caw, rec, father, lrec, win, j, m);\n\nldr_to_all(id, caw, rec, father, lrec, win, j, m) = ([] x:{0..call(get_NC, id)-1} @ [j == x]ch[call(get_NCN, id, x)]!call(triple, LDR, call(second, m), id) -> ldr_to_all(id, caw, rec, father, lrec, win, j + 1, m))\n\t\t\t\t\t\t\t\t\t\t\t            [] [j == call(get_NC, id)]LDR_L2 -> l2(id, caw, rec, father, lrec, win, j, m);\n\nl2(id, caw, rec, father, lrec, win, j, m) = L2_WAIT.id -> wait(id, caw, rec, father, lrec + 1, call(second, m), j);\n\nPROC() = {call(init_extinction, TOPOLOGY);} -> MAIN();\n\nMAIN() = ||| id:{0..N-1} @ start(id, id, 0, UNDEF, 0, UNDEF, 0);",
        "property_desc": [
            "Can the system reach more than one leader",
            "At least one leader will be elected"
        ],
        "properties": [
            "#define goal (leaders_num > 1);\n#assert PROC() reaches goal;",
            "#assert PROC |= <> ELECT;"
        ],
        "path": "pat_examples/beem/Leader Election Algorithms/Extinction.csp"
    },
    {
        "name": "Firewire tree",
        "tags": [
            "Protocol",
            "Leader Election"
        ],
        "use_non_container_lib": true,
        "description": "The tree identify process of IEEE 1394 is a leader election protocol which takes place after a bus reset in the network (i.e. when a node is added to, or removed from, the network). Immediately after a bus reset all nodes in the network have equal status, and know only to which nodes they are directly connected. A leader (root) needs to be chosen to act as the manager of the bus for subsequent phases of the 1394. The protocol is designed for use on connected networks, will correctly elect a leader if the network is acyclic, and will report an error if a cycle is detected.\n  In the IEEE 1394 standard, components connected to the bus are referred to as nodes. Each node has a number of ports which are used for bidirectional connections to (other) nodes. Each port has at most one connection. The tree identify phase follows on completion of the bus reset phase, which is for instance started whenever a connection is added or removed. The bus reset phase clears all topology information except local information on a node, i.e., which ports have connections. During the tree identify phase a spanning tree is constructed in the network.\n  Informally, the basic idea of the protocol is as follows: leaf nodes send a \u201cparent request\u201d message to their neighbor. When a node has received a parent request from all but one of its neighbors it sends a parent request to its remaining neighbor. In this way the tree grows from the leafs to a root. If a node has received parent requests from all its neighbors, it knows that it is has been elected as the root of the tree. The root node is also referred to as the leader or the bus master. \n  Let us consider the operation of the protocol in some more detail. During the tree identify phase every node goes through three stages. In the first stage, a node waits until it has received a parent request on all ports or on every port except one. Since leaf nodes have at most one connection, they can skip the first stage, and are thus responsible for starting up the algorithm. \n  In the second stage, a node acknowledges all the parent requests that it has received and sends a parent request on the remaining port (if any) on which it has not received a parent request. In figure 2, two links have been assigned as \u201cchild links\u201d and one parent request from a leaf node is still pending. In the third stage, if a node has received parent requests on all ports but has not sent a parent request itself, then it decides that it is the root of the tree and terminates. If a node that has sent a parent request receives an acknowledgement then it also terminates but decides that it has not been elected as the root. It is possible that two nodes send parent requests to each other; this situation is called root contention and is illustrated in figure 3. Whenever root contention occurs, the nodes that are involved retransmit their parent request after random timeouts and return to the beginning of the third stage. \n  If the network contains a cycle, then a node that is part of this cycle can never move to the second stage of the protocol because it will always have (at least) two neighbors from whom it has not received a parent request. In 1394, this deadlock situation is recognized with the help of timers. In principle, 1394 allows every node in the network to become the root of the tree, so even leaves in the network can be elected as leader. However, a node can increase its chances of becoming root by waiting long enough before moving to the second stage.",
        "content": "#import \"PAT.Lib.Firewire_tree\";\n// Topology: 0 = line with N nodes, 1 = fixed acyclic topology with 6 nodes, 2 = fixed cyclic topology with 6 nodes\n#define T 0;\n// Number of nodes\n#define N 4;\n\nvar connected[N * N];\nvar received[N * N];\n\n#define pair(x, y) (x * N + y);\n#define first(x) (x / N);\n#define second(x) (x % N);\n\nvar toss = 0;\n#define BE_MY_PARENT 1;\n#define BE_MY_CHILD 2;\n#define ACK 3;\nvar elected = N;\nvar elected_num = 0;\n\n#define UNDEF 255;\n\nchannel ch[N * N] 1;\n\nstart(id, j, n, m) = ([] x:{0..N-1} @ [call(adj, connected, id, N) == 1 && connected[call(pair, id, x)] == 1]start_found_partner.id -> found_partner(id, x, n, m)) \n\t            [] [call(adj, connected, id, N) > 1]start_wait_for_request.id -> wait_for_request(id, j, call(adj, connected, id, N), m); \n\nwait_for_request(id, j, n, m) = ([] x:{0..N-1} @ [x != id]ch[call(pair, x, id)]?msg -> wait_q(id, j, n, msg))\n\t\t\t\t            [] [n <= 1]wait_for_request_child_handshake.n.id -> child_handshake(id, 0, n, m); //WAIT_FOR_REQ_FIN.id -> \n\nwait_q(id, j, n, m) = [call(first, m) != BE_MY_PARENT || connected[call(pair, id, call(second, m))] != 1 || received[call(pair, id, call(second, m))] == 1]wait_q_error_st.id -> error_st(id, j, n, m)\n\t\t            [] [call(first, m) == BE_MY_PARENT && connected[call(pair, id, call(second, m))] == 1 && received[call(pair, id, call(second, m))] == 0]SET_RECEIVED_TRUE_wait_q_wait_for_request.id.m{received[call(pair, id, call(second, m))] = 1;} -> wait_for_request(id, j, n - 1, m); \n\nerror_st(id, j, n, m) = ERROR.id ->Stop;\n\nchild_handshake(id, j, n, m) = [j < N && received[call(pair, id, j)] == 0]child_handshake_child_handshake.id -> child_handshake(id, j + 1, n, m) \n\t\t\t\t\t            [] ([] x:{0..N-1} @ [x == j && received[call(pair, id, j)] == 1]ch[call(pair, id, x)]!call(pair, BE_MY_CHILD, id) -> child_handshake(id, j + 1, n, m))\n\t\t\t\t\t            [] [n == 0 && j == N]child_handshake_wait_for_acks.id -> wait_for_acks(id, j, n, m)\n\t\t\t\t\t            [] ([] x:{0..N-1} @ [n == 1 && j == N && connected[call(pair, id, x)] == 1 && received[call(pair, id, x)] == 0]ch[call(pair, id, x)]!call(pair, BE_MY_PARENT, id) -> wait_for_acks(id, j, n, m));\n\nwait_for_acks(id, j, n, m) = ([] x:{0..N-1} @ [x != id && received[call(pair, id, x)] == 1]ch[call(pair, x, id)]?msg-> wait_ack_q(id, j, n, msg))\n\t\t\t\t            [] [call(all_not_received, received, id, N) == 1]wait_for_acks_become_parent.id -> become_parent(id, j, n, m);\n\nwait_ack_q(id, j, n, m) = [call(first, m) != ACK]wait_ack_q_error_st.id -> error_st(id, j, n, m)\n\t\t\t\t            [] [call(first, m) == ACK]SET_RECEIVED_TRUE_wait_ack_q_wait_for_acks.id.m{received[call(pair, id, call(second, m))] = 0;} -> wait_for_acks(id, j, n, m);\n\nbecome_parent(id, j, n, m) = [n == 0]ELECTED.id{elected = id; elected_num = elected_num + 1;} -> finish(id, j, n, m)\n\t\t\t\t\t            [] [n == 1]become_parent_response.n.id -> response(id, j, n, m);\n\nfound_partner(id, j, n, m) = ([] x:{0..N-1} @ [x == j]ch[call(pair, id, x)]!call(pair, BE_MY_PARENT, id) -> response(id, j, n, m))\n\t\t\t            [] ([] x:{0..N-1} @ [x != id]ch[call(pair, x, id)]?msg -> found_q(id, j, n, msg));\n\nfound_q(id, j, n, m) = [call(first, m) == BE_MY_PARENT]SET_RECEIVED_TRUE_found_q_child_handshake.id.m{received[call(pair, id, call(second, m))] = 1;} -> child_handshake(id, j, 1, m)\n\t\t\t            [] [call(first, m) != BE_MY_PARENT]found_q_error_st.id -> error_st(id, j, n, m);\n\nresponse(id, j, n, m) = [] x:{0..N-1} @ [x != id]ch[call(pair, x, id)]?msg -> response_q(id, j, n, msg);\n\nresponse_q(id, j, n, m) = [call(first, m) == BE_MY_CHILD]response_q_become_child.id -> become_child(id, j, n, m)\n\t\t\t\t            [] [call(first, m) == BE_MY_PARENT]response_q_contention.id -> contention(id, j, n, m);\n\nbecome_child(id, j, n, m) = [] x:{0..N-1} @ [x == call(second, m)]ch[call(pair, id, x)]!call(pair, ACK, id) -> finish(id, j, n, m);\n\nfinish(id, j, n, m) = FINISH.id -> Skip;\n\ncontention(id, j, n, m) = [toss == 0]contention_winner.id{toss = 1} -> winner(id, j, n, m)\n\t\t\t\t            [] [toss == 1]contention_loser.id -> loser(id, j, n, m);\n\nwinner(id, j, n, m) = [] x:{0..N-1} @ [x == call(second, m)]ch[call(pair, id, x)]!call(pair, BE_MY_PARENT, id) -> response(id, j, n, m);\n\nloser(id, j, n, m) = [] x:{0..N-1} @ [x != id]ch[call(pair, x, id)]?msg -> loser_q(id, j, n, msg);\n\nloser_q(id, j, n, m) = [call(first, m) == BE_MY_PARENT]SET_RECEIVED_TRUE_loser_q_child_handshake.id.m{received[call(pair, id, call(second, m))] = 1;} -> child_handshake(id, j, 1, m);\n\nINIT(NO_USE) = {connected[0] = 0; received[0] = 0; connected[1] = 1; received[1] = 0; connected[2] = 0; received[2] = 0; connected[3] = 0; received[3] = 0; connected[4] = 1; received[4] = 0; connected[5] = 0; received[5] = 0; connected[6] = 1; received[6] = 0; connected[7] = 0; received[7] = 0; connected[8] = 0; received[8] = 0; connected[9] = 1; received[9] = 0; connected[10] = 0; received[10] = 0; connected[11] = 1; received[11] = 0; connected[12] = 0; received[12] = 0; connected[13] = 0; received[13] = 0; connected[14] = 1; received[14] = 0; connected[15] = 0; received[15] = 0; } -> Skip;\n\nPROC() = INIT(0);MAIN(0);\n\nMAIN(x) = ||| i:{0..N-1} @ start(i, UNDEF, UNDEF, UNDEF);",
        "property_desc": [
            "There can be two or more leaders. (this corresponds to error)",
            "The node0 will be elected as the leader",
            "The node2 will be elected as the leader"
        ],
        "properties": [
            "#define twoleaders (elected_num == 2);\n#assert PROC() reaches twoleaders;",
            "#define elected0 (elected == 0);\n#assert PROC() reaches elected0;",
            "#define elected1 (elected == 2);\n#assert PROC() reaches elected1;"
        ],
        "path": "pat_examples/beem/Leader Election Algorithms/Firewire tree.csp"
    },
    {
        "name": "Leader filter",
        "tags": [
            "Algorithm",
            "Leader Election"
        ],
        "use_non_container_lib": false,
        "description": "This model is leader election algorithm based on filters. \n  It demonstrate the basic principle of leader election through filters. It will terminate and not handle multiple elections.\n  A filter is a piece of code that satisfy the following conditions: \n    a) if m processes enter the filter, then at most m/2 processes exit; \n    b) if some process enter the filter, then at least one of them exits.",
        "content": "#define N_FIL 3;\t\t\t/*the number of the filters*/\n#define N_PRO 3;\t\t\t/*the number of the processes*/\n\nvar turn[N_FIL];\t\t\t/* For process p, when turn[i]==true indicates p can exit from the i-th filter */\nvar b[N_FIL];\t\t\t\t/* only the proess who exits can change the value*/\nvar c[N_FIL];\t\t\t\t/* c[i] == true indicates at least one process fails in i-th filter*/\nvar curr[N_FIL];\n\nhvar counter = 0;  \t\t\t/* which means how many leaders processes elect*/\n\nProcess(i) = Filter(i);\t/*i-th process begins to enter the 0-th filter*/\n\nFilter(i) = update.i.1{turn[curr[i]] = i;} -> ([b[curr[i]] == 0]update.i.2 -> update.i.2{ b[curr[i]] = 1;} -> Check(i));\t/*0-th process begins to enter the 0-th filter*/\n\t      \n/**\n * There are two states for process p in the i-th filter\n * If it is p's turn, then exit from the current filter, otherwise halt(fails in the i-th election).\n * Specially, if (x > 0 && c[x-1] == 0), it indicates that the current process is the only survivor from the previous filter,\n * so it is the last winner in this election.\n */\nCheck(i) = ([turn[curr[i]] != i] update.i.3 -> update.i.4{c[curr[i]] = 1;} -> update.i.5{b[curr[i]] = 0;} -> Stop)\t\t/* fail in the election */\n\t\t      [] ([turn[curr[i]] == i] update.i.6 -> (\n\t\t      \t\t\t\t\t\t\t\t\t\t[curr[i] > 0 && c[curr[i]-1] == 0]update.i.7 -> elected.i{counter++;} -> Stop\t/* new leader comes up, finish the election */\n\t\t      \t\t\t\t\t\t\t\t\t[]\t[curr[i] == 0 || c[curr[i]-1] == 1]update.i.8{curr[i]++;} -> Filter(i)\t/* exit from the i-th filter, continue*/\n\t\t      \t\t\t\t\t\t\t\t\t));\t\n\t\t      \n\nLeader_filter = |||x:{0..N_PRO-1}@Filter(x);",
        "property_desc": [
            "Whether two or more leaders are elected in one election",
            "In one election, only one can survive",
            "Whether 0-th process is eventually elected a leader",
            "The leader will be eventually elected",
            "The algorithm is deadlock-free"
        ],
        "properties": [
            "#define collision counter > 1;\t\t\t\t\t\n#assert Leader_filter() reaches collision;",
            "#define goal counter == 1;\n#assert Leader_filter() |= []<> goal;",
            "#assert Leader_filter() |= <> elected.0;",
            "#assert Leader_filter() |= <> (elected.0 || elected.1 || elected.2);",
            "#assert Leader_filter() deadlockfree;"
        ],
        "path": "pat_examples/beem/Leader Election Algorithms/Leader Election Algorithm Based on Filters.csp"
    },
    {
        "name": "Leader Filter-Unbounded version",
        "tags": [
            "Algorithm",
            "Leader Election"
        ],
        "use_non_container_lib": false,
        "description": "This model is leader election algorithm based on filters. \n  The unbounded version simulates a continuous election process and is closer to a real-world scenario where elections may need to happen repeatedly.\n  A filter is a piece of code that satisfy the following conditions: \n\ta) if m processes enter the filter, then at most m/2 processes exit; \n\tb) if some process enter the filter, then at least one of them exits. \n  The number of filters is doubled compared to the bounded version and the filters are in a circular fashion. It reuses the filters by using a sliding window. When the leader process is elected, the filters will be reset.\n  The unbounded version uses entry to control the filter where a process is started in next round.",
        "content": "#define N_FIL 3;\t\t\t\t/*the number of the filters*/\n#define N_PRO 3;\t\t\t\t/*the number of the processes*/\n\nvar turn[2 * N_FIL];\t\t\t/* For process p, when turn[i]==true indicates p can exit from the i-th filter */\nvar b[2 * N_FIL];\t\t\t\t/* only the proess who exits can change the value*/\nvar c[2 * N_FIL];\t\t\t\t/* c[i] == true indicates at least one process fails in i-th filter*/\n\nvar entry = 0;\t\t\t\t\t/*the first filter of the new election*/\n\nvar counter = 0;  \t\t\t\t/* which means how many leaders processes elect*/\n\nProcess0(i) = Filter0(i,i) ;\t/*0-th process begins to enter the 0-th filter*/\n\nFilter0(i,j) = update.0.1{turn[j] = 0;} -> (\n\t\t\t\t\t\t\t\t\t\t\t\t[ entry != i || b[j] == 0]\n\t\t\t\t\t\t\t\t\t\t\t\t\tifa (entry != i){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tready.0 -> Process0(entry)\t\t\t\t\t\t\t/*Ready for the next election*/\n\t\t\t\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tupdate.0.2{ b[j] = 1; } -> Check0(i,j)\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t);\t\t\t\t\t\t\t\t/*If exiting from all the filters, we consider the process as the leader by default*/\n\t\t      \n/**\n * There are two states for process p in the i-th filter\n * If it is p's turn, then exit from the current filter, otherwise halt(fails in the i-th election).\n * Specially, if (j > 0 && c[j-1] == 0), it indicates that the current process is the only survivor from the previous filter,\n * so it is the last winner in this election.\n */\nCheck0(i,j) = ifa( turn[j] != 0 ){\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\tupdate.0.3{c[j] = 1; b[j] = 0} -> ([entry != i] ready.0 -> Process0(entry))\t\t\t\t\t/* wait for the next election*/\n\t\t\t}else ifa( j > 0 && c[j-1] == 0){\n\t\t\t\telected.0{counter++;}  -> reset{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* New leader comes up, reset all for the next election*/\n\t\t      \t\t\t\t\t\t\t\tvar t = i;\n\t\t      \t\t\t\t\t\t\t\twhile (t < i + N_FIL){\n\t\t      \t\t\t\t\t\t\t\t\tturn[t] = 0;\n                                             b[t] = 0;\n                                             c[t] = 0;\n\t\t      \t\t\t\t\t\t\t\t\tt++\n\t\t      \t\t\t\t\t\t\t\t}\n\t\t      \t\t\t\t\t\t\t\tentry = (i+N_FIL)% (2 * N_FIL);\t\t\t\t\t\t\t\t\t/* update the entry, the begin filter of next election*/\n\t\t      \t\t\t\t\t\t\t\tcounter--;\n\t\t      \t\t\t\t\t\t\t} -> Process0(entry)\t\n\t\t\t}else{\n\t\t\t\texit.0.j -> Filter0(i,j+1)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* exit from the i-th filter, continue*/\t\n\t\t\t};\n\nProcess1(i) = Filter1(i,i) ;\t/*1-th process begins to enter the 1-th filter*/\n\nFilter1(i,j) = update.1.1{turn[j] = 1;} -> (\n\t\t\t\t\t\t\t\t\t\t\t\t[ entry != i || b[j] == 0]\n\t\t\t\t\t\t\t\t\t\t\t\t\tifa (entry != i){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tready.1 -> Process1(entry)\t\t\t\t\t\t\t/*Ready for the next election*/\n\t\t\t\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tupdate.1.2{ b[j] = 1; } -> Check1(i,j)\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t);\t\t\t\t\t\t\t\t/*If exiting from all the filters, we consider the process as the leader by default*/\n\t\t      \n/**\n * There are two states for process p in the i-th filter\n * If it is p's turn, then exit from the current filter, otherwise halt(fails in the i-th election).\n * Specially, if (j > 0 && c[j-1] == 0), it indicates that the current process is the only survivor from the previous filter,\n * so it is the last winner in this election.\n */\nCheck1(i,j) = ifa( turn[j] != 1 ){\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\tupdate.1.3{c[j] = 1; b[j] = 0} -> ([entry != i] ready.1 -> Process1(entry))\t\t\t\t\t/* wait for the next election*/\n\t\t\t}else ifa( j > 0 && c[j-1] == 0){\n\t\t\t\telected.1{counter++;}  -> reset{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* New leader comes up, reset all for the next election*/\n\t\t      \t\t\t\t\t\t\t\tvar t = i;\n\t\t      \t\t\t\t\t\t\t\twhile (t < i + N_FIL){\n\t\t      \t\t\t\t\t\t\t\t\tturn[t] = 0;\n                                             b[t] = 0;\n                                             c[t] = 0;\n\t\t      \t\t\t\t\t\t\t\t\tt++\n\t\t      \t\t\t\t\t\t\t\t}\n\t\t      \t\t\t\t\t\t\t\tentry = (i+N_FIL)% (2 * N_FIL);\t\t\t\t\t\t\t\t\t/* update the entry, the begin filter of next election*/\n\t\t      \t\t\t\t\t\t\t\tcounter--;\n\t\t      \t\t\t\t\t\t\t} -> Process1(entry)\t\n\t\t\t}else{\n\t\t\t\texit.1.j -> Filter1(i,j+1)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* exit from the i-th filter, continue*/\t\n\t\t\t};\n\nProcess2(i) = Filter2(i,i) ;\t/*2-th process begins to enter the 2-th filter*/\n\nFilter2(i,j) = update.2.1{turn[j] = 2;} -> (\n\t\t\t\t\t\t\t\t\t\t\t\t[ entry != i || b[j] == 0]\n\t\t\t\t\t\t\t\t\t\t\t\t\tifa (entry != i){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tready.2 -> Process2(entry)\t\t\t\t\t\t\t/*Ready for the next election*/\n\t\t\t\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tupdate.2.2{ b[j] = 1; } -> Check2(i,j)\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t);\t\t\t\t\t\t\t\t/*If exiting from all the filters, we consider the process as the leader by default*/\n\t\t      \n/**\n * There are two states for process p in the i-th filter\n * If it is p's turn, then exit from the current filter, otherwise halt(fails in the i-th election).\n * Specially, if (j > 0 && c[j-1] == 0), it indicates that the current process is the only survivor from the previous filter,\n * so it is the last winner in this election.\n */\nCheck2(i,j) = ifa( turn[j] != 2 ){\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\tupdate.2.3{c[j] = 1; b[j] = 0} -> ([entry != i] ready.2 -> Process2(entry))\t\t\t\t\t/* wait for the next election*/\n\t\t\t}else ifa( j > 0 && c[j-1] == 0){\n\t\t\t\telected.2{counter++;}  -> reset{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* New leader comes up, reset all for the next election*/\n\t\t      \t\t\t\t\t\t\t\tvar t = i;\n\t\t      \t\t\t\t\t\t\t\twhile (t < i + N_FIL){\n\t\t      \t\t\t\t\t\t\t\t\tturn[t] = 0;\n                                             b[t] = 0;\n                                             c[t] = 0;\n\t\t      \t\t\t\t\t\t\t\t\tt++\n\t\t      \t\t\t\t\t\t\t\t}\n\t\t      \t\t\t\t\t\t\t\tentry = (i+N_FIL)% (2 * N_FIL);\t\t\t\t\t\t\t\t\t/* update the entry, the begin filter of next election*/\n\t\t      \t\t\t\t\t\t\t\tcounter--;\n\t\t      \t\t\t\t\t\t\t} -> Process2(entry)\t\n\t\t\t}else{\n\t\t\t\texit.2.j -> Filter2(i,j+1)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* exit from the i-th filter, continue*/\t\n\t\t\t};\n\nLeader_filter = Process0(0) ||| Process1(0) ||| Process2(0);",
        "property_desc": [
            "Whether two or more leaders are elected in one election",
            "In one election, only one can survive",
            "Whether 0-th process is eventually elected a leader",
            "The leader will be eventually elected",
            "The algorithm is deadlock-free"
        ],
        "properties": [
            "#assert Leader_filter() reaches collision;",
            "#define goal counter == 1;\t\t\t\t\n#assert Leader_filter() |= []<> goal;",
            "#assert Leader_filter() |= <> elected.0;",
            "#assert Leader_filter() |= <> (elected.0 || elected.1 || elected.2);",
            "#assert Leader_filter() deadlockfree;"
        ],
        "path": "pat_examples/beem/Leader Election Algorithms/Unbounded Leader Election Algorithm Based on Filters.csp"
    },
    {
        "name": "Resistance",
        "tags": [
            "Real World"
        ],
        "use_non_container_lib": false,
        "description": "These three modeled systems simulates real complex system for testing the quality of the cables using in some Czech factories.\nOne device is intended for accurate measuring of resistance on cables. The other device generates high voltage and this device is \nin safety cage together with long cabels (for example 10 km) containing several wires. One computer maintains all other systems - \naccess to safety cage,safety lights, measuring of resistance, high voltage, results processing, etc.\n  * Algorithm simulates software for controlling all devices. \n  * Device_state shows the states in whitch the hardware for measuring resistance is. \n  * Measuring simulates the process of measuring resistance. \n  The software finds how are several wires conneted in cable using low voltage and resistance measuring, but this functionality is \nnot critical and therefore not modeled. The modeled Algorithm have to find the best range for the most accurate measuring. The \nAlgorithm system asks the Measuring system for actual_resistance using synchronization \"m?\". Then the Algorithm have to test the \nstate of the Device_state system (using qstate channel). When the state is \"Err7\" (the measured resistance is out of the range for sure), \nthe Algorithm and Device_state used \"err\" synchronization. When the state is ok, the \"ok\" synchronization is used.",
        "content": "// Number of measuring process\n#define N 1;\n\n// cage_safe==1 means that the cage around the high voltage devices is closed and therefore safe for people.\n// cage_safe==0 means that the cage around the high voltage devices is opened.\nvar cage_safe;\n// actual_resistance is the actual value of resistance which is obtained from Measuring system.\nvar actual_resistance;\nvar voltage;\nvar vInProg[N];\nvar tooLarge[N];\nvar tooSmall[N];\n \n// The algorithm have to find the best range for the most accurate measuring.\n// range is range for resistance measuring and should be from 0 to 5.\n//       0 coresponds to the smalest resistances\n//       5 coresponds to the largest resistances\n\nvar range;\n\n// Algorithm asks the Measuring system for actual_resistance using synchronization \"m?\".\n// Then the Algorithm have to test the state of the Device_state system (using qstate channel).\n// When the state is \"Err7\" (the measured resistance is out of the range for sure), the\n// Algorithm and Device_state used \"err\" synchronization. When the state is ok, the\n// \"ok\" synchronization is used.\n#define SIZE 0;\n\nchannel m\t\tSIZE;\nchannel qstate\tSIZE;\nchannel ok\t\tSIZE;\nchannel err\t\tSIZE;\n\nMeasuring(i) = measure_init.i{cage_safe = 1; vInProg[i] = 1;} -> MeasureInProgress(i);\t\t\t//initial -> measure_in_progress\n\nMeasureInProgress(i) =  // measure_in_progress -> measure_done\n\t\t\t\t\t  [cage_safe == 1]m!0{ vInProg[i] = 0;} -> (\n\t\t\t\t\t  \t\t\t\t\t\t\t\t//measure_done -> measure_in_progress\n\t\t\t\t\t\t\t\t\t\t\t\t\t[cage_safe == 1]done2progress.i{ vInProg[i] = 1;} -> MeasureInProgress(i)\n\t\t\t\t\t\t\t\t\t\t\t\t\t//measure_done -> cage_opened\t\tcage_opened -> measure_in_progress\n\t\t\t\t\t\t\t\t\t\t\t\t[]\t[cage_safe == 0]done2opened.i -> opened2progress.i{ cage_safe = 1; actual_resistance--; vInProg[i] = 1; } -> MeasureInProgress(i)\n\t\t\t\t\t\t\t\t\t\t\t\t) \n\t\t\t\t\t//measure_in_progress -> measure_in_progress\n\t\t\t\t\t[][actual_resistance < 6200 && cage_safe == 1] progress2progress.i{actual_resistance++; } -> MeasureInProgress(i)\n\t\t\t\t\t//measure_in_progress -> cage_opened\t\t\t\t\t\t\tcage_opened -> measure_in_progress\n\t\t\t\t\t[] progress2opened.i{ cage_safe = 0; actual_resistance--; vInProg[i] = 0;} -> opened2progress.i{ cage_safe = 1; actual_resistance--; vInProg[i] = 1;} -> MeasureInProgress(i);\n\t\t\t\t\t\nAlgorithm() = start2range{range = 3;} -> NewRange();\t\t/*start -> new_range*/\n\nNewRange() = m?0 -> qstate!0 -> (\t\t\t\t\t\t\t\t// new_range -> S1\tS1 -> S2\n\t\t\t\t\t\t\t\t\tok?0 -> Measured()\t\t\t// S2 -> measured\n\t\t\t\t\t\t\t\t[]\terr?0 -> LargeResistance()\t// S2 -> large_resistance\n\t\t\t\t\t\t\t\t); \n\nMeasured() = [actual_resistance > 999 && actual_resistance < 5999] measure_update.1{actual_resistance = 0;} -> CorrectValue()\t\t//measured -> correct_value\n\t\t[]\t[actual_resistance < 1000] measure_update.2{actual_resistance = 0;} -> SmallResistance()\t\t\t\t\t\t\t\t//measured -> small_resistance\n\t\t[]\t[actual_resistance > 5800] measure_update.3{actual_resistance = 0;} -> LargeResistance();\t\t\t\t\t\t\t\t//measured -> large_resistance\n\nCorrectValue() = correct2finished -> FinishedMeasuring();\t\t//correct_value -> finished_measuring\n\nSmallResistance() = [range > 0] small2range{range--;} -> NewRange()\t\t\t\t\t\t//small_resistance -> new_range\n\t\t\t\t[]\t[range == 0] toosmall{ tooSmall = 1;} -> small2finished{ tooSmall = 0;} -> FinishedMeasuring();\t\t//small_resistance -> too_small_resistance -> finished_measuring\n\nLargeResistance() = [range == 5] toolarge{ tooLarge = 1;} -> large2finished{ tooLarge = 0;} -> FinishedMeasuring()\t\t//large_resistance -> too_large_resistance -> finished_measuring\n\t\t\t\t[]\t[range < 5] large2range{range++;} -> NewRange();\t\t\t\t\t//large_resistance -> new_range\n\nFinishedMeasuring() = finished2start -> Algorithm();\n\nDeviceState() = qstate?0 -> (\t\t\t//initial -> state_request\n\t\t\t\t\t\t\t\trequest2err -> err!0 -> DeviceState()\t//state_request -> err7\n\t\t\t\t\t\t\t[]\trequest2state0 -> \t( \n\t\t\t\t\t\t\t\t\t\t\t\t\t\ts021{ cage_safe = 1; } -> ok!0 -> DeviceState()\n\t\t\t\t\t\t\t\t\t\t\t\t\t[]\tstate02err -> err!0 -> DeviceState()\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\nResistance() = (|||x:{0..N-1}@Measuring(x)) ||| Algorithm() ||| DeviceState();",
        "property_desc": [
            "The system is deadlock-free.",
            "When system Measuring is in the state measure_in_progress the system is under the high voltage. There should never happen that cage is not safe (it should be opened) and the system is under high voltage at the same time.",
            "The system Algorithm in too_small_resistance state only when all possible ranges are tested the range==0 is a minimum.",
            "The system Algorithm in too_large_resistance state only when all possible ranges are tested the range==5 is a maximum.",
            "Algorithm finds the value of resistance correct eventually."
        ],
        "properties": [
            "#assert Resistance() deadlockfree;",
            "#define goal1 (vInProg[0] == 1 && cage_safe == 0);\t\n#assert Resistance() reaches goal1;",
            "#define goal2 (tooSmall == 1 && range != 0);\n#assert Resistance() reaches goal2;",
            "#define goal3 (tooLarge == 1 && range != 5);\n#assert Resistance() reaches goal3;",
            "#assert Resistance() |= []<> measure_update.1;"
        ],
        "path": "pat_examples/beem/Miscellaneous/Cables Resistance Testing.csp"
    },
    {
        "name": "Lup",
        "tags": [
            "Real World",
            "Timing"
        ],
        "use_non_container_lib": false,
        "description": "Our model consists of N+1 synchronous modules - N lookup processors and a \"timer\". The \"timer\" counts time slots (each is 10 ns long in reality) modulo N in variable \"time\".\n  Lookup processors \"lup0\", \"lup1\", \"lup2\", etc. simulate N lookup processors sharing CAM and SRAM. Each lookup processor can be in one of six states; a processor can change state only when the variable \"time\" is equal to its rank.\n  Meaning and behavior of each state is as follows: The \"sleep\" state simulates behavior of a processor with empty input buffer. Subsequent state depends on whether any packet comes and whether CAM is not in use by another machine.\n  If no packet comes then the lookup processor remains in \"sleep\" else lookup processor changes to \"wait\" or \"load_data\" state. The choice of \"wait\" or \"load_data\" depends on whether CAM is in use by another machine or not.\n  The processor is in \"wait\" state if it wants to start processing of a packet but CAM is busy. Remaining in \"wait\" depends on availability of CAM.\n  If CAM is free, the next state is \"load_data\". The \"load_data\" state represents the critical section of CAM sharing - loading data into CAM. The next state is \"latency1\".\n  States \"latency1\" and \"latency2\" represent only waiting for result. In addition, \"latency2\" includes the finishing SRAM time slot. \"Latency2\" is followed by a sequence of \"comp\" states.\n  The \"comp\" states simulate computation using SRAM. A \"comp\" state corresponds to performing one instruction; in the end of the processing SRAM is accessed. The number of instructions is not limited.\n  It is obvious that the next states are \"comp\", \"sleep\", \"wait\", and \"load_data\". We abstract away from the emptiness of the input buffer and the number of instructions in computation using SRAM.\n  It means that each decision based on that features is replaced by a non-deterministic choice. There are no restrictions on the choice. The described (and verified) model is therefore a bit more general than reality. It allows the input buffer to be empty forever or even to stay in \"comp\" states infinitely.",
        "content": "// Number of lookup processors\n#define N 4;\nchannel to_lup[N] 0;\n#define condition (||x:{0..N-1}@getCAM[x]==1);\nhvar getCAM[N];\nhvar wait[N];\n\nTimer(time)=[]x:{0..N-1}@(([time==x]to_lup[x]!0->Timer((time+1)%N)));\n\nSleep(i) = to_lup[i]?m -> Sleep(i)\n\t\t[][!condition]to_lup[i]?m{getCAM[i] = 1;wait[i] = 0;}->Loaddata(i)\n\t\t[][condition]to_lup[i]?m{wait[i] = 1;}-> Wait(i);\n\nWait(i) = [condition]to_lup[i]?m{wait[i] = 1;}-> Wait(i)\n\t\t[][!condition]to_lup[i]?m{getCAM[i] = 1;wait[i] = 0;}-> Loaddata(i);\n\nLoaddata(i)=to_lup[i]?m{getCAM[i]=0;}->Latency1(i);\n\nLatency1(i)=to_lup[i]?m->Latency2(i);\n\nLatency2(i)=to_lup[i]?m->Comp(i);\n\nComp(i)=to_lup[i]?m -> Comp(i)\n\t   [][!condition]to_lup[i]?m{getCAM[i]=1;wait[i] = 0;}-> Loaddata(i)\n    [][condition]to_lup[i]?m{wait[i] = 1;}->Wait(i)\n    []to_lup[i]?m->Sleep(i);\n\nLup()=Timer(0)|||(|||x:{0..N-1}@Sleep(x));",
        "property_desc": [
            "The systme is deadlock-free",
            "Collision of processor 0, 1 on CAM",
            "Response property for processor 0"
        ],
        "properties": [
            "#assert Lup() deadlockfree;",
            "#define goal1 (getCAM[0]==1)&&(getCAM[1]==1);\n#assert Lup() reaches goal1;",
            "#define w0 (wait[0]==1);\n#define ld0 (getCAM[0]==1);\n#assert Lup()|= G(w0 -> F ld0);"
        ],
        "path": "pat_examples/beem/Miscellaneous/Lup.csp"
    },
    {
        "name": "Alur-Taubenfeld (fast timing-based mutual exclusion algorithm)",
        "tags": [
            "Algorithm",
            "Mutual Exclusion",
            "Timing"
        ],
        "use_non_container_lib": false,
        "description": "Dicrete time model of Alur-Taubenfeld fast timing-based mutual exclusion algorithm.\n  The algorithm has shared variables: X,Y: Integer, initially 0; Z: boolean, initially false. And process is denoted as p, where 1 <= p <= N. The number 255 means null of zero.\n  A process enters the noncritical section with setting X to its process ID(p). It watis for Y to be 0 and set Y to its process ID.\n  Then it check the value of X, if X is equal to p, which means no other process it trying to enter, then it set Z to true and enter critical section. If X is different from p, it delays itself. After that, it Y is not equal to p, the process goes back to the beginning and tries again. Otherwise, it waits for lock Z to be released and enter the critical section.\n  When leaving the critical section, the exit code needs to reset both the locks Y and Z to ensure guaranteed progress.\n  The fast timing-based mutual exclusion has the following pseudocode:\n  ```\n    Start: \n        Noncritical Section;\n        X := p;\n        await Y = 0;\n        Y := p;\n        if X != p then\n            delay(2 * \\Delta);\n            if Y != p then go to Start fi;\n            await !Z\n        else\n            Z := true\n        fi;\n        Critical Section;\n        Z := false;\n        if Y = p then\n            Y := 0\n        fi\n  ```",
        "content": "// Number of processes\n#define N 3;\n// Time needed to perform write/read operation\n#define K1 2;\n// Delay parameter of the algorithm (to ensure mutual exclusion K2 must be larger than 2*K1)\n#define K2 5;\n\nvar x;\nvar y = 255;\nvar z;\nvar t[N] = [255(N)];\n\nhvar csnum;\n\nTimer() = [&&u:{0..N-1}@(t[u] != 0)]q{if(t[0]!=255){t[0] = t[0]-1};if(t[1]!=255){t[1] = t[1]-1};if(t[2]!=255){t[2] = t[2]-1};} -> Timer();\n\nProcess(i) = ncs.i{x = i; t[i] = 255} -> P3(i);\nP3(i) = [y == 255]tp4.i{t[i] = K1;} -> P4(i);\nP4(i) = tp5.i{y = i; t[i] = K1;} -> P5(i);\n\nP5(i) = [x == i]tp9.i{t[i] = K1} -> P9(i) [] [x != i]tp6.i{t[i] = K2;} -> P6(i);\nP9(i) = tcs.i{z = 1; t[i] = 255; csnum = csnum + 1;} -> CS(i);\n\nP6(i) = [t[i] == 0]tp7.i{t[i] = K1;} -> P7(i);\nP7(i) = [y != i]tncs.i{t[i] = K1;} -> Process(i) [] [y == i]tp8.i{t[i] = 255;} -> P8(i);\nP8(i) = [z == 0]tcs.i{csnum = csnum + 1;} -> CS(i);\n\nCS(i) = tp12.i{z = 0; t[i] = K1;csnum = csnum - 1;} -> P12(i);\nP12(i) = [y != i]tncs.i{t[i] = 255;} -> Process(i) [] [y == i]tp13.i{t[i] = K1;} ->P13(i);\nP13(i) = tncs.i{y = 255; t[i] = 255;} -> Process(i);\n\nAT() = (|||w:{0..N-1}@Process(w))|||Timer();",
        "property_desc": [
            "Violation of mutual exclusion (more than one process in critical section).",
            "If P0 waits for CS then it will eventually get there.",
            "If P0 isn't in CS then it will eventually reach it.",
            "Infinitely many times someone critical section.",
            "The model is deadlock-free"
        ],
        "properties": [
            "#define goal csnum > 1;\n#assert AT() reaches goal;",
            "#assert AT() |= [](ncs.0 -> <>tcs.0);",
            "#assert AT() |= [](!tcs.0 -> <> tcs.0);",
            "#assert AT() |= []<>(tcs.0 || tcs.1);",
            "#assert AT() deadlockfree;"
        ],
        "path": "pat_examples/beem/Mutual Exclusion Algorithms/Alur-Taubenfeld.csp"
    },
    {
        "name": "Anderson's Mutual Exclusion Algorithm",
        "tags": [
            "Algorithm",
            "Mutual Exclusion"
        ],
        "use_non_container_lib": false,
        "description": "Situations, where two or more processes are reading and/or writing some shared data and the final result depends on who runs precisely when, are called race conditions.\n  Code sections containing race conditions can be regarded as \"critical\", because such code can lead to inconsistent data. To avoid inconsistence in critical sections, exclusive access to shared data must be granted.\n  This is called mutual exclusion, because if two processes compete for access then they have to exclude each other mutually. See also other mutex examples.\n\t\n  The Anderson's mutual exclusion algorithm can be described as follows.\n  There are two shared variables, the spin queue is defined by an array of slots: Array[0..N-1] of {0,1}, 0 means must wait, 1 means has lock, initially only slots[0] is 0 and the rest is 1; \n  The next free slot at the tail of the queue is indicated by the shared variable next_slot: Integer, initially 0.\n  One private variable my_place: Integer. The process is denoted as p, where 1 <= p <= N. \n\n  A process p enqueues itself onto the end of the spin queue by simply using fetch and inc to increment next_slot.\n  If some processes increment next_slot beyond slot N \u2212 1. It will be corrected to the range over {0,...,N \u2212 1}.\n  A process in its entry section waits until its slot has the value has lock. If there is a successor to process p in the spin\n  queue, then its slot is my_place[p] + 1 mod N. If a successor does exist, then it is granted the lock when p executes P3.\n  If no successor exists, then P3 ensures that the lock will be granted to the next process that performs the fetch and inc operation.",
        "content": "// Number of processes.\n#define N 3;\n\nvar slot[N] = [1,0(N-1)];\nvar my_place[N];\nvar next = 0;\nhvar incs;\n\nProcess(i) = ncs.i{ my_place[i] = next; next = next + 1 } -> P1(i);\n\nP1(i) = [ my_place[i] == N-1 ]wait.i{ next = next - N } -> P2(i) []\n\t\t[ my_place[i] != N-1 ]wait.i{ my_place[i] = my_place[i] % N } -> P2(i);\n\nP2(i) = [ slot[my_place[i]] == 1 ]p2.i -> P3(i);\nP3(i) = cs.i{ slot[(my_place[i])%N] = 0; incs++; } -> reset.i{ slot[(my_place[i] + 1)%N] = 1; incs--;} -> Process(i);\n\nAnderson()=|||x:{0..N-1}@Process(x);",
        "property_desc": [
            "Violation of mutual exclusion (more than one process in critical section).",
            "If P0 waits for CS then it will eventually get there.",
            "If P0 isn't in CS then it will eventually reach it.",
            "Infinitely many times someone critical section.",
            "The model is deadlock-free"
        ],
        "properties": [
            "#define goal (incs>1);\n#assert Anderson() reaches goal;",
            "#assert Anderson() |= [](wait.0 -> <> cs.0);",
            "#assert Anderson() |= [](!cs.0 -> <> cs.0);",
            "#assert Anderson() |= []<> (cs.0 || cs.1 || cs.2);",
            "#assert Anderson() deadlockfree;"
        ],
        "path": "pat_examples/beem/Mutual Exclusion Algorithms/Anderson.csp"
    },
    {
        "name": "Fischer's Mutual Exclusion Algorithm",
        "tags": [
            "Algorithm",
            "Mutual Exclusion",
            "Timing"
        ],
        "use_non_container_lib": false,
        "description": "Situations, where two or more processes are reading and/or writing some shared data and the final result depends on who runs precisely when, are called race conditions. Code sections containing race conditions can be regarded as \"critical\", because such code can lead to inconsistent data. To avoid inconsistence in critical sections, exclusive access to shared data must be granted. This is called mutual exclusion, because if two processes compete for access then they have to exclude each other mutually. This model is a discrete time simulation of the Fischer's real time mutual exclusion protocol. \n  \n  The Fischer's Mutual Exclusion Algorithm has a shared variable id: 0..N, initially 0. The process is denoted as p, where 0 <= p < n. The number 255 means null or zero.\n  A process p waits until the \"lock\" is available, which is indicated by id = 0. If p reads Y = 0, then it writes its process identifier to id, and delays for delta time units. If the value of id is still p after the delay, then p enters its critical section.",
        "content": "//N, K1, K2\n// Number of the processes\n#define N 3;     \n// The 1st constant of the protocol\n#define K1 2;\n// The 2nd constant of the protocol\n#define K2 3;\n\nvar id = 0;\nvar t = [255(N)];\n\n/*--------------------------------------------------------------------*/\nTimer() = [ t[0] != 0 && t[1] != 0 && t[2] != 0 ]\n\t\t    tick{ if( t[0] != 255 ){ t[0] = ( t[0] - 1 ) }\n\t\t          if( t[1] != 255 ){ t[1] = ( t[1] - 1 ) }\n\t\t          if( t[2] != 255 ){ t[2] = ( t[2] - 1 ) }\n\t\t  \t    } -> Timer();\n\n/*--------------------------------------------------------------------*/\n\nvar count = 0;\n\t\t  \t  \nP(i) = Ncs(i);\n\nNcs(i) = [ id == 0 ]ncs.i{ t[i] = K1; } -> Try(i);\n\nTry(i) = try.i{ t[i] = K2; id = i + 1 } -> Wait(i);\n\nWait(i) = [ t[i] == 0 ]wait.0.i{ t[i] = 255 } -> Wait(i) []\n\t\t  [ t[i] == 255 && id == i + 1 ]wait.1.i{ count = count + 1 } -> Cs(i) []\n\t\t  [ id != i + 1 && t[i] == 255 ]wait.2.i -> Ncs(i);\n\nCs(i) = cs.i{ id = 0; count = count - 1 } -> Ncs(i);\n\n/*--------------------------------------------------------------------*/\n\nFischer() = Timer() ||| (||| i:{0..N-1} @ P(i));\n\n/*--------------------------------------------------------------------*/",
        "property_desc": [
            "The model is deadlock-free",
            "Violation of mutual exclusion (more than one process in critical section).",
            "If P0 waits for CS then it will eventually get there.",
            "If P0 isn't in CS then it will eventually reach it.",
            "Infinitely many times someone critical section."
        ],
        "properties": [
            "#assert Fischer() deadlockfree;",
            "#define collision (count > 1);\n#assert Fischer reaches collision;",
            "#assert Fischer() |=[]( (wait.0.0 || wait.1.0 || wait.2.0) -> <> cs.0 );",
            "#assert Fischer() |=[]( !(cs.0) -> <> cs.0 );",
            "#assert Fischer() |= []<> (cs.0 || cs.1 || cs.2);"
        ],
        "path": "pat_examples/beem/Mutual Exclusion Algorithms/Fischer's Mutual Exclusion Algorithm.csp"
    },
    {
        "name": "Lamport Nonatomic Mutual Exclusion Algorithm",
        "tags": [
            "Algorithm",
            "Mutual Exclusion"
        ],
        "use_non_container_lib": false,
        "description": "The algorithm has shared variables x: Array[0..N-1] of boolean, initially 0. Process is denoted as p, where 0 <= p < N.\n  In this model, operation executions have duration and may be concurrent. Nonatomic read and write operations are modelled using processes NonatomicVar1/2.\n  Mutual exclusion is guaranteed by the following protocol: in order to enter its critical section, a process must first set its flag true and then find every other process\u2019s flag to be false.\n  In phase 1, a process yields to any process of lower index that is in its entry or critical section.\n  Then, in phase 2, a process checks each higher-indexed process to determine if it is in its entry section (and has not yielded), and waits if this is the case.",
        "content": "// Number of processes\n#define N 3;\n#define Signal 1;\n\nchannel read[N] 0;\nchannel write[N] 0;\nchannel done[N] 0;\n\nvar x[N];\nvar v1[N];\nvar i[N];\nvar v2[N];\n\nhvar csnum;\nhvar wait;\n\nNonatomicVar1(k) = read[k]!x[k] -> NonatomicVar1(k)\n                [] write[k]?temp{v1[k] = temp;} -> NonatomicVar2(k);\nNonatomicVar2(k) = done[k]!Signal{x[k] = v1[k];} -> NonatomicVar1(k)\n                [] read[k]!0 -> NonatomicVar2(k)\n                [] read[k]!1 -> NonatomicVar2(k);\n\nProcess(j) = write[j]!1{if(j == 0)wait = 1;} -> W1(j);\nW1(j) = done[j]?donevar{i[j] = 0;if(j == 0)wait = 0;} -> P3(j);\nP3(j) =  [i[j] == j]tp8.j{i[j] = j + 1;} ->P8(j)\n     [] ([]m1:{0..N-1}@([i[j] == m1]read[m1]?temp1{v2[j] = temp1;} -> P4(j)));\nP4(j) = [v2[j] == 0]tp3.j{i[j] = i[j] + 1;} -> P3(j)\n     [] [v2[j] == 1]tp5.j -> P5(j);\nP5(j) = [v2[j] == 1]tp6.j -> P6(j)\n     [] [v2[j] == 0]tncs.j -> Process(j);\nP6(j) = write[j]!0 -> W2(j);\nW2(j) = done[j]?donevar -> P61(j);\nP61(j) = []m2:{0..N-1}@([i[j] == m2]read[m2]?temp2{v2[j] = temp2;} -> P5(j));\nP8(j) =\t[i[j] == N]tcs.j{csnum = csnum + 1;} -> CS(j)\n     [] ([]m3:{0..N-1}@([i[j] == m3]read[m3]?temp3{v2[j] = temp3;} -> P9(j)));\nP9(j) = [v2[j] == 0]tp8.j{i[j] = i[j] + 1;} -> P8(j)\n     [] ([]m4:{0..N-1}@([v2[j] == 1 && i[j] == m4]read[m4]?temp4{v2[j] = temp4;} -> P9(j)));\nCS(j) = write[j]!0{csnum = csnum - 1;} -> W3(j);\nW3(j) = done[j]?donevar -> Process(j);\n\nLamport_Nonatomic()=(|||w:{0..N-1}@NonatomicVar1(w))|||(|||t:{0..N-1}@Process(t));",
        "property_desc": [
            "The model is deadlock-free",
            "Violation of mutual exclusion (more than one process in critical section).",
            "If P0 waits for CS then it will eventually get there.",
            "If P0 isn't in CS then it will eventually reach it.",
            "Infinitely many times someone critical section."
        ],
        "properties": [
            "#assert Lamport_Nonatomic() deadlockfree;",
            "#define goal1 csnum > 1;\n#assert Lamport_Nonatomic() reaches goal1;",
            "#define goal2 wait == 1;\n#assert Lamport_Nonatomic() |= [](goal2 -> <> tcs.0);",
            "#assert Lamport_Nonatomic() |= [](!tcs.0 -> <> tcs.0);",
            "#assert Lamport_Nonatomic() |= []<>(tcs.0 || tcs.1);"
        ],
        "path": "pat_examples/beem/Mutual Exclusion Algorithms/Lamport Nonatomic.csp"
    },
    {
        "name": "Lamport's Fast Mutual Exclusion Algorithm",
        "tags": [
            "Algorithm",
            "Mutual Exclusion"
        ],
        "use_non_container_lib": false,
        "description": "A mutual exclusion algorithm, which is optimized for a number of read/write operations.\n\n  The algorithm has three shared varialbes: B: array[1..N] of boolean initially false; X: 1..N; Y: 0..N initially 0. The process is denoted as p, where 0 <= p < n. The private variable counter: 0..N-1. The number 255 means null or zero.\n  A process p first enters the noncritical section and set the B[p] to true and X to p, indicating its intention to enter the critical section\n  If no other process is currently in the critical section(Y is 0), the process resets its flag B[p] to false, waits until the critical section is free(Y becomes 0) and restarts from the beginning.\n  Otherwise, it then checks if no other process tried to enter the critical section(X is equal to p). \n  - If it is, it enters the critical section. \n  - Otherwise, it resets its flag B[p] to false and iterates through all other processes' flags B[j], waiting until they are all false. This ensures that no other process is trying to enter the critical section concurrently.\n    After that, it checks if there is still no other process tried entered the critical(Y is equal to p). \n    - If it is, it enters the critical section.\n    - Othereise, the process waits until the critical section is free(Y becomes 0) and restarts from the beginning.\n  When leaving the critical section, it set Y to 0 and B[p] to false.",
        "content": "// Number of the processes\n#define N 3;\n// Presence of an (artifical) error (0/1/2)\n#define ERROR 1;\n\nvar b[N];\nvar x = 255;\nvar y = 255;\n\n//counters\nvar counter[N];\n\n/*-----------------------------------------------------------------------------------------------------------------------------------*/\n\nvar total = 0;\n\nProcess(i) = Ncs(i);\n\nNcs(i) = ncs.i{ b[i] = 1 } -> Q1(i);\n\nQ1(i) = q1.i{ x = i } -> Q2(i);\n\nQ2(i) = [ y != 255 ]q2.0.i{if(ERROR == 1){b[x] = 0} else {b[i] = 0}} -> Q22(i) []\n\t\t[ y == 255 ]q2.1.i -> P(i);\t\nQ22(i) = [ y == 255 ]q22.i -> Ncs(i);\nP(i) = p.i{ y = i } -> Q3(i);\n\nQ3(i) = [ x == i ]q3.0.i{ total = total + 1 } -> Cs(i) []\n\t\t[ x != i ]q3.1.i{ b[i] = 0; counter[i] = 0 } -> Q4(i);\n\t\t\nQ4(i) = [ counter[i] < N && b[counter[i]] == 0 ]q4.0.i{ counter[i] = counter[i] + 1 } -> Q4(i) []\n\t\t[ counter[i] == N ]q4.1.i -> Q5(i);\n\nQ5(i) = [ ERROR == 2 && y == x || ERROR != 2 && y == i ]q5.0.i{ total = total + 1 } -> Cs(i) []\n\t\t[ y == 255 ]q5.1.i -> Ncs(i);\n\nCs(i) = cs.i{ y = 255; total = total - 1 } -> E1(i);\n\nE1(i) = e1.i{ b[i] = 0 } -> Ncs(i);\n\n/*-----------------------------------------------------------------------------------*/\n\nLamport() = ||| i:{0..N-1} @ Process(i);\n\n/*--------------------------------------------------------------------*/",
        "property_desc": [
            "The model is deadlock-free",
            "Violation of mutual exclusion (more than one process in critical section).",
            "If P0 waits for CS then it will eventually get there.",
            "If P0 isn't in CS then it will eventually reach it.",
            "Infinitely many times someone critical section."
        ],
        "properties": [
            "#assert Lamport() deadlockfree;",
            "#define collision (total > 1);\n#assert Lamport() reaches collision;",
            "#assert Lamport() |= []( q1.0 -> <> cs.0);",
            "#assert Lamport() |= []( !(cs.0) -> <> cs.0);",
            "#assert Lamport() |= []<> (cs.0 || cs.1 || cs.2);"
        ],
        "path": "pat_examples/beem/Mutual Exclusion Algorithms/Lamport's Fast Mutual Exclusion Algorithm.csp"
    },
    {
        "name": "Lann",
        "tags": [
            "Algorithm",
            "Mutual Exclusion"
        ],
        "use_non_container_lib": false,
        "description": "N nodes are connected by a token ring. The token is used to guarantee mutual exclusion access to shared resource. \n  The communications link are unreliable, i.e., token can get lost. The leader election algorithm is used for sending of a new token after the timeout. \n\n  All processes begin in status ALPHA. It may send message to next node and transitions to status BETA or receive message from other node. \n  When message is received:\n  - If the received message is TOKEN, the process enters the critical section.\n  - If the received message is not TOKEN and greater then the message sent, the process forwards the message to next node and keeps current status.\n  - If the received message is not TOKEN and less then the message sent and the process is in status BETA, the process forwards the message to next node and transitions to status GAMMA.\n  - If the received message is not TOKEN and less then the message sent and the process is in status ALPHA, the process forwards the message to next node and keeps current status.\n  - If the received message is not TOKEN and equal to the message sent and the process is not in status BETA, the process transitions to status GAMMA.\n  - If the received message is not TOKEN and equal to the message sent and the process is in status BETA, the process enters the critical section.\n  When leaving the critical section, the process passes the TOKEN to next node.",
        "content": "// Number of nodes\n#define N 3; \n\n#define ALPHA 0;\n#define BETA 1;\n#define GAMMA 2;\n#define TOKEN 255;\n\nchannel ch[N] 1;\n\nwait(cur_node, next_node, status, arg_sent) = [status == ALPHA]ch[next_node]!arg_sent -> wait(cur_node, next_node, BETA, arg_sent)\n                                                         [] ch[cur_node]?msg -> got_msg(cur_node, next_node, status, arg_sent, msg);\n\ngot_msg(cur_node, next_node, status, arg_sent, msg) = [msg == TOKEN]{in_cs = in_cs + 1; who_in_cs = cur_node;} -> CS(cur_node, next_node, status, arg_sent)\n                                                                 [] [msg != TOKEN && msg > arg_sent]ch[next_node]!msg -> wait(cur_node, next_node, status, arg_sent)\n                                                                 [] [msg != TOKEN && status == BETA && msg < arg_sent]ch[next_node]!msg -> wait(cur_node, next_node, GAMMA, arg_sent)\n                                                                 [] [msg != TOKEN && status == ALPHA && msg < arg_sent]ch[next_node]!msg -> wait(cur_node, next_node, status, arg_sent)\n                                                                 [] [msg != TOKEN && msg == arg_sent && status != BETA]NONE -> wait(cur_node, next_node, ALPHA, arg_sent)\n                                                                 [] [msg != TOKEN && msg == arg_sent && status == BETA]{in_cs = in_cs + 1; who_in_cs = cur_node;} -> CS(cur_node, next_node, status, arg_sent);\n\nhvar in_cs = 0;\nhvar who_in_cs = N;\nCS(cur_node, next_node, status, arg_sent) = {in_cs = in_cs - 1; who_in_cs = N;} -> ch[next_node]!TOKEN -> wait(cur_node, next_node, ALPHA, arg_sent);\n\nPROC() = CS(0, 1, ALPHA, (((0+9)*(0+7)+42)%27)) ||| ( ||| x:{1..N-1} @ wait(x, (x+1)%N, ALPHA, (((x+9)*(x+7)+42)%27)) );",
        "property_desc": [
            "The model is deadlock-free",
            "Violation of mutual exclusion (more than one process in critical section).",
            "Eventually some processes will be in critical section.",
            "Infinitely many times P0 in critical section."
        ],
        "properties": [
            "#assert PROC() deadlockfree;",
            "#define goal_collision (in_cs > 1);\n#assert PROC() reaches goal_collision;",
            "#define SOMEONEINCS (in_cs == 1);\n#assert PROC() |= [] <> SOMEONEINCS;",
            "#define P0INCS (who_in_cs == 0);\n#assert PROC() |= [] <> P0INCS;"
        ],
        "path": "pat_examples/beem/Mutual Exclusion Algorithms/Lann.csp"
    },
    {
        "name": "MCS Queue Lock Mutual Exclusion",
        "tags": [
            "Algorithm",
            "Mutual Exclusion"
        ],
        "use_non_container_lib": false,
        "description": "Situations, where two or more processes are reading and/or writing some shared data and the final result depends on who runs precisely when, are called race conditions. Code sections containing race conditions can be regarded as \"critical\", because such code can lead to inconsistent data. To avoid inconsistence in critical sections, exclusive access to shared data must be granted. This is called mutual exclusion, because if two processes compete for access then they have to exclude each other mutually. \n\n  This is Mellor-Crummey and Scott list-based queue lock using fetch-and-store and compare-and-swap algorithm. \n  The list is of type Qnode, which contains a pointer to the next node, its predecessor and a Boolean flag(locked[]). The variable `tail` tracks the tail of the list.\n  Before the critical section, the processes need to acquire the lock. A process first set its successsor node to NIL, fetch the tail of the list and set the tail as its own node. \n  - If the predecessor doesn't exists, meaning no other processes are trying to get into the critical section, the process will proceeds to the critical.\n  - Otherwise, it sets its boolean locked flag to true, links the predecessor to the process's node and waits until the lock is released.\n  After the critical, the processes need to release the lock.\n  - If a process's node has successsor, it will release the lock on its successsor.\n  - Otherwise, since tail must still point to p\u2019s Qnode it waits until it has a successsor and release the lock on it.",
        "content": "// Number of processes\n#define N 3;\n#define NIL 255;\nvar next[N] = [NIL(N)];\t\t\t\t/*The next pointer to its successsor*/\nvar locked[N];\t\t\t\t\t\t/*locked by itself, only unlocked by its predecessor*/\nvar tail = NIL;\t\t\t\t\t\t/*The tail pointer*/\t\nvar pred[N] = [0(N)];\nhvar counter = 0;\t\t\t\t\t/*How many processes in the critical section*/\n\nProcess(i) = ncs_p2.i{next[i] = NIL;} -> NonCS(i);\t\t\nNonCS(i) = p2_p3.i{ pred[i] = tail; tail = i; } -> (\n\t\t\t\t\t\t\t\t\t[pred[i] == NIL] p3_cs.i{ counter ++;} -> CS(i)\t\t\t\t\t\t\t/*Predecessor is null*/\n\t\t\t\t\t\t\t\t[]\t[pred[i] != NIL] p3_p4.i -> p4_p5.i{locked[i] = 1;} -> p5_p6.i{ next[pred[i]] = i;} -> ( [locked[i] == 0] p6_cs.i{counter ++;} -> CS(i) )\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\nCS(i) = ([next[i] == NIL] cs_p9.i{ counter -- ;} -> (\n\t\t\t\t\t\t\t\t\t\t\t[ tail == i ] p9_ncs.i{ tail = NIL;} -> Process(i)\n\t\t\t\t\t\t\t\t\t \t[]\t[ tail != i ] p9_p10.i -> ( [ next[i] != NIL ] p10_p13.i -> p13_ncs.i{locked[next[i]] = 0; } -> Process(i) )\n\t\t\t\t\t\t\t\t\t\t)\n\t[]\t[next[i] != NIL] cs_p13.i{ counter -- ;} -> p13_ncs.i{locked[next[i]] = 0; } -> Process(i)\n\t\t);\n\nMCS = |||x:{0..N-1}@Process(x);",
        "property_desc": [
            "The model is deadlock-free",
            "Violation of mutual exclusion (more than one process in critical section).",
            "If a process waits for CS then it will eventually get there.",
            "If a process isn't in CS then it will eventually reach it.",
            "Infinitely many times someone in critical section."
        ],
        "properties": [
            "#assert MCS deadlockfree;",
            "#define violation counter >= 2;\n#assert MCS reaches violation;",
            "#assert MCS |= [](( ncs_p2.0 || p2_p3.0 || p3_p4.0 || p4_p5.0 || p5_p6.0 ) -> <>(p3_cs.0 || p6_cs.0));",
            "#assert MCS |= [](!(p3_cs.0 && p6_cs.0) -> <> (p3_cs.0 || p6_cs.0));",
            "#assert MCS |= ([]<> (p3_cs.0 || p6_cs.0) || []<> (p3_cs.1 || p6_cs.1) || []<> (p3_cs.2 || p6_cs.2));"
        ],
        "path": "pat_examples/beem/Mutual Exclusion Algorithms/MCS Queue Lock Mutual Exclusion.csp"
    },
    {
        "name": "Szymanski",
        "tags": [
            "Algorithm",
            "Mutual Exclusion"
        ],
        "use_non_container_lib": false,
        "description": "This is szymanski's three-bit linear wait algorithm for mutual exclusion.\n\n  The algorithm uses three one bit communication variables in each process, a(active, competing for a critical section), w(waiting inside the waiting room) and s(shutting the door to the waiting room): Array[0..N-1] of boolean initially false.\n  The algorithm simulates awaiting room with a door. All processes requesting entry to the critical section at roughly the same time gather first in the waiting room. Then, when there are no more processes requesting entry, processes inside waiting room shut the door and move to the exit from the waiting room. \n  From there, one by one, they enter their critical sections in the order of their numbering. Any process requesting access to its critical section at that time has to wait in the initial part of the prologue section (at the entry to the waiting room). \n  The door to the waiting room is initially opened. The door is closed when a process inside the waiting room does not see any new processes requesting entry. The door is opened again when the last process inside the waiting room leaves the exit section of the algorithm.\n  Each process can be in one of the following five states: \n  1. passive - all three communication variables are false (aws=false,false,false). A process in the passive state is executing the noncritical section. \n  2. entry - only the variable a is set to true (aws=true,false,false). A process in the entry state wants to access its critical section and attempts to enter the waiting room. \n  3. inside - only the variable w is set to true (aws=false,true,false). A process in the inside state passed through the door into the waiting room. \n  4. transient - two variables: s and w are set to true (aws=false,true,true). A process in the transient state shuts the door into the waiting room temporarily. \n  5. exit - only the variable s is set to true (aws=false,false,true). A process in the exit state keeps the door into the waiting room shut for good and is either executing its critical section or waiting for its turn to execute it.\n  The transitions can be described as follows:\n  - p2: A transition from the passive state to the entry state is unconditional\n  - p3-p4: A process is allowed to move from the entry state to the inside state if the variable s is set to false in all processes \n  - p5-p6: A process in the inside state that notices that there are no processes in the entry state (i.e. the variable a is set to false in each process) can move to the transient state and shut thedoor temporarily by setting its variable s to true.\n  - p6.1-06.4: From the transient state a process checks again for presence of anyprocesses in the entry state. If there are any, the checking process backs off to the inside state; otherwise it moves to the exit state and shuts the door for good.\n  - p7-p8: A process in the inside state that notices a process in the exit state moves to the exit state immediately. \n  - p9: From the exit state processes enter critical section in the order of their numbering.",
        "content": "// N   \tNumber of processes\n#define N 3;\n\nvar a[N];\nvar w[N];\nvar s[N];\n\nNCS(cur_proc, j) = P2.cur_proc{a[cur_proc] = 1;} -> p2(cur_proc, 0);\np2(cur_proc, j) = [j < N && s[j] == 0]P2.cur_proc -> p2(cur_proc, j + 1)\n            [] [j == N]P3.cur_proc -> p3(cur_proc, j);\np3(cur_proc, j) = P4.cur_proc{w[cur_proc] = 1; a[cur_proc] = 0;} -> p4(cur_proc, j);\np4(cur_proc, j) = [s[cur_proc] == 1]P9.cur_proc -> p9(cur_proc, 0)\n            [] [s[cur_proc] == 0]P5.cur_proc -> p5(cur_proc, 0);\np5(cur_proc, j) = [j < N && a[j] == 0]P5.cur_proc -> p5(cur_proc, j + 1)\n            [] [!(j < N && a[j] == 0)]P6.cur_proc -> p6(cur_proc, j);\np6(cur_proc, j) = [j < N]P7.cur_proc -> p7(cur_proc, j)\n            [] [j == N]P61.cur_proc{s[cur_proc] = 1;} -> p61(cur_proc, 0);\np61(cur_proc, j) = [j < N && a[j] == 0]P61.cur_proc -> p61(cur_proc, j + 1)\n            [] [j < N && a[j] == 1]P7.cur_proc{s[cur_proc] = 0;} -> p7(cur_proc, j)\n            [] [j == N]P64.cur_proc{w[cur_proc] = 0;} -> p64(cur_proc, 0);\np64(cur_proc, j) = [j < N && w[j] == 0]P64.cur_proc -> p64(cur_proc, j + 1)\n            [] [j == N]P7.cur_proc -> p7(cur_proc, j);\np7(cur_proc, j) = [j == N]P8.cur_proc -> p8(cur_proc, j)\n            [] [j < N]P71.cur_proc -> p71(cur_proc, 0);\n\n// if ERROR == 0\np71(cur_proc, j) = [j < N && (w[j] == 1 || s[j] == 0)]P71.cur_proc -> p71(cur_proc, j + 1)\n\t\t            [] [!(j < N && (w[j] == 1 || s[j] == 0))]P8.cur_proc -> p8(cur_proc, j);\n\np8(cur_proc, j) = [j != cur_proc && j < N]P4.cur_proc{s[cur_proc] = 1; w[cur_proc] = 0;} -> p4(cur_proc, j)\n            [] [!(j != cur_proc && j < N)]P4.cur_proc -> p4(cur_proc, j);\np9(cur_proc, j) = [j < cur_proc && w[j] == 0 && s[j] == 0]P9.cur_proc -> p9(cur_proc, j + 1)\n            [] [j == cur_proc]IN_CS.cur_proc{in_cs = in_cs + 1;} -> CS(cur_proc, j);\nhvar in_cs = 0;\nCS(cur_proc, j) = IN_NCS.cur_proc{in_cs = in_cs - 1; s[cur_proc] = 0} -> NCS(cur_proc, j);\n\nPROC() = ||| i:{0..N-1} @ NCS(i, 0);",
        "property_desc": [
            "The model is deadlock-free",
            "Violation of mutual exclusion (more than one process in critical section).",
            "If a process waits for CS then it will eventually get there.",
            "If a process isn't in CS then it will eventually reach it.",
            "Infinitely many times someone in critical section."
        ],
        "properties": [
            "#assert PROC() deadlockfree;",
            "#define goal (in_cs > 1);\n#assert PROC() reaches goal;",
            "#assert PROC() |= [] (P2.0 -> <> (IN_CS.0));",
            "#assert PROC() |= [] ((!IN_CS.0) -> <> IN_CS.0);",
            "#define SOMEONEINCS (in_cs == 1);\n#assert PROC() |= [] <> SOMEONEINCS;"
        ],
        "path": "pat_examples/beem/Mutual Exclusion Algorithms/Szymanski.csp"
    },
    {
        "name": "Msmie",
        "tags": [
            "Protocol"
        ],
        "use_non_container_lib": true,
        "description": "Multiprocessor Shared-Memory Information Exchange (MSMIE) is a protocol for communication between processors in a real-time control system. \n  The processors are classified as either masters, which perform application-related tasks, or slaves, which provide dedicated functions. \n  This protocol is an extension of readers (masters)/writers (slaves) problem.\n  \n  There are three buffers in the MSMIE protocol. Each of the three buffers can take the status values as one of IDLE, NEWEST, SLAVE and MASTER. The initial state of one buffer is slave, the initial state of the other buffers is idle. \n  Slave write:\n  1. Acquire semaphore \n  2. If a newest buffer is available, change its status to idle \n  3. If a slave buffer is found, change its status to newest, else an error has occurred \n  4. If an idle buffer is found, change its status to slave, else an error has occurred \n  5. Release semaphore \n  Master acquire:\n  1. Acquire semaphore \n  2. If a master buffer is not found, then if a newest buffer is found, change its status to master else release semaphore and try again \n  3. Increment number-of-readers count \n  4. Release semaphore \n  Master release:\n  1. Acquire semaphore \n  2. Decrement number-of-readers count \n  3. If number-of-readers = 0, then \n    if a newest buffer is found, then \n      change status of master buffer to idle \n    else change status of master buffer to newest \n  4. Release semaphore",
        "content": "#import \"PAT.Lib.Msmie\";\n\n// Number of slaves\n#define S 2;\n// Number of masters\n#define M 3;\n// Size of buffer\n#define N 3;\n\n#define IDLE 0;\n#define NEWEST 1;\n#define SLAVE 2;\n#define MASTER 3; \n\n// buffer\nvar b[N];\nvar readers;\nvar sem = 1;\nvar change_to;\n\nSET_INIT_VALUE() = SET_b_VALUE(0);\nSET_b_VALUE(i) = [i != N - 1]{b[i] = IDLE;} -> SET_b_VALUE(i + 1)\n\t\t            [] [i == N - 1]{b[i] = SLAVE} -> Skip;\n\nSlave_idle(id) = [sem == 1]Slave_idle_Slave_q0.id{sem = 0;} -> Slave_q0(id);\nSlave_q0(id) = [] i:{0..N-1} @ [b[i] == NEWEST]Slave_q0_Slave_q1.id{b[i] = IDLE;} -> Slave_q1(id)\n            [] [call(all_is_not, b, NEWEST, N)]Slave_q0_Slave_q1.id -> Slave_q1(id);\n\nhvar error_id = N;\n\nSlave_q1(id) = [] i:{0..N-1} @ [b[i] == SLAVE]Slave_q1_Slave_q2.id{b[i] = NEWEST;} -> Slave_q2(id)\n            [] [call(all_is_not, b, SLAVE, N)]Slave_q1_Slave_error_state.id{error_id = id;} -> Slave_error_state(id);\n\nSlave_q2(id) = [] i:{0..N-1} @ [b[i] == IDLE]Slave_q2_Slave_q3.id{b[i] = SLAVE;} -> Slave_q3(id)\n            [] [call(all_is_not, b, IDLE, N)]Slave_q2_Slave_error_state.id{error_id = id;} -> Slave_error_state(id);\n\nSlave_q3(id) = Slave_q3_Slave_idle.id{sem = 1} -> Slave_idle(id);\n\nSlave_error_state(id) = Skip;\n\nMaster_idle(id) = [sem == 1]Master_idle_Master_q0.id{sem = 0;} -> Master_q0(id);\n\nMaster_q0(id) = [] i:{0..N-1} @ [b[i] == MASTER]Master_q0_Master_master.id -> Master_master(id)\n            [] [call(all_is_not, b, MASTER, N)]Master_q0_Master_no_master.id -> Master_no_master(id);\n\nMaster_no_master(id) = [] i:{0..N-1} @ [b[i] == NEWEST]Master_no_master_Master_master.id{b[i] = MASTER} -> Master_master(id)\n\t            [] [call(all_is_not, b, NEWEST, N)]Master_no_master_Master_idle.id{sem = 1;} -> Master_idle(id);\n\nMaster_master(id) = Master_master_Master_reading.id{readers = readers + 1; sem = 1;} -> Master_reading(id);\n\nMaster_reading(id) = [sem == 1]Master_reading_Master_r0.id{sem = 0; readers = readers - 1;} -> Master_r0(id);\n\nMaster_r0(id) = [readers == 0]Master_r0_Master_no_readers.id -> Master_no_readers(id)\n            [] [readers > 0]Master_r0_Master_r1.id -> Master_r1(id);\n\nMaster_no_readers(id) = [call(any_is, b, NEWEST, N)]Master_no_readers_Master_change.id{change_to = IDLE;} -> Master_change(id)\n\t\t            [] [call(all_is_not, b, NEWEST, N)]Master_no_readers_Master_change.id{change_to = NEWEST;} -> Master_change(id);\nMaster_change(id) = [] i:{0..N-1} @ [b[i] == 3]Master_change_Master_r1.id{b[i] = change_to;} -> Master_r1(id);\n\nMaster_r1(id) = Master_r1_Master_idle.id{sem = 1;} -> Master_idle(id);\n\nPROC() = SET_INIT_VALUE();(Slave()|||Master());\nSlave() = ||| j:{0..S-1} @ Slave_idle(j);\nMaster() = ||| j:{0..M-1} @ Master_idle(j);",
        "property_desc": [
            "The system reaches a state where all memory are slaves or idle."
        ],
        "properties": [
            "#define goal (error_id == 1);\n#assert PROC() reaches goal;"
        ],
        "path": "pat_examples/beem/Other Protocols/Msmie.csp"
    },
    {
        "name": "Publish Subscribe",
        "tags": [
            "Protocol"
        ],
        "use_non_container_lib": false,
        "description": "Abstract specification (model) of the groupware protocol underlying thinkteam augmented with a publish/subscribe notification service.\n\n  Thinkteam is a three-tier data management system. The most typical installation scenario is a network of desktop clients interacting with one centralized RDBMS \nserver and one or more file servers. Persistence services are achieved by building on the characteristics of the RDBMS and file servers.\n  We now describe its vaulting subsystem. The controlled storage and retrieval of document data in PDM applications is traditionally called vaulting, the vault being a \nfile-system-like repository. One of the two main functions of vaulting is: to prevent inconsistent updates or changes to the document base, while still allowing the \nmaximal access compatible with the business rules. This is implemented in thinkteam\u2019s underlying groupware protocol by a standard set of operations, viz.\n  - get: extract a read-only copy of a document from the vault,\n  - import: insert an external document into the vault,\n  - checkOut: extract a copy of a document from the vault with the intent of modifying it (exclusive, i.e. only one checkout at a time is possible),\n  - unCheckOut: cancel the effects of a previous checkout,\n  - checkIn: replace an edited document in the vault (the document must previously have been checked out), and\n  - checkInOut: replace an edited document in the vault, while at the same time retaining it as checked out.\n\n  The thinkteam protocol is composed of three components, viz. the Vault, the Concurrency Controller (CC), and the User. While the User is located on the client side, \nthe Vault and the CC can be found on the server side. The messages that can be sent from one component to another, completed with the messages got, checkedOut, notAvailable, \nnotify, and update, whose functioning we now explain. A user requesting a read-only copy of a file via a get is answered by a got, while a user requesting editing rights \nfor a file via a checkOut is answered by a checkedOut or a notAvailable, depending on the availability of the requested file. In this way, the \u201cdirection\u201d of a message is \nclear from its name. Moreover, all users that are registered for a file receive a notify the moment in which this particular file is checked out by another user, while they \nreceive an update as soon as that user has sent either an unCheckOut, a checkIn, or a checkInOut to the CC.\n  Typical series of actions that take place in the thinkteam protocol are the following. \n  - A user can indicate the desire to extract a file from the vault by sending a checkOut to the CC. Upon receiving this action, the CC checks whether this file is available \n    or whether it is locked as the result of a checkOut by another user. If the file is not locked, then the CC sends it to the user that requested it via a checkedOut; \n\totherwise the user receives a notAvailable. \n  - Instead of extracting a file, a user can always request a read-only copy of a file by sending a get to the CC, which the CC responds to with a got. \n  - At any time, the user can insert a new file into the vault by sending it to the CC via an import.",
        "content": "//dnl Define constants\n#define NONE 0;\n#define UNDEF 255;\n\n#define TRUE 1;\n#define FALSE 0;\n\n#define numUsers 1;\n#define numFiles 3;\n\n//dnl pair will be used in buffer communication\n#define FIRST_SIZE 16;\n#define pair(x, y) (x*FIRST_SIZE + y);\n#define first(x) (x / FIRST_SIZE);\n#define second(x) (x % FIRST_SIZE);\n\n//dnl mtype definition\n\n//user\n#define GET 0;\n#define GOT 1;\n#define CHECKOUT 2;\n#define CHECKEDOUT 3;\n#define NOTAVAILABLE 4;\n#define UNCHECKOUT 5;\n\n//publish\n#define IMPORT 6;\n#define CHECKIN 7;\n#define CHECKINOUT 8;\n\n//subscribe\n#define REGISTER 9;\n#define UNREGISTER 10;\n\n//notification\n#define UPDATE 11;\n#define NOTIFY 12;\n\n//dnl Channels between client and server\nchannel userToCC 1;\nchannel ccToUser[numUsers] 1;\nchannel ccToUserAdmin[numUsers] 1;\n\n//dnl Internal server channels\nchannel ccToVault 1;\nchannel vaultToCC 1;\n\n//dnl Message sending synchronization (needed due to lack of constants matching when receiving a message, ie. ch?get)\nchannel msgSync 1;\n\n//dnl User process\nvar User_edit[numUsers][numFiles];\nvar User_registered[numUsers][numFiles];\n\nUser_ready(id, cmd, waitingForCheckedOut) = [waitingForCheckedOut == FALSE]userToCC!call(pair, GET, id) -> User_ready_User_doneGet.id -> User_doneGet(id, cmd, waitingForCheckedOut)\n\t\t\t\t\t\t\t\t            [] [User_registered[id][0] == FALSE && User_edit[id][0] == FALSE]userToCC!call(pair, REGISTER, id){User_registered[id][0] = TRUE;} -> User_doneRegister(id, cmd, waitingForCheckedOut)\n\t\t\t\t\t\t\t\t            [] [User_registered[id][0] == TRUE && User_edit[id][0] == FALSE]userToCC!call(pair, UNREGISTER, id){User_registered[id][0] = FALSE;} -> User_doneUnRegister(id, cmd, waitingForCheckedOut)\n\t\t\t\t\t\t\t\t            [] [User_edit[id][0] == FALSE && waitingForCheckedOut == FALSE]userToCC!call(pair, CHECKOUT, id) -> User_ready(id, cmd, TRUE)\n\t\t\t\t\t\t\t\t            [] [User_edit[id][0] == TRUE]User_ready_User_editing -> User_editing(id, cmd, waitingForCheckedOut)\n\t\t\t\t\t\t\t\t            [] ccToUser[id]?msg -> User_cmdReceived(id, msg, waitingForCheckedOut);\n\nUser_doneGet(id, cmd, waitingForCheckedOut) = ccToUser[id]?msg -> User_getCmdReceived(id, msg, waitingForCheckedOut);\n\nUser_getCmdReceived(id, cmd, waitingForCheckedOut) = [cmd == GOT]User_getCmdReceived_User_ready{User_registered[id][0] = TRUE;} -> User_ready(id, cmd, waitingForCheckedOut);\n\n\nUser_doneRegister(id, cmd, waitingForCheckedOut) = User_doneRegister_User_ready.id -> User_ready(id, cmd, waitingForCheckedOut);\n\nUser_doneUnRegister(id, cmd, waitingForCheckedOut) = User_doneUnRegister_User_ready.id -> User_ready(id, cmd, waitingForCheckedOut);\n\nUser_editing(id, cmd, waitingForCheckedOut) = userToCC!call(pair, UNCHECKOUT, id){User_edit[id][0] = FALSE;} -> User_ready(id, cmd, waitingForCheckedOut)\n\t\t\t\t\t\t\t\t            [] userToCC!call(pair, CHECKIN, id){User_edit[id][0] = FALSE;} -> User_ready(id, cmd, waitingForCheckedOut)\n\t\t\t\t\t\t\t\t            [] userToCC!call(pair, CHECKINOUT, id) -> User_ready(id, cmd, waitingForCheckedOut);\n\nUser_cmdReceived(id, cmd, waitingForCheckedOut) = [cmd == CHECKEDOUT]{User_edit[id][0] = TRUE;} -> User_ready(id, cmd, FALSE)\n\t\t\t\t\t\t\t\t\t            [] [cmd == NOTAVAILABLE]User_cmdReceived_User_ready -> User_ready(id, cmd, FALSE);\n\n//dnl UserAdmin process\nUserAdmin_ready(id, cmd) = ccToUserAdmin[id]?msg -> UserAdmin_cmdReceived(id, msg);\n\n//    cmdReceived -> doneNotify { guard cmd == NOTIFY; sync msgSync!; },\n//    cmdReceived -> doneUpdate { guard cmd == UPDATE; sync msgSync!; },\nUserAdmin_cmdReceived(id, cmd) = [cmd == NOTIFY]msgSync!NONE -> UserAdmin_doneNotify(id, cmd)\n\t\t\t            [] [cmd == UPDATE]msgSync!NONE -> UserAdmin_doneUpdate(id, cmd);\n\nUserAdmin_doneNotify(id, cmd) = UserAdmin_doneNotify_UserAdmin_ready.id -> UserAdmin_ready(id, cmd);\n\nUserAdmin_doneUpdate(id, cmd) = UserAdmin_doneUpdate_UserAdmin_ready -> UserAdmin_ready(id, cmd);\n\n\nUser() = ||| x:{0..numUsers-1} @ User_ready(x, UNDEF, FALSE);\n\nUserAdmin() = ||| x:{0..numUsers-1} @ UserAdmin_ready(x, UNDEF);\n\nvar CC_registered[numUsers];\nCC_ready(cmd, IDC, writeLock) = userToCC?msg -> CC_cmdReceived(msg, IDC, writeLock);\n\nCC_cmdReceived(cmd, IDC, writeLock) = ([] x:{0..numUsers-1} @ ([call(first, cmd) == GET && call(second, cmd) == x]doneGet.x{CC_registered[call(second, cmd)] = TRUE;} -> CC_get_step1(cmd, IDC, writeLock)))\n\t\t\t\t\t\t\t            [] ([] x:{0..numUsers-1} @ [call(first, cmd) == REGISTER && call(second, cmd) == x]doneRegister.x{CC_registered[x] = TRUE;} -> CC_ready(cmd, IDC, writeLock))\n\t\t\t\t\t\t\t            [] ([] x:{0..numUsers-1} @ [call(first, cmd) == UNREGISTER && call(second, cmd) == x]doneUnRegister.x{CC_registered[x] = FALSE;} -> CC_ready(cmd, IDC, writeLock))\n\t\t\t\t\t\t\t            [] [call(first, cmd) == CHECKOUT]CC_cmdReceived_CC_doneCheckOut -> CC_doneCheckOut(cmd, IDC, writeLock)\n\t\t\t\t\t\t\t            [] [call(first, cmd) == UNCHECKOUT]CC_cmdReceived_CC_doneUnCheckOut -> CC_doneUnCheckOut(cmd, IDC, writeLock)\n\t\t\t\t\t\t\t            [] [call(first, cmd) == CHECKIN]CC_cmdReceived_CC_doneCheckIn -> CC_doneCheckIn(cmd, IDC, writeLock)\n\t\t\t\t\t\t\t            [] [call(first, cmd) == CHECKINOUT]CC_cmdReceived_CC_doneCheckInOut -> CC_doneCheckInOut(cmd, IDC, writeLock);\n\nCC_get_step1(cmd, IDC, writeLock) = ccToVault!cmd -> CC_get_step2(cmd, IDC, writeLock);\n\nCC_get_step2(cmd, IDC, writeLock) = vaultToCC?msg -> CC_get_step3(msg, IDC, writeLock);\n\nCC_get_step3(cmd, IDC, writeLock) = [] x:{0..numUsers-1} @ [call(first, cmd) == GOT && call(second, cmd) == x]ccToUser[x]!GOT -> CC_ready(cmd, IDC, writeLock);\n\n\nCC_doneCheckOut(cmd, IDC, writeLock) = [writeLock == FALSE]CC_doneCheckOut_CC_checkOut_step1 -> CC_checkOut_step1(cmd, IDC, writeLock)\n\t\t\t\t\t\t\t\t            [] ([] x:{0..numUsers-1} @ [writeLock == TRUE && call(second, cmd) == x]ccToUser[x]!NOTAVAILABLE -> CC_doneNotAvailable(cmd, IDC, writeLock));\n\n//dnl v originale je zde assert(writeLock == false), neni mi znamo, proc\nCC_checkOut_step1(cmd, IDC, writeLock) = ccToVault!cmd -> CC_checkOut_step2(cmd, IDC, TRUE);\n\nCC_checkOut_step2(cmd, IDC, writeLock) = vaultToCC?msg -> CC_checkOut_step3(msg, IDC, writeLock);\n\nCC_checkOut_step3(cmd, IDC, writeLock) = [] x:{0..numUsers-1} @ [call(first, cmd) == CHECKEDOUT && call(second, cmd) == x]ccToUser[x]!CHECKEDOUT -> CC_checkOut_step3_CC_doneCheckedOut -> CC_doneCheckedOut(cmd, IDC, writeLock);\n\nCC_doneCheckedOut(cmd, IDC, writeLock) = ([] x:{0..numUsers-1} @ [call(second, cmd) == x]CC_doneCheckedOut_CC_checkOut_step4 -> CC_checkOut_step4(cmd, 0, writeLock));\n\nCC_checkOut_step4(cmd, IDC, writeLock) = [IDC < numUsers]CC_checkOut_step4_CC_checkOut_step5 -> CC_checkOut_step5(cmd, IDC, writeLock)\n\t\t\t\t\t\t\t\t            [] [IDC >= numUsers]CC_checkOut_step4_CC_ready -> CC_ready(cmd, IDC, writeLock);\n\nCC_checkOut_step5(cmd, IDC, writeLock) = [] x:{0..numUsers-1} @ [IDC == x && IDC != call(second, cmd) && CC_registered[IDC] == TRUE]ccToUserAdmin[x]!NOTIFY -> msgSync?NONE -> CC_checkOut_step4(cmd, IDC + 1, writeLock)\n\t\t\t\t\t\t\t\t            [] [IDC == call(second, cmd) || CC_registered[IDC] == FALSE]CC_checkOut_step5_CC_checkOut_step4 -> CC_checkOut_step4(cmd, IDC + 1, writeLock);\n\n\nCC_doneNotAvailable(cmd, IDC, writeLock) = CC_doneNotAvailable_CC_ready -> CC_ready(cmd, IDC, writeLock);\n\n\nCC_doneUnCheckOut(cmd, IDC, writeLock) = [] x:{0..numUsers-1} @ [call(second, cmd) == x]CC_doneUnCheckOut_CC_Update -> CC_Update(cmd, IDC, FALSE);\n\nCC_doneCheckIn(cmd, IDC, writeLock) = ccToVault!cmd -> CC_checkIn_step1(cmd, IDC, FALSE);\n\nCC_checkIn_step1(cmd, IDC, writeLock) = ccToVault?msg -> CC_checkIn_step2(msg, IDC, writeLock);\n\nCC_checkIn_step2(cmd, IDC, writeLock) = [] x:{0..numUsers-1} @ [call(second, cmd) == x]CC_checkIn_step2_CC_Update -> CC_Update(cmd, IDC, writeLock);\n\nCC_doneCheckInOut(cmd, IDC, writeLock) = ccToVault!call(pair, CHECKIN, call(second, cmd)) -> CC_checkInOut_step1(cmd, IDC, writeLock);\n\nCC_checkInOut_step1(cmd, IDC, writeLock) = vaultToCC?msg -> CC_checkInOut_step2(msg, IDC, writeLock);\n\nCC_checkInOut_step2(cmd, IDC, writeLock) = [] x:{0..numUsers-1} @ [call(first, cmd) == UPDATE && call(second, cmd) == x]CC_checkInOut_step2_CC_Update -> CC_Update(cmd, IDC, writeLock);\n\nCC_Update(cmd, IDC, writeLock) = CC_Update_CC_update_cycle -> CC_update_cycle(cmd, 0, writeLock);\n\nCC_update_cycle(cmd, IDC, writeLock) = [IDC < numUsers]CC_update_cycle_CC_update_step1 -> CC_update_step1(cmd, IDC, writeLock)\n\t\t\t\t\t\t\t\t            [] [IDC >= numUsers]CC_update_cycle_CC_ready -> CC_ready(cmd, IDC, writeLock);\n\n\nCC_update_step1(cmd, IDC, writeLock) = [] x:{0..numUsers-1} @ [IDC == x && IDC != call(second, cmd) && CC_registered[IDC] == TRUE]ccToUserAdmin[x]!UPDATE -> msgSync?NONE -> doneUpdate.x -> CC_update_cycle(cmd, IDC + 1, writeLock)\n\t\t\t\t\t\t\t            [] [IDC == call(second, cmd) || CC_registered[IDC] == FALSE]CC_update_step1_CC_update_cycle -> CC_update_cycle(cmd, IDC + 1, writeLock);\n\n\n//dnl Vault process\nVault_ready(cmd) = ccToVault?msg -> Vault_cmdReceived(msg);\nVault_cmdReceived(cmd) = [call(first, cmd) == GET]vaultToCC!call(pair, GOT, call(second, cmd)) -> Vault_ready(cmd)\n\t\t\t            [] [call(first, cmd) == CHECKOUT]vaultToCC!call(pair, CHECKEDOUT, call(second, cmd)) -> Vault_ready(cmd)\n\t\t\t            [] [call(first, cmd) == CHECKIN]vaultToCC!call(pair, CHECKIN, call(second, cmd)) -> Vault_ready(cmd);\n\n\nPROC() = User() ||| UserAdmin() ||| CC_ready(UNDEF, 0, FALSE) ||| Vault_ready(UNDEF);",
        "property_desc": [
            "Every lock request must eventually be responded to.",
            "Every lock on a file must eventually be released.",
            "A user does not receive a notify (update) if she is not registered for the file these messages refer to, i.e. the user does not receive any \u201cillegal\u201d notify (update)."
        ],
        "properties": [
            "#assert PROC() |= [] (CC_cmdReceived_CC_doneCheckOut -> <> (CC_checkOut_step3_CC_doneCheckedOut || CC_doneNotAvailable_CC_ready));",
            "#assert PROC() |= [] (CC_checkOut_step3_CC_doneCheckedOut -> F(CC_cmdReceived_CC_doneCheckIn || CC_cmdReceived_CC_doneUnCheckOut));",
            "#assert PROC() |= !(!(User_ready_User_doneGet.0 || User_doneRegister_User_ready.0) U UserAdmin_doneNotify_UserAdmin_ready.0) && [] (User_doneUnRegister_User_ready.0 -> !(!(User_ready_User_doneGet.0 || User_doneRegister_User_ready.0) U UserAdmin_doneNotify_UserAdmin_ready.0));"
        ],
        "path": "pat_examples/beem/Other Protocols/Publish subscribe.csp"
    },
    {
        "name": "Synapse",
        "tags": [
            "Protocol"
        ],
        "use_non_container_lib": true,
        "description": "Synapse cache coherence protocol: several caches are connected by a bus, the goal of the protocol is to keep the content of the caches coherent.\n\n  This approach was used in the Synapse N + 1, a multiprocessor for fault-tolerant transaction. The N + 1 differs from other shared bus designs considered here in that \nit has two system buses. Another noteworthy difference is the inclusion of a single-bit tag with each cache block in main memory, indicating whether main memory is to \nrespond to a miss on that block. If a cache has a modified copy of the block, the bit tells the memory that it need not respond. This prevents a possible race condition \nif a cache does not respond quickly enough to inhibit main memory from responding. Cache blocks are in one of the following states: INVALID, state state VALID (unmodified, \npossibly shared), and DIRTY (modified, no other copies). Only blocks in DIRTY are written back when replaced. Any cache with a copy of a block in DIRTY is called the owner \nof that block. If no DIRTY copy exists, memory is the owner. \n  The Synapse coherence solution is the following: \n  (1) Read miss. If another cache has a DIRTY copy, the cache submitting the read miss receives a negative acknowledgement block back to main memory, simultaneously \n      The owner then writes the resetting the bit tag and changing the local state to INVALID. additional The requesting cache must then send ,an miss request to get the \n\t  block from main memory. In all other cases the block comes directly from main memory. Note that the block is always supplied by its owner, whether memory or a cache. \n\t  The loaded block is always in state VALID. \n  (2) Write hit. If the block is DIRTY, the write can proceed without delay. If the block is VALID, the procedure is identical to a write miss (including a full data transfer)\n      since there is no invalidation signal.\n  (3) Write miss. Like a read miss, the block always comes from memory\u2014\u2014if the block was DIRTY in another cache, it must first be written to memory by the owner. \n      Any caches with a VALID block copy set their state to INVALID, and the block is loaded in state DIRTY. The block\u2019s tag in main memory is set so that the memory ignores \n\t  subsequent requests for the block.",
        "content": "#import \"PAT.Lib.Synapse\";\n\n#define TRUE 1;\n#define FALSE 0;\n\n// Number of applications and caches\n#define N 2;\n// Number of lines in a cache\n#define Lines 2;\n\nchannel read[N] 0;\nchannel write[N] 0;\nchannel answer[N] 0;\nchannel bus[N] 0;\n\n#define READ 1;\n#define READ_INVALIDATE 2;\n#define INVALIDATE 3;\n#define OK -1;\n#define UNDEF 255;\n\n#define TR 16;\n#define pair(x, y) (x * TR + y);\n#define first(x) (x/TR);\n#define second(x) (x%TR);\n\nvar lock = FALSE;\n\nvar written_line = UNDEF;\nvar written_value = UNDEF;\nvar read_line = UNDEF;\nvar read_value = UNDEF;\n\n\napplication_ext_idle(id, m) = ([] x:{0..Lines-1} @ [lock == FALSE]write[id]!call(pair, x, 0){lock = TRUE; written_line = x; written_value = 0; read_line = UNDEF; read_value= UNDEF;} -> WRITE_LINE_VALUE.written_line.written_value -> application_ext_wait_write(id, m))\n\t\t\t\t\t            [] ([] x:{0..Lines-1} @ [lock == FALSE]write[id]!call(pair, x, 1){lock = TRUE; written_line = x; written_value = 1; read_line = UNDEF; read_value= UNDEF;} -> WRITE_LINE_VALUE.written_line.written_value -> application_ext_wait_write(id, m))\n\t\t\t\t\t            [] ([] x:{0..Lines-1} @ [lock == FALSE]read[id]!x{lock = TRUE; read_line = x; read_value = 2; written_line = UNDEF; written_value= UNDEF;} -> application_ext_wait_read(id, m));\n\napplication_ext_wait_write(id, m) = answer[id]?msg{lock = FALSE;} -> application_ext_idle(id, msg);\n\napplication_ext_wait_read(id, m) = answer[id]?msg{read_value = msg; lock = FALSE;} -> READ_LINE_VALUE.read_line.read_value -> application_ext_idle(id, m);\n\n\ninvalid(id, value, m, m2) = bus[id]?msg -> i_bus_req(id, value, msg, m2)\n\t\t\t\t            [] read[id]?msg -> i_app_read(id, value, msg, m2)\n\t\t\t\t            [] write[id]?msg -> i_app_write(id, value, msg, m2);\n\ni_bus_req(id, value, m, m2) = [m == READ || m == READ_INVALIDATE]bus[id]!OK -> invalid(id, value, m, m2)\n\t\t\t\t\t            [] [m == INVALIDATE]i_bus_req_invalid.id -> invalid(id, value, m, m2);\n\ni_app_read(id, value, m, m2) = bus[id]!READ -> iv1(id, value, m, m2);\n\niv1(id, value, m, m2) = bus[id]?msg -> iv2(id, msg, m, m2);\n\niv2(id, value, m, m2) = answer[id]!call(cal_valid_value, value, m) -> valid(id, value, m, m2);\n\ni_app_write(id, value, m, m2) = bus[id]!READ_INVALIDATE -> id1(id, value, m, m2);\n\nid1(id, value, m, m2) = bus[id]?msg -> set_value(id, msg, m, m2);\n\nset_value(id, value, m, m2) = answer[id]!OK -> dirty(id, call(cal_set_value, value, call(first, m), call(second, m)), m, m2);\n\nvalid(id, value, m, m2) = bus[id]?msg -> v_bus_req(id, value, msg, m2)\n\t\t\t\t            [] read[id]?msg -> v_app_read(id, value, msg, m2)\n\t\t\t\t            [] write[id]?msg -> v_app_write(id, value, msg, m2);\n\nv_bus_req(id, value, m, m2) = [m == READ]bus[id]!OK -> valid(id, value, m, m2)\n\t\t\t\t\t            [] [m == INVALIDATE]v_bus_req_invalid.id -> invalid(id, value, m, m2)\n\t\t\t\t\t            [] [m == READ_INVALIDATE]bus[id]!OK -> invalid(id, value, m, m2);\n\nv_app_read(id, value, m, m2) = answer[id]!call(cal_valid_value, value, m) -> valid(id, value, m, m2);\n\nv_app_write(id, value, m, m2) = bus[id]!INVALIDATE -> wait_bus_ack(id, value, m, m2);\n\nwait_bus_ack(id, value, m, m2) = bus[id]?msg -> set_value(id, value, m, msg);\n\ndirty(id, value, m, m2) = bus[id]?msg -> d_bus_req(id, value, msg, m2)\n\t\t\t\t            [] read[id]?msg -> d_app_read(id, value, msg, m2)\n\t\t\t\t            [] write[id]?msg -> set_value(id, value, msg, m2);\n\nd_bus_req(id, value, m, m2) = [m == READ]bus[id]!value -> valid(id, value, m, m2)\n                                [] [m == READ_INVALIDATE]bus[id]!value -> invalid(id, value, m, m2)\n                                [] [m == INVALIDATE]d_bus_req_error_st.id -> error_st(id, value, m, m2);\n\nd_app_read(id, value, m, m2) = answer[id]!call(cal_valid_value, value, m) -> dirty(id, value, m, m2);\n\nvar error_cache = UNDEF;\nerror_st(id, value, m, m2) = CACHE_ERROR.id{error_cache = id;} -> Skip;\n\n\nP() = (||| i:{0..N-1} @ application_ext_idle(i, UNDEF))\n    ||| (||| i:{0..N-1} @ valid(i, 0, UNDEF, OK));\n\nBus_idle(i, j, value, m) = [] x:{0..N-1} @ bus[x]?msg -> Bus_send(x, 0, value, msg);\n\nBus_send(i, j, value, m) = [j == i]Bus_send_Bus_send.i.j -> Bus_send(i, j + 1, value, m)\n\t\t\t            [] ([] x:{0..N-1} @ [j == x && j != i]bus[x]!m -> Bus_send(i, j + 1, value, m))\n\t\t\t            [] ([] x:{0..N-1} @ [i == x && j == N && m == INVALIDATE]bus[x]!OK -> Bus_idle(i, j, value, m))\n\t\t\t            [] [j == N && m != INVALIDATE]Bus_send_Bus_wait.i.j -> Bus_wait(i, 0, value, m);\n\nBus_wait(i, j, value, m) = [j == i]Bus_wait_Bus_wait.i.j -> Bus_wait(i, j + 1, value, m)\n\t\t\t            [] ([] x:{0..N-1} @ [j == x && j != i]bus[x]?msg -> Bus_check(i, j + 1, value, msg))\n\t\t\t            [] ([] x:{0..N-1} @ [j == N && i == x]bus[x]!value -> Bus_idle(i, j, value, m));\n\nBus_check(i, j, value, m) = [m != OK]Bus_check_Bus_wait.i.j -> Bus_wait(i, j, m, m)\n\t\t\t            [] [m == OK]Bus_check_Bus_wait.i.j -> Bus_wait(i, j, value, m);\n\nPROC() = Bus_idle(UNDEF, UNDEF, UNDEF, UNDEF) ||| P();",
        "property_desc": [
            "No cache enters an error state.",
            "If no specific value is written to a line, the value will not be read.",
            "If a specific value is written to a line and, either the value is not modified or no other value is read until it has been modified."
        ],
        "properties": [
            "#define goal (error_cache == 0);\n#assert PROC() reaches goal;",
            "#assert PROC() |= ([] ! WRITE_LINE_VALUE.1.1) -> ([] ! READ_LINE_VALUE.1.1);",
            "#assert PROC() |= [] (WRITE_LINE_VALUE.1.1 -> (([] ! WRITE_LINE_VALUE.1.0) || ((! READ_LINE_VALUE.1.0) U (WRITE_LINE_VALUE.1.0)) ) );"
        ],
        "path": "pat_examples/beem/Other Protocols/Synapse.csp"
    },
    {
        "name": "Telecommunication Service",
        "tags": [
            "Protocol"
        ],
        "use_non_container_lib": false,
        "description": "Model of a telecommunication service with some features (call forward when busy, ring back when free).\n\n  The protocol has the following states and transition rules:\n  - Idle: The initial state of a user who waiting for a call or attempting to initiate a call.\n    - If there may be incoming call, it sets its partner to the corresponding user and transitions to QI state. \n    - When initiating a call, the device needs to be turned off and update chnl[i] to reflect a connection attempt.\n  - Dialing: The user may cancel the dialing and go back to the Idle state or dials someone.\n  - Calling: When calling\n    - If the partner is the user himself, transition to Busy state.\n\t- If the partner is invalid, transition to Unobtainable state.\n\t- If the partner is busy and ringback is enabled, transition to Ringback state.\n\t- If the partner is busy and call forwarding is not enabled, transition to Busy state and record the call attempt.\n\t- If the partner is busy and call forwarding is enabled, forward the call to another user and continue calling.\n\t- If the partner is free, alert the original caller and attempt to connect.\n  - Busy: The only thing the user can do is to reset the connection and transition back to Idle state.\n  - QI: Query Incoming. It checks whether the incoming call request from another user is valid and can be accepted.\n    - If so, it transitions to the Talert state, where they are alerted about the incoming call and can decide whether to accept it.\n\t- Otherwise, the user rejects the call by resetting their partner and returns to the Idle state\n  - Talert: When receiving an incoming call,\n    - This can not happen when the device if off or there is no connection. Thus, an error arises.\n\t- If the partner is the caller, the user picks up the call. Otherwise, it transitions to the Idle state.\n  - Unobtainable: Like Busy statem, the connection is reset, the device is turned on again and it transitions back to Idle state.\n  - Oalert: When a user has initiated a call and is waiting for the call to be answered\n    - If the connection doesn't matches the expected partner, an error arises.\n\t- If the partner has picked up the handset, the call is successfully established. Otherwise, it transitions to Oringout.\n  - Oconnected: After a successful call, the user may hang up the handset and the connection is reset and transactions back to Idle state.\n  - Oringout: The only thing the user can do is to reset the connection and transition back to Idle state.\n  - Tpickup:\n    - If the connection matches the expected partner, the user picks up the handset and the call is successfully established. \n\t- Otherwise, it clears the connection and transitions back to Idel state.\n  - Tconnected:\n    - The call may keep ongoing.\n    - If the call is terminated, it clears the connection and transitions back to Idel state.\n  - Ringback: If a call attempt is recorded, it trys to call the partner again. Otherwise, the connection is reset, the device is turned on again and it transitions back to Idle state",
        "content": "// Number of users\n#define N 2;\n// Enable forward when busy feature (0/1)\n//#define FORWARD 1;\n// Enable ring back when free feature (0/1)\n//#define BACK 1;\n\n#define ON 1;\n#define OFF 0;\n#define NULL 255;\n\n\n\nvar chnl= [NULL(N)];\nvar partner = [NULL(N)];\n\nvar call_forward_busy = [1..N-1,NULL];\n//ifelse(FORWARD,1,`byte call_forward_busy[N] = {myloop(x,0,eval(N-2), `eval(x+1)', `,'), NULL};',`')\n//FORWARD == 1, call_forward_busy = [1..N-1,255]\n//FORWARD != 1, null\n\nvar record = [NULL(N)];\n//ifelse(BACK,1,`byte record[N] = {myloop(x,0,decr(N), `NULL', `,')};',`')\n//Back ==1, record = [255(N)];\n//BACK != 1, null\n\n/*------------------------------------------------------------------------------------------------------------------------------------------------------*/\n\nTelephony() = (|||i:{0..N-1} @ User(i));\n\n\n/*------------------------------------------------------------------------------------------------------------------------------------------------------*/\n\nvar dev = [ON(N)];\nvar mbit = 0;\n\nhvar errorstate_flag = [0(N)];\n\nUser(i) = Idle(i) ; \n\nIdle(i) = [ chnl[i] == NULL ]idle.i.0{ dev[i] = OFF; chnl[i] = ((i)+(0)*20)} -> Dialing(i) []\n\t\t  [ chnl[i] != NULL ]idle.i.1{ partner[i] = ((chnl[i])%20) } -> QI(i);\t\t \n\nDialing(i) = (dialing.i.0{ dev[i] = ON; chnl[i] = NULL } -> Idle(i)) []\n\t\t\t dialing.i.1{ partner[i] = 0 } -> Calling(i) []\n\t\t\t dialing.i.2{ partner[i] = 1 } -> Calling(i) []\n\t\t\t dialing.i.3{ partner[i] = 2 } -> Calling(i);\n//forloop(x,0,N, ` dialing -> calling { effect partner[$1] = x; }, ')\n\t\t\t \nCalling(i) = [ partner[i] == i ]calling.i.0 -> Busy(i) []\n\t\t\t [ partner[i] == N ]calling.i.1 -> Unobtainable(i) []\n\t\t\t [ partner[i] == N ]calling.i.2 -> Ringback(i) [] \t\t//the only way to fire Ringback(i)\n\t\t\t [ (partner[i] != i && partner[i] != N && chnl[partner[i]] != NULL && call_forward_busy[partner[i]] == NULL) ]\n\t\t\t \t\tcalling.i.3{ record[partner[i]] = i } -> Busy(i) []\t\t\n \t\t\t [ partner[i] != i && partner[i] != N && chnl[partner[i]] != NULL && call_forward_busy[partner[i]] != NULL ]\n\t\t\t \t\tcalling.i.4{ record[partner[i]] = i ; partner[i] = call_forward_busy[partner[i]] } -> Calling(i) []\t\t\t \n\t\t\t [ partner[i] != i && partner[i] != N && chnl[partner[i]] == NULL ]\n\t\t\t \t\tcalling.i.5{ record[partner[i]] = i ; chnl[partner[i]] = ((i)+(0)*20); chnl[i] = ((partner[i])+(0)*20) } -> Oalert(i);\n\nBusy(i) = busy.i{ chnl[i] = NULL; partner[i] = NULL; dev[i] = ON } -> Idle(i);\n\nQI(i) = [ ((chnl[partner[i]])%20) == i ]qi.i.0 -> Talert(i) []\n\t\t[ ((chnl[partner[i]])%20) != i ]qi.i.1{ partner[i] = NULL } -> Idle(i);\n\nTalert(i) = [ dev[i] != ON || chnl[i] == NULL ]talert.i.0{ errorstate_flag[i] = 1 } -> Skip []\n\t\t\t[ ((chnl[partner[i]])%20) == i ]talert.i.1 -> Tpickup(i) []\n\t\t\t[ ((chnl[partner[i]])%20) != i ]talert.i.2 -> Idle(i);\n\nUnobtainable(i) = unobtainable.i{ chnl[i] = NULL; partner[i] = NULL; dev[i] = ON } -> Idle(i);\n\nOalert(i) = [ ((chnl[i])%20) != partner[i] ]oalert.i.0{ errorstate_flag[i] = 1 } -> Skip []\n\t\t\t[ ((chnl[i])%20) == partner[i] && ((chnl[i])/20) == 1 ]oalert.i.1 -> Oconnected(i) []\n\t\t\t[ ((chnl[i])%20) == partner[i] && ((chnl[i])/20) == 0 ]oalert.i.2 -> Oringout(i);\n\nOconnected(i) = oconnected.i{ dev[i] = ON; chnl[i] = NULL; chnl[partner[i]] = NULL } -> Idle(i);\n\nOringout(i) = oringout.i{ dev[i] = ON; chnl[i] = NULL; partner[i] = (((partner[i])%20)+(0)*20) } -> Idle(i);\n\nTpickup(i) = [ ((chnl[partner[i]])%20) == i && ((chnl[partner[i]])/20) == 0 ]tpickup.i.0{ dev[i] = OFF; chnl[partner[i]] = ((i)+(1)*20); chnl[i] = ((partner[i])+(1)*20) } -> Tconnected(i) []\n\t\t\t [ chnl[partner[i]] == NULL || ((chnl[partner[i]])%20) != i ]tpickup.i.1{ dev[i] = ON; partner[i] = NULL; chnl[i] = NULL } -> Idle(i);\n\nTconnected(i) = [ ((chnl[i])/20) == 1 && dev[i] == OFF ]tconnected.i.0{ dev[i] = ON } -> Tconnected(i) []\n\t\t\t\t[ ((chnl[i])/20) == 1 && dev[i] == ON ]tconnected.i.1{ dev[i] = OFF } -> Tconnected(i) []\n\t\t\t\t[ ((chnl[i])/20) == 0 ]tconnected.i.2{ partner[i] = NULL; chnl[i] = NULL; dev[i] = ON } -> Idle(i);\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\nRingback(i) = ringback.i.0{ chnl[i] = NULL; partner[i] = NULL; dev[i] = ON } -> Idle(i) []\n\t\t\t  [ record[i] != NULL ]ringback.i.1{ partner[i] = record[i] } -> Calling(i);\n\n\n\n/*-----------------------------------------------------------------------------------------------*/",
        "property_desc": [
            "The protocol is deadlockfree",
            "User can get into an error state."
        ],
        "properties": [
            "#assert Telephony deadlockfree;",
            "#define errorstate_pro errorstate_flag[0] == 1;\n#assert Telephony reaches errorstate_pro;"
        ],
        "path": "pat_examples/beem/Other Protocols/Telecommunication Service.csp"
    },
    {
        "name": "Schedule Blocks",
        "tags": [
            "Puzzle"
        ],
        "use_non_container_lib": false,
        "description": "There is a set of blocks on infinite table where one block may be on the other block or on the table and the goal is to put blocks into a certain configuration.\n  In this example, the goal is that block 3 is on block 2 and block 2 is on block 0 and block 0 is on block 1.\n  The block is clear if there is no other block on the top of it and it is not in the hand.\n  There are four actions can be performed:\n  - Pick up: When a block is clear and it is on the table, it can be picked up if the hand is empty(The block is no longer clear and the hand is no longer empty).\n  - Put down: When the hand is holding a block, it can be placed on the table(The block is clear and the hand is empty).\n  - Stack: When the hand is holding block X and block Y is clear, block X can be placed on top of block Y(The block X is clear, the block Y is no longer clear the hand is empty).\n  - Unstack: When block X is on top of block Y and block X is clear, it can be picked up if the hand is empty(The block X is no longer clear, the block Y is clear and the hand is no longer empty).",
        "content": "#define TABLE 254;\n#define HAND 255;\n#define EMPTY 253;\n\nvar holding = EMPTY;\nhvar finish = 0;\n\n#define N 4;\nvar on[N] = [3,2,0,TABLE];\nvar clear[N] = [0,1,0,0];\n\nEmptyhand() =  ( []x:{0..N-1}@([ clear[x] == 1 && on[x] == TABLE ]match_tofull{ on[x] = HAND; clear[x] = 0; holding = x } -> Fullhand()))\n            [] ( []y:{0..N-1}@([ clear[y] == 1 && on[y] != TABLE ]notmatch_tofull{ clear[on[y]] = 1; on[y] = HAND; clear[y] = 0; holding=y } -> Fullhand()))\n            [] [on[3] == 2 && on[2] == 0 && on[0] == 1 ]done{ finish = 1 } -> Stop;\n\nFullhand() =  ( []i:{0..N-1}@([ clear[i] == 1 ]toempty{ clear[i] = 0; clear[holding] = 1; on[holding] = i; holding = EMPTY } -> Emptyhand()))\n           [] ( controlclear{ clear[holding] = 1; on[holding] = TABLE; holding = EMPTY } -> Emptyhand());\n\nBlocks() = Emptyhand();",
        "property_desc": [
            "The given goal state is reached.",
            "The model is deadlock-free."
        ],
        "properties": [
            "#define goal (finish == 1);\n#assert Blocks() reaches goal;",
            "#assert Blocks() deadlockfree;"
        ],
        "path": "pat_examples/beem/Planning and Scheduling/Blocks.csp"
    },
    {
        "name": "Elevator_planning",
        "tags": [
            "Real World"
        ],
        "use_non_container_lib": false,
        "description": "Planning of elevator strategy under several constraints. The goal is to serve All passengers to the 0. floor.\n  There are several restricting constraints like:\n  - Capacity: The number of passengers in the elevator is limited.\n  - Conflict_A/B: Special groups of passengers who cannot be served simultaneously or on the same floor.\n  - Not Alone: There exists passengers who must always be accompanied by an attendant.\n  The passengers are on a certain floor and the elevator are on floor 0 at the beginning. The elevator may move up or down. \n  Passengers can get in or get out of the elevator when the passenger is at the same floor as the elevator and the above constraints are satisfied.",
        "content": "#define FLOORS 7;\n#define CAPACITY 3;\n#define N 7;\nvar person[N]    = [0,1,2,3,4,0,3];\nvar conflictA[N] = [1,0,0,1,1,0,0];\nvar conflictB[N] = [0,1,1,0,0,1,0];\nvar not_alone[N] = [1,1,0,0,0,0,0];\nvar at=0;\nvar inA=0;\nvar inB=0;\nvar in=0;\nvar alone=0;\n\nGettingIn()=[]x:{0..N-1}@([person[x]==at&&in<CAPACITY&&(conflictA[x]==0||inB==0)&&(conflictB[x]==0||inA==0)&&(not_alone[x]==0||in>0)]\n            { person[x]=255; in=in+1; inA=inA+conflictA[x]; inB = inB + conflictB[x]; alone = alone + not_alone[x];}->Elevator());\nGettingOut()=[]x:{0..N-1}@([person[x]==255&&(in>2 || (alone - not_alone[x]==0))]\n            { person[x] = at; in = in-1;inA = inA - conflictA[x]; inB = inB - conflictB[x]; alone = alone - not_alone[x];}->Elevator());\nMoveUpDown()=[]x:{0..FLOORS-1}@({at=x;}->Elevator());\nDone()=[person[0]==0&&person[1]==0&&person[2]==0&&person[3]==0&&person[4]==0&&person[5]==0&&person[6]==0]done->Stop;\nElevator()=GettingIn()[]GettingOut()[]MoveUpDown()[]Done();",
        "property_desc": [
            "All passengers are at the 0. floor.",
            "The model is deadlock-free."
        ],
        "properties": [
            "#define goal person[0]==0&&person[1]==0&&person[2]==0&&person[3]==0&&person[4]==0&&person[5]==0&&person[6]==0;\n#assert Elevator() reaches goal;",
            "#assert Elevator() deadlockfree;"
        ],
        "path": "pat_examples/beem/Planning and Scheduling/Elevator planning.csp"
    },
    {
        "name": "EXIT: Model of a City Team Game",
        "tags": [
            "Puzzle",
            "Timing"
        ],
        "use_non_container_lib": false,
        "description": "\"EXIT\" is a game for teams of 3-5 people. The game takes place in a city of Brno a lasts for 5 hours. \n  During the game teams have to solve different tasks (e.g., ciphers) at different places(e.g. Studovna, Moravak). \n  These tasks each have prerequisites(solving other tasks or adequate collective effort) and time constraints. \n  Actions may involve solving tasks, moving to other locations. Once a task is solve, the player contributs to the team's collective effort (body).\n  The goal of the game is to get into a \"modul\" before certain time limit.",
        "content": "// Number of players\n#define N 2;\n// Max time\n#define MAX 2;\n\n\nvar time = 0;\t\t\t\t//counter\nvar done[N];\t\t\t\t//slots for individual action\nvar at_modul = 0;\t\t\t//if at 'modul' or not\nvar body = 0;\t\t\t\t//record the human resources used during the process\nvar solved[20];\t\t\t\t//the puzzles have been solved or not\n\n/*--------------------------------------------------------------------------------------------------------------------------------*/\n\n//release the human resource per time unit\nTimer() = [ time < MAX ] tick { \n\t\t\t\t\t\t\t\tvar index = 0;\n\t\t\t\t\t\t\t    while( index < N )\n\t\t\t\t\t\t\t    {\n\t\t\t\t\t\t\t   \t\tdone[index] = 0;\n\t\t\t\t\t\t\t   \t\tindex = index + 1;\n\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t    time = time + 1; \n\t\t\t\t\t\t\t  } -> Timer();\n\n/*--------------------------------------------------------------------------------------------------------------------------------*/\n\n\n\nStudovna(x) = /*studovna ->*/ ( [ done[x] == 0 ]tau{ done[x] = 1; } -> Moravak(x)) [] \n\t\t\t  \t\t\t\t( [ done[x] == 0 ]tau{ done[x] = 1; } -> Svobodak(x)) [] \n\t\t\t  \t\t\t\t( [ done[x] == 0 ]tau{ done[x] = 1; } -> Spilberk(x)) []\t  \t\t\t\t\n\t\t\t\t\t\t    ( [ done[x] == 0 && solved[3] == 0 && time >= 2 && time <= MAX ]tau{ done[x] = 1; solved[3] = 1; body = body + 1; } -> Studovna(x)) [] \t\t  \t\t\t\t\t\t\t  \t\t\t\t\n\t\t\t\t\t\t    ( [ done[x] == 0 && solved[6] == 0 && time >= 3 && time <= MAX ]tau{ done[x] = 1; solved[6] = 1; body = body + 1; } -> Studovna(x)) []\n\t\t\t\t\t\t    ( [ done[x] == 0 && solved[9] == 0 && time >= 7 && time <= MAX ]tau{ done[x] = 1; solved[9] = 1; body = body + 1; } -> Studovna(x)) []\n\t\t\t\t\t\t    ( [ done[x] == 0 && solved[10] == 0 && time >= 6 && time <= MAX ]tau{ done[x] = 1; solved[10] = 1; body = body + 1; } -> Studovna(x)) []\n\t\t\t\t\t\t    ( [ done[x] == 0 && solved[11] == 0 && time >= 7 && time <= MAX ]tau{ done[x] = 1; solved[11] = 1; body = body + 1; } -> Studovna(x)) []\n\t\t\t\t\t\t    ( [ done[x] == 0 && solved[12] == 0 && time >= 9 && time <= MAX ]tau{ done[x] = 1; solved[12] = 1; body = body + 1; } -> Studovna(x)) []\n\t\t\t\t\t\t    ( [ done[x] == 0 && solved[15] == 0 && time >= 11 && time <= MAX ]tau{ done[x] = 1; solved[15] = 1; body = body + 1; } -> Studovna(x))\t\t\t\t  \t\t\t\t\n\t\t\t  \t\t\t;\n\t\t\t  \t\t\t\nMoravak(x) = /*moravak ->*/ ([ done[x] == 0 ]tau{ done[x] = 1; } -> Studovna(x)) [] \n\t\t\t\t\t\t  ([ done[x] == 0 ]tau{ done[x] = 1; } -> Tyrs(x)) []\n\t\t\t\t\t\t  ([ done[x] == 0 ]tau{ done[x] = 1; } -> Jaroska(x)) []\n\t\t\t\t\t\t  ([ done[x] == 0 ]tau{ done[x] = 1; } -> Svobodak(x)) []\n\t\t\t\t\t\t  ([ done[x] == 0 && solved[19] == 1 && solved[17] == 1 ]tau{ done[x] = 1; } -> Burian(x)) []\n\t\t\t\t\t\t  ([ done[x] == 0 && solved[7] == 0 && time >= 6 && time <= MAX ]tau{ done[x] = 1; solved[7] = 1; body = body + 1; } -> Moravak(x)) [] \n\t\t\t\t\t\t  ([ solved[16] == 1 && done[x] == 0]tau{ done[x] = 1; solved[18] = 1; } -> Moravak(x))\n\t\t\t\t\t\t;\n\nTyrs(x) = /*tyrs ->*/ ([ done[x] == 0 ]tau{ done[x] = 1; } -> Moravak(x)) [] \n\t\t\t          ([ done[x] == 0 && solved[2] == 0 && time >= 1 && time <= 4 ]tau{ done[x] = 1; solved[2] = 1; body = body + 1 } -> Tyrs(x)) []\n\t\t     \t  \t  ([ done[x] == 0 && solved[14] == 0 && time >= 9 && time <= 13]tau{ done[x] = 1; solved[14] = 1; body = body + 1 } -> Tyrs(x));\n\nJaroska(x) = /*jaroska ->*/ ([ done[x] == 0]tau{ done[x] = 1 } -> Moravak(x)) []\n\t\t\t\t\t\t\t([ done[x] == 0 && solved[0] == 0 && time >= 0 && time <= 2 ]tau{ done[x] = 1; solved[0] = 1; body = body + 1 } -> Jaroska(x)) []\n\t\t\t\t\t\t\t([ solved[18] == 1 && done[x] == 0 ]tau{ done[x] = 1; solved[19] = 1 } -> Jaroska(x));\n\nSvobodak(x) = /*svobodak ->*/([ done[x] == 0 ]tau{ done[x] = 1 } -> Moravak(x)) []\n\t\t\t\t\t\t\t ([ done[x] == 0 ]tau{ done[x] = 1 } -> Malinak(x)) []\n\t\t\t\t\t\t\t ([ done[x] == 0 ]tau{ done[x] = 1 } -> Petrov(x)) []\n\t\t\t\t\t\t\t ([ done[x] == 0 ]tau{ done[x] = 1 } -> Studovna(x)) []\n\t\t\t\t\t\t\t ([ done[x] == 0 && solved[5] == 0 && time >= 5 && time <= 5 ]tau{ done[x] = 1; solved[5] = 1; body = body + 1 } -> Svobodak(x)) []\n\t\t\t\t\t\t\t ([ done[x] == 0 && solved[7] == 0 && time >= 6 && time <= MAX ]tau{ done[x] = 1; solved[7] = 1; body = body + 1 } -> Svobodak(x))[]\n\t\t\t\t\t\t\t ([ body >= 10 && done[x] == 0 ]tau{ done[x] = 1; solved[17] = 1 } -> Svobodak(x));\n\t\t\t\t\t\t\t \nMalinak(x) = /*malinak ->*/ ([ done[x] == 0 ]tau{ done[x] = 1 } -> Svobodak(x)) []\n\t\t\t\t\t\t\t([ done[x] == 0 && solved[13] == 0 && time >= 12 && time <= MAX ]tau{ done[x] = 1; solved[13] = 1; body = body + 1 } -> Malinak(x)) []\n\t\t\t\t\t\t\t([ done[x] == 0 && solved[7] == 0 && time >= 6 && time <= MAX ]tau{ done[x] = 1; solved[7] = 1; body = body + 1 } -> Malinak(x));\n\nPetrov(x) = /*petrov ->*/ ([ done[x] == 0 ]tau{ done[x] = 1 } -> Svobodak(x)) []\n\t\t\t\t\t\t  ([ done[x] == 0 ]tau{ done[x] = 1 } -> Spilberk(x)) []\n\t\t\t\t\t\t  ([ done[x] == 0 && solved[0] == 0 && time >= 0 && time <= 2 ]tau{ done[x] = 1; solved[0] = 1; body = body + 1 } -> Petrov(x)) []\n\t\t\t\t\t\t  ([ done[x] == 0 && solved[4] == 0 && time >= 5 && time <= 5 ]tau{ done[x] = 1; solved[4] = 1; body = body + 1 } -> Petrov(x)) []\n\t\t\t\t\t\t  ([ body >= 10 && done[x] == 0 ]tau{ done[x] = 1; solved[16] = 1 } -> Petrov(x));\n\nSpilberk(x) = /*spilberk ->*/ ([ done[x] == 0 ]tau{ done[x] = 1 } -> Petrov(x)) []\n\t\t\t\t\t\t\t  ([ done[x] == 0 ]tau{ done[x] = 1 } -> Studovna(x)) []\n\t\t\t\t\t\t\t  ([ done[x] == 0 && solved[1] == 0 && time >= 0 && time <= 4 ]tau{ done[x] = 1; solved[1] = 1; body = body + 1 } -> Spilberk(x)) []\n\t\t\t\t\t\t\t  ([ done[x] == 0 && solved[8] == 0 && time >= 8 && time <= 9 ]tau{ done[x] = 1; solved[8] = 1; body = body + 1 } -> Spilberk(x));\n\t\t\t\t\t\t\t  \nBurian(x) = /*burian ->*/ [ done[x] == 0 ]tau{ done[x] = 1 } -> Wilson(x);\n\nWilson(x) = /*wilson ->*/ [ done[x] == 0 ]atmodule{ at_modul = at_modul + 1; done[x] = 1 } -> Module();\n\nModule() = Skip;\n\n\n\n/*--------------------------------------------------------------------------------------------------------------------------------*/\n\n  \t\t\nExit() = Timer() ||| Studovna(0) ||| (||| x:{1..N-1} @ Moravak(x));\n\n/*--------------------------------------------------------------------------------------------------------------------------------*/",
        "property_desc": [
            "The model is deadlock-free.",
            "Team can get into the \"modul\" in a given time limit."
        ],
        "properties": [
            "#assert Exit() deadlockfree;",
            "#define goal (time < MAX && at_modul == N);\n#assert Exit() reaches goal;"
        ],
        "path": "pat_examples/beem/Planning and Scheduling/EXIT Model of a City Team Game.csp"
    },
    {
        "name": "Krebs Cycle",
        "tags": [
            "Real World"
        ],
        "use_non_container_lib": false,
        "description": "The Krebs cycle is a series of chemical reactions of central importance in all living cells that utilize oxygen as part of cellular respiration.\n  In these aerobic organisms, the citric acid cycle is a metabolic pathway that forms part of the break down of carbohydrates, fats and proteins into carbon dioxide and water in order to generate energy. \n  It is the second of three metabolic pathways that are involved in fuel molecule catabolism and ATP production. This model is a scheduling problem inspired by the Krebs cycle. \n  \n  This model simulates both process within or outside the krebs cycle.\n  - Glykoza: Using 2 units of ATP, 2 units of ADP and 2 units of NADp, a single glucose unit is split into 2 units of NADH, 2 units of puryvat, 2 units of Hp and 2 units of H2O.\n  - Puryvat_oxyd: Using 1 unit of NADp, 1 unit of puryvat is then converted to acetyl CoA, meanwhile, producing 1 unit of NADH and 1 unit of CO2.\n  - Krebs_0: The main Krebs cycle. Acetyl CoA is then utilized within the Krebs cycle.\n    1. It first takes 1 unit of acetyl CoA and 1 unit of H2O to produce 1 unit of citrat.\n    2. Then, 1 unit of citrat is converted to 1 unit of H2O and 1 unit of cis-Aconitate which consumes 1 unit water to produce 1 unit of isocitrat. (The intermediate process is ignored in this case)\n    3. 1 unit of isocitrat takes 1 unit of NADp to produce 1 unit of NADH, 1 unit of Hp, 1 unit of CO2 and 1 unit of oxoglutarat.\n    4. 1 unit of oxoglutarat is combined with 1 unit of NADp to produce 1 unit of NADH and 1 unit of CO2 and to form 1 unit of succinyl-CoA. \n       The process of transforming succinyl-CoA to succinate and from succinate to fumarate is ignored in this case.\n    5. It takes 1 unit of H2O to trasnform 1 unit of fumarate into 1 unit of malate.\n    6. It takes 1 unit of NADp to trasnform 1 unit of malatep into 1 unit of oxaloacetate and produce 1 unit of NADH. (transforming oxaloacetate into citrat is ignored in this case) Then, the cycle repeats. \n  - Glykolyza: Part of the Electron Transport System. It takes 1 unit of NADH, 1 unit of O2 and 2 units of Hp to donate electrons to the electron transport chain (via the electrons!1 channel) \n    and produces 1 unit of NADP and 1 unit of water as byproducts.\n  - ETS(Electron Transport System): It converts 2 units ADP into 2 units of ATP using the energy from the electron transport chain.\n  - Rest_of_cell(Energy Comsumption): 1 unit of ATP is consumed to produce 1 unit of ADP and 1 unit of energy for the cell.",
        "content": "// Number of glukosa molecules at the beginning\n#define GLUKOSA 2;\n// Number of \"Krebs cycles\" (i.e., number of oxalacetrat molecules) at the beginning\n#define KREBS 1;\nvar glukosa = GLUKOSA;\nvar ATP = 4;\nvar ADP = 4;\nvar NADp = 12;\nvar NADH = 2;\nvar puryvat = 0;\nvar acetyl_co_a = 0;\nvar O2 = 15;\nvar CO2 = 0;\nvar Hp = 10;\nvar H20 = 10;\nvar energy = 0;\nchannel electrons 0;\n\nGlykoza()=[glukosa >= 1 && ATP >=2 && ADP >=2 && NADp >=2]{glukosa = glukosa -1; ADP = ADP - 2; ATP = ATP + 2; NADp = NADp -2; NADH = NADH + 2; puryvat = puryvat + 2; Hp = Hp + 2; H20 = H20 + 2;}->Glykoza();\n\nPuryvat_oxyd()=[puryvat >= 1 && NADp >=1]{puryvat = puryvat -1; NADp = NADp -1; acetyl_co_a = acetyl_co_a + 1; NADH = NADH + 1; CO2 = CO2 + 1;}->Puryvat_oxyd();\n\nKrebs_0()=[acetyl_co_a >= 1 && H20 >=1]{acetyl_co_a = acetyl_co_a -1; H20 = H20 - 1;}->Citrat_0();\nCitrat_0()=cit_0->Isocitrat_0();\nIsocitrat_0()=[NADp >=1] {NADp = NADp - 1; NADH = NADH +1; Hp = Hp +1; CO2 = CO2 + 1;}->Oxoglutarat2_0();\nOxoglutarat2_0()=[NADp >=1]{NADH = NADH + 1; CO2 = CO2 + 1;}->Fumarat_0();\nFumarat_0()=[ H20 >= 1]{H20 = H20 -1;}->Malat_0();\nMalat_0()=[NADp >= 1] {NADp = NADp - 1; NADH = NADH +1;}->Krebs_0();\n\nGlykolyza()=[NADH >=1 && O2>=1 && Hp >=2]electrons!1{NADH = NADH -1; NADp = NADp+1; O2 = O2 -1; Hp = Hp -2; H20 = H20 + 1;}->Glykolyza();\n\nETS()=[ADP >= 2]electrons?1{ ADP = ADP -2; ATP = ATP +2;}->ETS(); \n\nRest_of_cell()=[ATP >= 1]{ATP = ATP - 1; ADP = ADP +1; energy = energy + 1;}->Rest_of_cell();\n\nKrebs()=Glykoza()|||Puryvat_oxyd()|||Glykolyza()|||ETS()|||Rest_of_cell()|||Krebs_0();",
        "property_desc": [
            "energyabovelimit: It is possible to create more then 5 units of \"energy\".",
            "The model is deadlock-free."
        ],
        "properties": [
            "#define goal energy==5;\n#assert Krebs() reaches goal;",
            "#assert Krebs() deadlockfree;"
        ],
        "path": "pat_examples/beem/Planning and Scheduling/Krebs.csp"
    },
    {
        "name": "Schedule_world",
        "tags": [
            "Real World"
        ],
        "use_non_container_lib": false,
        "description": "This model defines a manufacturing scheduling system where parts undergo various processing actions to meet specific conditions.\n  There are some states of the part:\n  - Temperature: Can be either \"cold\" or \"hot\".\n  - Shape: Is \"cylindrical\" or not.\n  - Surface: Includes \"polished\", \"rough\" and \"smooth\".\n  - Painted: Different paint colours.\n  - Has Hole: Has a hole or not.\n  And there are 8 machines processing the part. The machine can process a part when it is not busy and the part is not scheduled. Once a machine starts working, the machine is busy and the part is scheduled.\n  - Polisher: Parts can be polished if they are cold and the polisher is not busy. The action makes the part polished and marks it as scheduled.\n  - Roller: It heats the part, changes its shape to cylindrical, and marks it as scheduled.\n  - Lathe: It changes the surface condition to rough and the shape to cylindrical.\n  - Grinder: This machine smooths the surface of a part and marks it as scheduled.\n  - Punch: Holes can be punched into cold and rough parts if the part doesn't has a hold or holes can be filled if there is.\n  - Drill: Similar to punch, it creates or fills holes in cold but not necessary rough parts.\n  - Spray: Parts can be spray-painted with a specific colour if the part is cold.\n  - Immersion Like spray painting, but uses a different painting method without temperature restrictions.\n  Also, there is a process represents the passage of time where all scheduled parts are marked as unscheduled, and all machines are marked as not busy.",
        "content": "#define UNDEF 255;\n#define COLD 0;\n#define HOT 1;\n#define POLISHED 0;\n#define SMOOTH 1;\n#define ROUGH 2;\n#define POLISHER 0;\n#define ROLLER 1;\n#define LATHE 2;\n#define GRINDER 3;\n#define PUNCH 4;\n#define DRILL 5;\n#define SPRAY 6;\n#define IMMERSION 7;\n// number of machines\n#define M 8;\n// number of parts\n#define N 4;\nvar temperature[N] = [COLD,COLD, COLD, COLD];\nvar surface[N] = [POLISHED, POLISHED, SMOOTH, ROUGH];\nvar shape[N] = [0,1,1,1];\nvar painted[N] = [0,0,1,1];\nvar hashole[N] = [1,1,1,0];\nvar busy[M] = [ 0 ,0 ,0 ,0 ,0 ,0 ,0 ,0  ];\nvar scheduled[N] = [ 0, 0, 0, 0 ];\nvar objscheduled = 0;\n//do-polish\nPolish()=[]x:{0..N-1}@([busy[POLISHER] == 0 && scheduled[x] == 0 && temperature[x] == COLD]\n         {objscheduled = 1; busy[POLISHER] = 1; scheduled[x] = 1; surface[x] = POLISHED;}->Schedule_world());\n\n//do-roll\nRoll()=[]x:{0..N-1}@([busy[ROLLER] == 0 && scheduled[x] == 0]\n        {objscheduled = 1; busy[ROLLER] = 1; scheduled[x] = 1; shape[x] = 0; temperature[x] = HOT; painted[x] = UNDEF; hashole[x] = UNDEF; surface[x] = UNDEF;}->Schedule_world());\n\n//do-lathe\nLathe()=[]x:{0..N-1}@([busy[LATHE] == 0 && scheduled[x] == 0]\n       {objscheduled = 1; busy[LATHE] = 1; scheduled[x] = 1; surface[x] = ROUGH; shape[x] = 0; painted[x] = UNDEF;}->Schedule_world());\n\n//do-grind\nGrind()=[]x:{0..N-1}@([busy[GRINDER] == 0 && scheduled[x] == 0]\n       {objscheduled = 1; busy[GRINDER] = 1; scheduled[x] = 1; surface[x] = SMOOTH; painted[x] = UNDEF;}->Schedule_world());\n\n//do-punch 0\nPunch0()=[]x:{0..N-1}@([busy[PUNCH] == 0 && scheduled[x] == 0 && temperature[x] == COLD && hashole[x] !=0]\n       {objscheduled = 1; busy[PUNCH] = 1; scheduled[x] = 1; surface[x] = ROUGH;  hashole[x] = 0;}->Schedule_world());\n\n//do-punch 1\nPunch1()=[]x:{0..N-1}@([busy[PUNCH] == 0 && scheduled[x] == 0 && temperature[x] == COLD && hashole[x] !=1]\n       {objscheduled = 1; busy[PUNCH] = 1; scheduled[x] = 1; surface[x] = ROUGH;  hashole[x] = 1;}->Schedule_world()); \n\n// do-drill 0\nDrill0()=[]x:{0..N-1}@([busy[DRILL] == 0 && scheduled[x] == 0 && temperature[x] == COLD && hashole[x] !=0]\n      {objscheduled = 1; busy[DRILL] = 1; scheduled[x] = 1; hashole[x] = 0;}->Schedule_world()); \n\n// do-drill 1\nDrill1()=[]x:{0..N-1}@([busy[DRILL] == 0 && scheduled[x] == 0 && temperature[x] == COLD && hashole[x] !=1]\n      {objscheduled = 1; busy[DRILL] = 1; scheduled[x] = 1; hashole[x] = 1;}->Schedule_world()); \n\n// do-spray 0\nSpray0()=[]x:{0..N-1}@([busy[SPRAY] == 0 && scheduled[x] == 0 && temperature[x] == COLD]\n     {objscheduled = 1; busy[SPRAY] = 1; scheduled[x] = 1; painted[x] = 0;}->Schedule_world()); \n\n// do-spray 1\nSpray1()=[]x:{0..N-1}@([busy[SPRAY] == 0 && scheduled[x] == 0 && temperature[x] == COLD]\n      {objscheduled = 1; busy[SPRAY] = 1; scheduled[x] = 1; painted[x] = 1;}->Schedule_world()); \n\n// do-immersion 0\nImmersion0()=[]x:{0..N-1}@([ busy[IMMERSION] == 0 && scheduled[x] == 0]\n     {objscheduled = 1; busy[IMMERSION] = 1; scheduled[x] = 1; painted[x] = 0;}->Schedule_world()); \n\n// do-immersion 1\nImmersion1()=[]x:{0..N-1}@([busy[IMMERSION] == 0 && scheduled[x] == 0]\n     {objscheduled = 1; busy[IMMERSION] = 1; scheduled[x] = 1; painted[x] = 1;}->Schedule_world()); \n\n//done\nDone()=[shape[1] == 1 && surface[0] == POLISHED && surface[1] == POLISHED && hashole[1] == 1 && shape[0] == 0]done->Stop;\nQ()=[objscheduled == 1]{scheduled[0] = 0;scheduled[1] = 0;scheduled[2] = 0;scheduled[3] = 0;busy[0] = 0; busy[1] = 0; busy[2] = 0; busy[3] = 0; busy[4] = 0; busy[5] = 0; busy[6] = 0; busy[7] = 0; objscheduled = 0;}->Schedule_world();\n\nSchedule_world()=Polish()[]Roll()[]Lathe()[]Grind()[]Punch0()[]Punch1()[]Drill0()[]Drill1()[]Spray0()[]Spray1()[]Immersion0()[]Immersion1()[]Q()[]Done();",
        "property_desc": [
            "In this case, the scheduling goal is to make the part 1 polished and not cylindrical with a hold and part 0 polished and cylindrical.",
            "The model is deadlock-free"
        ],
        "properties": [
            "#define goal shape[1] == 1 && surface[0] == 0 && surface[1] == 0 && hashole[1] == 1 && shape[0] == 0;\n#assert Schedule_world() reaches goal;",
            "#assert Schedule_world() deadlockfree;"
        ],
        "path": "pat_examples/beem/Planning and Scheduling/Schedule world.csp"
    },
    {
        "name": "Adding",
        "tags": [
            "Puzzle"
        ],
        "use_non_container_lib": false,
        "description": "Considering two process P, Q running in parallel.\n  P = loop { x=c; x=x+c; c=x;} and Q = loop { y=c; y=y+c; c=y;}. Initial value of c is 1. \n  The claim is that c can possibly contain any natural value. \n  With model checker we cannot prove this, but for any value, we can try to find it.",
        "content": "// Bound on value of variables\n#define MAX 20;\n// The value of c that we want to reach\n#define VAL 17;\nvar c=1;\nvar x1=0;\nvar x2=0;\nADD()=A1()|||A2();\nA1()= [c<MAX]add1{x1=c;}->increase1{x1=x1+c;}->readd1{c=x1;} -> A1();\nA2()= [c<MAX]add2{x2=c;}->increase2{x2=x2+c;}->readd2{c=x2;} -> A2();",
        "property_desc": [
            "Variable c equals the selected value",
            "The model is deadlock-free"
        ],
        "properties": [
            "#define goal(c==VAL);\n#assert ADD() reaches goal;",
            "#assert ADD() deadlockfree;"
        ],
        "path": "pat_examples/beem/Puzzles/Adding.csp"
    },
    {
        "name": "Frogs and Toads",
        "tags": [
            "Puzzle"
        ],
        "use_non_container_lib": false,
        "description": "The Toads And Frogs Puzzle is also known under the names of Hares and Tortoise and Sheep and Goats, \n  Traffic Jam, or Black and White stones. This is 2D variant of the puzzle. It takes place on NxM board.  \n  Toads move righward and downward; toads move leftward and upward. Every move is either a Slide to the nearby square or a Jump over one position, \nwhich is allowed only if the latter is occupied by a fellow of a different kind. \n  In any case, no two animals are allowed in the same square. The goal is to switch positions of toads and frogs.",
        "content": "#define ROW 2;\n#define COL 17;\nvar a[34]=[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2];\nvar x=1;\nvar y=8;\nhvar goal=0;\nGame()=Frog()[]Toad()[]Check();\nToad()=[x>0 && a[((y)*ROW+x-1)]==1]T_moveleft{a[((y)*ROW+x)] = 1;a[((y)*ROW+x-1)] = 0;x = x-1;}->Game()\n[][y>0 && a[((y-1)*ROW+x)]==1]T_moveup{a[((y)*ROW+x)] = 1;a[((y-1)*ROW+x)] = 0;y = y-1;}->Game()\n[][x>1 && a[((y)*ROW+x-1)]==2 && a[((y)*ROW+x-2)]==1]T_jumpleft{a[((y)*ROW+x)] = 1;a[((y)*ROW+x-2)] = 0;x = x-2;}->Game()\n[][y>1 && a[((y-1)*ROW+x)]==2 && a[((y-2)*ROW+x)]==1]T_jumpup{a[((y)*ROW+x)] = 1;a[((y-2)*ROW+x)] = 0;y = y-2;}->Game();\n\nFrog()=[x<ROW-1 && a[((y)*ROW+x+1)]==2]F_moveright{a[((y)*ROW+x)]=2;a[((y)*ROW+x+1)] = 0;x = x+1;}->Game()\n[][y<COL-1 && a[((y+1)*ROW+x)]==2]F_movedown{a[((y)*ROW+x)] = 2;a[((y+1)*ROW+x)] = 0;y = y+1;}->Game()\n[][x<ROW-2 && a[((y)*ROW+x+1)]==1 && a[((y)*ROW+x+2)]==2]F_jumpright{a[((y)*ROW+x)] = 2;a[((y)*ROW+x+2)] = 0;x = x+2;}->Game()\n[][y<COL-2 && a[((y+1)*ROW+x)]==1 && a[((y+2)*ROW+x)]==2]F_jumpdown{a[((y)*ROW+x)] = 2;a[((y+2)*ROW+x)] = 0;y = y+2;}->Game();\nCheck() =[a[0]==2&&a[1]==2&&a[2]==2&&a[3]==2&&a[4]==2&&a[5]==2&&a[6]==2&&a[7]==2&&a[8]==2&&a[9]==2&&a[10]==2&&a[11]==2&&a[12]==2&&a[13]==2&&a[14]==2&&a[15]==2&&a[16]==0&&a[17]==1&&a[18]==1&&a[19]==1&&a[20]==1&&a[21]==1&&a[22]==1&&a[23]==1&&a[24]==1&&a[25]==1&&a[26]==1&&a[27]==1&&a[28]==1&&a[29]==1&&a[30]==1&&a[31]==1&&a[32]==1&&a[33]==1&&a[33]==1]Goal();\nGoal()={goal=1}->Goal();",
        "property_desc": [
            "The puzzle is solved",
            "The model is deadlock-free"
        ],
        "properties": [
            "#define goalq(goal==1);\n#assert Game() reaches goalq;",
            "#assert Game() deadlockfree;"
        ],
        "path": "pat_examples/beem/Puzzles/Frogs and Toads.csp"
    },
    {
        "name": "Loyd",
        "tags": [
            "Puzzle"
        ],
        "use_non_container_lib": false,
        "description": "The 15 puzzle is a sliding square puzzle introduced by Sam Lloyd in 1878. It consists of 15 squares numbered from 1 to 15 which are placed in a box leaving one position out of the 16 empty. \n  The goal is to reposition the squares from a given arbitrary starting arrangement by sliding them one at a time into a configuration, where the squares are ordered by their numbers. \n  Because the 'fifteen' version has too big state space, we consider smaller instances as well. The goal, expressed by the reachability property below, is to reverse the order of pieces.",
        "content": "#define COLS 3;\n#define ROWS 3;\nvar a[9]=[0,1,2,3,4,5,6,7,8];\nvar x=0;\nvar y=0;\nhvar flag=0;\nGame() = Left() [] Right() [] Up() [] Down();\nMain()=Game()|||Check();\nLeft() = [x>0]goleft{a[(y)*COLS+x] = a[(y)*COLS+x-1];a[(y)*COLS+x-1] = 0;x = x-1;} -> Game();\nRight() = [x<COLS-1]goright{a[(y)*COLS+x] = a[(y)*COLS+x+1];a[(y)*COLS+x+1] = 0;x = x+1;} -> Game();\nUp() = [y>0]goup{a[(y)*COLS+x] = a[(y-1)*COLS+x];a[(y-1)*COLS+x] = 0;y = y-1;} -> Game();\nDown() = [y<ROWS-1]godown{a[(y)*COLS+x] = a[(y+1)*COLS+x];a[(y+1)*COLS+x] = 0;y = y+1;} -> Game();\nCheck()=[a[0]==8&&a[1]==7&&a[2]==6&&a[3]==5&&a[4]==4&&a[5]==3&&a[6]==2&&a[7]==1&&a[8]==0]Done();\nDone()= {flag=1;}->Skip;",
        "property_desc": [
            "The puzzle is solved",
            "The model is deadlock-free"
        ],
        "properties": [
            "#define goal {flag==1};\n#assert Main() reaches goal;",
            "#assert Main() deadlockfree;"
        ],
        "path": "pat_examples/beem/Puzzles/Loyd.csp"
    },
    {
        "name": "Sokoban",
        "tags": [
            "Puzzle"
        ],
        "use_non_container_lib": false,
        "description": "A Sokoban puzzle represents a store room, where boxes appear to be randomly placed. You help the warehouse keeper to push the boxes around the maze of the room so that, at the end, all boxes are on marked fields.\n  The only restrictions are that the warehouse keeper can only push a box, never pull, and that just one box may be pushed at a time.",
        "content": "//0 = free\n//1 = wall\n//2 = box\n//person is reprezented by x,y (not marked on plan)\n//VERSION 2\n#define N 19;\n#define M 11;\nvar a[19*11]=[\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,\n1,1,1,1,2,0,0,1,1,1,1,1,1,1,1,1,1,1,1,\n1,1,1,1,0,0,2,1,1,1,1,1,1,1,1,1,1,1,1,\n1,1,1,0,2,0,2,0,0,1,1,1,1,1,1,1,1,1,1,\n1,1,1,0,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,\n1,0,0,0,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,\n1,0,2,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,1,\n1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,0,0,1,\n1,1,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1];\nvar x=11;\nvar y=9;\nvar flag=0;\nGame()=[flag==0&&a[74] == 2 && a[75] == 2 && a[85] == 2 && a[86] == 2&&a[96]==2&&a[97]==2]reach{flag=1;}->Game()[]\n[flag==0&&a[y*N+x-1]==0]moveleft{x=x-1;}->Game()[]\n[flag==0&&a[y*N+x+1]==0]moveright{x=x+1;}->Game()[]\n[flag==0&&a[(y-1)*N+x]==0]moveup{y=y-1;}->Game()[]\n[flag==0&&a[(y+1)*N+x]==0]movedown{y=y+1;}->Game()[]\n[flag==0&&a[y*N+x-1]==2&&a[y*N+x-2]==0]pushleft{a[x-2+y*N]=2; a[x-1+y*N]=0; x=x-1;}->Game()[]\n[flag==0&&a[y*N+x+1]==2&&a[y*N+x+2]==0]pushright{a[x+2+y*N]=2; a[x+1+y*N]=0; x=x+1;}->Game()[]\n[flag==0&&a[(y-1)*N+x]==2&&a[(y-2)*N+x]==0]pushup{a[(y-1)*N+x]=0;a[(y-2)*N+x]=2;y=y-1}->Game()[]\n[flag==0&&a[(y+1)*N+x]==2&&a[(y+2)*N+x]==0]pushdown{a[(y+1)*N+x]=0;a[(y+2)*N+x]=2;y=y+1}->Game();",
        "property_desc": [
            "The puzzle is solved.",
            "The model is deadlock-free."
        ],
        "properties": [
            "#define goal (flag==1);\n#assert Game() reaches goal;",
            "#assert Game() deadlockfree;"
        ],
        "path": "pat_examples/beem/Puzzles/Sokoban.csp"
    },
    {
        "name": "Dijkstra Mutual Exclusion Algorithm",
        "tags": [
            "Algorithm",
            "Mutual Exclusion"
        ],
        "use_non_container_lib": false,
        "description": "To begin, consider N computers, each engaged in a process which, for our aims, can be regarded as cyclic. In each of the cycles a so-called \"critical section\" occurs and the computers have to be programmed in such a way that at any moment only one of these N cyclic processes is in its critical section. In order to effectuate this mutual exclusion of critical-section execution the computers can communicate with each other via a common store. Writing a word into or nondestructively reading a word from this store are undividable operations; i.e., when two or more computers try to communicate (either for reading or for writing) simultaneously with the same common location, these communications will take place one after the other, but in an unknown order. \n  The solution must satisfy the following requirements. \n  (a) The solution must be symmetrical between the N computers; as a result we are not allowed to introduce a static priority. \n  (b) Nothing may be assumed about the relative speeds of the N computers; we may not even assume their speeds to be constant in time. \n  (c) If any of the computers is stopped well outside its critical section, this is not allowed to lead to potential blocking of the others. \n  (d) If more than one computer is about to enter its critical section, it must be impossible to devise for them such finite speeds, that the decision to determine which one of them will enter its critical section first is postponed until eternity. In other words, constructions in which \"After you\"-\"After you\"-blocking is still possible, although improbable, are not to be regarded as valid solutions\n\nDijkstra Mutual Exclusion Algorithm:\n```\nShared variables:\nturn:{1..N}\nfor every 0 <= i <= (N -1) flag[i]: {0, 1, 2}\n\nturn: initially arbitrary\nflag(i): initially 0\n\nProcess i:\nL: flag(i) := 1\nwhile turn != i do\n\tif flag(turn) = 0 then turn:= i\nflag(i) := 2\nfor j != i do\n\tif flag(j) = 2 then goto L\nenter critical section\n...\nexit critical section\nflag(i) := 0\n```",
        "content": "#define N 2;\n\nvar flag[N];\nvar enter_cs[N];\nvar turn;\n\nProcess(i) = set_flag.i {flag[i] = 1;} -> (Check1(i) ; (set_flag.i {flag[i] = 2;} -> Check2(i, 0)));\n\nCheck1(i) = if(turn != i)\t\t\t\t\n\t\t\t{\n\t\t\t\tif(flag[turn] == 0)\n\t\t\t\t{\n\t\t\t\t\tget_turn{turn = i;} -> Skip\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tCheck1(i)\n\t\t\t\t}\n\t\t\t};\n\nCheck2(i, j) = \n\tif(j==N)\n\t{\n\t\tCS(i)\n\t}\n\telse if(j == i)\n\t{\n\t\tCheck2(i, j+1)\n\t}\n\telse if(flag[j] == 2)\n\t{\n\t\tProcess(i)\n\t}\n\telse \n\t{\n\t\tCheck2(i, j + 1)\n\t};\n\t\nCS(i) = cs.i{enter_cs[i] = 1;} -> exit.i {flag[i] = 0; enter_cs[i]= 0;} -> Process(i);\n\n\nDijkstra() = [] x:{0..N-1} @ (tau{turn = x} -> (|||y :{0..N-1}@Process(y)));",
        "property_desc": [
            "The algorithm is deadlock-free",
            "The processes will not reach mutual exclusion"
        ],
        "properties": [
            "#assert Dijkstra() deadlockfree;",
            "#define p ((enter_cs[0] + enter_cs[1]) >= 2); \n#assert Dijkstra() reaches p;"
        ],
        "path": "pat_examples/csp_module/Classic Algorithms/Dijkstra's Mutual Exclusion Algorithm.csp"
    },
    {
        "name": "Dining Philosopher(deadlock-free)",
        "tags": [
            "Algorithm",
            "Mutual Exclusion"
        ],
        "use_non_container_lib": false,
        "description": "In 1971, Edsger Dijkstra set an examination question on a synchronization problem where five computers competed for access to five shared tape drive peripherals. \n  Soon afterwards the problem was retold by Tony Hoare as the dining philosophers' problem. \n  The problem is summarized as N philosophers sitting around a round table.\n\n  The five philosophers sit at a circular table with a large bowl of spaghetti in the center. \n  A fork is placed in between each philosopher, and as such, each philosopher has one fork to his or her left and one fork to his or her right. \n  As spaghetti is difficult to serve and eat with a single fork, it is assumed that a philosopher must eat with two forks. \n  The philosopher can only use the fork on his or her immediate left or right. It is further assumed that the philosophers are so stubborn that a philosopher only put down the forks after eating.\n\n  There are several interesting problems. One is a dangerous possibility of deadlock when every philosopher holds a left fork and waits perpetually for a right fork. \n  The other is starvation. A philosopher may starve for different reasons, e.g., system deadlock, greedy neighbor, etc.",
        "content": "#define N 5;\n\nPhil(i) = get.i.(i+1)%N -> get.i.i -> eat.i -> put.i.(i+1)%N -> put.i.i -> Phil(i);\nFork(x) = get.x.x -> put.x.x -> Fork(x) [] get.(x-1)%N.x -> put.(x-1)%N.x -> Fork(x);\nPhil0 = get.0.0 -> get.0.1 -> eat.0 -> put.0.0 -> put.0.1 -> Phil0;\nCollege() = Phil0|| Fork(0)||(||x:{1..N-1}@(Phil(x)||Fork(x))) ;",
        "property_desc": [
            "The model is deadlock-free",
            "All philosophers will eventually eat"
        ],
        "properties": [
            "#assert College() deadlockfree;",
            "#assert College() |= []<> eat.0;"
        ],
        "path": "pat_examples/csp_module/Classic Algorithms/Dining Philosopher(Deadlock Free).csp"
    },
    {
        "name": "Interrupt Controller",
        "tags": [
            "Real World"
        ],
        "use_non_container_lib": false,
        "description": "Component C acts as a counter, while INT is designed to halt C when the environment issues a shut-down request. \n  The interrupt controller INT should communicate 'i' whenever possible, so that C cannot receive 'up' or 'down' after INT has received 'shut_down'.",
        "content": "// Counter modulo (wrap-around).\n#define MODULO 16;\n\n// Input to the counter\nchannel up 0;\nchannel down 0;\n\n// Shut down request\nchannel shutdown 0;\n\n// Internal communication\nchannel i 0;\n\nvar noOfError = 0;\n\nvar count;\n\nInt = shutdown?0 -> i!0 -> Stop;\n\nC = up?0 {count = (count + 1) % MODULO;} -> C [] down?0 {if(count > 0) {count = count - 1;}} -> C [] i?0 -> Stop;\n\nEvn = up!0 -> Evn [] down!0 -> Evn []  shutdown!0 -> ( up!0 -> Error() [] down!0 -> Error());\n\nError = error{noOfError++} -> Stop;\n\naSys = Int ||| C ||| Evn;",
        "property_desc": [
            "C can receive 'up' or 'down' after INT has received 'shut_down'"
        ],
        "properties": [
            "#define goal noOfError > 0;\n#assert aSys reaches goal;"
        ],
        "path": "pat_examples/csp_module/Classic Algorithms/Interrupt Controller.csp"
    },
    {
        "name": "Milner's Cyclic Scheduler",
        "tags": [
            "Algorithm"
        ],
        "use_non_container_lib": false,
        "description": "This scheduling algorithm is described by Milner in \"Communication and Concurrency, 1989\". \n  There are N processes, which are activated in a cyclic manner, i.e., process i activates \nprocess i+1 and after process n process 1 is activated again. Moreover, a process may never \nbe re-activated before it has terminated. The scheduler is built from n cyclers who are \npositioned in a ring. The first cycler plays a special role as it starts up the system. \n  This model is perfect demonstration of the partial order reduction techniques for model checking.",
        "content": "#define N 10;\n#alphabet Cycle {ini.i,ini.(i+1)%N};\n\nCycle0 \t\t= a.0 -> ini.1 -> work.0 -> ini.0 -> Cycle0;\nCycle(i) \t\t= ini.i -> a.i -> (work.i -> atomic{ini.(i+1)%N -> Skip}; Cycle(i) [] ini.(i+1)%N -> atomic{work.i -> Skip}; Cycle(i));\nMilnerAcyclic() = Cycle0 || (|| x:{1..N-1} @ Cycle(x)); \nImplementation()=(MilnerAcyclic() \\ {ini.0,a.0,work.1,ini.1,a.1,work.2,ini.2,a.2,work.3,ini.3,a.3,work.4,ini.4,a.4,work.5,ini.5,a.5,work.6,ini.6,a.6,work.7,ini.7,a.7,work.8,ini.8,a.8,work.9,ini.9,a.9});\nSpecification()=(work.0->Specification());",
        "property_desc": [
            "The algorithm is deadlock-free.",
            "The first process will always keep working",
            "Checks if the Implementation model refines the Specification",
            "Checks if the Specification model refines the Implementation",
            "Checks if the Implementation model refines the Specification in stable failures semantics",
            "Checks if the Specification model refines the Implementation in stable failures semantics",
            "Checks if the Implementation model refines the Specification in failures divergence semantics",
            "Checks if the Specification model refines the Implementation in failures divergence semantics"
        ],
        "properties": [
            "#assert MilnerAcyclic() deadlockfree;",
            "#assert MilnerAcyclic() |= []<>work.0;",
            "#assert Implementation() refines Specification();",
            "#assert Specification() refines Implementation();",
            "#assert Implementation() refines <F> Specification();",
            "#assert Specification() refines <F> Implementation();",
            "#assert Implementation() refines <FD> Specification();",
            "#assert Specification() refines <FD> Implementation();"
        ],
        "path": "pat_examples/csp_module/Classic Algorithms/Milner's Scheduler.csp"
    },
    {
        "name": "Needham-Schroeder Public-Key Protocol(No security flaw)",
        "tags": [
            "Protocol"
        ],
        "use_non_container_lib": false,
        "description": "The Needham-Schroeder Public Key Protocol is a well known authentication protocol that \n  dates back to 1978. It aims to establish mutual authentication between an initiator A \n  and a responder B, after which some session involving the exchange of messages between A \n  and B can take place. It is based on public key cryptography i.e. RSA and aims to establish \n  mutual authentication between two parties communicating over an unsecure network connection. \n  Messages are encrypted using the recipient's public key and only the recipient who holds the \n  private key can decrypt the messages to learn its contents. We denote messages encrypted with \n  some public key as {x,y}PK{Z} with x and y being the data items of the encrypted message and \n  PK(Z) being the public key of the recipient Z. Private or secret keys are denoted as SK and \n  are used for both decryption and digitally signing messages to ensure message integrity.\n\n  Lowe was the first to demonstrate how formal specification techniques can be used to verify \n  the security properties of cryptographic protocols. In his seminal 1995 paper, Lowe announced \n  the discovery of a previously unknown man-in-the-middle attack on the Needham-Schroeder public \n  key authentication protocol. The Needham-Schroeder protocol forms the basis of the widely-used \n  Kerberos protocol. Before Lowe's announcement the Needham-Schroeder protocol had been subjected \n  to various verification exercises and real-world use and was deemed as secure for 17 years!\n\n  In this example, we demonstrate both the original version of the protocol and fixed version.",
        "content": "//A is Alice, the initiator;\n//B is Bob, the responder;\n//I is the Intruder;\n//Na is the Nonce A;\n//Nb is the Nonce B;\n//gD is the generic Data;\nenum {A, B, I, Na, Nb, gD};\n\n//ca: type 1 messages {x1,x2}PK{x3}\n//cb: type 2 messages {x1}PK{x2}\n//cc: type 3 messages {x1,x2,x3}PK{x4}\nchannel ca 0;\nchannel cb 0;\nchannel cc 0;\n\n//IniRunningAB is true iff initiator A takes part in a session of the protocol with B.\nvar IniRunningAB = false;\n//IniCommitAB is true iff initiator A commits to a session with B.\nvar IniCommitAB = false;\n//ResRunningAB is true iff responder B takes part in a session of the protocol with A.\nvar ResRunningAB = false;\n//ResCommitAB is true iff responder B commits to a session with A.\nvar ResCommitAB = false;\n\n//Initiator\nPIni(sender, receiver, nonce) =\n\tIniRunning_AB { if (sender == A && receiver == B) { IniRunningAB = true; } } ->\n\t\n\t//sending {nonce, sender}Pk{receiver}\n\tca!sender.nonce.sender.receiver ->\n\t\n\t//receiving {nonce, g1}Pk{sender}\n\tcc?sender.nonce.g1.receiver.sender -> IniCommit_AB { if (sender == A && receiver == B) { IniCommitAB = true; } } ->\n\t\n\t//sending {g1}Pk{receiver}\n\tcb!sender.g1.receiver -> Skip;\n\n//Responder\nPRes(receiver, nonce) =\t\n\t//receiving {g2, g3}Pk{receiver}\n\tca?receiver.g2.g3.receiver -> ResRunning_AB { if (g3 == A && receiver == B) { ResRunningAB = true; } } ->\n\t\n\t//sending {g2, nonce, receiver}Pk{g3}\n\tcc!receiver.g2.nonce.receiver.g3 ->\n\t\t\n\t//receiving {nonce}Pk{receiver}\n\tcb?receiver.nonce.receiver -> ResCommit_AB { if (g3 == A && receiver == B) { ResCommitAB = true; } } -> Skip;\n\n//Intruder knows Na\nvar kNa = false; \n//Intruder knows Nb\nvar kNb = false;\n//Intruder knows {Na, Nb, B}PK{A}\nvar k_Na_Nb_B__A = false;\n//Intruder knows {Na, A}PK{B}\nvar k_Na_A__B = false;\n//Intruder knows {Nb}PK{B}\nvar k_Nb__B = false;\n\n//Intruder Process, which always knows A, B, I, PK(A), PK(B), PK(I), SK(I) and Ng\nPI() =\n\tca!B.gD.A.B -> PI() []\n\tca!B.gD.B.B -> PI() []\n\tca!B.gD.I.B -> PI() []\n\t\n\tca!B.A.A.B -> PI() []\n\tca!B.A.B.B -> PI() []\n\tca!B.A.I.B -> PI() []\n\t\n\tca!B.B.A.B -> PI() []\n\tca!B.B.B.B -> PI() []\n\tca!B.B.I.B -> PI() []\n\t\n\tca!B.I.A.B -> PI() []\n\tca!B.I.B.B -> PI() []\n\tca!B.I.I.B -> PI() []\n\t\n\t[kNa]                        cc!A.Na.Na.B.A -> PI() []\n\t[(kNa && kNb) || k_Na_Nb_B__A] cc!A.Na.Nb.B.A -> PI() []\n\t[kNa]                        cc!A.Na.gD.B.A -> PI() []\n\t\n\t[kNa] cc!A.Na.A.B.A -> PI() []\n\t[kNa] cc!A.Na.B.B.A -> PI() []\n\t[kNa] cc!A.Na.I.B.A -> PI() []\n\t\n\t[kNa]        cc!A.Na.Na.I.A -> PI() []\n\t[kNa && kNb] cc!A.Na.Nb.I.A -> PI() []\n\t[kNa]        cc!A.Na.gD.I.A -> PI() []\n\t\n\t[kNa] cc!A.Na.A.I.A -> PI() []\n\t[kNa] cc!A.Na.B.I.A -> PI() []\n\t[kNa] cc!A.Na.I.I.A -> PI() []\n\t\n\t[kNa || k_Na_A__B] ca!B.Na.A.B -> PI() []\n\t[kNa]              ca!B.Na.B.B -> PI() []\n\t[kNa]              ca!B.Na.I.B -> PI() []\n\t\n\t[kNb] ca!B.Nb.A.B -> PI() []\n\t[kNb] ca!B.Nb.B.B -> PI() []\n\t[kNb] ca!B.Nb.I.B -> PI() []\n\t\n\t[k_Nb__B || kNb] cb!B.Nb.B -> PI() []\n\t\n\tca?tmp1.x1.x2.x3\n\t-> InterceptChanA {\n\t\tif (x3 == I) {\n\t\t\tif (x1 == Na) { kNa = true; }\n\t\t\telse if (x1 == Nb) { kNb = true; }\n\t\t\tif (x2 == Na) { kNa = true; }\n\t\t\telse if (x2 == Nb) { kNb = true; }\n\t\t}\n\t\telse if (x1 == Na && x2 == A && x3 == B) { k_Na_A__B = true; }\n\t} -> PI() []\n\t\n\tcb?tmp2.y1.y2\n\t-> InterceptChanB {\n\t\tif (y2 == I) {\n\t\t\tif (y1 == Na) { kNa = true; }\n\t\t\telse if (y1 == Nb) { kNb = true; }\n\t\t}\n\t\telse if (y1 == Nb && y2 == B) { k_Nb__B = true; }\n\t}\n\t->  PI() []\n\t\n\tcc?tmp3.z1.z2.z3.z4 \n\t-> InterceptChanC {\n\t\tif (z4 == I) {\n\t\t\tif (z1 == Na) { kNa = true; }\n\t\t\telse if (z1 == Nb) { kNb = true; }\n\t\t\tif (z2 == Na) { kNa = true; }\n\t\t\telse if (z2 == Nb) { kNb = true; }\n\t\t\tif (z3 == Na) { kNa = true; }\n\t\t\telse if (z3 == Nb) { kNb = true; }\n\t\t}\n\t\telse if (z1 == Na && z2 == Nb && z3 == B && z4 == A) { k_Na_Nb_B__A = true; }\n\t} -> PI;\n\nProtocol = ( PIni(A, I, Na) [] PIni(A, B, Na) ) ||| PRes(B, Nb) ||| PI;",
        "property_desc": [
            "Authentication of B to A can thus be expressed saying that ResRunningAB must become true before IniCommitAB. i.e., the initiator A commits to a session with B only if B has indeed taken part in a run of the protocol with A.",
            "The converse authentication property corresponds to saying that IniRunningAB becomes true before ResCommitAB.",
            "The protocol is deadlock-free."
        ],
        "properties": [
            "#define iniRunningAB (IniRunningAB == true);\n#define iniCommitAB (IniCommitAB == true);\n#define resRunningAB (ResRunningAB == true);\n#define resCommitAB (ResCommitAB == true);\n\n#assert Protocol |= [] ( ([] !iniCommitAB) || (!iniCommitAB U resRunningAB) );",
            "#assert Protocol |= [] ( ([] !resCommitAB) || (!resCommitAB U iniRunningAB) );",
            "#assert Protocol deadlockfree;"
        ],
        "path": "pat_examples/csp_module/Classic Algorithms/Needham-Schroeder Public-Key Protocol(Fixed).csp"
    },
    {
        "name": "Peterson's problem",
        "tags": [
            "Algorithm",
            "Mutual Exclusion"
        ],
        "use_non_container_lib": false,
        "description": "Peterson's algorithm is a concurrent programming algorithm for mutual exclusion that \n  allows two processes to share a single-use resource without conflict, using only shared \n  memory for communication. It was formulated by Gary Peterson in 1981 at the University \n  of Rochester. While Peterson's original formulation worked with only two processes, the \n  algorithm can be generalised for more than two, as discussed in \"Operating Systems Review, \n  January 1990 (Proof of a Mutual Exclusion Algorithm, M Hofri)\".",
        "content": "#define N 3;\n\nvar step[N];\nvar pos[N];\nvar counter = 0; //which counts how many processes are in the critical session.\nProcess0() = Repeat0(1); cs.0{counter = counter+1;} -> reset{pos[0] = 0; counter = counter-1;} -> Process0();\nRepeat0(j) = [j < N] update.0.1{pos[0] = j;} -> update.0.2{step[j] = 0;} -> \n\t\t\t\t([step[j] != 0 || (pos[1] < j && pos[2] < j)]idle.j -> Repeat0(j+1))\n\t\t[] [j == N] Skip;\n\nProcess1() = Repeat1(1); cs.1{counter = counter+1;} -> reset{pos[1] = 0; counter = counter-1;} -> Process1();\nRepeat1(j) = [j < N] update.1.1{pos[1] = j;} -> update.1.2{step[j] = 1;} -> \n\t\t\t\t([step[j] != 1 || (pos[0] < j && pos[2] < j)]idle.j -> Repeat1(j+1))\n\t\t[] [j == N] Skip;\n\nProcess2() = Repeat2(1); cs.2{counter = counter+1;} -> reset{pos[2] = 0; counter = counter-1;} -> Process2();\nRepeat2(j) = [j < N] update.2.1{pos[2] = j;} -> update.2.2{step[j] = 2;} -> \n\t\t\t\t([step[j] != 2 || (pos[0] < j && pos[1] < j)]idle.j -> Repeat2(j+1))\n\t\t[] [j == N] Skip;\n\nPeterson() = Process0() ||| Process1() ||| Process2();",
        "property_desc": [
            "more than one process is in the critical section simultaneously",
            "if it's always eventually possible for Process0 to enter its critical section"
        ],
        "properties": [
            "#define goal counter > 1;\n#assert Peterson() reaches goal;",
            "#assert Peterson() |= []<> cs.0;"
        ],
        "path": "pat_examples/csp_module/Classic Algorithms/Peterson's Problem.csp"
    },
    {
        "name": "Readers/Writers Problem",
        "tags": [
            "Algorithm",
            "Mutual Exclusion"
        ],
        "use_non_container_lib": false,
        "description": "In computer science, the readers-writers problems are examples of a common computing\n  problem in concurrency. The problem deals with situations in which many threads must\n  access the same shared memory at one time, some reading and some writing, with the \n  natural constraint that no process may access the share for reading or writing while \n  another process is in the act of writing to it. In particular, it is allowed for two \n  readers to access the share at the same time. In this model, a controller is used to \n  guarantee the correct coordination among multiple readers/writers.",
        "content": "#define M 10;\n\nWriter() \t= startwrite -> stopwrite -> Writer();\nReader() \t= startread -> stopread -> Reader();\nReading(i) \t= [i == 0]Controller() []\n\t \t \t \t [i == M] stopread -> Reading(i-1) []\n\t \t \t \t [i > 0 && i < M] (startread -> Reading(i+1) [] stopread -> Reading(i-1));\n\nController() \t= startread -> Reading(1)\n\t \t \t \t [] stopread -> error -> Controller()\n\t \t \t \t [] startwrite -> (stopwrite -> Controller() [] stopread -> error -> Controller());\n\nReadersWriters() = Controller() || (|||x:{0..M-1} @ (Reader() ||| Writer()));\n\nImplementation() \t= ReadersWriters() \\ {startread, stopread, startwrite, stopwrite};\nSpecification() \t= error -> Specification();\n\n#alphabet Reading {startread,stopread};",
        "property_desc": [
            "The model is deadlock-free",
            "Check if the error can always eventually be reached",
            "(counterexample) Check if the error can always eventually be reached",
            "Checks if the Implementation model refines the Specification",
            "Checks if the Specification model refines the Implementation",
            "Checks if the Implementation model refines the Specification in stable failures semantics",
            "Checks if the Specification model refines the Implementation in stable failures semantics",
            "Checks if the Implementation model refines the Specification in failures divergence semantics",
            "Checks if the Specification model refines the Implementation in failures divergence semantics"
        ],
        "properties": [
            "#assert ReadersWriters() deadlockfree;",
            "#assert ReadersWriters() |= []<>error;",
            "#assert ReadersWriters() |= ![]<>error;",
            "#assert Implementation() refines Specification();",
            "#assert Specification() refines Implementation();",
            "#assert Implementation() refines <F> Specification();",
            "#assert Specification() refines <F> Implementation();",
            "#assert Implementation() refines <FD> Specification();",
            "#assert Specification() refines <FD> Implementation();"
        ],
        "path": "pat_examples/csp_module/Classic Algorithms/Reader-Writers.csp"
    },
    {
        "name": "Two Phase Commit Protocol (TPCP)",
        "tags": [
            "Protocol",
            "Distributed System"
        ],
        "use_non_container_lib": false,
        "description": "In transaction processing, databases, and computer networking, the two-phase commit protocol (2PC) \n  is a type of atomic commitment protocol (ACP). It is a distributed algorithm that coordinates all \n  the processes that participate in a distributed atomic transaction on whether to commit or abort (roll back)\n  the transaction (it is a specialized type of consensus protocol). The protocol achieves its goal even \n  in many cases of temporary system failure (involving either process, network node, communication, etc. failures), \n  and is thus widely utilized. However, it is not resilient to all possible failure configurations, \n  and in rare cases user (e.g., a system's administrator) intervention is needed to remedy outcome. \n  To accommodate recovery from failure (automatic in most cases) the protocol's participants use logging of the protocol's states. \n  Log records, which are typically slow to generate but survive failures, are used by the protocol's recovery procedures. \n  Many protocol variants exist that primarily differ in logging strategies and recovery mechanisms. \n  Though usually intended to be used infrequently, recovery procedures comprise a substantial portion of the protocol, \n  due to many possible failure scenarios to be considered and supported by the protocol.",
        "content": "#define N 2; //number of pages\nenum {Yes, No, Commit, Abort}; //constants\n//channel result 0;\n//channel inform 0;\nchannel vote 0;\nvar hasNo = false;\nvar votes[N];\n \n//The following models the coordinator \nCoord(decC) = (|||i:{0..N-1}@ request -> Skip); \n\t\t\t  (|||i:{0..N-1}@ vote?vo -> atomic{tau{votes[i] = vo; if (vo == No) {hasNo = true;}} -> Skip}); \n\t\t\t  decide -> \n\t\t\t  (([hasNo == false] (|||i:{0..N-1}@inform.Commit -> Skip); CoordPhaseTwo(Commit)) [] ([hasNo == true] (|||i:{0..N-1}@inform.Abort -> Skip); CoordPhaseTwo(Abort)));\nCoordPhaseTwo(decC) = |||{N}@acknowledge -> Skip;\n\n//The following models a page\nPage(decP, stable) = request -> execute -> (vote!Yes -> PhaseTwo(decP) [] vote!No -> PhaseTwo(decP));\nPhaseTwo(decP) = inform.Commit -> complete -> result.decP -> acknowledge -> Skip\n\t\t\t\t\t\t [] inform.Abort -> undo -> result.decP -> acknowledge -> Skip;\n\n#alphabet Coord {request, inform.Commit, inform.Abort, acknowledge};\n#alphabet Page {request, inform.Commit, inform.Abort, acknowledge};\n\t\t\t\t\t\t\nSystem = Coord(Abort) || (|||i:{0..N-1}@Page(Abort, true));\nImplementation = System \\{request, execute, acknowledge, inform.Abort, inform.Commit, decide, result.Abort, result.Commit};\n\nSpecification = PC(N);\nPC(i) = [i == 0](|||{N}@complete -> Skip)\n\t\t[]\n\t\t[i > 0]\t(vote.Yes -> PC(i-1) [] vote.No -> PU(i-1));\nPU(i) = [i == 0](|||{N}@undo -> Skip)\n\t\t[]\n\t\t[i > 0](vote.Yes -> PU(i-1) [] vote.No -> PU(i-1));",
        "property_desc": [
            "The protocol is deadlock-free.",
            "If there's at least one \"No\" vote (has), eventually the undo action will occur. This ensures that if any page wants to abort, the transaction will ultimately be rolled back.",
            "If a request is made, eventually the undo action might occur. This implies that even if the coordinator initially intends to commit, there's a possibility of aborting due to page votes.",
            "The specification is deadlock-free.",
            "Checks if the Implementation model refines the Specification"
        ],
        "properties": [
            "#assert System deadlockfree;",
            "#define has hasNo == 1;\n#assert System |= [](has -> <> undo);",
            "#assert System |= [](request -> <> undo);",
            "#assert Specification deadlockfree;",
            "#assert Implementation refines Specification;"
        ],
        "path": "pat_examples/csp_module/Classic Algorithms/Two Phase Commit Protocol.csp"
    },
    {
        "name": "1d Channel Array Demonstration Example",
        "tags": [
            "Example"
        ],
        "use_non_container_lib": false,
        "description": "This example demonstrates some language features in PAT: one dimension synchronous channel Array\n  This model simulates a simple pipeline for data transmission using a synchronous channel array. \n  The data flow is only in one direction from left to right. The Send process acts as a source, \n  injecting data into the beginning of the pipe, and the Receive process acts as a sink, receiving \n  data from the end of the pipe. The COPY processes act as intermediate relay, copying data from \n  the source and sending it to the sink.",
        "content": "#define N 3;\n\n//a synchronous channel array\nchannel right[N+1] 0;  \n\n//example of channel array to send data in one action\nSend() = right[0]!5 -> Send();\n//example of channel array to receive data in one action\nReceive() = right[N]?x -> Receive();\n\nCOPY(i) = right[i]?x -> right[i+1]!x -> COPY(i);\nPIPE() = ||| i:{0..(N-1)} @ COPY(i);\n\nSystem() = PIPE() ||| Send() ||| Receive();",
        "property_desc": [
            "The system is deadlock-free"
        ],
        "properties": [
            "#assert System() deadlockfree;"
        ],
        "path": "pat_examples/csp_module/Demonstration Examples/1d Channel Array Demonstration Example.csp"
    },
    {
        "name": "2d Channel Array Demonstration Example",
        "tags": [
            "Example"
        ],
        "use_non_container_lib": false,
        "description": "This example demonstrates some language features in PAT: two dimension synchronous channel array.\n\n  This model simulates a simple network of cells arranged in a 2D grid where each cell communicates with its adjacent cells. \n  The data flow is in two directions, from left to right and from top to down.\n  The Send process for each cell attempts to insert data into both the right and down channels. \n  The Cell processes transmit this data to other cells. Data is then collected by Receive processes.",
        "content": "#define M 2; // raw number \n#define N 3; // column number\n\n// The following are one-dimension synchrnous channle arrays used to simulate the 2-d synchronous channel array\n// channel right[i][j] is represented as c[i*N + j] \nchannel right[M*N] 0;\nchannel down[M*N] 0;\n\n//The system is a network of cells, messages transimit from one cell to its adjacent cell horizontally or vertically\nSend(i,j) = right[i*N]!i*N -> Send(i,j)\n         [] down[j]!j -> Send(i,j);\n \nReceive(i,j) = right[(i+1)*N-1]?x -> Receive(i,j)\n         [] down[(M-1)*N+j]?x -> Receive(i,j);\n         \nCell(i,j) = [(j+1)%N != 0]right[i*N+j]?x -> right[(i*N+j+1)]!x -> Cell(i,j)\n         [] [(i+1)%M != 0]down[i*N+j]?x -> down[((i+1)*N+j)]!x -> Cell(i,j);\n         \nSystem() = ||| i:{0..(M-1)}@(|||j:{0..(N-1)}@(Send(i,j)|||Receive(i,j)|||Cell(i,j)));",
        "property_desc": [
            "The system is deadlock-free"
        ],
        "properties": [
            "#assert System() deadlockfree;"
        ],
        "path": "pat_examples/csp_module/Demonstration Examples/2d Channel Array Demonstration Example.csp"
    },
    {
        "name": "C# Library Demonstration Example",
        "tags": [
            "Example"
        ],
        "use_non_container_lib": false,
        "description": "This example demonstrates how to use C# libraries in PAT models. This example uses the builtin List, Stack and Queue libraries.",
        "content": "#import \"PAT.Lib.List\";\n#import \"PAT.Lib.SerializableList\";\n#import \"PAT.Lib.Stack\";\n#import \"PAT.Lib.Queue\";\n#import \"PAT.Lib.Set\";\n\n//test the list library \nvar<List> list; \nvar<List> list2;\n\n\nList() = field{list$Field = 5; list$Property = list$Field + 3;} -> \n           ((add1{list.Add(1);list2.Add(4);list2.Add(5);} -> add2{list.Add(2);} -> add3{list.Add(3)} -> remove{list.Remove(2);} -> Skip)\n           []\n           (add1{list.Add(2);list2.Add(2);list2.Add(2);} -> add2{list.Add(2);} -> add3{list.Add(3)} -> remove{list.Remove(2);} -> Skip)\n           );\n           \n           \n\t\tif(!list.Contains(2))\n\t\t{\n\t\t\tadd22{list.Add(3);} -> concatenate{list= list.Concat(list, list2);} -> List2()\t\t\t\n\t\t};\t\n\nList2() = add1{list.Add(1);}  -> remove{list.Remove(1);} ->remove{list.Remove(2);} -> Skip;\n\n//test the SerializableList list library \nvar<SerializableList> list3; \nvar<SerializableList> list4;\n\n\nList3() = field{list3$Field = 5; list3$Property = list3$Field + 3;} -> \n           ((add1{list3.Add(1);list4.Add(4);list4.Add(5);} -> add2{list3.Add(2);} -> add3{list3.Add(3)} -> remove{list3.Remove(2);} -> Skip)\n           []\n           (add1{list3.Add(2);list4.Add(2);list4.Add(2);} -> add2{list3.Add(2);} -> add3{list3.Add(3)} -> remove{list3.Remove(2);} -> Skip)\n           );\n           \n           \n\t\tif(!list3.Contains(2))\n\t\t{\n\t\t\tadd22{list3.Add(3);} -> concatenate{list3= list3.Concat(list3, list4);} -> List4()\t\t\t\n\t\t};\t\n\nList4() = add1{list3.Add(1);}  -> remove{list3.Remove(1);} ->remove{list3.Remove(2);} -> Skip;\n\n\n//test the stack library \nvar<Stack> stack1;\n\nStack() =  push1{stack1.Push(1)}-> clear{stack1.Clear()}-> push2{stack1.Push(2)} -> pop1{stack1.Pop()} -> \n\t\t   push3{stack1.Push(3)} -> if (3 == stack1.Peek()){if ( (stack1.Contains(3)== true) ) { Stack()} };\n\nStackException() =push1{stack1.Push(1)} -> pop1{stack1.Pop()}-> peek{stack1.Peek()} -> StackException();\n\n//test the queue library \nvar<Queue> queue;\nvar<Queue> queue2;\n\nQueue() = enter1{queue.Enqueue(1);queue2.Enqueue(2);queue2.Enqueue(3) } -> enter1{queue.Enqueue(2)} ->\n\t\t  if (1 == queue.First() && 2 == queue.Last())\n\t\t  {\n\t\t  \texit{queue.Dequeue()} -> concat{queue = queue.Concat(queue, queue2)}\n          \t-> if (queue.Contains(3)&& 3 == queue.Count()) {Queue() }\n\t      };\t\t\n\n//test the set library\nvar<Set> set1;\nvar<Set> set2;\nvar<Set> set3;\n\nSet() = initialize{ set1.Add(1);set2.Add(2);set3.Add(3);set3.Add(4)} -> remove3 {set3.Remove(4)} ->\n\t\tif (set1.IsDisjoint(set2)== true)\n\t\t{\n\t\t\tunion12{set3 = set3.Union(set1, set2)} ->\n\t\t\t\n\t\t\tif (set1.IsOverlapping(set3)== true)\n\t\t\t{\n\t\t\t\tsubstract3{set3 = set3.Substract(set3,set1)} -> add3{set3.Add(6)} ->\n\t\t\t\t if (set3.Contains(2) == true){intersect23{set3 = set3.Intersect(set3, set2)}-> remove3{set3.Remove(2)} -> Skip}\n\t\t\t\n\t\t\t}\n\t\t\n\t\t};",
        "property_desc": [
            "The list example is deadlock-free.",
            "The serializable list example is deadlock-free.",
            "The stack example is deadlock-free.",
            "The queue example is deadlock-free.",
            "The set example is deadlock-free."
        ],
        "properties": [
            "#assert List() deadlockfree;",
            "#assert List3() deadlockfree;",
            "#assert Stack() deadlockfree;",
            "#assert Queue() deadlockfree;",
            "#assert Set() deadlockfree;"
        ],
        "path": "pat_examples/csp_module/Demonstration Examples/C# Library Demonstration Example.csp"
    },
    {
        "name": "Channel Operators Demonstration",
        "tags": [
            "Example"
        ],
        "use_non_container_lib": false,
        "description": "This model gives the exmaple of channel opeations:\n  - `cfull`: a boolean function to test whether the an asynchronous channel is full or not. e.g. `call(cfull, c)`.\n  - `cempty`: a boolean function to test whether the an asynchronous channel is empty or not. e.g. `call(cempty, c)`.\n  - `ccount`: an integer function to return the number of elements in the buffer of an asynchronous channel. e.g. `call(ccount, c)`.\n  - `csize`: an integer function to return the buffer size of an asynchronous channel. e.g. `call(cfull, c)`.\n  - `cpeek`: return the first element of an asynchronous channel. e.g. `call(cpeek, c)`.",
        "content": "//define asynchronous channel\nchannel AC 3;\n\n//define variables\nvar Peek;//used to store the first element in the channel\nvar Size;//used to store the channel size\nvar Count;//used to store how many elements are in the channel\n\n//define processes\n\nSystem = case{\n              call(cempty, AC) : ChannelOutput//if the channel is empty, we can just send data to channel\n              call(cfull, AC) : ChannelInput  //if the channel is full, we can just get data from channel\n              default : ChannelOutput[]ChannelInput // otherwise, we could both send or get data.\n             };\n\n                            //here using some varibles to record the channel's information    \nChannelOutput = AC!Count -> read{Peek = call(cpeek, AC); Size = call(csize, AC); Count = call(ccount, AC)} -> System;\n\n                       //note here: cpeek is used only when the channel is not empty.\nChannelInput = AC?i -> read{Count = call(ccount, AC); if(Count != 0){Peek = call(cpeek, AC);}else{Peek = 0} Count = call(ccount, AC)} -> System;",
        "property_desc": [
            "The system is deadlock-free"
        ],
        "properties": [
            "#assert System deadlockfree;"
        ],
        "path": "pat_examples/csp_module/Demonstration Examples/Channel Operators Demonstration.csp"
    },
    {
        "name": "Language Feature Demonstration",
        "tags": [
            "Example"
        ],
        "use_non_container_lib": false,
        "description": "This example demonstrates some language features in PAT: multi-dimentional array, synchronous and asynchornous channels, compound data passing in channal and C# library call invocations .",
        "content": "#define D1 2;\n#define D2 3;\n\n//A synchronous channel\nchannel c 0;\n\n//An asynchronous channel\nchannel ac 1;\n\n//example of multi-dimensional array \nvar x[D1][D2];\n//example of multi-dimensional array with initial value\nvar y[D1][D2] = [1..6];\n\n//example of channel to send multiple data in one action. An array can be sent in the channel as a whole.\n//in the channel input events, constanst can be used to make sure that only channel data with matching value are received, otherwise the input event is blocked.\nP(i) = c!x.i -> ac?u.1 -> P(x);\n\nQ(i) = c?z.m -> \n\t   //the channel communication are pass-by-value, change the value of x will not affect z.\n\t   //although z is recieved as a two dimensional array, but it can only be accessed as a 1 dimensional array. This is a limiation of PAT, since PAT does not store multi-dimentional array internally.\n\t   tau{x[0][1] = 5; x[0][2] = z[1];} ->\n\t   //value of z can be used, but can not be updated.\n\t   ac!z[1].m -> Q(m);\n\naSys1 = P(1) ||| Q(2);",
        "property_desc": [
            "The system is deadlock-free"
        ],
        "properties": [
            "#assert aSys1 deadlockfree;"
        ],
        "path": "pat_examples/csp_module/Demonstration Examples/Language Feature Demonstration.csp"
    },
    {
        "name": "Consensus With Crashes",
        "tags": [
            "Algorithm",
            "Leader Election"
        ],
        "use_non_container_lib": false,
        "description": "This CSP model simulates a consensus algorithm among N(three) processes where some processes might crash during execution.",
        "content": "//////////////// The Model //////////////////\n#define N 3;\n\n//////////////// Global Variables //////////////////\nvar state[N];\nvar crashed[N];\n\nvar hascrashed=0;\n\n//////////////// Interaction //////////////////\nInteraction(i, r) =\n\t    [ crashed[i]==0 && crashed[r]==0 && state[i] < state[r] ] (interaction.i.r{state[r] = state[i];} -> Interaction(i,r))\n\t[]  [ crashed[i]==0 && hascrashed < N-1 ] (crash.i{crashed[i] = 1; hascrashed = hascrashed+1;} -> Skip);\n\nInitialization() = \n\t((t{state[0] = 0; crashed[0] = 0;} -> Skip) [] (t{state[0] = 1; crashed[0] = 0;} -> Skip));\n\t((t{state[1] = 0; crashed[1] = 0;} -> Skip) [] (t{state[1] = 1; crashed[1] = 0;} -> Skip));\n\t((t{state[2] = 0; crashed[2] = 0;} -> Skip) [] (t{state[2] = 1; crashed[2] = 0;} -> Skip));\n\nConsensus() = Initialization();(\n                  Interaction(0,1) |||Interaction(0,2) |||\n                  Interaction(1,0) |||Interaction(1,2) |||\n                  Interaction(2,0) |||Interaction(2,1));",
        "property_desc": [
            "Eventually, all non-crashed processes will reach the same state and stay at that state (global consensus).",
            "Eventually, process0 and process1 are un-crashed processes and will reach the same state and stay at that state (pair consensus).",
            "Eventually, process0 and process2 are un-crashed processes and will reach the same state and stay at that state (pair consensus).",
            "Eventually, process1 and process2 are un-crashed processes and will reach the same state and stay at that state (pair consensus)."
        ],
        "properties": [
            "// if each processes are non-crashed and reach consensus.\n#define stabagree01 (crashed[0]==0 && crashed[1]==0 && state[0]==state[1]);\n#define stabagree02 (crashed[0]==0 && crashed[2]==0 && state[0]==state[2]);\n#define stabagree12 (crashed[1]==0 && crashed[2]==0 && state[1]==state[2]);\n\n#assert Consensus() |= <>[] stabagree01 && stabagree02 && stabagree12;",
            "#assert Consensus() |= <>[] stabagree01;",
            "#assert Consensus() |= <>[] stabagree02;",
            "#assert Consensus() |= <>[] stabagree12;"
        ],
        "path": "pat_examples/csp_module/Leader Election/Consensus With Crashes.csp"
    },
    {
        "name": "Deterministic 2-hop coloring in rings",
        "tags": [
            "Protocol"
        ],
        "use_non_container_lib": false,
        "description": "A protocol to make nodes to recognize their neighbors in a ring. In fact, it is a general algorithm that enables each node in a degree-bounded graph to distinguish between its neighbors. The graph is colored such that any two nodes adjacent to the same node have different colors. More precisely, for each node v, if u and w are distinct neighbors of v, then u and w must have different colors. (u, w) is called a \"two-hop\" pair. In the current paper, we restrict ourselves to rings, and three colors suffice the purpose (see [1]).\n  Each node u in a ring has two state components, color[u] encodes the color of node u and F[u] is a bit array, indexed by colors. Initially, color[u] and F[u] can have arbitrary values. The following description defines the interaction between an initiator u and a responder v. \n  ```\n  if F[u][color[v]] != F[v][color[u]] then\n      color[u] <- (color[u]+r[u]) % C\n      F[u][color[v]]=F[v][color[u]]\n  else F[u][color[v]]= neg(F[u][color[v]])\n      F[v][color[u]]= neg{F[v][color[u]]}\n      r[u] <- neg r[u]\n  ```\n  Instead of nondeterministically assigning all possible colors to the initiator u, its color is updated as color[u] <- (color[u]+r[u]) mod C. The additional state component r[u] is a local bit for node u that flits whenever u acts as the initiator of an interaction.",
        "content": "////////////////  the number of nodes N, the number of colors (d*(d-1)+1), d is the degree of the graph\n//////////////// we only focus on the ring topology, hence, C=3\n#define N 3;\n#define C 3;\n////////////////Global Variables//////////////////\n//////////////// color is a array of possible colors (C)\n//////////////// F is a bit array\nvar color[N];\nvar r[N];\nvar F[N*C];\n//////////////// Interaction //////////////////\nInteraction(u,v) =    \n\tifa (F[C*u+color[v]] != F[C*v+color[u]]) { \n\t     interact.u.v{ color[u] = (color[u] + r[u]) % C ; F[C*u+color[v]] = F[C*v+color[u]]; r[u] = 1-r[u]; } -> Interaction(u,v)\n        } else { \n             interact.u.v{ F[C*u+color[v]] = 1- F[C*u+color[v]]; F[C*v+color[u]] = 1- F[C*v+color[u]];  r[u] = 1-r[u]; } -> Interaction(u,v)\n\t};\n//////////////// Initialization //////////////////\nInitialization() = \n\t  ((t{color[0] = 0;}-> Skip) [] (t{color[0] = 1;}-> Skip) [] (tau{color[0] = 2;}-> Skip));\n\t  ((t{color[1] = 0;}-> Skip) [] (t{color[1] = 1;}-> Skip) [] (tau{color[1] = 2;}-> Skip));\n\t  ((t{color[2] = 0;}-> Skip) [] (t{color[2] = 1;}-> Skip) [] (tau{color[2] = 2;}-> Skip));\n\t  ((t{r[0] = 0;} -> Skip) [] (t{r[0] = 1;} -> Skip));\n\t  ((t{r[1] = 0;} -> Skip) [] (t{r[1] = 1;} -> Skip));\n\t  ((t{r[2] = 0;} -> Skip) [] (t{r[2] = 1;} -> Skip));\n\t  ((t{F[0] = 0;} -> Skip) [] (t{F[0] = 1;} -> Skip));\n\t  ((t{F[1] = 0;} -> Skip) [] (t{F[1] = 1;} -> Skip));\n\t  ((t{F[2] = 0;} -> Skip) [] (t{F[2] = 1;} -> Skip));\n\t  ((t{F[3] = 0;} -> Skip) [] (t{F[3] = 1;} -> Skip));\n\t  ((t{F[4] = 0;} -> Skip) [] (t{F[4] = 1;} -> Skip));\n\t  ((t{F[5] = 0;} -> Skip) [] (t{F[5] = 1;} -> Skip));\n\t  ((t{F[6] = 0;} -> Skip) [] (t{F[6] = 1;} -> Skip));\n\t  ((t{F[7] = 0;} -> Skip) [] (t{F[7] = 1;} -> Skip));\n\t  ((t{F[8] = 0;} -> Skip) [] (t{F[8] = 1;} -> Skip));\n\nTwoHopColoringRings() = Initialization();(\n\t  Interaction(0,1) ||| Interaction(0,2) ||| \n\t  Interaction(1,2) ||| Interaction(1,0) ||| \n\t  Interaction(2,0) ||| Interaction(2,1));",
        "property_desc": [
            "If all three nodes have different colors and the 2-hop coloring condition is satisfied. The twohopcoloring property eventually becomes true and remains true forever"
        ],
        "properties": [
            "#define twohopcoloring (color[0]!=color[2]) && (color[1]!=color[0]) && (color[2]!=color[1]);\n#assert TwoHopColoringRings() |= <>[] twohopcoloring;"
        ],
        "path": "pat_examples/csp_module/Leader Election/Deterministic 2-Hop Coloring in Rings.csp"
    },
    {
        "name": "Self-stabilizing leader election in (directed) rooted trees",
        "tags": [
            "Algorithm",
            "Leader Election"
        ],
        "use_non_container_lib": false,
        "description": "This example models an leader-election algorithm for directed rooted tree of odd size. \n  We consider the rooted directed trees topologies where the root is the only node of in-degree 0 and for each node in the tree there is a directed path from the root to that node\n  Each node has a memory slot that can hold either a leader mark \"x\" or nothing \"-\" for a total of two states.\n  The algorithm can be formalled described by 3 pattern rules which are matched against the state and input of the initiator and responder, respectively.\n  - Rule 1. ((x,*), (x,*)) -> ((x), (-)) \n  - Rule 2. ((-,F), (-,*)) -> ((x), (-))\n  - Rule 3. ((-,*), (x,*)) -> ((x), (-))",
        "content": "#define N 3;\n\nvar detectorcorrect = 0;\nvar detector = false;\nvar leader[N];\n\n/*Rule 1*/\nRule1(i, r) = [leader[i] == 1 && leader[r] == 1]\n\t\t\t     (rule1.i.r{leader[r] = 0;} -> Rule1(i, r));\n\n/*Rule 2*/\nRule2(i, r) = [leader[i] == 0 && leader[r] == 0 && !((detectorcorrect == 0 && detector) || (detectorcorrect != 0 && (  leader[0] + leader[1] + leader[2] > 0)))]\n\t\t\t     (rule2.i.r{leader[i] = 1;} -> Rule2(i, r));\n\n/*Rule 3*/\nRule3(i, r) = [leader[i] == 0 && leader[r] == 1]\n\t\t\t     (rule3.i.r{leader[i] = 1; leader[r] = 0;} -> Rule3(i, r));\n\n/* eventual leader detector*/\nDetectorCorrect() = [detectorcorrect == 0](progress{detectorcorrect = 1;} ->  DetectorCorrect());\nRandomDetector() = [detectorcorrect == 0]((random1{detector = false;} -> RandomDetector()) [] (random2{detector = true;} -> RandomDetector()));\n\nInitialization() = ((tau{leader[0] = 0;} -> Skip) [] (tau{leader[0] = 1;} -> Skip));\n                   ((tau{leader[1] = 0;} -> Skip) [] (tau{leader[1] = 1;} -> Skip));\n                   ((tau{leader[2] = 0;} -> Skip) [] (tau{leader[2] = 1;} -> Skip));\n\n/* The topology is a rooted tree. */\nLeaderElection() = Initialization(); (DetectorCorrect() ||| RandomDetector() |||\n                   Rule1(0,1)|||Rule1(0,2)|||\n                   Rule2(0,1)|||Rule2(0,2)|||\n                   Rule3(0,1)|||Rule3(0,2));",
        "property_desc": [
            "the system will eventually reach a stable state where a single leader exists and this state will be maintained"
        ],
        "properties": [
            "#define oneLeader (leader[0] + leader[1] + leader[2] == 1);\n#assert LeaderElection() |= <>[]oneLeader;"
        ],
        "path": "pat_examples/csp_module/Leader Election/Leader Election in (Directed) Rooted Trees.csp"
    },
    {
        "name": "Leader Election in Odd Size Ring",
        "tags": [
            "Algorithm",
            "Leader Election"
        ],
        "use_non_container_lib": false,
        "description": "This example models an leader-election algorithm for network rings of odd size.\n  \n  Supposing each agent has a label bit, we call a maximal sequence of alternating labels a segment. \n  Since the size of the ring is odd, there is at least one pair of adjacent agents with the same label. \n  We define the head and tail of a segment in the natural way according to the direction of the ring.\n \n  The algorithm starts with \u201cunstable clock\u201d algorithm, in which the barriers move forward (clockwise) around the ring. \n  When two barriers collide, one of them is eliminated. There exists a sequence of activations that remove all but one barrier. \n  By fairness, eventually there is a single barrier which rotates clockwise around the ring forever.\n \n  Then, the leader marks and two kinds of tokens, bullet and probe. \n  Probes move faster than barriers. (We do not allow abarrier to go past a probe from behind.) \n  Probes are sent out by the barrier in a clockwise direction and absorbed by any leader they run into. \n  If a probe makes it all the way back to the barrier, it is converted to leader (just behind the barrier, which we can imagine is between the two endpoints of the barrier edge). \n  Leaders fire bullets counterclockwise around the ring. Bullets are absorbed by the barrier, but they kill any leaders they encounter along the way. (That is, they remove the leader mark.)\n \n  The algorithm ensures a safe configuration with one barrier, one leader, and no bullets or probes between them. \n  As the barrier rotates, this safe region shrinks until a single leader remains.",
        "content": "#define N 3;\n\n////////////////Global Variables//////////////////\nvar leader[N];\nvar bullet[N];\nvar label[N];\nvar probe[N];\nvar phase[N];\n\n////////////////Processes//////////////////\nProcess(i) = [label[i] == label[(i+1)%N] && probe[i] == 1 && phase[i] == 0 && leader[(i+1)%N] == 0 ]\n\t\t\t\t rule01.i.(i+1)%N{ leader[i] = 1; probe[i] = 0; phase[i] = 1; probe[(i+1)%N] = 1; } -> Process(i)\n\t\t\t [] [label[i] == label[(i+1)%N] && probe[i] == 1 && phase[i] == 0 && leader[(i+1)%N] == 1 ]\n\t\t\t\t rule02.i.(i+1)%N{ leader[i] = 1; probe[i] = 0; phase[i] = 1; } -> Process(i)\n\t\t\t [] [label[i] == label[(i+1)%N] && probe[i] == 1 && phase[i] == 1 && probe[(i+1)%N] == 0 ]\n\t\t\t\t rule03.i.(i+1)%N{ leader[i] = 1; probe[i] = 0; bullet[(i+1)%N] = 0; label[(i+1)%N] = 1-label[(i+1)%N]; phase[(i+1)%N] = 0; } -> Process(i)\n\t\t\t [] [label[i] == label[(i+1)%N] && probe[i] == 1 && phase[i] == 1 && probe[(i+1)%N] == 1 ]\n\t\t\t\t rule04.i.(i+1)%N{ leader[i] = 1; probe[i] = 0; } -> Process(i)\n\t\t\t [] [label[i] == label[(i+1)%N] && probe[i] == 0 && phase[i] == 0 && leader[(i+1)%N] == 0 ]\n\t\t\t\t rule05.i.(i+1)%N{ phase[i] = 1; probe[(i+1)%N] = 1; } -> Process(i)\n\t\t\t [] [label[i] == label[(i+1)%N] && probe[i] == 0 && phase[i] == 0 && leader[(i+1)%N] == 1 ]\n\t\t\t\t rule06.i.(i+1)%N{ phase[i] = 1; } -> Process(i)\n\t\t\t [] [label[i] == label[(i+1)%N] && probe[i] == 0 && phase[i] == 1 && probe[(i+1)%N] == 0 ]\n\t\t\t\t rule07.i.(i+1)%N{ bullet[(i+1)%N] = 0; label[(i+1)%N] = 1-label[(i+1)%N]; phase[(i+1)%N] = 0; } -> Process(i)\n\t\t\t [] [label[i] != label[(i+1)%N] && leader[(i+1)%N] == 1 && bullet[(i+1)%N] == 1  ]\n\t\t\t\t rule08.i.(i+1)%N{ leader[(i+1)%N] = 0; } -> Process(i)\n\t\t\t [] [label[i] != label[(i+1)%N] && leader[(i+1)%N] == 1 && bullet[(i+1)%N] == 0  ]\n\t\t\t\t rule09.i.(i+1)%N{ bullet[i] = 1; probe[i] = 0;} -> Process(i)\n\t\t\t [] [label[i] != label[(i+1)%N] && leader[(i+1)%N] == 0 && bullet[(i+1)%N] == 1 && probe[i] == 1]\n\t\t\t\t rule10.i.(i+1)%N{ bullet[i] = 1; bullet[(i+1)%N] = 0;  probe[i] = 0; probe[(i+1)%N] = 1;} -> Process(i)\n\t\t\t [] [label[i] != label[(i+1)%N] && leader[(i+1)%N] == 0 && bullet[(i+1)%N] == 0 && probe[i] == 1]\n\t\t\t\t rule11.i.(i+1)%N{ probe[i] = 0; probe[(i+1)%N] = 1; } -> Process(i)\n\t\t\t [] [label[i] != label[(i+1)%N] && leader[(i+1)%N] == 0 && bullet[(i+1)%N] == 1 && probe[i] == 0]\n\t\t\t\t rule12.i.(i+1)%N{ bullet[i] = 1; bullet[(i+1)%N] = 0; } -> Process(i);\n\nInitialization() = ((tau{leader[0] = 0;} -> Skip) [] (tau{leader[0] = 1;} -> Skip));\n                   ((tau{leader[1] = 0;} -> Skip) [] (tau{leader[1] = 1;} -> Skip));\n                   ((tau{leader[2] = 0;} -> Skip) [] (tau{leader[2] = 1;} -> Skip));\n                   ((tau{bullet[0] = 0;} -> Skip) [] (tau{bullet[0] = 1;} -> Skip));\n                   ((tau{bullet[1] = 0;} -> Skip) [] (tau{bullet[1] = 1;} -> Skip));\n                   ((tau{bullet[2] = 0;} -> Skip) [] (tau{bullet[2] = 1;} -> Skip));\n                   ((tau{label[0] = 0;} -> Skip) [] (tau{label[0] = 1;} -> Skip));\n                   ((tau{label[1] = 0;} -> Skip) [] (tau{label[1] = 1;} -> Skip));\n                   ((tau{label[2] = 0;} -> Skip) [] (tau{label[2] = 1;} -> Skip));\n                   ((tau{probe[0] = 0;} -> Skip) [] (tau{probe[0] = 1;} -> Skip));\n                   ((tau{probe[1] = 0;} -> Skip) [] (tau{probe[1] = 1;} -> Skip));\n                   ((tau{probe[2] = 0;} -> Skip) [] (tau{probe[2] = 1;} -> Skip));\n                   ((tau{phase[0] = 0;} -> Skip) [] (tau{probe[0] = 1;} -> Skip));\n                   ((tau{phase[1] = 0;} -> Skip) [] (tau{probe[1] = 1;} -> Skip));\n                   ((tau{phase[2] = 0;} -> Skip) [] (tau{probe[2] = 1;} -> Skip));\n\nLeaderElectionOddRing() = Initialization(); (Process(0)|||Process(1)|||Process(2));",
        "property_desc": [
            "the system will eventually reach a stable state where a single leader exists and this state will be maintained"
        ],
        "properties": [
            "#define oneLeader ( leader[0] + leader[1] + leader[2] == 1);\n#assert LeaderElectionOddRing() |= <>[]oneLeader;"
        ],
        "path": "pat_examples/csp_module/Leader Election/Leader Election in Odd Size Ring.csp"
    },
    {
        "name": "Orienting Undirected in Ring",
        "tags": [
            "Protocol"
        ],
        "use_non_container_lib": false,
        "description": "It is possible to have a protocol that gives a sense of orientation to each node on an undirected ring[1]. After the orienting, (1) each node has exactly one predecessor and one successor, the predecessor and successor of a node are different; (2) for any two nodes u and v, u is the predecessor of v if and only if v is the successor of u, for any edge (u, v), either u is the predecessor of v or v is the predecessor of u. \n\n  Each node u in a ring has three state components: color[u] encodes the color of node u, precolor[u] the color of its predecessor, and succolor[u] the color of its successor. Initially, all nodes are two-hop colored (array color satisfies the two-hop coloring property), precolor[u] and succolor[u] can have arbitrary values. The following description defines the interaction between an initiator u and a responder v.",
        "content": "////////////////The Model//////////////////\n////////////////  the number of nodes, the number of colors (d*(d-1)+1), d is the degree of the graph\n//////////////// we only focus on the ring topology, hence, C=3\n#define N 3;\n#define C 3;\n\n////////////////Global Variables//////////////////\nvar mycolor[N];\nvar precolor[N];\nvar succolor[N];\n\n//////////////// Interaction //////////////////\nInteraction(u,v) =    \n\tifa (mycolor[v]==precolor[u] && mycolor[v]!=succolor[u]) { \n\t\tinteract.u.v{succolor[v] = mycolor[u];} -> Interaction(u,v)\n        } else { \n\t\tifa (mycolor[v]==succolor[u] && mycolor[v]!=precolor[u]) { \n\t\t\tinteract.u.v{precolor[v] = mycolor[u];} -> Interaction(u,v) \n\t\t} else{ \n\t\t\tinteract.u.v{precolor[u] = mycolor[v]; succolor[v] = mycolor[u];} -> Interaction(u,v)\n\t\t}\n\t};\n\n/////////////// Inputs should be two-hop coloring on the nodes,\n/////////////// which means the neighbors of one node must have different colors.\n\n/////////////// Since the ring has nodes with 3 colors, the only way is to make nodes with unique color.\n/////////////// Cases are symmetric. Hence, we only give one possibility here.\n\nInitialization() = (\n                     (t{mycolor[0] = 0; mycolor[1] = 1; mycolor[2] = 2;} -> Skip)\n                     );\n                     ((t{precolor[0] = 0;} -> Skip) [] (t{precolor[0] = 1;} -> Skip) [] (t{precolor[0] = 2;} -> Skip));\n                     ((t{precolor[1] = 0;} -> Skip) [] (t{precolor[1] = 1;} -> Skip) [] (t{precolor[1] = 2;} -> Skip));\n                     ((t{precolor[2] = 0;} -> Skip) [] (t{precolor[2] = 1;} -> Skip) [] (t{precolor[2] = 2;} -> Skip));\n                     ((t{succolor[0] = 0;} -> Skip) [] (t{succolor[0] = 1;} -> Skip) [] (t{succolor[0] = 2;} -> Skip));\n                     ((t{succolor[1] = 0;} -> Skip) [] (t{succolor[1] = 1;} -> Skip) [] (t{succolor[1] = 2;} -> Skip));\n                     ((t{succolor[2] = 0;} -> Skip) [] (t{succolor[2] = 1;} -> Skip) [] (t{succolor[2] = 2;} -> Skip));\n\n/////// here, the interactions also define a ring\nOrientingUndirectedRing() = Initialization(); (\n                     Interaction(0,1) ||| Interaction(0,2) ||| \n                     Interaction(1,2) ||| Interaction(1,0) ||| \n                     Interaction(2,0) ||| Interaction(2,1)\n                     );",
        "property_desc": [
            "The predecessor and successor colors of each node are distinct",
            "The colors of adjacent nodes satisfy the orientation condition"
        ],
        "properties": [
            "#define presucdistinct ((precolor[0]!=succolor[0]) &&(precolor[1]!=succolor[1]) &&(precolor[2]!=succolor[2]));\n#assert OrientingUndirectedRing() |= <>[] presucdistinct;",
            "#define adjecent01 ((mycolor[0]==precolor[1] && mycolor[1]==succolor[0]) || (mycolor[0]==succolor[1] && mycolor[1]==precolor[0]));\n#define adjecent12 ((mycolor[1]==precolor[2] && mycolor[2]==succolor[1]) || (mycolor[1]==succolor[2] && mycolor[2]==precolor[1]));\n#define adjecent20 ((mycolor[2]==precolor[0] && mycolor[0]==succolor[2]) || (mycolor[2]==succolor[0] && mycolor[0]==precolor[2]));\n#assert OrientingUndirectedRing() |= <>[] adjecent01 && adjecent12 && adjecent20;"
        ],
        "path": "pat_examples/csp_module/Leader Election/Orienting Undirected in Ring.csp"
    },
    {
        "name": "Token Circulation in Rings",
        "tags": [
            "Algorithm",
            "Leader Election"
        ],
        "use_non_container_lib": false,
        "description": "This example models an leader-election algorithm for network rings with token circulations. \n  By utilizing the leader-election algorithm for network rings, a self-stabilizing token-circulation algorithm is implemented.\n  There are two rules defined how the token moves between nodes:\n  - Rule1(i, r): This rule is executed when node i is a non-leader, node r is the leader, and both have the same label. Node i passes its token to node r, and the label of the leader is flipped.\n  - Rule2(i, r): This rule is executed when node r is a non-leader and the labels of node i and r are different. Node i passes its token to node r, and the label of the receiver becomes the label of the sender.",
        "content": "#define N 3;\n\n////////////////Global Variables//////////////////\nvar leader[N];\nvar token[N];\nvar label[N];\n\n////////////////Rules//////////////////\n/*Rule 1*/\nRule1(i, r) = [leader[i] == 0 && leader[r] == 1 && label[i] == label[r]]\n\t\t\t     (rule1.i.r{token[i] = 0; token[r] = 1; label[r] = 1-label[i];} -> Rule1(i, r));\n\n/*Rule 2*/\nRule2(i, r) = [leader[r] == 0 && label[i] != label[r]]\n\t\t\t  (rule2.i.r{token[i] = 0; token[r] = 1; label[r] = label[i];} -> Rule2(i, r));\n\nInitialization() = (tau{leader[0] = 1;leader[1] = 0; leader[2] = 0; }  -> Skip);\n                   ((tau{token[0] = 0;} -> Skip) [] (tau{token[0] = 1;} -> Skip));\n                   ((tau{token[1] = 0;} -> Skip) [] (tau{token[1] = 1;} -> Skip));\n                   ((tau{token[2] = 0;} -> Skip) [] (tau{token[2] = 1;} -> Skip));\n                   ((tau{label[0] = 0;} -> Skip) [] (tau{label[0] = 1;} -> Skip));\n                   ((tau{label[1] = 0;} -> Skip) [] (tau{label[1] = 1;} -> Skip));\n                   ((tau{label[2] = 0;} -> Skip) [] (tau{label[2] = 1;} -> Skip));\n\nTokenCirculation() = Initialization();\n                   (Rule1(0,1)|||Rule1(1,2)|||Rule1(2,0)|||Rule2(0,1)|||Rule2(1,2)|||Rule2(2, 0));",
        "property_desc": [
            "The token will always circulate in a specific order: from node 0 to node 1, then to node 2, and back to node 0",
            "Eventually, there will always be only one token in the system",
            "Each node will eventually hold the token."
        ],
        "properties": [
            "#define oneToken (token[0] + token[1] + token[2] == 1);\n#define token0 (token[0] == 1);\n#define token1 (token[1] == 1);\n#define token2 (token[2] == 1);\n#assert TokenCirculation() |= []<> (token0 -> (!token2 U token1)) && []<> (token1 -> (!token0 U token2)) && []<> (token2 -> (!token1 U token0));",
            "#assert TokenCirculation() |= <>[]oneToken;",
            "#assert TokenCirculation() |= []<> token0 && []<> token1 && []<> token2;"
        ],
        "path": "pat_examples/csp_module/Leader Election/Token Circulation in Rings.csp"
    },
    {
        "name": "Concurrent Stack Implementation",
        "tags": [
            "Algorithm",
            "Data Structure"
        ],
        "use_non_container_lib": false,
        "description": "The basic principle for the algorithm is to only add something new to the stack once you know the item you are trying to add is the only thing that has been added since you began the operation. \n  Pushing an item to the stack is done by first taking the top of the stack (old head) and placing it after your new item to create a new head. \n  You then compare the old head to the current head. If the two are matching then you can swap old head to the new one, if not then it means another thread has added an item to the stack, in which case you must try again.\n  When popping an item from the stack, before returning the item you must check that another thread has not added a new item since the operation began.",
        "content": "////number of processes\n#define N 2;\n//stack size\n#define SIZE 2;\n\n//shared head pointer for the concrete implementation\nvar H = 0;\n//local variable to store the temporary head value\nvar HL[N];\n\n//shared head pointer for the abstract implementation\nvar HA = 0;\n//local variable to store the temporary head value\nvar HLA[N];\n\n////////////////The Concrete Implementation Model//////////////////\nPushLoop(i) = headread.i{HL[i]=H;} -> (\n\tifa (HL[i] == H) {\n\t\tpush.i{if(H < SIZE) {H = H+1;} HL[i]=H;} -> tau -> push_res.i.HL[i] -> Skip\n\t} else {\n\t\tPushLoop(i)\n\t});\n\nPopLoop(i) = headread.i{HL[i]=H;} -> \n\t(if(HL[i] == 0) {\n\t\tpop_res.i.0 -> Skip \n\t} else {\n\t\t(ifa(HL[i] != H) { PopLoop(i) } else { pop.i{H = H-1; HL[i]=H;} -> tau -> pop_res.i.(HL[i]+1) -> Skip\n\t\t})\n\t});\n\nProcess(i) = (push_inv.i -> PushLoop(i)[] pop_inv.i -> PopLoop(i));Process(i);\nStack() = (|||x:{0..N-1}@Process(x)) \\ {headread.0, push.0, pop.0, headread.1, push.1, pop.1};\n\n////////////////The Abstract Specification Model//////////////////\nPushAbs(i) = push_inv.i -> push.i{if(HA < SIZE) {HA = HA+1;}; HLA[i]=HA;} -> push_res.i.HLA[i] -> Skip;\n\nPopAbs(i) = pop_inv.i ->\n\t(ifa(HA == 0) {\n\t\ttau-> pop_res.i.0 -> Skip \n\t} else {\n\t\t pop_empty.i{HA = HA -1; HLA[i]=HA;} -> pop_res.i.(HLA[i]+1) -> Skip\n\t});\n\nProcessAbs(i) = (PushAbs(i)[]PopAbs(i));ProcessAbs(i);\n\nStackAbs() = (|||x:{0..N-1}@ProcessAbs(x)) \\{push.0, pop.0, pop_empty.0, push.1, pop.1, pop_empty.1};",
        "property_desc": [
            "Checks if the concrete Stack model refines the abstract Stack model",
            "Checks if the abstract Stack model refines the concrete Stack model",
            "The model is deadlock-free",
            "A process must eventually be able to update the stack."
        ],
        "properties": [
            "#assert Stack() refines StackAbs();",
            "#assert StackAbs() refines Stack();",
            "#assert Stack() deadlockfree;",
            "#assert Stack() |= [](push_inv.0 -> <>(push_res.0.0 ||push_res.0.1 || push_res.0.2));"
        ],
        "path": "pat_examples/csp_module/Linearizibility Examples/Concurrent Stack Implementation.csp"
    },
    {
        "name": "Linked List",
        "tags": [
            "Algorithm",
            "Data Structure"
        ],
        "use_non_container_lib": false,
        "description": "This algorithm is based on a singly linked list with sentinel nodes Head and Tail. Each node in the list contains three fields: an integer variable key, a pointer variable next and a boolean variable marked. The list is intended to be maintained in a sorted manner using the key field. The Head node always contains the minimal possible key, and the Tail node always contains the maximal possible key. The keys in these two sentinel nodes are never modified, but are only read and used for comparison. Initially the set is empty, that is, in the linked list, the next field of Head points to Tail and the next field of Tail points to null. The marked fields of both sentinel nodes are initialized to false. This algorithm consists of three methods: add, remove and contains.\n\n  To keep the list sorted, the add method first optimistically searches over the list until it finds the position where the key should be inserted. This search traversal is performed optimistically without any locking. If a key is already in the set, then the method returns false. Otherwise, the thread tries to insert the key. However, in between the optimistic traversal and the insertion, the key may have been removed, or the predecessor which should point to the new key has been removed. In either of these two cases, the algorithm does not perform the insertion and restarts its operation from the beginning of the list. Otherwise, the key is inserted and the method returns true. The operation of the remove method is similar. It iterates over the list, and if it does not find the key it is looking for, it returns false. Otherwise, it checks whether the shared invariants are violated and if they are, it restarts. If they are not violated, it physically removes the node and sets its marked field to true. The marked field and setting it to true are important because they consistute a communication mechanism to tell other threads that this node has been removed in case they end up with it after the optimistic traversal. The last method is contains. It simply iterates over the heap without any kind of synchronization, and if it finds the key it is looking for, it returns true. Otherwise, it returns false.",
        "content": "#import \"PAT.Lib.EntryList\";\n#import \"PAT.Lib.Set\";\n \n//smalledst key for HEAD\n#define MIN 0;\n#define MIN1 1;\n\n//largest key for TAIL\n#define MAX 3; \n#define MAX1 2;\n\n//number of processes\n#define N 2; \n\n//number of nodes including Head and Tail\n#define M 10;\n\n//number of operations for each process\n#define Q 2;\n\n//operation types\nenum {ADD, REMOVE, CONTAINS}; \n\n//the underlying data structure to represent a singly linked list.\nvar<EntryList> l = new EntryList(M, MIN, MAX);     \n\n//array of local variables which are used in the operations, \n//as there may be N processes calling one operation concurrently, there could be PROCESS_SIZE * OPERATION_SIZE local variables\n//For example, for add operation, the local variable curr of process j is c[j][0]\n//Note: variable[i][0] is local variable for ADD operation;\n//      variable[i][1] is local variable for REMOVE operation;\n//      variable[i][2] is local variable for CONTAINS operation;\nvar c[N][3];           // N * 3\nvar pred[N][3];        // N * 3\nvar k[N][3];          // N * 3\n\nvar entry[N];          // N * 1, for Add operation\nvar r[N];              // N * 1, for Remove operation\n\n//var mp[N][2];\nvar val[N][2];\n\n\n//algorithm implementation\n//Note: in the implementaion, the garbage collection makes use of reference counting alg. Every assignment which involves the reference\n//      counter modification of the element in the linked list is encapsulated as a method call of Class EntryList in C# library. \n//      So all gc details are a black box for this model. \n\nSyst = (|||i:{0..N-1}@(Pro(i, 0)));\n         \nPro(i, j) = ifa(j < Q){(Add(i)[] Remove(i)[]Contains(i));Pro(i, j+1)};\n\nAdd(i) =  []x:{MIN1..MAX1}@(add.i.x -> Loc(x,i,ADD));\n\nRemove(i) = []x:{MIN1..MAX1}@(rm.i.x -> Loc(x,i,REMOVE));\n\nContains(i) = []x:{MIN1..MAX1}@(ct.i.x -> Loc(x,i,CONTAINS));\n\nLoc(key, p, o) = tau{pred[p][o]= 0} ->  //line 44: pred = Head\n                 tau{c[p][o]= l.GetNext(c[p][o], 0)}->  //line: 45curr = Head -> next\n                 l46(key, p, o);     \n\t\t\t\t \nl46(key, p, o) = if (l.Key(c[p][o])< key) //line 46: while(c-> key < key)\n                    {\n                       tau{l.Assign(pred[p][o],c[p][o]);pred[p][o]= c[p][o]; }-> //line 47: pred = curr\n                       tau{c[p][o]= l.GetNext(c[p][o], c[p][o])}->  //line48: c = curr ->next\n                       l46(key, p, o)\n                    }\n                    else\n                    {\n                      ifa(o ==ADD){Add5(key, p)}\n                      else  \n                      {\n                      \tifa(o == REMOVE)  {Rm22(key, p)}\n                      \telse {Ct38(key, p)}\n                      }\n                    };\nAdd5(key, p)= \n\t\t\t\ttau{k[p][0] = (l.Key(c[p][0]) == key)} -> //line 5: k= (curr -> key == key)\n                if (k[p][0]== true) //line 6: if (k) return false\n                {\n                \tadd.p.key.(l.GetData()){\n\t\t\t\t\t\t\t\t\t  //reset the local variables\n\t\t\t\t\t\t\t\t\t  k[p][0]=false;\n\t\t\t\t\t\t\t\t\t  \t val[p][0] = false;\n\t\t\t\t\t\t\t\t\t  l.Reset3(pred[p][0], c[p][0], entry[p]);\n                \t                  pred[p][0] = 0;\n                \t                  c[p][0] = 0;\n                \t                  entry[p] = 0;\n                \t                  } -> Skip\n                }\n                else\n                { \n                \t//atomic {\n                \t//\tl7{entry[p] = l.Create(entry[p],key)} ->  //line 7: entry = new Entry(key)\n                \t//\tif (entry[p] == 0) {outOfMemory -> Stop} //not in original model, for checking memory leak\n                \t//\telse {l8{l.SetNext(entry[p], c[p][0])}-> Skip} //line 8: entry -> next = curr}\n                \t//\tl8{l.SetNext(entry[p], c[p][0])->Skip\n                \t//}; \n                    tau{entry[p] = l.Create(entry[p],key, c[p][0] );} -> //combine l7 and l8\n                    tau{\n                        //mp[p][0] = !(l.Marked(pred[p][0])); //line 10: mp = !pred -> marked\n                \t\tval[p][0] = (l.Next(pred[p][0])== c[p][0]) && !(l.Marked(pred[p][0])); // line 11: val = (pred-> next == curr) && mp\n                \t\tif (val[p][0] == true)// line 13: if (!val) goto restart\n                \t\t{\n                \t\t  l.SetNext(pred[p][0], entry[p]) //line 14: pred -> next = entry                \t\t\n                \t\t}\n                \t} ->               \t\n                \tifa(!val[p][0]) {Loc(key,p,ADD)}\n                \telse{\n                \t\tadd.p.key.(l.GetData()){\n                \t\tk[p][0]=false;\n                \t\t val[p][0] = false;\n                \t \t\t\t\tl.Reset3(pred[p][0], c[p][0], entry[p]);\n                \t\t\t\t\tpred[p][0] = 0;\n                \t\t\t\t\tc[p][0] = 0;\n                \t    \t\t\tentry[p] = 0\n                \t\t} -> Skip  \n                \t}\n                };\n\nRm22(key, p)= \n                tau{k[p][1] = (l.Key(c[p][1]) == key)} ->  //line 22:  k= (curr -> key == key)\n                if (!k[p][1])//line 23: if (!k) return false;\n                {\n                \trm.p.key.(l.GetData()){\n                \tk[p][1]=false;\n                \t              //    k[p][1] = false; \n                \t                  val[p][1] = false;\n                \t                  l.Reset3(pred[p][1],c[p][1], r[p] );\n                \t                  pred[p][1] = 0; \n                \t                  c[p][1] = 0;\n                \t                  r[p] = 0;\n                \t              } -> Skip\n                }\n                else\n                {\n                  tau{l.SetMarked(c[p][1], true)}-> //line 24: curr->marked = true\n                  tau{r[p] = l.GetNext(r[p], c[p][1])}-> //line 25: r = curr -> next                  \n                  tau{\n                      //  mp[p][1] = !(l.Marked(pred[p][1])); //line 27: mp = !pred -> marked\n                \t\tval[p][1] = (l.Next(pred[p][1])== c[p][1]) &&!(l.Marked(pred[p][1])); // line 28: val = (pred-> next == curr) && mp\n                \t\tif (val[p][1]== true) //line 30: if(!val) goto restart\n                \t\t{\n                \t\t l.SetNext(pred[p][1], r[p]) // line 31: pred-> next = r\n                \t\t}\n                  }->                  \n                  ifa (!val[p][1]) {Loc(key, p, REMOVE)}\n                  else{\n                  \trm.p.key.(l.GetData()){\n                \t    k[p][1] = false; \n                \t //   mp[p][1] = false;\n                \t    val[p][1] = false;\n\t\t\t\t\t\tl.Reset3(pred[p][1],c[p][1], r[p]);\n                \t\tpred[p][1] = 0; \n                \t\tc[p][1] = 0; \n                \t\tr[p]= 0;\n                \t}\t-> Skip  \n                 }\n                };\n                \nCt38(key, p) =  tau{k[p][2] = (l.Key(c[p][2]) == key)} -> //line 38: k= (curr -> key == key)\n                if (!k[p][2]) //line 39: if (!k) return false\n                {\n                \tct.p.key.(l.GetData()){\n                \t                  k[p][2] = false; \n                \t                  l.Reset2(pred[p][2],c[p][2] );\n                \t                  pred[p][2] = 0; \n                \t                  c[p][2] = 0\n                \t                  } -> Skip\n                }\n                else\n                { \n                  ct.p.key.(l.GetData()){\n               \t                 k[p][2] = false; \n                \t             l.Reset2(pred[p][2],c[p][2] );\n                \t             pred[p][2] = 0; \n                \t             c[p][2] = 0\n                \t            } -> Skip\n                };\n\n//Specification\nvar<Set> s;\n    \nSys = |||i:{0..N-1}@(P(i, 0));\n\nP(i, j) = ifa(j < Q){( (A(i, j)[] R(i, j)[]C(i, j)))};\n\nA(i, j) = []x:{MIN1..MAX1}@\n          ( \n              add.i.x -> tau{s.Add(x)}-> add.i.x.(s.GetData())-> P(i, j+1) \n          );\n\nR(i, j) = []x:{MIN1..MAX1}@\n          ( \n              rm.i.x -> tau{s.Remove(x)}-> rm.i.x.(s.GetData())-> P(i, j+1) \n          );\nC(i, j) = []x:{MIN1..MAX1}@\n          ( \n              ct.i.x -> ct.i.x.(s.GetData())->  P(i, j+1) //{s.Contains(x)}\n          );",
        "property_desc": [
            "linearizibility Testing"
        ],
        "properties": [
            "#assert Syst refines Sys;"
        ],
        "path": "pat_examples/csp_module/Linearizibility Examples/Linked List.csp"
    },
    {
        "name": "Mailbox Problem",
        "tags": [
            "Real World"
        ],
        "use_non_container_lib": true,
        "description": "This is a theoretical synchronization problem that arises from this setting, which we call the mailbox problem. From time to time, a postman (the device) places letters (requests) for a housewife (the processor) in a mailbox by the street.3 The mailbox has a flag that the wife can see from her house. She looks at the flag from time to time and, depending on what she sees, may decide to go to the mailbox to pick up its contents, perhaps changing the position of the flag. The wife and postman can leave notes for one another at the mailbox. (The notes cannot be read from the house.) We require a protocol to ensure that (i) the wife picks up every letter placed in the mailbox and (ii) the wife never goes to the mailbox when it is empty (corresponding to a spurious interrupt). The protocol cannot leave the wife or the postman stuck at the mailbox, regardless of what the other does. For example, if the wife and postman are both at the mailbox when the postman decides to take a nap, the wife need not remain at themailbox until the postmanwakes up.We do not require the wife to receive letters that are still in the sleeping postman's bag. However, we interpret condition (i) to require that she be able to receive mail left by the postman in previous visits to the mailbox without waiting for him to wake up. \n\n  The mailbox problem is an instance of a general class of problems called boundedsignaling problems. We give a general algorithm for any problem in this class. The algorithm is non-blocking but not wait-free. It is an open problem whether there are general wait-free algorithms in this case.",
        "content": "#import \"PAT.Lib.Example\";\n\n#define EQ 0;\n#define NEQ 1;\n \n#define BOTTOM  0;\n#define UNKNOWN  1;\n#define SUCCESS  2;\n#define DONE  3;\n \n//bounded number of Rounds\n#define ROUND 4;\n#define MaxROUND 2;\n \nvar A0TS[ROUND];\nvar A0C[ROUND];\n \nvar A1TS[ROUND];\nvar A1C[ROUND];\n \nvar B0[ROUND];\nvar B1[ROUND];\n \nvar TS = [1, 1];\nvar Rel = [0, 0];\n \nvar Counter[2];\nvar Rounds[2];\nvar Otherc[2];\nvar OutvalueTS[2];\nvar OutvalueC[2];\nvar Outcome[2];\nvar TSL[2];\nvar RelL[2];\n \nvar NextTS=[2,2];\nvar Otherts = [1,1];\nvar TSC = [1, 1];\n \nvar rnd0 = 0;\nvar rnd1 = 0;\n \n////////////////The Concrete Implementation Model//////////////////\n//process 0: postman\nPostman(i) = [i < MaxROUND](deliver_inv -> tau{Counter[0] = Counter[0] + 1;} -> (Compare(0); deliver_res -> Postman(i+1)));\n \nCompare(i) = tau{Outcome[i] = UNKNOWN;} -> \n   (CompareLoop(i); \n    (if(Counter[i]!=Otherc[i]) {\n         tau{TS[i] = TSC[i]; Rel[i] = NEQ;} -> Skip\n     } else { \n         tau{TS[i] = TSC[i]; Rel[i] = EQ;} -> Skip\n     })\n   );\n \nCompareLoop(i)  =  if (Outcome[i] == SUCCESS) { Skip } else {\n                  tau{Rounds[i] = Rounds[i]+1;} -> tau{TSC[i] = NextTS[i];} -> Sussus(i);\n                        (if(OutvalueC[i] !=  BOTTOM) { \n                             tau{Otherts[i] = OutvalueTS[i];} -> tau{Otherc[i] = OutvalueC[i];} -> Skip\n                        } else {\n                             Skip\n                        });\n                        tau{NextTS[i] = call(dominate, Otherts[i], TS[1-i]);} -> CompareLoop(i)\n                  };\n \nSussus(i) = if(i==0) { Sussus0() } else { Sussus1()};\n \nSussus0() = tau{rnd0 = Rounds[0] - 1; A0TS[rnd0] = TSC[0]; A0C[rnd0] = Counter[0];} ->  tau{OutvalueTS[0] = A1TS[rnd0]; OutvalueC[0] = A1C[rnd0];} ->\n    (if(OutvalueC[0] == BOTTOM ) {\n        tau{Outcome[0] = SUCCESS;} -> Skip\n    } else {\n        tau{B0[rnd0] = DONE;} ->\n            (if(B1[rnd0] == BOTTOM) {\n                tau{Outcome[0] = UNKNOWN;} -> Skip\n             } else {\n                tau{Outcome[0] = SUCCESS;} -> Skip\n             })\n    });\n \nSussus1() = tau{rnd1 = Rounds[1] - 1; A1TS[rnd1] = TSC[1]; A1C[rnd1] = Counter[1];} ->  tau{OutvalueTS[1] = A0TS[rnd1]; OutvalueC[1] = A0C[rnd1];} ->\n    (if(OutvalueTS[1] == BOTTOM ) {\n        tau{Outcome[1] = SUCCESS;} -> Skip\n    } else {\n        tau{B1[rnd1] = DONE;} ->\n            (if(B0[rnd1] == BOTTOM) {\n                tau{Outcome[1] = UNKNOWN;} -> Skip\n             } else {\n                tau{Outcome[1] = SUCCESS;} -> Skip\n             })\n    });\n \n//process 1: wife\nCheck() = check_inv -> tau{TSL[0] = TS[0]; RelL[0] = Rel[0];} -> tau{TSL[1] = TS[1]; RelL[1] = Rel[1];} ->\n   (if(call(mailorder, TSL[0],  TSL[1])) {\n           (if(RelL[0] == EQ) {\n               check_resf -> Check()\n           } else {\n               check_rest -> Remove()\n           }) \n    } else {\n           (if(RelL[1] == EQ) {\n               check_resf -> Check()\n           } else {\n               check_rest -> Remove()\n           })\n    }); \n  \nRemove() = remove_inv -> tau{Counter[1] = Counter[1] + 1;} -> (Compare(1); remove_res -> Skip);\nWife(i) = [i < MaxROUND](Check();Wife(i+1));\nMailbox() = Postman(0) ||| Wife(0);\n \n////////////////The Abstract Specification Model////////////////// \nvar FlagL = 0;\nvar CountA = 0;\n \nPostmanAbs(i) =[i < MaxROUND]( deliver_inv -> deliver{CountA = CountA + 1;} -> deliver_res -> PostmanAbs(i+1));\n \nCheckAbs() = check_inv -> check{FlagL = CountA;} -> (if(FlagL > 0) {check_rest -> RemoveAbs()} else { check_resf -> CheckAbs() });\nRemoveAbs() = remove_inv -> remove{CountA = CountA - 1;} -> remove_res -> Skip;\nWifeAbs(i) = [i < MaxROUND] (CheckAbs();WifeAbs(i+1));\n \nMailboxAbs() = (PostmanAbs(0) ||| WifeAbs(0)) \\{deliver, check, remove};",
        "property_desc": [
            "Checks if the concrete Mailbox model refines the abstract Mailbox model",
            "Checks if the abstract Mailbox model refines the concrete Mailbox model"
        ],
        "properties": [
            "#assert Mailbox() refines MailboxAbs();",
            "#assert MailboxAbs() refines Mailbox();"
        ],
        "path": "pat_examples/csp_module/Linearizibility Examples/Mailbox Problem.csp"
    },
    {
        "name": "Multi-valued Register Simulation with Multiple Readers",
        "tags": [
            "Algorithm"
        ],
        "use_non_container_lib": false,
        "description": "This example describes how to simulate a K-valued single-writer multi-reader register from K binary single-writer multi-reader registers for K >2. \n  Each position in the register array is effectively a binary register. The index represents the \"value\" it is storing, and the value 0 or 1 represents whether that value is currently \"written\".\n  \n  The reader starts looking at the first position of the K registers and keeps going through the shared registers one by one to finds a register written with value 1.\n  It then proceeds to the scan backwards. In the backwards scanning, if it finds a register with value 1, it updates the value to be read to the index of this register. \n  When reaching the start of the K registers, the reader reports the read value.\n\n  The writer sets the binary register corresponding to the value 'i' of the K binary register to 1. Then it starts to loop through registres from position i-1 down to index 0, setting them to 0. This clears the old state of the register.",
        "content": "#define N 2;\n\n//shared binary array\nvar B = [0,0,1];\n//register value used by the abstract model\nvar R = 2;\n//temporary value for abstract reader to stored the value read from register\nvar M[N];\n\n////////////////The Concrete Implementation Model//////////////////\nReaders(id) = read_inv.id -> UpScan(0, id);\nUpScan(i, id) =  if(B[i] == 1) { DownScan(i - 1, i, id) } else { UpScan(i + 1, id) };\nDownScan(i, v, id) =\n\t\tif(i >= 0) {\n\t\t\tif(B[i] == 1) { DownScan(i - 1, i, id) } else { DownScan(i - 1, v, id) }\n\t\t} else {\n\t\t\tread_res.id.v -> Readers(id)\n\t\t};\n\nWriter(i) = write_inv.i -> tau{B[i] = 1;} -> WriterDownScan(i-1);\nWriterDownScan(i) = if(i >= 0 ) { tau{B[i] = 0;} -> WriterDownScan(i-1) } else { write_res -> Skip } ;\n\nWriters() = (Writer(0)[]Writer(1)[]Writer(2)); Writers();\nRegister() = (|||x:{0..N-1}@Readers(x)) ||| Writers();\n////////////////The Abstract Specification Model//////////////////\nReadersAbs(id) = read_inv.id -> tau{M[id]=R;} -> read_res.id.M[id] -> ReadersAbs(id);\n\nWriterAbs(i) = write_inv.i -> tau{R=i;} -> write_res -> Skip;\nWritersAbs() = (WriterAbs(0)[]WriterAbs(1)[]WriterAbs(2)); WritersAbs();\n\nRegisterAbs() = (|||x:{0..N-1}@ReadersAbs(x))||| WritersAbs();",
        "property_desc": [
            "Checks if the concrete Register model refines the abstract Register model",
            "Checks if the abstract Register model refines the concrete Register model",
            "The model is deadlock-free",
            "A process must eventually be able to read the data."
        ],
        "properties": [
            "#assert Register() refines RegisterAbs();",
            "#assert RegisterAbs() refines Register();",
            "#assert Register() deadlockfree;",
            "#assert Register() |= [](read_inv.0 -> <>(read_res.0.0 ||read_res.0.1 ||read_res.0.2));"
        ],
        "path": "pat_examples/csp_module/Linearizibility Examples/Multi-valued Register Simulation with Multiple Readers.csp"
    },
    {
        "name": "SNZI: Scalable NonZero Indicators",
        "tags": [
            "Algorithm"
        ],
        "use_non_container_lib": false,
        "description": "A SNZI object behaves similarly to traditional shared counter. It has one shared integer variable surplus and supports three operations: \nArrive increments surplus by 1 when a process enters; Depart decrements surplus by 1 when the process leaves; the only difference from \ntraditional counters is Query operation: it returns a boolean value indicating whether the value of surplus is greater than 0. We assume\nthat each Arrive operation is always followed by a Depart operation for the same process. Therefore surplus is always greater or equal to 0.\n  The authors propose a rooted tree as the underlying data structure of the SNZI objects implementation. An operation on a child node may \ninvoke operations on its parent. An important invariant is used to guarantee the correctness: the surplus of parent node is non-zero if \nand only if there exists at least one child whose surplus is non-zero. Thus, if the surplus of one node in the tree is non-zero, so does\nthe root. A process begins Arrive operation on any node as long as the corresponding Depart will be invoked at the same node, and Query \noperation is directly invoked on the root. Every tree node has a counter X that is increased by Arrive and decreased by Depart. Since \nthe operations on hierarchial nodes differ from those on root node, the algorithms are separated for hierarchical nodes and root node.\n  The operations for hierarchical SNZI nodes: \n  An Arrive operation on a hierarchial node invokes Arrive operation on its parent node when increasing X from 0 to 1. Otherwise, it \ncompletes without invoking any operation. Moreover, a process which increases X from 0 to 1 should firstly set X by an intermediate value 1/2. \nAny process which sees 1/2 must help that process to invoke parent. Arrive and try to change X to 1. If a process succeeds in invoking \nparent. Arrive but fails in setting X to 1, it will invoke a compensating parent.Depart.\n  Similarly, a Depart operation on a hierarchial node only invokes Depart on its parent node when decreasing X from 1 to 0. A version number \nis added to X to ensure that every change of X will be detected in both Arrive and Depart operations for hierarchial nodes as well as root node.\n  The operations for root node:\n  In order to reduce frequent accesses to X by Query, the solution for the root node separates out an indicator bit I from X. Hence every \nprocess can nish Query only by reading the bit I. The authors model all accesses to I using Read, Write, Load Linked and Store Conditional \nprimitives to tolerate spurious failures when external applications try to modify I.\n  I is set to true after a 0 to 1 transition of X, and it is unset to false after a 1 to 0 transition of X. Furthermore, an announce bit a \nis added to X to indicate that I needs to be set. Similar to the intermediate value 1/2, a process should set a during a 0 to 1 transition \nand clean it after setting I successfully. Any other process will also set I if it sees that a is set. Once the indicator is set, it can \nsafely clear a to prevent unnecessary future writes to the indicator.",
        "content": "//number of processes\n#define PRO_SIZE 2;\n\n// number of nodes\n#define NODE_SIZE 2;\n\n\n//------------------------------shared variable------------------------------\n//Since SNZI algorithm is organized as a rooted tree of SNZI objects, we create a NODE_SIZE array of Node objects.\n//The root is the first element of the array,  and for 0 < i < NODE_SIZE, the parent of the ith node is the (i-1)/2th node.\n\n//array of shared variables of nodes (including hierarchical and root nodes), \n//each nodes has its own local copy. so there are NODE_SIZE copies \nvar node_c[NODE_SIZE];  //the original X.c\nvar node_v[NODE_SIZE];  //the original X.v\n\n\nvar node_a = 0;    //the origina X.a for the root, i.e. the first element of the array\n\n//presence indicator\nvar I = 0;\n\n\n//------------------------------local variable------------------------------\n\n//array of local variables which are used in the corresponding operations of nodes when a process arrives at or departs from nodes, \n// i.e. representing x in the original algorithm\n//as there may be N processes visiting one node concurrently, there could be NODE_SIZE * PRO_SIZE local variables\n//this is a variant of 2-dimention array. for node i, the local variable of process j\n//can be calculated by (i * PRO_SIZE + j)\nvar cc[NODE_SIZE * PRO_SIZE];\nvar vv[NODE_SIZE * PRO_SIZE];\n\n//aa is the local variable of root node, so there will at most PRO_SIZE copies because only at most\n//PRO_SIZE processes can visit root node at the same time.\nvar aa[PRO_SIZE];\n\n\n\n//another local variables of root node, representing x' in the original algorithm\n//As above, only at most PRO_SIZE processes can visit the root node concurrently,\n//so each array contains PRO_SIZE elements.\nvar rootc[PRO_SIZE];\nvar roota[PRO_SIZE];\nvar rootv[PRO_SIZE];\n\n\n//other local variables of hierarchical SNZI node\n//for each such node, PRO_SIZE processes can visit it simultoneously, \n//so the total number of each local varaible should be NODE_SIZE * PRO_SIZE\nvar succ[NODE_SIZE * PRO_SIZE];    //the original succ in the Arrive operation \nvar undoArr[NODE_SIZE * PRO_SIZE]; //the original undoArr in the Arrive operation\n\n//for LL-SC primitive\nvar updateCounter;\nvar pro_counter[PRO_SIZE];\n\n\n//------------------------------The Concrete Implementation Model------------------------------\n//Single Entry of Arrival and Departure operations on any nodes\nArriveImpl(process, node) = arrive_inv.process -> ArriveGeneral(process,node); arrive_res.process -> Skip;\n\nDepartImpl(process, node) = depart_inv.process -> DepartGeneral(process,node);depart_res.process -> Skip;\n\nArriveGeneral(process, node) = ifa (node == 0) {ArriveRoot(process)} else { Arrive(process, node)};\n\nDepartGeneral(process,node) = ifa (node == 0) {DepartRoot(process)} else {Depart(process,node)};\n\n//------------------------------start - this part is for root node------------------------------\n//Arrival on root node\nArriveRoot(process) =  t {cc[process] = node_c[0]; aa[process] = node_a; vv[process] = node_v[0];} // x <- Read(X)\n\t\t\t\t\t  -> Repeat(process);Until(process);\n\nRepeat(process) = if (cc[process] == 0) \n\t\t\t\t {   // if x.c = 0 \n\t\t\t\t\t t {rootc[process] = 1; roota[process] = 1; rootv[process] = vv[process] + 1;} -> Skip //  x'<- (1, true, x.v + 1)\n\t\t\t\t }\t\t\n\t\t\t\telse \n\t\t\t\t{\n\t\t\t\t\t t {rootc[process] = cc[process] + 1; roota[process] = aa[process]; rootv[process] = vv[process];} -> Skip // x'<-(x.c+1, x.a, x.v)\n\t\t\t\t\t\n\t\t\t\t};\nUntil(process) = ifa (cc[process] == node_c[0]&& aa[process] == node_a && vv[process] == node_v[0])  //  until CAS(X, x, x')\n\t\t\t\t{           \n\t\t\t\t\tt {node_c[0] = rootc[process]; node_a = roota[process]; node_v[0] = rootv[process];} -> Write(process)   \n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tArriveRoot(process)\n\t\t\t\t};\n\nWrite(process) = if (roota[process] == 1) {// if x'.a then\n\t\t\t\t \tt {I = 1; updateCounter = updateCounter + 1;} -> CAS(process)   // Write(I, true)\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t Skip\n\t\t\t\t};\n\t\t\nCAS(process) = ifa (node_c[0] == rootc[process] && node_a == roota[process] && node_v[0] == rootv[process]) { //CAS(X,x',(x'.c, false, x'.v))\n\t\t\t\t\tt {node_c[0] = rootc[process]; node_a = 0; node_v[0] = rootv[process];} -> Skip\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSkip\n\t\t\t\t};\n\n\n//Departure from root node\nDepartRoot(process) =  t {cc[process] = node_c[0]; aa[process] = node_a; vv[process] = node_v[0];}-> line15(process);  \nline15(process) = ifa (cc[process] == node_c[0] && aa[process] == node_a && vv[process] == node_v[0]) //if CAS(X, x, (x.c - 1, false, x.v))\n\t\t\t\t  { \n\t\t\t\t\tt {node_c[0] = cc[process] - 1; node_a = 0; node_v[0] = vv[process];} -> l151(process)\n\t\t\t\t  }\n\t\t\t\telse { DepartRoot(process)};\n\t\t\t\t\nl151(process) = if (cc[process] > 1) {Skip}  \n \t\t\t\telse {DepartRootLoop(process) };\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\nDepartRootLoop(process) = t { pro_counter[process] = updateCounter;} // LL(I)\n\t\t\t\t\t\t-> \n\t\t\t\t\t\tif (vv[process] != node_v[0]) { Skip}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tifa ( pro_counter[process] != updateCounter) {t -> DepartRootLoop(process)}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t   t {I = 0; updateCounter = updateCounter + 1;} -> Skip\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t             ;\n//------------------------------end - this part is for root node------------------------------\n\n\t\t\n\t\t\n\t\t\n//------------------------------start - hierarchical SNZI node------------------------------\n//Arrival of hierarchical SNZI node\nArrive(process, node) = t {succ[node * PRO_SIZE + process] = 0;} \n\t\t\t\t\t\t-> t {undoArr[node * PRO_SIZE + process] = 0;} \n\t\t\t\t\t\t-> ArriveLoop1(process, node); ArriveLoop2(process, node); Skip;\n\nArriveLoop1(process, node) = if (succ[node * PRO_SIZE + process] == 0) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tt {cc[node * PRO_SIZE + process] = node_c[node]; vv[node * PRO_SIZE + process] = node_v[node];}\n\t\t\t\t\t\t\t\t-> \n\t\t\t\t\t\t\t\tArriveCase1(process, node)\n\t\t\t                }else {Skip};\n\t\t\t                \n //Because 1/2 cannot be expressed in pat, all values of x.c and X.c on hierarchical node will be twice as the original values.           \nArriveCase1(process, node) = if (cc[node * PRO_SIZE + process] > 1 ) { //if x.c >= 1 then\n\t\t\t\t\t\t\t l2(process, node);ArriveCase2(process, node)\n\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t else {\n\t\t\t\t\t\t\t    ArriveCase2(process, node)\n\t\t\t\t\t\t\t };\n\t\nl2(process, node) = ifa (cc[node * PRO_SIZE + process] == node_c[node] && vv[node * PRO_SIZE + process] == node_v[node]) { //if CAS(X, x, (x.c + 1, x.v)) then \n\t\t\t\t\t\tt {node_c[node] = cc[node * PRO_SIZE + process] + 2; node_v[node] = vv[node * PRO_SIZE + process];} \n\t\t\t\t\t\t-> \n\t\t\t\t\t\tt {succ[node * PRO_SIZE + process] = 1;} -> Skip\n\t\t\t\t\t}\n\t\t\t\t\telse { t -> Skip};\n\t\t\nArriveCase2(process, node) = if (cc[node * PRO_SIZE + process]== 0) { // if x.c = 0 then\n\t\t\t\t\t\t\t\tl3(process, node);ArriveCase3(process, node)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t  ArriveCase3(process, node)\n\t\t\t\t\t\t\t};\n\nl3(process, node) =  ifa (cc[node * PRO_SIZE + process] == node_c[node] && vv[node * PRO_SIZE + process] == node_v[node]) { // if CAS(X, x, (1 / 2, x.v + 1)) then\n\t\t\t\t\t\tt {node_c[node] = 1; node_v[node] = vv[node * PRO_SIZE + process] + 1;} \n\t\t\t\t\t\t-> \n\t\t\t\t\t\tt {succ[node * PRO_SIZE + process] = 1;}\n\t\t\t\t\t\t->\n\t\t\t\t\t\tt{cc[node * PRO_SIZE + process] = 1; vv[node * PRO_SIZE + process] = vv[node * PRO_SIZE + process] + 1;} \n\t\t\t\t\t\t-> Skip\n\t\t\t\t\t}\n\t\t\t\t\telse { t -> Skip};\n\n//if x.c = 1/2 then\nArriveCase3(process, node) = if (cc[node * PRO_SIZE + process] == 1) {  \n\t\t\t\t\t\t\t\tArriveGeneral(process, (node - 1)/2);l5(process,node)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t   ArriveLoop1(process, node)\n\t\t\t\t\t\t\t};\n\nl5(process, node) = ifa (cc[node * PRO_SIZE + process] == node_c[node] && vv[node * PRO_SIZE + process] == node_v[node]) {\n\t\t\t\t\t\tt{node_c[node] = 2; node_v[node] = vv[node * PRO_SIZE + process];} -> ArriveLoop1(process, node)\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tt -> t{undoArr[node * PRO_SIZE + process] = undoArr[node * PRO_SIZE + process] + 1;} -> ArriveLoop1(process, node)\n\t\t\t\t\t};\n\t\t \n\t \t\t \nArriveLoop2(process, node) = if (undoArr[node * PRO_SIZE + process] > 0) {\n\t\t\t\t\t\t\t    DepartGeneral(process, (node - 1)/2) ;\n\t\t\t\t\t\t\t\tt{undoArr[node * PRO_SIZE + process] = undoArr[node * PRO_SIZE + process] - 1;} \n\t\t\t\t\t\t\t\t->ArriveLoop2(process, node)\n\t\t\t\t\t\t\t}\n\t\t\t\t           else { Skip};\n\n//Departure of hierarchical SNZI node\nDepart(process, node) =  t {cc[node * PRO_SIZE + process] = node_c[node]; vv[node * PRO_SIZE + process] = node_v[node];} \n\t\t\t\t\t\t-> l8(process, node); Skip;\n\t\t\t\t\t\t\nl8(process, node) = ifa (cc[node * PRO_SIZE + process] == node_c[node] && vv[node * PRO_SIZE + process] == node_v[node]) { //if CAS(X, x, (x.c - 1, x.v)) then\n\t\t\t\t\t\tt{node_c[node] = cc[node * PRO_SIZE + process] - 2; node_v[node] = vv[node * PRO_SIZE + process];} \n\t\t\t\t\t\t-> \n\t\t\t\t\t\tl9(process, node)\n\t\t\t\t\t}\n\t\t\t\t\telse {t -> Depart(process, node)};\n\n// if x.c = 1 then call parent.Depart\t\t\nl9(process, node) = if (cc[node * PRO_SIZE + process] == 2) {\n\t\t\t\t\t\tDepartGeneral(process, (node - 1)/2); \t  Skip\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tSkip\n\t\t\t\t\t};\n//------------------------------end - hierarchical SNZI node------------------------------\n\n\t\t\n\t\t\nProcess(i, j) = [j <2]([] x:{0..NODE_SIZE - 1}@(ArriveImpl(i, x);DepartImpl(i, x));Process(i, j+1)); \n\nQuery() = query.I -> Query();\n\nSNZI() = (|||x:{0..PRO_SIZE - 1}@Process(x, 0)) \\{t} ||| Query();\n\n\n//------------------------------Abstract Specification Model------------------------------\n\n//shared variable\nvar surplus = 0;\nvar indicator = 0;\n\nArriveAbs(i) = arrive_inv.i -> t{surplus = surplus + 1; indicator = 1;}-> arrive_res.i -> Skip;\n\nDepartAbs(i) = depart_inv.i -> t{surplus = surplus - 1;\n\t\t\t\tif (surplus == 0) {indicator = 0;} }\n\t\t\t\t-> depart_res.i -> Skip; \n\nProcessAbs(i, j) = [j <2](ArriveAbs(i);DepartAbs(i);ProcessAbs(i, j+1));\n\nQueryAbs() = query.indicator -> QueryAbs();\n\nSNZIAbs() = (|||x:{0..PRO_SIZE-1}@ProcessAbs(x, 0)) \\ {t}||| QueryAbs();",
        "property_desc": [
            "Checks if the concrete SNZI model refines the abstract SNZI model",
            "Checks if the abstract SNZI model refines the concrete SNZI model"
        ],
        "properties": [
            "#assert SNZI() refines SNZIAbs();",
            "#assert SNZIAbs() refines SNZI();"
        ],
        "path": "pat_examples/csp_module/Linearizibility Examples/SNZI Scalable NonZero Indicators.csp"
    },
    {
        "name": "Java Meta-Lock",
        "tags": [
            "Algorithm"
        ],
        "use_non_container_lib": false,
        "description": "Metalocking is a highly-optimized technique for ensuring mutually exclusive access by threads to object monitor queues and, therefore; plays an essential role in allowing Java to offer concurrent access to objects. \n  Metalocking can be viewed as a two-tiered scheme. At the upper level, the metalock level, a thread waits until it can enqueue itself on an object's monitor queue in a mutually exclusive manner.",
        "content": "#define N 2; /* max num of threads that can wait at waiting state */\n\n/* msg */\n#define put_fast 100;\n#define get_fast 101;\n#define go 102;\n#define request 103;\n#define release 104;\n#define get_slow 105;\n#define put_slow 106;\n\nchannel ascChan 0;\nvar count =0;\nvar access = false;\n\nhandoff() = ascChan?release -> ascChan?request -> ascChan!go -> handoff()\n\t     [] ascChan?request -> ascChan?release -> ascChan!go -> handoff();\n\nshared_obj() = ascChan?get_fast -> Busy_0();\n\nBusy_0() = ascChan?put_fast -> shared_obj()\n    \t[] ascChan?get_slow -> inc{count = count+1;} -> Busy_N();\n\nBusy_N() = [count < N]ascChan?get_slow -> inc{count = count+1;} -> Busy_N()\n\t    [] ascChan?put_slow -> dec{count = count -1;} ->\n        \t(\n\t\t      if(count == 0){\n\t\t\t     Busy_0()\n\t\t      } else {\n\t\t\t     Busy_N()\n\t\t      }\n\t       );\n\t       \t       \n\nmy_thread() = ascChan!get_fast -> enterCritical{access = true;} ->Owner()\n\t       [] ascChan!get_slow -> ascChan!request -> ascChan?go -> enterCritical{access = true;} ->Owner();\n\nOwner() = leaveCritical{access = false;} ->\n          (\n\t\t       ascChan!put_fast -> my_thread()\n\t    \t[] ascChan!put_slow -> ascChan!release -> my_thread()\n\t      );\n\nSystem() = ((|||{..}@my_thread())||| handoff() ||| shared_obj());",
        "property_desc": [
            "The model is deadlock-free",
            "Eventually, some thread will gain access to the shared object"
        ],
        "properties": [
            "#assert System() deadlockfree;",
            "#define someoneaccess access == true;\n#assert System() |= []<>someoneaccess;"
        ],
        "path": "pat_examples/csp_module/Parameterized Systems/Java Meta-Lock.csp"
    },
    {
        "name": "Bridge Crossing Puzzle",
        "tags": [
            "Puzzle"
        ],
        "use_non_container_lib": false,
        "description": "All four people start out on the southern side of the bridge, namely the king, queen, a young lady and a knight. \n  The goal is for everyone to arrive at the castle north of the bridge before the time runs out. \n  The bridge can hold at most two people at a time and they must be carrying the torch when crossing the bridge. \n  The king needs 5 minutes to cross, the queen 10 minutes, the lady 2 minutes and the night 1 minutes.",
        "content": "#define Max 17;\n\n#define KNIGHT 1;\n#define LADY 2;\n#define KING 5;\n#define QUEEN 10;\n\nvar Knight = 0; \nvar Lady = 0; \nvar King = 0; \nvar Queen = 0; \nvar time; \n\nSouth() = [(time+LADY) <= Max && Knight == 0 && Lady == 0]go_knight_lady{Knight = 1; Lady= 1; time = time+LADY;} -> North()\n                 [] [(time+KING) <= Max && Knight == 0 && King == 0]go_knight_king{Knight = 1; King= 1; time = time+KING;} -> North()        \n                 [] [(time+QUEEN) <= Max && Knight == 0 && Queen == 0]go_knight_queen{Knight = 1; Queen= 1; time = time+QUEEN;} -> North()\n                 [] [(time+KING) <= Max && Lady == 0 && King == 0]go_lady_king{Lady = 1; King= 1; time = time+KING;} -> North()\n                 [] [(time+QUEEN) <= Max && Lady == 0 && Queen == 0]go_lady_queen{Lady = 1; Queen= 1; time = time+QUEEN;} -> North()\n                 [] [(time+QUEEN) <= Max && King == 0 && Queen == 0]go_king_queen{King = 1; Queen= 1; time = time+QUEEN;} -> North()\n                 [] [(time+KNIGHT) <= Max && Knight == 0]go_knight{Knight = 1; time = time+KNIGHT;} -> North()\n                 [] [(time+LADY) <= Max && Lady == 0]go_lady{Lady = 1; time = time+LADY;} -> North()\n                 [] [(time+KING) <= Max && King == 0]go_king{King = 1; time = time+KING;} -> North()\n                 [] [(time+QUEEN) <= Max && Queen == 0]go_queen{Queen = 1; time = time+QUEEN;} -> North();\n\nNorth() = [(time+LADY) <= Max && Knight == 1 && Lady == 1]back_knight_lady{Knight = 0; Lady = 0; time = time+LADY;} -> South()\n                [] [(time+KING) <= Max && Knight == 1 && King == 1]back_knight_king{Knight = 0; King = 0; time = time+KING;} -> South()\n                [] [(time+QUEEN) <= Max && Knight == 1 && Queen == 1]back_knight_queen{Knight = 0; Queen = 0; time = time+QUEEN;} -> South()\n                [] [(time+KING) <= Max && Lady == 1 && King == 1]back_lady_king{Lady = 0; King = 0; time = time+KING;} -> South()\n                [] [(time+QUEEN) <= Max && Lady == 1 && Queen == 1]back_lady_queen{Lady = 0; Queen = 0; time = time+QUEEN;} -> South()\n                [] [(time+QUEEN) <= Max && King == 1 && Queen == 1]back_king_queen{King = 0; Queen = 0; time = time+QUEEN;} -> South()\n                [] [(time+KNIGHT) <= Max && Knight == 1]back_knight{Knight = 0; time = time+KNIGHT;} -> South()\n                [] [(time+LADY) <= Max && Lady == 1]back_lady{Lady = 0; time = time+LADY;} -> South()\n                [] [(time+KING) <= Max && King == 1]back_king{King = 0; time = time+KING;} -> South()\n                [] [(time+QUEEN) <= Max && Queen == 1]back_queen{Queen = 0; time = time+QUEEN;} -> South();",
        "property_desc": [
            "The king, the queen, the young lady and the knight can cross the bridge within given time.",
            "If the time is unknow, we can ask for the minimum time needed to reach the goal.",
            "Alternative way to query the reachibility using LTL, PAT will recognize the safety LTL and turn it into reachibility test."
        ],
        "properties": [
            "#define goal (Knight==1 && Lady==1 && King==1 && Queen==1);\n#assert South() reaches goal;",
            "#assert South() reaches goal with min(time);",
            "#define alter ((Knight==1 && Lady==1 && King==1 && Queen==1 && time > Max) || !(Knight==1 && Lady==1 && King==1 && Queen==1));\n#assert South() |= [] alter;"
        ],
        "path": "pat_examples/csp_module/Puzzles/Bridge Crossing Problem.csp"
    },
    {
        "name": "Hua Rong Dao",
        "tags": [
            "Puzzle"
        ],
        "use_non_container_lib": false,
        "description": "Several different-sized block pieces are placed inside a box, which is normally 4\u00d75 in size. \n  Among the blocks, there is a special one (usually the largest) which must be moved to a special area designated by the game board. \n  The player is not allowed to remove blocks, and may only slide blocks horizontally and vertically. \n\n  The game goal is find a solution which is not required to have minimum number of steps .\n  This game huarongdao contains 4 bing (b1..b4), 5 jiang (j5..j9) and 1 caocao (cc),2 space(sp)\nnoted that enumerate data values are from 0 such that sp=0,b1=1 etc.That feature is used in this mode.",
        "content": "//j5:guanyu,j6:zhangfei,j7:zhaoyun,j8:machao,j9:huangzhongb1:bing,b2:ding,b3:zu,b4:yong\nenum {sp,b1,b2,b3,b4,j5,j6,j7,j8,j9,cc};\n\n//this array indicates jiang[i] is set either horizontally or vertically\n//1--vertical  0--horizontal 99-not used\nhvar jiang[11] = [99,99,99,99,99,1,1,1,1,1,99];\n\n//The board can be modified to check other stages and it is the only structure needed to change\n//one jiang occupys 2 position such that there are two j5.others are similar\n//99 is just a number which indicates the boundary. It can be changed to any number lager than 10\nhvar board[42] = [ 99,99,99,99,99,99,\n                   99,j7,j7,cc,cc,99,\n                   99,j8,j8,cc,cc,99,\n                   99,j6,j6,j5,j5,99,\n                   99,b1,b4,b2,j9,99,\n                   99,b3,sp,sp,j9,99,\n                   99,99,99,99,99,99 ];          \n                   \n\n//all moves are described in it\nvar seq[42] = [99(42)];\n\n//the two space position. Setting to 6 only for skip the Simluation(F6) checking \nhvar space1 = 6;\nhvar space2 = 6;\n\n//max steps which we allow PAT to try \n#define MAX_STEP 90;\n\n//standard game steps counter\nhvar counter=0;\nhvar last_move=0;\n\n#define UP 1;\n#define DOWN 2;\n#define LEFT 3;\n#define RIGHT 4;\n\nhvar last_direction = 0;\n\n//initialize the game\nInitial() = INIT{\n                    counter=0;\n                    last_move=0;\n\t                seq = board;\n\t                //set 7 to skip the boundary\n\t                var i = 7;\n\t                //initialize all jiang's placing directions(vertical or horizontal) and space positions\n\t                while(i<36)\n\t                {\n\t                \tif(seq[i]-seq[i-1]==0 && seq[i]!=cc && seq[i]!=sp && seq[i]!=99) jiang[seq[i]]=0;\n\t                \tif(seq[i]==sp)\n\t                \t{\n\t                \t    if(space1==6) space1 = i;\n\t                \t    else space2 = i;\n\t                \t}\n\t                    i++;                              \t\n\t                }\n                }->Skip;\n                \n\n//Bing's move\nBing(i) = [((seq[space1+6]==i) || (seq[space2+6]==i)) && !(last_move==i && last_direction==DOWN) && counter<=MAX_STEP]\n          bingup.i{\n                     if(seq[space1+6]==i)\n                     {seq[space1]=i;space1=space1+6;seq[space1]=sp}\n                     else\n                     {seq[space2]=i;space2=space2+6;seq[space2]=sp}\n                     if (last_move!=i) counter++;\n                     last_move=i;\n                     last_direction=UP;\n                   }->Bing(i)\n          []\n          [((seq[space1-6]==i) || (seq[space2-6]==i)) && !(last_move==i && last_direction==UP) && counter<=MAX_STEP]\n          bingdown.i{\n\t                    if(seq[space1-6]==i)\n\t                    {seq[space1]=i;space1=space1-6;seq[space1]=sp}\n\t                    else\n\t                    {seq[space2]=i;space2=space2-6;seq[space2]=sp}\n\t                    if (last_move!=i) counter++;\n                        last_move=i;\n                        last_direction=DOWN;\n\t                }->Bing(i)\n\t      []\n\t      [((seq[space1+1]==i) || (seq[space2+1]==i)) && !(last_move==i && last_direction==RIGHT) && counter<=MAX_STEP]\n\t      bingleft.i{\n\t                    if(seq[space1+1]==i)\n\t                    {seq[space1]=i;space1=space1+1;seq[space1]=sp}\n\t                    else\n\t                    {seq[space2]=i;space2=space2+1;seq[space2]=sp}\n\t                    if (last_move!=i) counter++;\n                        last_move=i;\n                        last_direction=LEFT;\n\t                }->Bing(i)\n\t      []\n\t      [((seq[space1-1]==i) || (seq[space2-1]==i)) && !(last_move==i && last_direction==LEFT) && counter<=MAX_STEP]\n\t      bingright.i{\n\t                     if(seq[space1-1]==i)\n\t                     {seq[space1]=i;space1=space1-1;seq[space1]=sp}\n\t                     else\n\t                     {seq[space2]=i;space2=space2-1;seq[space2]=sp}\n\t                     if (last_move!=i) counter++;\n                         last_move=i;\n                         last_direction=RIGHT;\n\t                 }->Bing(i);\n\n//Jiang's move\nJiang(i) = ifa(jiang[i]==0)\n           {\n           \t\t[seq[space1+6]==i && seq[space2+6]==i  && !(last_move==i && last_direction==DOWN) && counter<=MAX_STEP]\n           \t\tjiangup.i{\n           \t\t             seq[space1]=i;\n           \t\t             seq[space2]=i;\n           \t\t             space1=space1+6;\n           \t\t             space2=space2+6;\n           \t\t             seq[space1]=sp;\n           \t\t             seq[space2]=sp;\n           \t\t             if (last_move!=i) counter++;\n                             last_move=i;\n                             last_direction=UP;\n           \t\t         }->Jiang(i)\n           \t\t[]\n           \t\t[seq[space1-6]==i && seq[space2-6]==i && !(last_move==i && last_direction==UP) && counter<=MAX_STEP]\n           \t\tjiangdown.i{\n           \t\t               seq[space1]=i;\n           \t\t               seq[space2]=i;\n           \t\t               space1=space1-6;\n           \t\t               space2=space2-6;\n           \t\t               seq[space1]=sp;\n           \t\t               seq[space2]=sp;\n           \t\t               if (last_move!=i) counter++;\n                               last_move=i;\n                               last_direction=DOWN;\n           \t\t           }->Jiang(i)\t\n           \t\t[]\n           \t\t[((seq[space1+1]==i) || (seq[space2+1]==i)) && !(last_move==i && last_direction==RIGHT) && counter<=MAX_STEP]\n           \t\tjiangleft.i{\n           \t\t               if(seq[space1+1]==i)\n           \t\t               {seq[space1]=i;space1=space1+2;seq[space1]=sp}\n           \t\t               else\n           \t\t               {seq[space2]=i;space2=space2+2;seq[space2]=sp}\n           \t\t               if (last_move!=i) counter++;\n                               last_move=i;\n                               last_direction=LEFT;\n           \t\t           }->Jiang(i)\t\n           \t\t[]           \n           \t\t[((seq[space1-1]==i) || (seq[space2-1]==i)) && !(last_move==i && last_direction==LEFT) && counter<=MAX_STEP]\n           \t\tjiangright.i{\n           \t\t                if(seq[space1-1]==i)\n           \t\t                {seq[space1]=i;space1=space1-2;seq[space1]=sp}\n           \t\t                else\n           \t\t                {seq[space2]=i;space2=space2-2;seq[space2]=sp}\n           \t\t                if (last_move!=i) counter++;\n                                last_move=i;\n                                last_direction=RIGHT;\n           \t\t            }->Jiang(i)\n           }\n           else ifa(jiang[i]==1)\n           {\n                [((seq[space1+6]==i) || (seq[space2+6]==i)) && !(last_move==i && last_direction==DOWN) && counter<=MAX_STEP]\n                jiangup.i{\n                             if(seq[space1+6]==i)\n                             {seq[space1]=i;space1=space1+12;seq[space1]=sp}\n                             else\n                             {seq[space2]=i;space2=space2+12;seq[space2]=sp}\n                             if (last_move!=i) counter++;\n                             last_move=i;\n                             last_direction=UP;\n                         }->Jiang(i)\n                []\n                [((seq[space1-6]==i) || (seq[space2-6]==i)) && !(last_move==i && last_direction==UP)&& counter<=MAX_STEP]\n                jiangdown.i{\n                               if(seq[space1-6]==i)\n                               {seq[space1]=i;space1=space1-12;seq[space1]=sp}\n                               else\n                               {seq[space2]=i;space2=space2-12;seq[space2]=sp}\n                               if (last_move!=i) counter++;\n                               last_move=i;\n                               last_direction=DOWN;\n                           }->Jiang(i)\n                []\n                [seq[space1+1]==i && seq[space2+1]==i && !(last_move==i && last_direction==RIGHT) && counter<=MAX_STEP]\n                jiangleft.i{\n                               seq[space1]=i;\n           \t\t               seq[space2]=i;\n           \t\t               space1=space1+1;\n           \t\t               space2=space2+1;\n           \t\t               seq[space1]=sp;\n           \t\t               seq[space2]=sp;\n           \t\t               if (last_move!=i) counter++;\n                               last_move=i;\n                               last_direction=LEFT;\n           \t\t           }->Jiang(i)\t\n           \t\t[]\n           \t\t[seq[space1-1]==i && seq[space2-1]==i && !(last_move==i && last_direction==LEFT) && counter<=MAX_STEP]\n                jiangright.i{\n                                seq[space1]=i;\n           \t\t                seq[space2]=i;\n           \t\t                space1=space1-1;\n           \t\t                space2=space2-1;\n           \t\t                seq[space1]=sp;\n           \t\t                seq[space2]=sp;\n           \t\t                if (last_move!=i) counter++;\n                                last_move=i;\n                                last_direction=RIGHT;\n           \t\t            }->Jiang(i)\t\n           };\n\n//Caocao's move           \nCaocaoMove() = [seq[space1+6]==cc && seq[space2+6]==cc && !(last_move==cc && last_direction==DOWN) && counter<=MAX_STEP]\n           caocaoup{\n                       seq[space1]=cc;\n                       seq[space2]=cc;\n                       space1=space1+12;\n                       space2=space2+12;\n                       seq[space1]=sp;\n           \t\t       seq[space2]=sp;\n           \t\t       if (last_move!=cc) counter++;\n                       last_move=cc;\n                       last_direction=UP; \n                   }->CaocaoMove()\n           []\n           [seq[space1-6]==cc && seq[space2-6]==cc && !(last_move==cc && last_direction==UP) && counter<=MAX_STEP]\n           caocaodown{\n                         seq[space1]=cc;\n                         seq[space2]=cc;\n                         space1=space1-12;\n                         space2=space2-12;\n                         seq[space1]=sp;\n           \t\t         seq[space2]=sp;\n           \t\t         if (last_move!=cc) counter++;\n                         last_move=cc;\n                         last_direction=DOWN;\n                     }->CaocaoMove()\n           []\n           [seq[space1+1]==cc && seq[space2+1]==cc && !(last_move==cc && last_direction==RIGHT) && counter<=MAX_STEP]\n           caocaoleft{\n                         seq[space1]=cc;\n                         seq[space2]=cc;\n                         space1=space1+2;\n                         space2=space2+2;\n                         seq[space1]=sp;\n           \t\t         seq[space2]=sp;\n           \t\t         if (last_move!=cc) counter++;\n                         last_move=cc;\n                         last_direction=LEFT;\n                     }->CaocaoMove()\n           []\n           [seq[space1-1]==cc && seq[space2-1]==cc && !(last_move==cc && last_direction==LEFT) && counter<=MAX_STEP]\n           caocaoright{\n                          seq[space1]=cc;\n                          seq[space2]=cc;\n                          space1=space1-2;\n                          space2=space2-2;\n                          seq[space1]=sp;\n           \t\t          seq[space2]=sp;\n           \t\t          if (last_move!=cc) counter++;\n                          last_move=cc;\n                          last_direction=RIGHT;\n                      }->CaocaoMove();\n\n//10 entities synchronize                                        \nBingMove() = ||x:{b1..b4}@Bing(x);\nJiangMove() = ||x:{j5..j9}@Jiang(x);\nGame() = Initial();(BingMove()||JiangMove()||CaocaoMove());",
        "property_desc": [
            "Caocao arrives the exit and try to find out the best solution"
        ],
        "properties": [
            "#define goal (seq[26]==cc && seq[27]==cc && seq[32]==cc && seq[33]==cc);\n#assert Game() reaches goal with min(counter);"
        ],
        "path": "pat_examples/csp_module/Puzzles/Hua Rong Dao.csp"
    },
    {
        "name": "Knight Tour",
        "tags": [
            "Puzzle"
        ],
        "use_non_container_lib": false,
        "description": "The Knight's Tour is a mathematical problem involving a knight on a chessboard. \n  The knight is placed on the empty board and, moving according to the rules of chess, must visit each square exactly once. \n  A knight's tour is called a closed tour if the knight ends on a square attacking the square from which it began (so that it may tour the board again immediately with the same path). Otherwise the tour is open. \n  The exact number of open tours is still unknown. Creating a program to solve the knight's tour is a common problem given to computer science students.",
        "content": "#define N 5;\n\n//the board is a N*N matrix\nvar board[N*N];\nvar steps = 0;\n\n//there are 8 ways of jumping\n// 0 1\n//2   3\n//  k\n//4   5\n// 6 7 \nKnight(i, j) = [i-2 >= 0 && j-1 >=0] Move0(i,j)\t[]\n       \t       [i-2 >= 0 && j+1 < N] Move1(i,j)\t[]\n\t\t\t   [i-1 >= 0 && j-2 >=0] Move2(i,j) []\n\t\t\t   [i-1 >= 0 && j+2 < N] Move3(i,j) []\n\t\t\t   [i+1 < N && j-2 >=0] Move4(i,j)  []\n\t\t\t   [i+1 < N && j+2 < N] Move5(i,j)\t[]\n\t\t\t   [i+2 < N && j-1 >=0] Move6(i,j)\t[]\n\t\t\t   [i+2 < N && j+1 < N] Move7(i,j);\t\t\t   \n\n//each jump will update the board and counter\nMove0(i, j) = [board[(i-2)*N+j-1]==0]jump0{board[(i-2)*N+j-1]=1;steps++} -> Knight(i-2, j-1); \nMove1(i, j) = [board[(i-2)*N+j+1]==0]jump1{board[(i-2)*N+j+1]=1;steps++} -> Knight(i-2, j+1);\nMove2(i, j) = [board[(i-1)*N+j-2]==0]jump2{board[(i-1)*N+j-2]=1;steps++} -> Knight(i-1, j-2);\nMove3(i, j) = [board[(i-1)*N+j+2]==0]jump3{board[(i-1)*N+j+2]=1;steps++} -> Knight(i-1, j+2);\nMove4(i, j) = [board[(i+1)*N+j-2]==0]jump4{board[(i+1)*N+j-2]=1;steps++} -> Knight(i+1, j-2);\nMove5(i, j) = [board[(i+1)*N+j+2]==0]jump5{board[(i+1)*N+j+2]=1;steps++} -> Knight(i+1, j+2);\nMove6(i, j) = [board[(i+2)*N+j-1]==0]jump6{board[(i+2)*N+j-1]=1;steps++} -> Knight(i+2, j-1);\nMove7(i, j) = [board[(i+2)*N+j+1]==0]jump7{board[(i+2)*N+j+1]=1;steps++} -> Knight(i+2, j+1);\n\nGame(i, j) = start{board[i*N+j] = 1} -> Knight(i, j);\nGameInstance = Game(0,0);",
        "property_desc": [
            "If all squares on the board have been visited",
            "Another expression of the goal that all squares on the board have been visited"
        ],
        "properties": [
            "#define goal (board[0] == 1 && board[1] == 1 && board[2] == 1 && board[3] == 1 && board[4] == 1 && board[5] == 1 && board[6] == 1 && board[7] == 1 && board[8] == 1 && board[9] == 1 && board[10] == 1 && board[11] == 1 && board[12] == 1 && board[13] == 1 && board[14] == 1 && board[15] == 1 && board[16] == 1 && board[17] == 1 && board[18] == 1 && board[19] == 1 && board[20] == 1 && board[21] == 1 && board[22] == 1 && board[23] == 1 && board[24] == 1);\n#assert GameInstance reaches goal;",
            "#define altergoal steps == N*N-1;\n#assert GameInstance reaches altergoal;"
        ],
        "path": "pat_examples/csp_module/Puzzles/Knight Tour.csp"
    },
    {
        "name": "LightOff Game",
        "tags": [
            "Puzzle"
        ],
        "use_non_container_lib": false,
        "description": "The game consists of a 5 by 5 grid of lights. \n  When the game starts, a random number or a stored pattern of these lights is switched on. \n  Pressing any of the lights will toggle it and the adjacent lights. \n  The goal of the puzzle is to switch all the lights off, preferably with as few button presses as possible.",
        "content": "/*The following models the game LightOff (available for iPhone).*/\n/*The following is the drawing of the board settings.*/\n/////////////////////////// 0  1  2  3  4/////////////////////////\n/////////////////////////// 5  6  7  8  9/////////////////////////\n///////////////////////////10 11 12 13 14/////////////////////////\n///////////////////////////15 16 17 18 19/////////////////////////\n///////////////////////////20 21 22 23 24/////////////////////////\n\nvar a00 =  0; var a01 =  0; var a02 =  1; var a03 =  1; var a04 =  1;\nvar a05 =  0; var a06 =  1; var a07 =  1; var a08 =  0; var a09 =  1;\nvar a10 =  1; var a11 =  0; var a12 =  1; var a13 =  0; var a14 =  0;\nvar a15 =  0; var a16 =  0; var a17 =  1; var a18 =  0; var a19 =  0;\nvar a20 =  0; var a21 =  1; var a22 =  1; var a23 =  0; var a24 =  0;\n\nLightsOff() = click0{a00=1-a00;a01=1-a01;a05=1-a05;} -> LightsOff()\n\t\t\t[] click1{a00=1-a00;a01=1-a01;a02=1-a02;a06=1-a06;} -> LightsOff() \n\t\t\t[] click2{a01=1-a01;a02=1-a02;a03=1-a03;a07=1-a07;} -> LightsOff()\n\t\t\t[] click3{a02=1-a02;a03=1-a03;a04=1-a04;a08=1-a08;} -> LightsOff()\n\t\t\t[] click4{a03=1-a03;a04=1-a04;a09=1-a09;} -> LightsOff()\n\t\t\t[] click5{a00=1-a00;a05=1-a05;a06=1-a06;a10=1-a10;} -> LightsOff()\n\t\t\t[] click6{a01=1-a01;a05=1-a05;a06=1-a06;a07=1-a07;a11=1-a11;} -> LightsOff()\n\t\t\t[] click7{a02=1-a02;a06=1-a06;a07=1-a07;a08=1-a08;a12=1-a12;} -> LightsOff()\n\t\t\t[] click8{a03=1-a03;a07=1-a07;a08=1-a08;a09=1-a09;a13=1-a13;} -> LightsOff()\n\t\t\t[] click9{a04=1-a04;a08=1-a08;a09=1-a09;a14=1-a14;} -> LightsOff()\n\t\t\t[] click10{a05=1-a05;a10=1-a10;a11=1-a11;a15=1-a15;} -> LightsOff()\n\t\t\t[] click11{a06=1-a06;a10=1-a10;a11=1-a11;a12=1-a12;a16=1-a16;} -> LightsOff()\n\t\t\t[] click12{a07=1-a07;a11=1-a11;a12=1-a12;a13=1-a13;a17=1-a17;} -> LightsOff()\n\t\t\t[] click13{a08=1-a08;a12=1-a12;a13=1-a13;a14=1-a14;a18=1-a18;} -> LightsOff()\n\t\t\t[] click14{a09=1-a09;a13=1-a13;a14=1-a14;a19=1-a19;} ->  LightsOff()\n\t\t\t[] click15{a10=1-a10;a15=1-a15;a16=1-a16;a20=1-a20;} -> LightsOff()\n\t\t\t[] click16{a11=1-a11;a15=1-a15;a16=1-a16;a17=1-a17;a21=1-a21;} -> LightsOff()\n\t\t\t[] click17{a12=1-a12;a16=1-a16;a17=1-a17;a18=1-a18;a22=1-a22;} -> LightsOff()\n\t\t\t[] click18{a13=1-a13;a17=1-a17;a18=1-a18;a19=1-a19;a23=1-a23;} -> LightsOff()\n\t\t\t[] click19{a14=1-a14;a18=1-a18;a19=1-a19;a24=1-a24;} -> LightsOff()\n\t\t\t[] click20{a15=1-a15;a20=1-a20;a21=1-a21;} -> LightsOff()\n\t\t\t[] click21{a16=1-a16;a20=1-a20;a21=1-a21;a22=1-a22;} -> LightsOff()\n\t\t\t[] click22{a17=1-a17;a21=1-a21;a22=1-a22;a23=1-a23;} -> LightsOff()\n\t\t\t[] click23{a18=1-a18;a22=1-a22;a23=1-a23;a24=1-a24;} -> LightsOff()\n\t\t\t[] click24{a19=1-a19;a23=1-a23;a24=1-a24;} -> LightsOff();",
        "property_desc": [
            "All lights are off"
        ],
        "properties": [
            "#define goal (a00+a01+a02+a03+a04+a05+a06+a07+a08+a09+a10+a11+a12+a13+a14+a15+a16+a17+a18+a19+a20+a21+a22+a23+a24==0);\n#assert LightsOff() reaches goal;"
        ],
        "path": "pat_examples/csp_module/Puzzles/LightOff Game.csp"
    },
    {
        "name": "Minesweeper Game",
        "tags": [
            "Puzzle"
        ],
        "use_non_container_lib": false,
        "description": "The Minesweeper is a fashionable and easy to learn computer game. The player is initially \npresented with a grid of undistinguished squares. Some randomly selected squares, unknown \nto the player, are designated to contain mines. The game is won when all mine-free squares are revealed. \n\n  The player can reveal a square by left-clicking it with a mouse. If a square containing a mine is revealed, \nthe player loses the game. Otherwise, a digit is revealed in the square, indicating the number of \nadjacent squares that contain mines. In typical implementations, if this number is zero then the square appears blank, \nand the surrounding squares are automatically also revealed. By using logic, the player can in many instances use this \ninformation to deduce that certain other squares are mine-free, in which case they may be safely revealed, or mine-filled, \nin which they can be marked by right-clicking the square and indicated by a flag graphic.",
        "content": "//The following are constants of the Minesweeper game\n#define Ro 4; // Number of Rows\n#define Co 4; // Number of Columns\n\n#define b -1; // Indicates a Mine\n#define s 0; // Indicates a blank Space\n\n#define close 9; // Square is closed\n#define open 8; // Square is open\n#define flag -9; // Square is flagged\n\nvar NumOfClick = 0; // The number of useful left-clicks.\nvar recursiveOrnot = false;\n//Click[Row][Column] records the state of the square.\n//   col number     :0 1 2 3 \nvar click[Ro][Co] = [close,close,close,close, //Row 0\n\t\t\t\t     close,close,close,close, //Row 1\n\t\t\t\t     close,close,close,close, //Row 2\n\t\t\t\t     close,close,close,close];//Row 3\n\n//board[Row][Column] indicates the cell is either a mine, a number or a blank square\n//   col number    :0 1 2 3 \nvar board[Ro][Co] = [1,b,2,1,\n                     1,1,2,b,\n                     1,1,1,1,\n                     b,1,s,s];\n\t\t\t\t\t \n//Game Initialization\nGame() = ([!goal_win && !goal_lose]([]x:{0..(Ro - 1)}@[]y:{0..(Co - 1)}@ Choice(x,y)))[]([goal_win || goal_lose]Skip);\nChoice(x,y)= [click[x][y]==close||click[x][y]==flag](([click[x][y]==close](IncreaseTurn(x,y)))[](RightClick(x,y);Game()));\nIncreaseTurn(x,y) = increase{NumOfClick++}->LeftClick(x,y); //Note: We only count the number of useful left-click (See Section 3.1.4).\n\n//If the square contains a mine or a number, leftclick just open this square. If the square is a blank square, leftclick will open this square and its neighbour squares recursively\nLeftClick(x,y) = if(board[x][y]==s && click[x][y]!=open && click[x][y]!=flag)\n{\n\tif(x == 0 && y == 0)\n\t{\n\t\tbubble{click[x][y]=open;recursiveOrnot = true}\n\t\t->LeftClick(x + 1,y) ;\n\t\t\tLeftClick(x + 1,y + 1) ; LeftClick(x,y + 1);changeVar{recursiveOrnot = false}->Game()\n\t}\n\telse if(x == 0 && y == (Co - 1)) \n\t{\n\t\tbubble{click[x][y]=open;recursiveOrnot = true}\n\t\t->LeftClick(x,y - 1) ; LeftClick(x + 1,y - 1) ; LeftClick(x + 1,y);changeVar{recursiveOrnot = false}->Game()\n\t}\n\telse if(x == (Ro - 1) && y == 0)\n\t{\n\t\tbubble{click[x][y]=open;recursiveOrnot = true}\n\t\t->LeftClick(x,y + 1) ; LeftClick(x - 1,y + 1) ; LeftClick(x - 1,y);changeVar{recursiveOrnot = false}->Game()\n\t}\n\telse if(x == (Ro - 1) && y == (Co - 1))\n\t{\n\t\tbubble{click[x][y]=open;recursiveOrnot = true}\n\t\t->LeftClick(x - 1,y - 1) ; LeftClick(x,y - 1) ;\n\t\t\tLeftClick(x - 1,y);changeVar{recursiveOrnot = false}->Game()\n\t}\n\telse if(x == 0)\n\t{\n\t\tbubble{click[x][y]=open;recursiveOrnot = true}\n\t\t->LeftClick(x,y - 1) ; LeftClick(x + 1,y - 1) ; LeftClick(x + 1,y) ;\n\t\t\tLeftClick(x + 1,y + 1) ; LeftClick(x,y + 1);changeVar{recursiveOrnot = false}->Game()\n\t}\n\telse if(y == 0)\n\t{\n\t\tbubble{click[x][y]=open;recursiveOrnot = true}\n\t\t->LeftClick(x + 1,y) ;\n\t\t\tLeftClick(x + 1,y + 1) ; LeftClick(x,y + 1) ; LeftClick(x - 1,y + 1) ; LeftClick(x - 1,y);changeVar{recursiveOrnot = false}->Game()\n\t}\n\telse if(x == (Ro - 1))\n\t{\n\t\tbubble{click[x][y]=open;recursiveOrnot = true}\n\t\t->LeftClick(x - 1,y - 1) ; LeftClick(x,y - 1) ;\n\t\t\tLeftClick(x,y + 1) ; LeftClick(x - 1,y + 1) ; LeftClick(x - 1,y);changeVar{recursiveOrnot = false}->Game()\n\t}\n\telse if(y == (Co - 1))\n\t{\n\t\tbubble{click[x][y]=open;recursiveOrnot = true}\n\t\t->LeftClick(x - 1,y - 1) ; LeftClick(x,y - 1) ; LeftClick(x + 1,y - 1) ; LeftClick(x + 1,y) ;\n\t\t\tLeftClick(x - 1,y);changeVar{recursiveOrnot = false}->Game()\n\t}\n\telse\n\t{\n\t\tbubble{click[x][y]=open;recursiveOrnot = true}\n\t\t->LeftClick(x - 1,y - 1) ; LeftClick(x,y - 1) ; LeftClick(x + 1,y - 1) ; LeftClick(x + 1,y) ;\n\t\t\tLeftClick(x + 1,y + 1) ; LeftClick(x,y + 1) ; LeftClick(x - 1,y + 1) ; LeftClick(x - 1,y);changeVar{recursiveOrnot = false}->Game()\n\t}\n}\nelse if (click[x][y]!=open && click[x][y]!=flag)\n{\n\tif (recursiveOrnot == false){penacell{click[x][y]=open}->Game()}\n\telse {penacell{click[x][y]=open}->Skip}\n}\nelse{\n\tSkip\n};\n\n//RightClick is used to either flag a square or unflag a square which has been flaged before \nRightClick(x,y) = [click[x][y]!=open && ( (x==0&&y==1) || (x==1&&y==3) || (x==3&&y==0)) ]flagacell{click[x][y]=click[x][y]*(-1)}->Skip;",
        "property_desc": [
            "(Winning)Game ends when all the squares that do not contain the mine are opened, and squares with mine are either closed or flagged.",
            "Winning the game with least number of steps required.",
            "(Losing)Game ends when any of the squares containing mines is opened.",
            "Losing the game with least number of steps required.",
            "The model is deadlock-free.",
            "The model is deterministic."
        ],
        "properties": [
            "#define goal_win (click[0][0] == open && (click[0][1] == close || click[0][1] == flag) && click[0][2] == open && click[0][3] == open && click[1][0] == open && click[1][1] == open && click[1][2] == open && (click[1][3] == close||click[1][3] == flag) && click[2][0] == open && click[2][1] == open && click[2][2] == open && click[2][3] == open && (click[3][0] == close||click[3][0] == flag)&& click[3][1] == open && click[3][2] == open && click[3][3] == open);\n#assert Game() reaches goal_win;",
            "#assert Game() reaches goal_win with min(NumOfClick);",
            "#define goal_lose (click[0][1]==open || click[1][3]==open || click[3][0]==open);\n#assert Game() reaches goal_lose;",
            "#assert Game() reaches goal_lose with min(NumOfClick);",
            "#assert Game() deadlockfree;",
            "#assert Game() deterministic;"
        ],
        "path": "pat_examples/csp_module/Puzzles/Minesweeper Game.csp"
    },
    {
        "name": "Missionaries and Cannibals Problem",
        "tags": [
            "Puzzle"
        ],
        "use_non_container_lib": false,
        "description": "In the missionaries and cannibals problem, three missionaries and three cannibals must cross a river \nusing a boat which can carry at most two people, under the constraint that, for both banks, \nif there are missionaries present on the bank, they cannot be outnumbered by cannibals (if they were, \nthe cannibals would eat the missionaries.) The boat cannot cross the river by itself with no people on board.\n- Start bank: A \n- Other bank: B\n  In this program, there are 2 variables: missionary and cannibal which store the number of missionaries and cannibals in the bank A.",
        "content": "//The number of Missionary or the number of Cannibal\n#define N 3;\n\n//the number of people that the boat can hold\n#define M 2;\n\nvar missionary=N;\nvar cannibal=N;\n\nCross()=[cannibal>=1 && (missionary==0 || missionary==N)]one_cannibal_cross{cannibal=cannibal-1;}->Return()\n     [] [cannibal>=2 && (missionary==0 || missionary==N)]two_cannibals_cross{cannibal=cannibal-2;}->Return()\n     [] [missionary-cannibal==1 || missionary==1]one_missionary_cross{missionary=missionary-1;}->Return()\n     [] [missionary-cannibal==2 || missionary==2]two_missionaries_cross{missionary=missionary-2;}->Return()\n     [] [cannibal>=1 && missionary>=1 && N-cannibal+1<=N-missionary+1]one_missionary_one_cannibal_cross{missionary=missionary-1;cannibal=cannibal-1;}->Return();\n\nReturn()= [cannibal<=N-1 &&(missionary==0||missionary==N) ]one_cannibal_return{cannibal=cannibal+1;}->Cross()\n     [] [cannibal<=N-2&&(missionary==0||missionary==N)]two_cannibals_return{cannibal=cannibal+2;}->Cross()\n     [] [missionary==N-1]one_missionary_return{missionary=missionary+1;}->Cross()\n     [] [missionary==N-2]two_missionaries_return{missionary=missionary+2;}->Cross()\n     [] [cannibal<=N-1 && missionary<=N-1]one_missionary_one_cannibal_return{missionary=missionary+1;cannibal=cannibal+1;}->Cross();",
        "property_desc": [
            "Allmissionaries and cannibals cross the river"
        ],
        "properties": [
            "#define goal (missionary==0 && cannibal==0);\n#assert Cross() reaches goal;"
        ],
        "path": "pat_examples/csp_module/Puzzles/Missionaries and Cannibals Problem.csp"
    },
    {
        "name": "Peg Game",
        "tags": [
            "Puzzle"
        ],
        "use_non_container_lib": false,
        "description": "Peg Game is a board game for one player involving movement of pegs on a board with holes. \n  Some sets use marbles in a board with indentations. The rule is to jump pegs by clicking and \n  dragging an adjoining peg to the open hole on the other side. Each time a peg is jumped, \n  it is automatically removed. You can only remove pegs by jumping them. \n  The best solution is with this peg in the center. In this example, we provide 9 different settings.",
        "content": "#define X -1;\n#define P 1;\n#define E 2;\n#define S 1; //sticky has the same value as P now.\n\n//===== Board 1 =========\n#define initEmptyX 3;\n#define initEmptyY 3;\n#define W 7;\n#define H 7;\nvar board[H][W] = \n\t\t  [X,X,P,P,P,X,X,\n           X,X,P,P,P,X,X,\n           S,S,P,P,P,P,P,\n           P,P,P,E,P,P,P,\n           S,S,P,P,P,P,P,\n           X,X,S,P,S,X,X,\n           X,X,S,P,S,X,X];\n    \nvar pegsCounter = 32;\n\n//four different ways of jumping\nUp(i, j) = [i-2>=0]([board[i-2][j]==E && board[i-1][j]== P]up{board[i-2][j] = P; board[i-1][j] = E; board[i][j] = E; pegsCounter--;} -> Game()); \nLeft(i, j) = [j-2>=0]([board[i][j-2]==E && board[i][j-1]== P]left{board[i][j-2] = P; board[i][j-1] = E; board[i][j] = E; pegsCounter--;} -> Game()); \nDown(i, j) = [i+2<H]([board[i+2][j] != X && board[i+2][j]==E && board[i+1][j]== P]down{board[i+2][j] = P; board[i+1][j] = E; board[i][j] = E; pegsCounter--;} -> Game());  \nRight(i, j) = [j+2<W]([board[i][j+2] != X && board[i][j+2]==E && board[i][j+1]== P]right{board[i][j+2] = P; board[i][j+1] = E; board[i][j] = E; pegsCounter--;} -> Game()); \n\n//if there is a peg in the cell, it makes four diffferent moves\nPeg(i,j) = [board[i][j]==P](Up(i,j) [] Left(i,j) [] Down(i,j) [] Right(i,j));\nGame() = []i:{0..H-1};j:{0..W-1}@ Peg(i,j);",
        "property_desc": [
            "Only one peg remains on the board and the peg is in the initial empty hole."
        ],
        "properties": [
            "#define goal pegsCounter == 1 && board[initEmptyX][initEmptyY] == P;\n#assert Game() reaches goal;"
        ],
        "path": "pat_examples/csp_module/Puzzles/Peg Game.csp"
    },
    {
        "name": "Rubik's Cube",
        "tags": [
            "Puzzle"
        ],
        "use_non_container_lib": false,
        "description": "The Rubik's Cube is a 3-D mechanical puzzle invented in 1974 by Hungarian sculptor and professor of architecture Ern\u0151 Rubik. \n  Originally called the \"Magic Cube\", the puzzle was licensed by Rubik to be sold by Ideal Toys in 1980 and \n  won the German Game of the Year special award for Best Puzzle that year. As of January 2009, 350 million cubes \n  have sold worldwide making it the world's top-selling puzzle game. It is widely considered to be the world's best-selling toy. \n\n  In a classic Rubik's Cube, each of the six faces is covered by 9 stickers, among six solid colours (traditionally white, \n  red, blue, orange, green, and yellow). A pivot mechanism enables each face to turn independently, thus mixing up the colours. \n  For the puzzle to be solved, each face must be a solid colour.\n\n  this model models the cubix \n/**************************************\n\t\t\t0\t1 \t2 \t \n\t\t\t3\t4 \t5 \t\n\t\t\t6\t7 \t8 \t\n9\t10 \t11 \t12\t13\t14\t15\t16\t17\t\n18\t19 \t20 \t21\t22\t23\t24\t25\t26\t\n27\t28 \t29 \t30\t31\t32\t33\t34\t35\t\n\t\t\t36\t37 \t38  \n\t\t\t39\t40 \t41\n\t\t\t42\t43 \t44\n\t\t\t45\t46 \t47 \t\t\t\t\t51\t52\t53\n\t\t\t48\t49 \t50\t\t\t\t\t48\t49\t50\n\t\t\t51\t52 \t53\t\t\t\t\t45\t46\t47\n**************************************",
        "content": "#define white 1;\n#define yellow 2;\n#define red 3;\n#define blue 4;\n#define green 5;\n#define orange 6;\n\n//this model models the initial configuration \nvar Cubix = [\t\t\tblue, \tyellow, blue, \n\t\t\t\t\t\tgreen, \tgreen, \tgreen,\n\t\t\t\t\t\tred, \tyellow, yellow,\nred, \tblue, \tgreen,\twhite,\tred,\torange,\tblue,\torange,\torange,\nblue, \tblue, \tblue,\torange,\torange,\twhite,\torange,\twhite,\tred,\norange, blue, \twhite,\torange,\twhite,\tred,\tyellow,\tred,\torange,\n\t\t\t\t\t\tgreen, \tgreen, \twhite, \n\t\t\t\t\t\tyellow, yellow, white,\n\t\t\t\t\t\twhite, \tyellow, blue,\n\t\t\t\t\t\tyellow, white, \tred, \n\t\t\t\t\t\tred, \tred, \tgreen,\n\t\t\t\t\t\tgreen, \torange, green];\nvar CubixPrime = [\t\tblue, \tyellow, blue, \n\t\t\t\t\t\tgreen, \tgreen, \tgreen,\n\t\t\t\t\t\tred, \tyellow, yellow,\nred, \tblue, \tgreen,\twhite,\tred,\torange,\tblue,\torange,\torange,\nblue, \tblue, \tblue,\torange,\torange,\twhite,\torange,\twhite,\tred,\norange, blue, \twhite,\torange,\twhite,\tred,\tyellow,\tred,\torange,\n\t\t\t\t\t\tgreen, \tgreen, \twhite, \n\t\t\t\t\t\tyellow, yellow, white,\n\t\t\t\t\t\twhite, \tyellow, blue,\n\t\t\t\t\t\tyellow, white, \tred, \n\t\t\t\t\t\tred, \tred, \tgreen,\n\t\t\t\t\t\tgreen, \torange, green];\n\nLeftTop() = turn_top_row_left{\n\t\t\t\t//the top face\n\t\t\t\tCubixPrime[0] = Cubix[6]; CubixPrime[1] = Cubix[3];\tCubixPrime[2] = Cubix[0];\n\t\t\t\tCubixPrime[3] = Cubix[7]; CubixPrime[5] = Cubix[1]; CubixPrime[6] = Cubix[8];\n\t\t\t\tCubixPrime[7] = Cubix[5]; CubixPrime[8] = Cubix[2];\n\t\t\t\t//the side face\n\t\t\t\tCubixPrime[9] = Cubix[12]; CubixPrime[10] = Cubix[13];\n\t\t\t\tCubixPrime[11] = Cubix[14]; CubixPrime[12] = Cubix[15];\n\t\t\t\tCubixPrime[13] = Cubix[16]; CubixPrime[14] = Cubix[17];\n\t\t\t\tCubixPrime[15] = Cubix[53]; CubixPrime[16] = Cubix[52];\n\t\t\t\tCubixPrime[17] = Cubix[51]; CubixPrime[51] = Cubix[11];\n\t\t\t\tCubixPrime[52] = Cubix[10]; CubixPrime[53] = Cubix[9];\n\t\t\t\tCubix = CubixPrime;\n\t\t\t} -> Game();\nLeftMiddle() = turn_middle_row_left{\n\t\t\t\t//the side face\n\t\t\t\tCubixPrime[18] = Cubix[21]; CubixPrime[19] = Cubix[22];\n\t\t\t\tCubixPrime[20] = Cubix[23]; CubixPrime[21] = Cubix[24];\n\t\t\t\tCubixPrime[22] = Cubix[25]; CubixPrime[23] = Cubix[26];\n\t\t\t\tCubixPrime[24] = Cubix[50]; CubixPrime[25] = Cubix[49];\n\t\t\t\tCubixPrime[26] = Cubix[48]; CubixPrime[48] = Cubix[20];\n\t\t\t\tCubixPrime[49] = Cubix[19]; CubixPrime[50] = Cubix[18];\n\t\t\t\tCubix = CubixPrime;\n\t\t\t} -> Game();\n\nLeftBottom() = turn_bottom_row_left{\n\t\t\t\t//the bottom face\n\t\t\t\tCubixPrime[36] = Cubix[38]; CubixPrime[37] = Cubix[41];\tCubixPrime[38] = Cubix[44];\n\t\t\t\tCubixPrime[39] = Cubix[37]; CubixPrime[41] = Cubix[43]; CubixPrime[42] = Cubix[36];\n\t\t\t\tCubixPrime[43] = Cubix[39]; CubixPrime[44] = Cubix[42];\n\t\t\t\t//the side face\n\t\t\t\tCubixPrime[27] = Cubix[30]; CubixPrime[28] = Cubix[31];\n\t\t\t\tCubixPrime[29] = Cubix[32]; CubixPrime[30] = Cubix[33];\n\t\t\t\tCubixPrime[31] = Cubix[34]; CubixPrime[32] = Cubix[35];\n\t\t\t\tCubixPrime[33] = Cubix[47]; CubixPrime[34] = Cubix[46];\n\t\t\t\tCubixPrime[35] = Cubix[45]; CubixPrime[45] = Cubix[29];\n\t\t\t\tCubixPrime[46] = Cubix[28]; CubixPrime[47] = Cubix[27];\n\t\t\t\tCubix = CubixPrime;\n\t\t\t} -> Game();\n\nLeftUp() = turn_left_column_up{\n\t\t\t\t//the side face\n\t\t\t\tCubixPrime[9] = Cubix[11]; CubixPrime[10] = Cubix[20];\tCubixPrime[11] = Cubix[29];\n\t\t\t\tCubixPrime[18] = Cubix[10]; CubixPrime[20] = Cubix[28]; CubixPrime[27] = Cubix[9];\n\t\t\t\tCubixPrime[28] = Cubix[18]; CubixPrime[29] = Cubix[27];\n\t\t\t\t//the side face\n\t\t\t\tCubixPrime[0] = Cubix[12]; CubixPrime[3] = Cubix[21];\n\t\t\t\tCubixPrime[6] = Cubix[30]; CubixPrime[12] = Cubix[36];\n\t\t\t\tCubixPrime[21] = Cubix[39]; CubixPrime[30] = Cubix[42];\n\t\t\t\tCubixPrime[36] = Cubix[45]; CubixPrime[39] = Cubix[48];\n\t\t\t\tCubixPrime[42] = Cubix[51]; CubixPrime[45] = Cubix[0];\n\t\t\t\tCubixPrime[48] = Cubix[3]; CubixPrime[51] = Cubix[6];\n\t\t\t\tCubix = CubixPrime;\n\t\t\t} -> Game();\n\nMiddleUp() = turn_middle_column_up{\n\t\t\t\t//the side face\n\t\t\t\tCubixPrime[1] = Cubix[13]; CubixPrime[4] = Cubix[22];\n\t\t\t\tCubixPrime[7] = Cubix[31]; CubixPrime[13] = Cubix[37];\n\t\t\t\tCubixPrime[22] = Cubix[40]; CubixPrime[31] = Cubix[43];\n\t\t\t\tCubixPrime[37] = Cubix[46]; CubixPrime[40] = Cubix[49];\n\t\t\t\tCubixPrime[43] = Cubix[52]; CubixPrime[46] = Cubix[1];\n\t\t\t\tCubixPrime[49] = Cubix[4]; CubixPrime[52] = Cubix[7];\n\t\t\t\tCubix = CubixPrime;\n\t\t\t} -> Game();\n\nRightUp() = turn_right_column_up{\n\t\t\t\t//the side face\n\t\t\t\tCubixPrime[15] = Cubix[33]; CubixPrime[16] = Cubix[24];\tCubixPrime[17] = Cubix[15];\n\t\t\t\tCubixPrime[24] = Cubix[34]; CubixPrime[26] = Cubix[16]; CubixPrime[33] = Cubix[35];\n\t\t\t\tCubixPrime[34] = Cubix[26]; CubixPrime[35] = Cubix[17];\n\t\t\t\t//the side face\n\t\t\t\tCubixPrime[2] = Cubix[14]; CubixPrime[5] = Cubix[23];\n\t\t\t\tCubixPrime[8] = Cubix[32]; CubixPrime[14] = Cubix[38];\n\t\t\t\tCubixPrime[23] = Cubix[41]; CubixPrime[32] = Cubix[44];\n\t\t\t\tCubixPrime[38] = Cubix[47]; CubixPrime[41] = Cubix[50];\n\t\t\t\tCubixPrime[44] = Cubix[53]; CubixPrime[47] = Cubix[2];\n\t\t\t\tCubixPrime[50] = Cubix[5]; CubixPrime[53] = Cubix[8];\n\t\t\t\tCubix = CubixPrime;\n\t\t\t} -> Game();\n\nLeftBack() = turn_back_left{\n\t\t\t\t//the bottom face\n\t\t\t\tCubixPrime[51] = Cubix[53]; CubixPrime[52] = Cubix[50];\tCubixPrime[53] = Cubix[47];\n\t\t\t\tCubixPrime[48] = Cubix[52]; CubixPrime[50] = Cubix[46]; CubixPrime[45] = Cubix[51];\n\t\t\t\tCubixPrime[46] = Cubix[48]; CubixPrime[47] = Cubix[45];\n\t\t\t\t//the side face\n\t\t\t\tCubixPrime[0] = Cubix[17]; CubixPrime[1] = Cubix[26];\n\t\t\t\tCubixPrime[2] = Cubix[35]; CubixPrime[17] = Cubix[44];\n\t\t\t\tCubixPrime[26] = Cubix[43]; CubixPrime[35] = Cubix[42];\n\t\t\t\tCubixPrime[44] = Cubix[27]; CubixPrime[43] = Cubix[18];\n\t\t\t\tCubixPrime[42] = Cubix[9]; CubixPrime[27] = Cubix[0];\n\t\t\t\tCubixPrime[18] = Cubix[1]; CubixPrime[9] = Cubix[2];\n\t\t\t\tCubix = CubixPrime;\n\t\t\t} -> Game();\n\nLeftMiddleBack() = turn_middle_back_left{\n\t\t\t\t//the side face\n\t\t\t\tCubixPrime[3] = Cubix[16]; CubixPrime[4] = Cubix[25];\n\t\t\t\tCubixPrime[5] = Cubix[34]; CubixPrime[16] = Cubix[41];\n\t\t\t\tCubixPrime[25] = Cubix[40]; CubixPrime[34] = Cubix[39];\n\t\t\t\tCubixPrime[41] = Cubix[28]; CubixPrime[40] = Cubix[19];\n\t\t\t\tCubixPrime[39] = Cubix[10]; CubixPrime[28] = Cubix[3];\n\t\t\t\tCubixPrime[19] = Cubix[4]; CubixPrime[10] = Cubix[5];\n\t\t\t\tCubix = CubixPrime;\n\t\t\t} -> Game();\n\nLeftFrontBack() = turn_front_back_left{\n\t\t\t\t//the front face\n\t\t\t\tCubixPrime[12] = Cubix[14]; CubixPrime[13] = Cubix[23];\tCubixPrime[14] = Cubix[32];\n\t\t\t\tCubixPrime[21] = Cubix[13]; CubixPrime[23] = Cubix[31]; CubixPrime[30] = Cubix[12];\n\t\t\t\tCubixPrime[31] = Cubix[21]; CubixPrime[32] = Cubix[30];\n\t\t\t\t//the side face\n\t\t\t\tCubixPrime[6] = Cubix[15]; CubixPrime[7] = Cubix[24];\n\t\t\t\tCubixPrime[8] = Cubix[33]; CubixPrime[15] = Cubix[38];\n\t\t\t\tCubixPrime[24] = Cubix[37]; CubixPrime[33] = Cubix[36];\n\t\t\t\tCubixPrime[38] = Cubix[29]; CubixPrime[37] = Cubix[20];\n\t\t\t\tCubixPrime[36] = Cubix[11]; CubixPrime[29] = Cubix[6];\n\t\t\t\tCubixPrime[20] = Cubix[7]; CubixPrime[11] = Cubix[8];\n\t\t\t\tCubix = CubixPrime;\n\t\t\t} -> Game();\n\nGame() = LeftTop() [] \n\t\tLeftMiddle() []\n\t\tLeftBottom() []\n\t\tLeftUp() []\n\t\tMiddleUp() []\n\t\tRightUp() []\n\t\tLeftBack() []\n\t\tLeftMiddleBack() []\n\t\tLeftFrontBack();",
        "property_desc": [
            "Each face must be a solid colour",
            "The center of one face of a Rubik's Cube is different from the center of the other faces."
        ],
        "properties": [
            "#define goal Cubix[0] == Cubix[1] && Cubix[1] == Cubix[2] && Cubix[2] == Cubix[3] && \n\t\t\t Cubix[3] == Cubix[4] && Cubix[4] == Cubix[5] && Cubix[5] == Cubix[6] &&   \n\t\t\t Cubix[6] == Cubix[7] && Cubix[7] == Cubix[8] &&   \n\t\t\t Cubix[9] == Cubix[10] && Cubix[10] == Cubix[11] && Cubix[11] == Cubix[18] && \n\t\t\t Cubix[18] == Cubix[19] && Cubix[19] == Cubix[20] && Cubix[20] == Cubix[27] &&   \n\t\t\t Cubix[27] == Cubix[28] && Cubix[28] == Cubix[29] &&\t\t\t \n\t\t\t Cubix[12] == Cubix[13] && Cubix[13] == Cubix[14] && Cubix[14] == Cubix[21] && \n\t\t\t Cubix[21] == Cubix[22] && Cubix[22] == Cubix[23] && Cubix[23] == Cubix[30] &&   \n\t\t\t Cubix[30] == Cubix[31] && Cubix[31] == Cubix[32] &&\t\t\t \n\t\t\t Cubix[15] == Cubix[16] && Cubix[16] == Cubix[17] && Cubix[17] == Cubix[24] && \n\t\t\t Cubix[24] == Cubix[25] && Cubix[25] == Cubix[26] && Cubix[26] == Cubix[33] &&   \n\t\t\t Cubix[33] == Cubix[34] && Cubix[34] == Cubix[35] &&\t\t\t \n\t\t\t Cubix[36] == Cubix[37] && Cubix[37] == Cubix[38] && Cubix[38] == Cubix[39] && \n\t\t\t Cubix[39] == Cubix[40] && Cubix[40] == Cubix[41] && Cubix[41] == Cubix[42] &&   \n\t\t\t Cubix[42] == Cubix[43] && Cubix[43] == Cubix[44] &&\t\t\t \n\t\t\t Cubix[45] == Cubix[46] && Cubix[46] == Cubix[47] && Cubix[47] == Cubix[48] && \n\t\t\t Cubix[48] == Cubix[49] && Cubix[49] == Cubix[50] && Cubix[50] == Cubix[51] &&   \n\t\t\t Cubix[51] == Cubix[52] && Cubix[52] == Cubix[53];\n#assert Game() reaches goal;",
            "#define check Cubix[4] != Cubix[19];\n#assert Game() |= [] check;"
        ],
        "path": "pat_examples/csp_module/Puzzles/Rubik's Cube.csp"
    },
    {
        "name": "Shunting Game",
        "tags": [
            "Puzzle"
        ],
        "use_non_container_lib": false,
        "description": "Shunting game has a board with one black piece (the shunter), n white piece and n cells marked with cross. \n  The goal of the shunting game is to move the shunter to push the white piece around until all white pieces \n  are in cells marks with cross. A move consists of black piece (the shunter) moving one position either \n  vertically or horizontally provided either\n  1) the position moved to is empty\n  2) the position moved to is occupied by a white piece but the position beyond the white piece is empty, in which case the white piece id pushed into the empty position. \n  The shunter can not push two white pieces at the same time.",
        "content": "//The following are constants of the shunting game; They are defined only for readability.\n#define M 7;\n#define N 6;\n#define o -1;\n#define a 1;\n#define w 0;\n\n//The following are variables of the system, which constitute the state space.\n//The initial valuation of the variables corresponds to the initial schema.\n//Note that top left position is [0][0], while bottom right position is [5],[6]\n//which is different from the Z model in NUS-CS4211/5232.\n//The state invariants in Z model will be guaranteed by the operations.\n//\n//    col number:  0 1 2 3 4 5 6\nvar board[N][M] = [o,o,a,a,o,o,o, //0 row number starting from 0\n                  o,o,a,a,o,o,o, //1\n                  a,a,a,w,a,a,a, //2\n                  a,w,a,a,a,w,a, //3\n                  o,o,a,w,o,o,o, //4\n                  o,o,a,a,o,o,o];//5\n// Black position:\nvar r:{0..N-1} = 3; //row\nvar c:{0..M-1} = 0; //column\n\nGame = [r-1>=0]MoveUp [] [r-2>=0]PushUp\n          [] [r+1<N]MoveDown [] [r+2<N]PushDown\n          [] [c-1>=0]MoveLeft [] [c-2>=0]PushLeft\n          [] [c+1<M]MoveRight [] [c+2<M]PushRight;\n\nMoveUp = [board[r-1][c]==a]go_up{r=r-1} -> Game;\nPushUp = [board[r-2][c]==a && board[r-1][c]==w] push_up{board[r-2][c]=w;board[r-1][c]=a;r=r-1;} -> Game;\n\nMoveDown = [board[r+1][c]==a]go_down{r=r+1} -> Game;\nPushDown = [board[r+2][c]==a && board[r+1][c]==w] push_down{board[r+2][c]=w;board[r+1][c]=a;r=r+1;} -> Game;\n\nMoveLeft = [board[r][c-1]==a]go_left{c=c-1} -> Game;\nPushLeft = [board[r][c-2]==a && board[r][c-1]==w] push_left{board[r][c-2]=w;board[r][c-1]=a;c=c-1;} -> Game;\n\nMoveRight = [board[r][c+1]==a]go_right{c=c+1} -> Game;\nPushRight = [board[r][c+2]==a && board[r][c+1]==w] push_right{board[r][c+2]=w;board[r][c+1]=a;c=c+1;} -> Game;",
        "property_desc": [
            "The Game reaches one particular potential trouble position",
            "Testing if a white can be pushed to ourside",
            "All white pieces are in cells marks with cross",
            "The trouble position will prevent the goal",
            "Testing the impossible"
        ],
        "properties": [
            "#define trouble board[0][3] == w;\n#assert Game reaches trouble;",
            "#define outside board[4][1] == w;\n#assert Game reaches outside;",
            "#define goal board[2][2] == w && board[2][3] == w && board[3][2] == w && board[3][3] == w;\n#assert Game reaches goal;",
            "#assert Game |= [] (trouble -> !<> goal);",
            "#assert Game |= [] (trouble -> <> goal);"
        ],
        "path": "pat_examples/csp_module/Puzzles/Shunting Game.csp"
    },
    {
        "name": "Sieve Of Eratosthenes",
        "tags": [
            "Puzzle"
        ],
        "use_non_container_lib": false,
        "description": "In mathematics, the Sieve of Eratosthenes is a simple, ancient algorithm for finding all prime numbers \n  up to a specified integer. It was created by Eratosthenes, an ancient Greek mathematician. \n  Wheel factorization is often applied on the list of integers to be checked for primality, \n  before the Sieve of Eratosthenes is used, to increase the speed. By Wikipedia.",
        "content": "#define N 100;\n#define SqrtOfN 10;\nvar i=2;\nvar j=2;\nvar k=2;\n\n//care the numbers from 2 to N\n//0 means not sieved, also prime\n//1 means already sieved, not prime\nvar sievePrime[N+1];\n\nP()= if(i<=SqrtOfN)\n\t {\n\t \t Q()\n\t }\n\t else\n\t {\n\t \tStop\n\t };\n\t \nQ()=if(sievePrime[i]==0)\n\t{\n\t\tadd{j=i;k=i+j;}->Sieve()\n\t}\n\telse\n\t{\n\t\tnext{i=i+1;}->P()\n\t};\n\t\nSieve()=if(k<=N)\n\t\t{\n\t\t\tsieve{sievePrime[k]=1;k=k+j;}->Sieve()\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnext{i=i+1;}->P()\t\t\t\t\t\t\n\t\t};",
        "property_desc": [
            "It can identify prime and non-prime numbers up to N"
        ],
        "properties": [
            "#define goal (i==SqrtOfN+1&&sievePrime[2]==0&&sievePrime[3]==0&&sievePrime[4]==1&&sievePrime[5]==0&&sievePrime[6]==1&&sievePrime[7]==0&&sievePrime[8]==1&&sievePrime[9]==1&&sievePrime[10]==1&&sievePrime[11]==0&&sievePrime[12]==1&&sievePrime[13]==0&&sievePrime[14]==1&&sievePrime[15]==1&&sievePrime[16]==1&&sievePrime[17]==0&&sievePrime[18]==1&&sievePrime[19]==0&&sievePrime[20]==1&&sievePrime[21]==1&&sievePrime[22]==1&&sievePrime[23]==0&&sievePrime[24]==1&&sievePrime[25]==1&&sievePrime[26]==1&&sievePrime[27]==1&&sievePrime[28]==1&&sievePrime[29]==0&&sievePrime[30]==1&&sievePrime[31]==0&&sievePrime[32]==1&&sievePrime[33]==1&&sievePrime[34]==1&&sievePrime[35]==1&&sievePrime[36]==1&&sievePrime[37]==0&&sievePrime[38]==1&&sievePrime[39]==1&&sievePrime[40]==1&&sievePrime[41]==0&&sievePrime[42]==1&&sievePrime[43]==0&&sievePrime[44]==1&&sievePrime[45]==1&&sievePrime[46]==1&&sievePrime[47]==0&&sievePrime[48]==1&&sievePrime[49]==1&&sievePrime[50]==1&&sievePrime[51]==1&&sievePrime[52]==1&&sievePrime[53]==0&&sievePrime[54]==1&&sievePrime[55]==1&&sievePrime[56]==1&&sievePrime[57]==1&&sievePrime[58]==1&&sievePrime[59]==0&&sievePrime[60]==1&&sievePrime[61]==0&&sievePrime[62]==1&&sievePrime[63]==1&&sievePrime[64]==1&&sievePrime[65]==1&&sievePrime[66]==1&&sievePrime[67]==0&&sievePrime[68]==1&&sievePrime[69]==1&&sievePrime[70]==1&&sievePrime[71]==0&&sievePrime[72]==1&&sievePrime[73]==0&&sievePrime[74]==1&&sievePrime[75]==1&&sievePrime[76]==1&&sievePrime[77]==1&&sievePrime[78]==1&&sievePrime[79]==0&&sievePrime[80]==1&&sievePrime[81]==1&&sievePrime[82]==1&&sievePrime[83]==0&&sievePrime[84]==1&&sievePrime[85]==1&&sievePrime[86]==1&&sievePrime[87]==1&&sievePrime[88]==1&&sievePrime[89]==0&&sievePrime[90]==1&&sievePrime[91]==1&&sievePrime[92]==1&&sievePrime[93]==1&&sievePrime[94]==1&&sievePrime[95]==1&&sievePrime[96]==1&&sievePrime[97]==0&&sievePrime[98]==1&&sievePrime[99]==1&&sievePrime[100]==1);\n#assert P() reaches goal;"
        ],
        "path": "pat_examples/csp_module/Puzzles/Sieve Of Eratosthenes.csp"
    },
    {
        "name": "Sliding Game",
        "tags": [
            "Puzzle"
        ],
        "use_non_container_lib": false,
        "description": "The simple sliding game to move the pieces around to make them ordered as 1 to (n*n - 1).\n  It has 15 square tiles numbered 1 to 15 in a frame that is 4 tile positions high and 4 tile positions wide, with one unoccupied position. \n  Tiles in the same row or column of the open position can be moved by sliding them horizontally or vertically, respectively. \n  The goal of the puzzle is to place the tiles in numerical order (from left to right, top to bottom)",
        "content": "//The following models the class sliding game.\n//The following is the board setting.\n// 0 \t1 \t2 \t3\n// 4 \t5 \t6 \t7\n// 8 \t9 \t10 \t11\n// 12 \t13 \t14 \t15\n\nvar board = [3,5,6,0,2,7,8,4,1,10,15,12,9,13,11,14];\nhvar emptypos = 3; //emptypos is a secondary variable, no need to put it in the state space\n\nGame() = Left() [] Right() [] Up() [] Down();\n\nLeft() = [emptypos!=3&&emptypos!=7&&emptypos!=11&&emptypos!=15]goleft{board[emptypos]=board[emptypos+1];board[emptypos+1]=0;emptypos=emptypos+1;} -> Game();\nRight() = [emptypos!=0&&emptypos!=4&&emptypos!=8&&emptypos!=12]goright{board[emptypos]=board[emptypos-1];board[emptypos-1]=0;emptypos=emptypos-1;} -> Game();\nUp() = [emptypos!=12&&emptypos!=13&&emptypos!=14&&emptypos!=15]goup{board[emptypos]=board[emptypos+4];board[emptypos+4]=0;emptypos=emptypos+4;} -> Game();\nDown() = [emptypos!=0&&emptypos!=1&&emptypos!=2&&emptypos!=3]godown{board[emptypos]=board[emptypos-4];board[emptypos-4]=0;emptypos=emptypos-4;} -> Game();",
        "property_desc": [
            "Check if the tiles in numerical order"
        ],
        "properties": [
            "#define goal board[0] == 1 && board[1] == 2 && board[2] == 3 && board[3] == 4 && board[4] == 5 && board[5] == 6 && board[6] == 7 &&  board[7] == 8 && board[8] == 9 && board[9] == 10 && board[10] == 11 && board[11] == 12 && board[12] == 13 && board[13] == 14 && board[14] == 15 && board[15] == 0;\n#assert Game() reaches goal;"
        ],
        "path": "pat_examples/csp_module/Puzzles/Sliding Game.csp"
    },
    {
        "name": "The Tower of Hanoi",
        "tags": [
            "Puzzle"
        ],
        "use_non_container_lib": false,
        "description": "The Tower of Hanoi or Towers of Hanoi (also known as The Towers of Brahma) is a mathematical game or puzzle. \n  It consists of three rods, and a number of disks of different sizes which can slide onto any rod. \n  The puzzle starts with the disks neatly stacked in order of size on one rod, the smallest at the top, thus making a conical shape. \n \n  The objective of the puzzle is to move the entire stack to another rod, obeying the following rules: \n  - Only one disk may be moved at a time. \n  - Each move consists of taking the upper disk from one of the pegs and sliding it onto another rod, on top of the other disks that may already be present on that rod. \n  - No disk may be placed on top of a smaller disk.",
        "content": "#define N 3;\nvar column1[N+1];\nvar column2[N+1];\nvar column3[N+1];\nvar size[4];\n\nInit()=ini{size[1]=N;size[2]=0;size[3]=0;column1[1]=3;column1[2]=2;column1[3]=1;}->Skip;\nMove1To2()=if((size[1] > 0&&column1[size[1]]<column2[size[2]])||(size[1] >0&&size[2]==0))\n\t{\n\t\tmove.1.2{size[2]=size[2]+1;column2[size[2]]=column1[size[1]];size[1]=size[1]-1;}->Skip\n\t};\nMove1To3()=if((size[1] > 0&&column1[size[1]]<column3[size[3]])||(size[1] >0&&size[3]==0))\n\t{\n\t\tmove.1.3{size[3]=size[3]+1;column3[size[3]]=column1[size[1]];size[1]=size[1]-1;}->Skip\n\t};\nMove2To1()=if((size[2] > 0&&column2[size[2]]<column1[size[1]])||(size[2] >0&&size[1]==0))\n\t{\n\t\tmove.2.1{size[1]=size[1]+1;column1[size[1]]=column2[size[2]];size[2]=size[2]-1;}->Skip\n\t};\nMove2To3()=if((size[2] > 0&&column2[size[2]]<column3[size[3]])||(size[2] >0&&size[3]==0))\n\t{\n\t\tmove.2.3{size[3]=size[3]+1;column3[size[3]]=column2[size[2]];size[2]=size[2]-1;}->Skip\n\t};\nMove3To1()=if((size[3] > 0&&column3[size[3]]<column1[size[1]])||(size[3] >0&&size[1]==0))\n\t{\n\t\tmove.3.1{size[1]=size[1]+1;column1[size[1]]=column3[size[3]];size[3]=size[3]-1;}->Skip\n\t};\nMove3To2()=if((size[3] >0&&column3[size[3]]<column2[size[2]])||(size[3] >0&&size[2]==0))\n\t{\n\t\tmove.3.2{size[2]=size[2]+1;column2[size[2]]=column3[size[3]];size[3]=size[3]-1;}->Skip\n\t};\nMove()=\tMove1To2()[]Move1To3()[]Move2To1()[]Move2To3()[]Move3To1()[]Move3To2();\nSystem()=Init();System1();\nSystem1()=Move();System1();",
        "property_desc": [
            "All disks stacked on column3 in descending order of size."
        ],
        "properties": [
            "#define goal (column3[1]==3&&column3[2]==2&&column3[3]==1);\n#assert System() reaches goal;"
        ],
        "path": "pat_examples/csp_module/Puzzles/The Tower of Hanoi.csp"
    },
    {
        "name": "Vibe Game",
        "tags": [
            "Puzzle"
        ],
        "use_non_container_lib": true,
        "description": "//Game Rule\nObjective: make all the figures disappear\nRule: \n1. figures will disappear when there are 3 or more adjecent same figures in a row or column.\n2. figures will automatically shift down if the space below is empty\nMove: swap any two adjecent figures (cannot swap figure with a empty space)\n//this model models the board\n0\t1\t2\t3\t4\t5\n6\t7\t8\t9\t10\t11\n12\t13\t14\t15\t16\t17\n18\t19\t20\t21\t22\t23\n24\t25\t26\t27\t28\t29\n30\t31\t32\t33\t34\t35\n36\t37\t38\t39\t40\t41",
        "content": "#import \"PAT.Lib.VibePuzzle\";\n\n#define ROWS 7;\n#define COLS 6;\n#define MAX_STEPS 6; //max steps allowed\n\n#define em 0; //empty space\n#define t1 1;\n#define t2 2;\n#define t3 3;\n#define t4 4;\n#define t5 5;\n#define t6 6;\n\n//board is the only state variable to be tracked. all other variables are hidden or constant.\n\n//difficulty level: hard  : 6 steps\nvar board = [\nem,\tem,\tem,\tem,\tt1,\tem,\nem,\tem,\tem,\tem,\tt4,\tem,\nem,\tem,\tem,\tem,\tt6,\tem,\nem,\tem,\tem,\tt2,\tt5,\tt2,\nem,\tem,\tem,\tt3,\tt3,\tt5,\nem,\tem,\tem,\tt6,\tt6,\tt4,\nt1,\tt1,\tt2,\tt3,\tt4,\tt5 \n];\n\n\n/*\n//difficulty level: midle : 4 steps\nvar board = [\nem,\tem,\tem,\tem,\tem,\tem,\nt1,\tt4,\tem,\tem,\tem,\tem,\nt3,\tt4,\tem,\tem,\tem,\tem,\nt2,\tt3,\tem,\tem,\tem,\tem,\nt2,\tt1,\tem,\tem,\tem,\tem,\nt3,\tt4,\tem,\tem,\tem,\tem,\nt1,\tt2,\tem,\tem,\tem,\tem \n];\n*/\n\n/*\n//difficulty level: midle : 4 steps\nvar board = [\nem,\tem,\tem,\tem,\tem,\tem,\nem,\tem,\tem,\tem,\tem,\tem,\nem,\tt2,\tt4,\tem,\tem,\tem,\nem,\tt4,\tt2,\tem,\tem,\tem,\nt1,\tt1,\tt4,\tem,\tem,\tem,\nt2,\tt4,\tt3,\tem,\tem,\tem,\nt1,\tt3,\tt2,\tt3,\tem,\tem \n];\n*/\n\n/*\n//difficulty level: easy : 2 steps\nvar board = [\nem,\tem,\tem,\tem,\tem,\tem,\nem,\tem,\tem,\tem,\tem,\tem,\nem,\tem,\tem,\tem,\tem,\tem,\nem,\tem,\tem,\tem,\tem,\tem,\nem,\tem,\tem,\tem,\tem,\tem,\nem,\tem,\tem,\tt2,\tt3,\tt3,\nt2,\tt2,\tt1,\tt3,\tt1,\tt1 \n];\n*/\n\nvar step=0;\n\n//swap item i with the one on the left\nleft(i) = [step<MAX_STEPS && !call(isDead, board, ROWS, COLS) && i%COLS!=0 && board[i]!=em && board[i-1]!=em && board[i-1]!=board[i] ] \n\t\tswap_left.i{\n\t\t\tstep++;\n\t\t\t//swap\n\t\t\tvar temp = board[i];\n\t\t\tboard[i] = board[i-1];\n\t\t\tboard[i-1] = temp;\t\t\n\t\t\t\n\t\t\tboard = call(eliminate, board, ROWS, COLS);\n\t\t\t\n\t\t} -> Game();\n\t\n//swap item i with the one on the row above\nup(i) = [step<MAX_STEPS && !call(isDead, board, ROWS, COLS) && i>=COLS && board[i]!=em && board[i-COLS]!=em && board[i-COLS]!=board[i] ] \n\t\tswap_up.i{\n\t\t\tstep++;\n\t\t\t//swap\n\t\t\tvar temp = board[i];\n\t\t\tboard[i] = board[i-COLS];\n\t\t\tboard[i-COLS] = temp;\n\t\t\t\n\t\t\tboard = call(eliminate, board, ROWS, COLS);\n\t\t\t\n\t\t} -> Game();\n\n\nGame() = [] x:{0..ROWS*COLS-1}@( left(x) [] up(x)) ;",
        "property_desc": [
            "All figures disappear"
        ],
        "properties": [
            "#define goal \n\tboard[0]==em && board[1]==em && board[2]==em && board[3]==em && board[4]==em && board[5]==em && \n\tboard[6]==em && board[7]==em && board[8]==em && board[9]==em && board[10]==em && board[11]==em && \n\tboard[12]==em && board[13]==em && board[14]==em && board[15]==em && board[16]==em && board[17]==em && \n\tboard[18]==em && board[19]==em && board[20]==em && board[21]==em && board[22]==em && board[23]==em && \n\tboard[24]==em && board[25]==em && board[26]==em && board[27]==em && board[28]==em && board[29]==em && \n\tboard[30]==em && board[31]==em && board[32]==em && board[33]==em && board[34]==em && board[35]==em && \n\tboard[36]==em && board[37]==em && board[38]==em && board[39]==em && board[40]==em && board[41]==em ;\n#assert Game() reaches goal;"
        ],
        "path": "pat_examples/csp_module/Puzzles/Vibe Game.csp"
    },
    {
        "name": "Wolf Goat Cabbage Problem",
        "tags": [
            "Puzzle"
        ],
        "use_non_container_lib": false,
        "description": "A farmer with his wolf, goat and cabbage come to the edge of a river they wish to cross. \n  There is a boat at the river's edge. But, of course, only the farmer can row it. \n  The boat also can carry only two things (including the rower) at a time. \n  If the wolf is ever left alone with the goat, the wolf will eat the goat; similarly, \n  if the goat is left alone with the cabbage, the goat will eat the cabbage. \n  Devise a sequence of crossings of the river so that all four characters arrive safely on the other side of the river. \n  - Start bank: A\n  - Other bank: B\n  In this program, there are 4 variables: farmer, wolf, goat and cabbage to know which \n  bank farmer, wolf, goat and cabbage are staying, respectively 0 is in bank A, and 1 is in bank B.",
        "content": "var farmer=0;\nvar wolf=0;\nvar goat=0;\nvar carbage=0;\n\nCross()=[farmer==0 && ((! (wolf==0 && goat==0) ) && (! (goat==0 && carbage==0)))]farmer_cross{farmer=1;}->Return()\n\t[] [farmer==0 && wolf==0 && (! (goat==0 && carbage ==0))] farmer_wolf_cross{farmer=1;wolf=1;}->Return()\n\t[] [farmer==0 && goat==0] farmer_goat_cross{farmer=1;goat=1;}->Return()\n\t[] [farmer==0 && carbage==0 && (! (wolf==0 && goat==0))] farmer_carbage_cross{farmer=1;carbage=1;}->Return();\n\nReturn()=[farmer==1 && ((! (wolf==1 && goat==1)) && (! (goat==1 && carbage==1)))]farmer_return{farmer=0;}->Cross()\n\t[] [farmer==1 && wolf==1 && (! (goat==1 && carbage ==1))] farmer_wolf_return{farmer=0;wolf=0;}->Cross()\n\t[] [farmer==1 && goat==1] farmer_goat_return{farmer=0;goat=0;}->Cross()\n\t[] [farmer==1 && carbage==1 && (! (wolf==1 && goat==1))] farmer_carbage_return{farmer=0;carbage=0;}->Cross();",
        "property_desc": [
            "The farmer, the wolf, the goat and the cabbage all reach bank B"
        ],
        "properties": [
            "#define goal (farmer==1&&wolf==1&&goat==1&&carbage==1);\n#assert Cross() reaches goal;"
        ],
        "path": "pat_examples/csp_module/Puzzles/Wolf Goat Cabbage Problem.csp"
    },
    {
        "name": "Driving Philosophers",
        "tags": [
            "Algorithm",
            "Mutual Exclusion"
        ],
        "use_non_container_lib": false,
        "description": "The Driving Philosophers is a new synchronization problem in mobile ad-hoc systems. \nIn this problem, an unbounded number of driving philosophers (processes) try to access \na round-about (set of shared resources, organized along a logical ring).   \nThe process does not release the resources it has occupied until it occupies all the resources it needs.\n\"enter\" and \"exit\" are separated as two phases.",
        "content": "//the number of philosophers\n#define N 2; \n//the number of resources\n#define M 4; \n\n//the start and end resource of each philosopher\n#define ph1_start 0;\n#define ph1_end   3;\n\n#define ph2_start 1;\n#define ph2_end   2;\n\n//for each i:\n//start_end[i*2] indicates the i-th philosopher's start resource\n//start_end[i*2+1] indicates the i-th philosopher's end resource \nvar start_end[2*N] = [ph1_start,ph1_end,ph2_start,ph2_end];\n\n//pointer[i] indicates the current resource which i-th philosopher needs to enter\nvar pointer[N]:{0..M-1} = [ph1_start,ph2_start];\n\n\n//flag[i*2]==1: the i-th philosopher has done the drive and can exit the resources\n//flag[i*2+1]==1: the i-th phiolsopher has entered all the resources it needs and can drive\nvar flag[2*N]:{0..1};\n \n//variables for the fairness\nvar count[N];\nvar sum;\n\n//resource[k] indicates the current number of phil which enters k-th resource\n//this variable is only for testing the mutex. it will NOT appear in any preconditions\nvar resource[M];\n\n//this variable is only for testing if there is a state that two processes share one resource\nvar mutex = false;\n\n/***************************************************************************************************\nThe second part is the modeling of the philosopher.\nAssume: 1.Each philosopher needs to enter a finite continuous sequence of resources to drive.\n        2.Each philosopher enters the resources which it needs by sequence until its end resource \n          is entered and starts at its start resource.\n        3.Each philosopher exits the resources after its driving by sequence and\n          starts at its first entered resource.\n*****************************************************************************************************/\n\n//Mainly, in this case, every phil has three phases: occupy all the resources->drive->release all the resources\n//Simply, here can use \"if else\" to control the process, but we use \"[]\" to split the process to 3 subprocesses just for clarity\n\nPhilosopher(i)=[count[i]*N <= sum]   // \"counter\" method is used to ensure the fairness        \n               Phil_occupy(i) [] Phil_drive(i) [] Phil_release(i);\n           \nPhil_occupy(i) =[]k:{0..M-1}@Phil_enter(i,k);\nPhil_release(i)=[]k:{0..M-1}@Phil_exit(i,k);\n\n//i-th philosopher enters the k-th resource\nPhil_enter(i,k) = [flag[i*2+1]==0 && flag[i*2]==0 && k==pointer[i]]\n                  enter.i.k\n                  -> {                                   //tau event is to update      \n                         resource[k]++;\n               \t\t     if(k==start_end[i*2+1])\n               \t\t     flag[i*2+1]=1;\n               \t\t     pointer[i] = (pointer[i]+1)%M;\n                     }\n                  -> occupied.i.k\n                  -> Philosopher(i);\n        \n//i-th philosopher drives              \nPhil_drive(i) = [flag[i*2]==0 && flag[i*2+1]==1]\n                drive.i\n                {\n                    flag[i*2] = 1;\n                 \tsum = sum +1;\n                 \tcount[i] = count[i] + 1; \n                 \tif (sum == N){                        //clear the counter variables after all phils have done once driving \n                 \t    sum = 0;                          //otherwise, it will reaches a run time error\n                 \t    var y;                            //and also, it can speed up the verification\n                 \t    while(y<N){\n                 \t    count[y]=0;\n                 \t    y=y+1;}}\n                }\n                -> Philosopher(i);\n               \n//i-th philosopher exits k-th resource              \nPhil_exit(i,k) = [flag[i*2]==1 && k==(start_end[i*2]+start_end[i*2+1]-pointer[i]+1)%M]\n                 exit.i.k\n                 -> {\n                        resource[k]--;\n                        pointer[i]=(pointer[i]-1)%M;\n                        if(pointer[i]==start_end[i*2])\n        \t              {flag[i*2] = 0;\n                           flag[i*2+1]=0;}\n                    }\n                 -> released.i.k\n                 -> Philosopher(i);\n               \n/***************************************************************************************************\nThe third part is the modeling of the resources.\n*****************************************************************************************************/\n\nRes_Phil(i,k) = enter.i.k -> occupied.i.k -> exit.i.k -> released.i.k -> Resource(k);\nResource(k) = []x:{0..N-1}@Res_Phil(x,k);\n\n/***************************************************************************************************\nThe fourth part is the modeling of the system.\n*****************************************************************************************************/\n\nRes()  = ||k:{0..M-1}@Resource(k);\nPhil() = ||x:{0..N-1}@Philosopher(x);\n\nCollege() = Res()||Phil();\n\nTest_mutex = []k:{0..M-1}@([resource[k]>1]{mutex=true}->Test_mutex);\nImplementation = College() || Test_mutex;",
        "property_desc": [
            "The system is deadlock-free",
            "(Fairness) It is always eventually possible for philosopher 0 to drive.",
            "(Fairness) It is always eventually possible for philosopher 0 to enter resource 0.",
            "Violation of mutual exclusion (2 or more philosophers occupy one resource at the same time)",
            "another way to check mutex (whether resource0 reaches mutex)",
            "INVALID STATE TRANSITIONS CHECKING. phil0 has done driving but not entered all resources"
        ],
        "properties": [
            "#assert College() deadlockfree;",
            "#assert College() |= []<> drive.0;",
            "#assert College() |= []<> enter.0.0;",
            "#define Mutex (mutex==true);\n#assert Implementation() reaches Mutex;",
            "#define Mutex_resource0 (resource[0]>1);\n#assert College() reaches Mutex_resource0;",
            "#define BadTransition (flag[1] == 0 && flag[0] == 1);\n#assert College reaches BadTransition;"
        ],
        "path": "pat_examples/csp_module/Real World Problems/Driving Philosopher.csp"
    },
    {
        "name": "Flash Memory Device Driver",
        "tags": [
            "Algorithm"
        ],
        "use_non_container_lib": false,
        "description": "In this example, we verify the functional correctness of multi-sector read operation of the Samsung OneNAND flash device driver.\n\n  A NAND flash device consists of a set of pages, which are grouped into blocks. A unit\ncan be equal to a block or multiple blocks. Each page contains a set of sectors. When\nnew data is written to flash memory, rather than overwriting old data directly, the data\nis written on empty physical sectors and the physical sectors that contain the old data\nare marked as invalid. Since the empty physical sectors may reside in separate physical\nunits, one logical unit (LU) containing data is mapped to a linked list of physical units\n(PU). STL manages this mapping from logical sectors (LS) to physical sectors (PS).\nThis mapping information is stored in a sector allocation map (SAM), which returns\nthe corresponding PS offset from a given LS offset. Each PU has its own SAM.\n\n  A mechanism to simultaneously read as many multiple sectors as possible is provided\nin order to improve the reading speed. The core logic of this mechanism is implemented\nin a single function in STL. Due to the non-trivial traversal of data structures for \nlogicalto-physical sector mapping, the function for MSR having 4-level nested loops. \n  The outermost loop iterates over LUs of data (line 2-17). The second outermost loop \niterates until the LS\u2019s of the current LU are completely read (line 4-15). The third loop \niterates over PUs mapped to the current LU (line 6-14). The innermost loop identifies \nconsecutive PS\u2019s that contain consecutive LS\u2019s in the current PU (line 7-10). This loop \ncalculates conScts and offset, which indicate the number of such consecutive PS\u2019s and the \nstarting offset of these PS\u2019s, respectively. Once conScts and offset are obtained, BML READ \nreads these consecutive PS\u2019s as a whole fast (line 11).\n\n```\n01:curLU = LU0;\n02:while(curLU != NULL) {\n03:  readScts = # of sectors to read in the current LU\n04:  while(readScts>0){\n05:    curPU = LU->firstPU;\n06:    while(curPU != NULL ) {\n07:      while(...) {\n08:        conScts = # of consecutive PS\u2019s to read in curPU\n09:        offset = the starting offset of these consecutive PS\u2019s in curPU\n10:      }\n11:      BML_READ(curPU, offset, conScts);\n12:      readScts = readScts - conScts;\n13:      curPU = curPU->next;\n14:    }\n15:  }\n16:  curLU = curLU->next;\n17:}\n```\n\n  For example, suppose that the data is \u201cABCDEF\u201d and each unit consists of four\nsectors and PU0, PU1 and PU2 are mapped to LU0 (\u201cABCD\u201d) in order and PU3 and\nPU4 are mapped to LU1 (\u201cEF\u201d) in order as depicted in Figure 4(a). Initially, MSR\naccesses SAM0 to find which PS of PU0 contains LS0(\u2018A\u2019). Then, it finds SAM0[0]=1\nand reads PS1 of PU0. Since SAM0[1] is empty (i.e., PU0 does not have LS1(\u2018B\u2019)),\nMSR moves to the next PU, which is PU1. For PU1, MSR accesses SAM1 and finds that\nLS1(\u2018B\u2019) and LS2(\u2018C\u2019) are stored in PS1 and PS2 of PU1 consecutively. Thus, MSR\nreads PS1 and PS2 of PU1 altogether through BML READ and continues its reading\noperation.\n  The requirement for MSR is that the content of the read buffer should correspond\nto the original data in the flash memory when MSR finishes reading.",
        "content": "#define NUM_LS_USED 6;\n#define SECT_PER_U 4;\n#define MAX_VUN 8;\n\n#define after_MSR (logical_sectors[0] == buf[0] && logical_sectors[1] == buf[1]\n\t\t\t\t\t&& logical_sectors[2] == buf[2] && logical_sectors[3] == buf[3]\n\t\t\t\t\t&& logical_sectors[4] == buf[4] && logical_sectors[5] == buf[5]);\n\n#define safety_mapping ((MULTI_SAM[0][0] == -1) || (MULTI_SAM[0][0] != MULTI_SAM[0][1] && MULTI_SAM[0][0] != MULTI_SAM[0][2] && MULTI_SAM[0][0] != MULTI_SAM[0][3]));\n#define init_mapping (MULTI_SAM[0][0] == -1);\n\nvar MULTI_SAM[MAX_VUN][SECT_PER_U];\nvar MEMORY[MAX_VUN][SECT_PER_U];\nvar logical_sectors[NUM_LS_USED];\n\nvar buf[NUM_LS_USED] = [-1, -1, -1, -1, -1, -1];\nvar lui[3];\n\nvar NUM_VUN_LUN0 = 2;\nvar NUM_VUN_LUN1;\n\nvar data_len = 0;\nvar random_DATA = 64;\nvar random_sector = 0;\nvar data_offset = 0;\nvar sam_sector_index = 0;\nvar pu_idx;\nvar enter_new_logical_unit = 0;\n\nrandom_write() = if (data_len < NUM_LS_USED) { (increase_DATA { random_DATA = (random_DATA + 1); }\n\t\t\t\t\t\t\t\t\t\t\t-> decide_random_sector();\n\t\t\t\t\t\t\t\t\t\t\twrite_data\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tif (pu_idx == NUM_VUN_LUN0 && enter_new_logical_unit == 0)\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tenter_new_logical_unit = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\tsam_sector_index = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\twhile (MEMORY[pu_idx][random_sector] != -1)\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\trandom_sector = (random_sector + 1)%SECT_PER_U;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tif (MEMORY[pu_idx][random_sector] == -1)\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tMEMORY[pu_idx][random_sector] = random_DATA;\n\t\t\t\t\t\t\t\t\t\t\t\t\tMULTI_SAM[pu_idx][sam_sector_index] = random_sector;\n\t\t\t\t\t\t\t\t\t\t\t\t\tlogical_sectors[data_offset] = random_DATA;\n\t\t\t\t\t\t\t\t\t\t\t\t\tsam_sector_index++;\n\t\t\t\t\t\t\t\t\t\t\t\t\tdata_offset++;\n\t\t\t\t\t\t\t\t\t\t\t\t\tdata_len++;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tif (data_len >= SECT_PER_U && pu_idx < NUM_VUN_LUN0)\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tpu_idx = NUM_VUN_LUN0;\n\t\t\t\t\t\t\t\t\t\t\t\t\tsam_sector_index = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t-> reset_sector { random_sector = 0; }\n\t\t\t\t\t\t\t\t\t\t\t-> random_increase_unit();\n\t\t\t\t\t\t\t\t\t\t\trandom_write())\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse { Skip };\n\n\nSM_ReadSectors() =\tinit_SAM();\n\t\t\t\t\tdecide_NUM_VUN_LUNs();\n\t\t\t\t\tset_value {\n\t\t\t\t\t\tNUM_VUN_LUN1 = MAX_VUN - NUM_VUN_LUN0;\n\t\t\t\t\t\tlui[0] = 0;\n\t\t\t\t\t\tlui[1] = NUM_VUN_LUN0;\n\t\t\t\t\t\tlui[2] = MAX_VUN;\n\t\t\t\t\t}\n\t\t\t\t\t-> random_write();\n\t\t\t\t\tread_data {\n\t\t\t\t\t\t\t \tvar buffer_index;\n\t\t\t\t\t\t\t \tvar luIdx = 0;\n\t\t\t\t\t\t\t \twhile (luIdx < 2) {\n\t\t\t\t\t\t\t \t\tvar logical_offset = 0;\n\t\t\t\t\t\t\t \t\tvar vun_id = lui[luIdx];\n\n\t\t\t\t\t\t\t \t\twhile (vun_id < lui[luIdx + 1]) {\n\n\t\t\t\t\t\t\t \t\t\t// curPU  = MEMORY[vun_id];\n\t\t\t\t\t\t\t \t\t\t// curSAM = MULTI_SAM[vun_id];\n\n\t\t\t\t\t\t\t \t\t\twhile (logical_offset < SECT_PER_U && MULTI_SAM[vun_id][logical_offset] != -1)\n\t\t\t\t\t\t\t \t\t\t{\n\t\t\t\t\t\t\t \t\t\t\tvar physical_offset;\n\t\t\t\t\t\t\t \t\t\t\tphysical_offset = MULTI_SAM[vun_id][logical_offset];\n\t\t\t\t\t\t\t \t\t\t\tvar conScts = 1;\n\t\t\t\t\t\t\t \t\t\t\tvar entry_physical_offset = physical_offset;\n\t\t\t\t\t\t\t \t\t\t\twhile (logical_offset + 1 < SECT_PER_U && MULTI_SAM[vun_id][logical_offset + 1] == physical_offset + 1)\n\t\t\t\t\t\t\t \t\t\t\t{\n\t\t\t\t\t\t\t \t\t\t\t\tlogical_offset = logical_offset + 1;\n\t\t\t\t\t\t\t \t\t\t\t\tconScts = conScts + 1;\n\t\t\t\t\t\t\t \t\t\t\t\tphysical_offset = physical_offset + 1;\n\t\t\t\t\t\t\t \t\t\t\t}\n\n\t\t\t\t\t\t\t \t\t\t\t// BML_READ(curPU, offset, conScts);\n\t\t\t\t\t\t\t \t\t\t\tvar ii = 0;\n\t\t\t\t\t\t\t \t\t\t\twhile (ii < conScts)\n\t\t\t\t\t\t\t \t\t\t\t{\n\t\t\t\t\t\t\t \t\t\t\t\tbuf[buffer_index] = MEMORY[vun_id][entry_physical_offset + ii];\n\t\t\t\t\t\t\t \t\t\t\t\tbuffer_index = buffer_index + 1;\n\t\t\t\t\t\t\t \t\t\t\t\tii = ii + 1;\n\t\t\t\t\t\t\t \t\t\t\t}\n\t\t\t\t\t\t\t \t\t\t\t// end BML_READ(curPU, offset, conScts);\n\n\t\t\t\t\t\t\t \t\t\t\tlogical_offset = logical_offset + 1;\n\t\t\t\t\t\t\t \t\t\t}\n\t\t\t\t\t\t\t \t\t\tvun_id = vun_id + 1;\n\t\t\t\t\t\t\t \t\t}\n\t\t\t\t\t\t\t \t\tluIdx = luIdx + 1;\n\t\t\t\t\t\t\t \t}\n\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t -> Skip;\n\ninit_SAM() = initialize{\tvar ii = 0;\n\n\t\t\t\t\t\t\twhile (ii < MAX_VUN) {\n\t\t\t\t\t\t\t\tvar jj = 0;\n\t\t\t\t\t\t\t\twhile (jj < SECT_PER_U) {\n\t\t\t\t\t\t\t\t\tMULTI_SAM[ii][jj] = -1;\n\t\t\t\t\t\t\t\t\tMEMORY[ii][jj]    = -1;\n\t\t\t\t\t\t\t\t\tjj = jj + 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tii = ii + 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} -> Skip;\n\ndecide_random_sector() = (ifb (random_sector < SECT_PER_U - 1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t(increase{\n\t\t\t\t\t\t\t\t\t\t\trandom_sector = (random_sector + 1);\n\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t -> Skip)\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tdecide_random_sector())\n\t\t\t\t\t\t[]\n\t\t\t\t\t\tSkip;\n\ndecide_random_data() = (ifb (random_DATA < 66)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t(increase{\n\t\t\t\t\t\t\t\t\t\t\trandom_DATA = (random_DATA + 1);\n\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t -> Skip)\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\tdecide_random_data())\n\t\t\t\t\t\t[]\n\t\t\t\t\t\tSkip;\n\nrandom_increase_unit() = (ifb (pu_idx < MAX_VUN - 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t(increase{\n\t\t\t\t\t\t\t\t\t\t\tpu_idx = pu_idx + 1;\n\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t -> Skip)\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t[]\n\t\t\t\t\t\tSkip;\n\ndecide_NUM_VUN_LUNs() = (ifb (NUM_VUN_LUN0 < MAX_VUN - 2)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t(increase{\n\t\t\t\t\t\t\t\t\t\t\tNUM_VUN_LUN0 = NUM_VUN_LUN0 + 1;\n\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t -> Skip)\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t[]\n\t\t\t\t\t\tSkip;\n\nrandom_write_DATA() =\tinit_SAM();\n\t\t\t\t\t\tdecide_NUM_VUN_LUNs();\n\t\t\t\t\t\tset_value {\n\t\t\t\t\t\t\tNUM_VUN_LUN1 = MAX_VUN - NUM_VUN_LUN0;\n\t\t\t\t\t\t\tlui[0] = 0;\n\t\t\t\t\t\t\tlui[1] = NUM_VUN_LUN0;\n\t\t\t\t\t\t\tlui[2] = MAX_VUN;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t-> random_write();",
        "property_desc": [
            "Multi-sector read operation consistently and eventually reads the correct data into buf",
            "Mapping remains safe and valid throughout the execution of SM_ReadSectors",
            "The system is deadlock-free",
            "The process of random write is deadlock-free."
        ],
        "properties": [
            "#assert SM_ReadSectors |= G F after_MSR;",
            "#assert SM_ReadSectors |= G (init_mapping -> G safety_mapping);",
            "#assert SM_ReadSectors() deadlockfree;",
            "#assert random_write_DATA() deadlockfree;"
        ],
        "path": "pat_examples/csp_module/Real World Problems/Flash Memory Device Driver.csp"
    },
    {
        "name": "Hadoops Parallel Architecture",
        "tags": [
            "Protocol",
            "Distributed System"
        ],
        "use_non_container_lib": false,
        "description": "Hadoop, the open source implementation of MapReduce has quickly gained popularity because it abstracts away system level details from users, leaving a parallel black-box to program in. Any Hadooop cluster setup has at least four kinds of processes-namenodes, datanodes, jobtrackers and tasktrackers. \n  Since Hadoop is a large project, the full architecture has not been model in PAT. Instead, it focuses on the relationship between the namenode and datanode. Data locality properties has also been modeled and identified. The system modeling is as below: \n  Start up: the most natural way to bring up a cluster to ready state is to start up the namenode first followed by the jobtracker or datanodes, which are both depending on namenode), and then, the tasktracker depending on jobtracker. \n  After the namenode ahs verified that sufficient datanodes are online, it will allow the cluster to exit safe mode.=-> computation. \n  Work: the datanode contacts the namenode to tell it is ready to receive tasks. The namenode activates the jobtracker and it selects and assigns the task and relevant block to the datanode. The datanode processes the task and recourses.",
        "content": "#define OFF 0;\n#define ON 1;\n#define N 2;\n#define NoRecord 2;\n#define NoEntries 4;\n\n//parameters for tracing status for main processors\nvar namenode = OFF;\nvar jobtracker = OFF;\nvar tasktracker = [OFF(N)];\nvar datanode = [OFF(N)];\nvar trackercount = 0;\nvar count = 0;\nvar jobpicker = OFF;\n\n// parameters for constructing the model for specific job\nvar weight = 0;\nvar safemode  =  ON; \nvar job_at_datanode[N];\nvar is_job_running[N];\nvar record[NoRecord][NoEntries] = [-1, 0, 0, 1, -1, 1, 2, 3];// CSV format: [selected, location, key, value] and repeated.  \nvar assignedblock[N];\nvar job_at_namenode  =  2;\nvar completed = 0;\nvar req_to_exit_safemode = N-1; // number of datanodes needed\n\n//channel\nchannel sendReady N;\nchannel signedjob 0;\n\n\n#define operationalmin (count >0 && trackercount >0 && namenode == ON && jobtracker == ON);\n#define safemod_cond (safemode ==  ON && operationalmin && count >= req_to_exit_safemode);\n#define execstrat_push(job_at_namenode != 0 && operationalmin); // Condition to release task to datanode\n\n//***************Model Construction*****************************//\nsimulationconfig() = initialization{\n\tvar j = 0;\n\twhile (j < N){\n\t\tdatanode[j] = OFF;\n\t\ttasktracker[j] = OFF;\n\t\tjob_at_datanode[j] = 0;\n\t\tis_job_running[j] = 0;\n\t\tj = j + 1;\n\t}\n} -> Skip;\n\ncluster1() = simulationconfig();namenode_status()||jobtracker_status()||\n\t\t\t(||i:{0..N-1}@tasktracker_status(i))||\n\t\t\t(||i:{0..N-1}@datanode_status(i));\n\t\t\t\nnamenode_status() = ifa(namenode == OFF){turnon_nn{namenode = ON;} -> turnon_nn_success->namenode_exitsafe()};\njobtracker_status() = turnon_nn_success -> ifa(jobtracker == OFF && namenode == ON){turnon_jt{jobtracker = ON;} -> atomic{turnon_jt_success -> Skip}};\ntasktracker_status(i) = turnon_jt_success -> ifa(tasktracker[i] == OFF && jobtracker == ON){\n\t\t\t\t\t\tturnon_tt.i{tasktracker[i] = ON;trackercount++} -> atomic{turnon_tt_success.i -> Skip}};\n\t\t\t\t\t\ndatanode_status(i) = turnon_nn_success -> ifa(datanode[i] == OFF && namenode == ON){turnon_dn.i{datanode[i] = ON;count++;}\n\t\t\t\t\t -> turnon_dn_success.i -> datanode_sendready(i)};\n\nnamenode_exitsafe() = ifb(safemod_cond){exit_safemode{safemode = OFF;} -> namenode_receiver()};\t\n\n//job assignment and scheduling\n//datanode signals and indicates ready to work. namenode sign it to taskscheduler. taskscheduler shops arround the records and collected\n//records to signedblocks.\ndatanode_sendready(i) = [datanode[i] == ON && tasktracker[i] == ON && safemode == OFF && is_job_running[i] == 0 && job_at_datanode[i] == 0](\n\t\t\t\t\t\tsendReady!i -> sendReady_success.i ->signedjob!i->received_job.i->datanode_execute(i));\n\nnamenode_receiver() = sendReady?x -> taskscheduler(x);\n\n#alphabet taskscheduler {X}; \ntaskscheduler(i) =  blockpicker.i{\n\tvar j = 0;\n\twhile(j<NoRecord){\n\t\tif(record[j][0] == -1){\n\t\t\tassignedblock[i] = j;\n\t\t\trecord[j][0] = 1;\n\t\t\tj = NoRecord;\n\t\t}\n\t\tj++;\t\t\n\t}\n} -> signedjob?i-> atomic{signedjob_i->push_to_datanode(i)};\n\npush_to_datanode(i) = [execstrat_push](push_to_dn.i{job_at_namenode--;job_at_datanode[i] = 1;} -> namenode_receiver());\n\ndatanode_execute(i) = if(job_at_datanode[i] == 1 && datanode[i] == ON && operationalmin && safemode == OFF){\n\t\t\t\t\t\tif(i == record[assignedblock[i]][1]){execute(i)}//if local\n\t\t\t\t\t\telse{{weight = weight + 2;} -> execute(i)}//if not ,assign penalty\n\t\t\t\t\t}else{datanode_execute(i)};\nexecute(i)=runjob.i{is_job_running[i] = 1;} -> finishjob.i{completed++;job_at_datanode[i] = 0;is_job_running[i] = 0;} -> datanode_sendready(i);",
        "property_desc": [
            "Datanodes are online even if the Namenode is not running",
            "The system is deadlock-free",
            "The system is nonterminating",
            "Checks if the system can continue operating even after all tasks are finished",
            "Checks if the record of process0 in the system eventually get processed",
            "Checks if the record of process1 in the system eventually get processed",
            "Once it starts computational mode, datanode1 always works",
            "Checks if all tasks are completed and the Jobtracker has no pending tasks",
            "Checks if records are no longer located in their initial datanode location, all tasks can still completed and the Jobtracker has no pending tasks",
            "Checks if all tasks are completed and the Jobtracker has no pending tasks with least penalty",
            "Checks if records are no longer located in their initial datanode location, all tasks can still completed and the Jobtracker has no pending tasks with least penalty",
            "System achieves the goal state with the least penalty for non-local processing.",
            "If records are no longer located in their initial datanode location, system achieves the goal state with the least penalty for non-local processing."
        ],
        "properties": [
            "#define go_live_wo_namenode count > 0 && namenode == OFF;\n#assert cluster1 reaches go_live_wo_namenode;",
            "#assert cluster1 deadlockfree;",
            "#assert cluster1 nonterminating;",
            "cluster1_w_t()=cluster1()interrupt end();\nend() = [completed == NoRecord]finishedAll->Stop;\n#assert cluster1_w_t nonterminating;",
            "//Starvation\n#define record_process0 record[0][0] != -1;\n#assert cluster1 |= <>[](record_process0);",
            "#define record_process1 record[1][0] != -1;\n#assert cluster1 |= <>[](record_process1);",
            "#assert cluster1 |= <>[]exit_safemode->push_to_dn.1;",
            "//Data Locality\ncluster1ds() = shift{record[0][1] = 3; record[1][1] = 3;}->cluster1();\n#define goal job_at_namenode  == 0 && completed == NoRecord;\n#assert cluster1 reaches goal;",
            "#assert cluster1ds reaches goal;",
            "#assert cluster1 reaches goal with min(weight);",
            "#assert cluster1ds reaches goal with min(weight);",
            "#define goal2 goal && weight <= 3;\n#assert cluster1 reaches goal2;",
            "#assert cluster1ds reaches goal2;"
        ],
        "path": "pat_examples/csp_module/Real World Problems/Hadoops Parallel Architecture.csp"
    },
    {
        "name": "Keyless Car System",
        "tags": [
            "Real World"
        ],
        "use_non_container_lib": false,
        "description": "One of the latest automotive technologies, push-button keyless system, allows you to start\nyour car's engine without the hassle of key insertion and offers great convenience. \n\nPush-button keyless system allows owner with key-fob in her pocket to unlock the door when she is very near the car.\nThe driver can slide behind the wheel, with the key-fob in her pocket \n(briefcase or purse or anywhere inside the car), she can push the start/stop button on the control panel. \nShutting off the engine is just as hassle-free, and is accomplished by merely pressing the start/stop button. \n\nThese systems are designed so it is impossible to start the engine without the owner's key-fob\nand it cannot lock your key-fob inside the car because the system will sense it and prevent \nthe user from locking them in.\n\nHowever, the keyless system can also surprise you as it may allow you to drive the car without key-fob.\nThis has happened to Jin Song when his wife droped him to his office on the way to a shopping mall but\nthe key-fob was in Jin Song's pocket. At the shopping mall, when the engine was turned off, the car could\nnot be locked or re-started again. Jin Song had to take a taxi to the mall to pass the key-fob.\nThis really motivated Jin Song to come up the model :-)",
        "content": "#define N 2;        // number of owners\n\n//enumerations used in the model\n#define far 0;      // owner is out and far away from the car\n#define near 1;     // owner is near and close enough to open/lock the door if he/she has the keyfob\n#define in 2;       // owner is in the car\n\n#define off 0;      // engine is off\n#define on 1;       // engine is on\n\n#define unlock 0;   // door is unlocked but closed\n#define lock 1;     // door is locked (must be closed)\n#define open 2;     // door is open\n\n#define incar -1;    // key is put inside car\n#define faralone -2; // key is put outside and far\n\nvar owner[N];       // owners' position. initially, all users are far away from the car\n\nvar engine = off;   // engine status, initially off\nvar door = lock;    // door status, initially locked\nvar key = 0;        // key fob position, initially, it is with first owner\nvar moving = 0;     // car moving status, 0 for stop and 1 for moving\nvar fuel = 10;      // energy costs, say 1 for a short drive and 5 for a long driving\n\nowner_pos(i) = \n          [owner[i] == far]towards.i{owner[i] = near;} -> owner_pos(i)\n          []\n          [owner[i] == near]goaway.i{owner[i] = far;} -> owner_pos(i)\n          []\n          [owner[i] == near && door == open && moving==0]getin.i{owner[i] = in; } -> owner_pos(i)\n          []\n          [owner[i] == in && door == open && moving==0]goout.i{owner[i] = near; } -> owner_pos(i);          \n\nkey_pos(i) = \n\t         [key == i && owner[i] == in]putincar.i{key = incar;} -> key_pos(i) \n          [] \n          [key == i && owner[i] == far]putaway.i{key = faralone;} -> key_pos(i)\n          []\n          [(key == faralone && owner[i] == far) || (key == incar && owner[i] == in)]getkey.i{key = i;} -> key_pos(i);          \n\ndoor_op(i) = \n          [key == i && owner[i]==near && door ==lock && moving==0]unlockopen.i{door = open;} -> door_op(i)\n          []\n          [owner[i]==near && door==unlock && moving==0]justopen.i{door = open;} -> door_op(i)\n          []\n          [door != open && owner[i] == in]insideopen.i{door = open;} -> door_op(i)\n          []\n          [door == open]close.i{door = unlock;} -> door_op(i)\n          []\n          [door==unlock&&owner[i]==in]insidelock.i{door=lock;} -> door_op(i)\n          []\n          [door == unlock && owner[i]==near && key==i]outsidelock.i{door=lock;} -> door_op(i);\n        \nmotor(i) = \n          [owner[i]==in&&(key==i||key==incar)&&engine==off&& fuel!= 0]turnon.i{engine = on;} -> motor(i)\n          []\n          [engine==on&&owner[i]==in&&moving==0]startdrive.i{moving=1;} -> motor(i) \n          []\n          [moving==1&&fuel!=0]shortdrive.i{fuel=fuel-1;if (fuel==0) {engine=off; moving =0;}  } -> motor(i)\n          []\n          [moving==1&&fuel > 5]longdrive.i{fuel=fuel-5;if (fuel==0) {engine=off; moving =0;}} -> motor(i)\n          []\n          [engine==on&&moving==1&&owner[i]==in]stop.i{moving=0;} -> motor(i)\n          []\n          [fuel==0&&engine==off]refill{fuel=10;} -> motor(i)\n          [] \n          [engine==on&&moving==0&&owner[i]==in]turnoff.i{engine = off;} -> motor(i);\n          \ncar =     (|||i:{0..N-1} @ (motor(i) ||| door_op(i) ||| key_pos(i) ||| owner_pos(i)));",
        "property_desc": [
            "The model is deadlock-free",
            "It is always eventually able to have long drive with the car",
            "Can key be locked inside",
            "Can car moving without owner",
            "Can ower drives the car",
            "Can car move when engine is off",
            "Can car move without fuel",
            "Car can be driven without key"
        ],
        "properties": [
            "#assert car deadlockfree;",
            "#assert car |= []<> longdrive.0;",
            "#define keylockinside (key == incar && door == lock && owner[0] != in && owner[1] != in); \n#assert car reaches keylockinside;",
            "#define runwithoutowner (moving==1 && owner[0] == far && owner[1] == far);\n#assert car reaches runwithoutowner;",
            "#define ownerdrivetogether (moving==1 && owner[0] == in && owner[1] == in); \n#assert car reaches ownerdrivetogether;",
            "#define drivewithoutengineon (moving==1 && engine==off); \n#assert car reaches drivewithoutengineon;",
            "#define drivewithoutfuel (moving==1&&fuel==0); \n#assert car reaches drivewithoutfuel;",
            "#define drivewithoutkeyholdbyother (moving ==1 && owner[1] == in && owner[0] == far && key == 0); \n#assert car reaches drivewithoutkeyholdbyother;"
        ],
        "path": "pat_examples/csp_module/Real World Problems/Keyless Car System.csp"
    },
    {
        "name": "Lifting Truck System",
        "tags": [
            "Real World"
        ],
        "use_non_container_lib": false,
        "description": "The lift system studied in this model consists of 3 lifts. \n  The system is operated by means of buttons on the lifts.\n  There are four such buttons on each lift: up, down, setref and axis.\n  If the up or down button of a certain lift is pressed, all the lifts of the system should go up, respectively down. \n  If the up or down button is pressed together with setref, only one lift (the one of whichthe buttons are pressed) should go up or down. \n\n  Behavior description:\n  -- STARTUP phase\n     A. The SETREF button of a station might be pressed\n     \t1. it stores that it has pos 1,\n     \t2. it adopts the STARTUP state,\n     \t3. it closes its relay,\n     \t4. it broadcasts a STARTUP message,\n     \t5. it opens its relay,\n     \t6. { if it receives an another startup message it stores the pos of the sender of that message as the number of stations in the network,\n\t\t   { if it receives a standby message it adopts the standby state (if the station has pos 2 it will in addition initiate normal operation by broadcasting its state).\n\n  -- Normal operation phase\n     During normal operation, the first station (with pos 1) broadcasts its state\n\t  and height, then the next station broadcasts its state and height and so on, until the last station has\n\t  broadcast its state and height after which the first station starts again.",
        "content": "////////////////The Model//////////////////\n#import \"PAT.Lib.List\";\n#define STARTUP 0;\t\t\t\t// 5 types of messages of station \n#define STANDBY 1;\n#define UP 2;\n#define DOWN 3;\n#define SYNC 4;\n#define NIL 0;\n#define ST 3;\t\t\t\t\t// number of stations in the network\n \n/* Global variables */\nvar suc[ST+1] = [0, 2, 3, 1]; \t// suc[i]: the id of the next lift of lift i\nvar pre[ST+1] = [0, 3, 1, 2];\t// pre[i]: the id of the previous lift of lift i\n \nvar pos[ST+1]=[NIL(ST+1)]; \t\t// pos[i]: pos obtained by station i\nvar num[ST+1] = [NIL(ST+1)];    // num[i]: number of stations in the network known by station i\nvar state[ST+1];\t\t\t\t// STARTUP, STANDBY, UP, DOWN, SYNC\nvar pressed_SETREF[ST+1];\t\t// pressed_SETREF[i] = 1: button SETREF of station i is being pressed\n\t\t\t\t\t\t\t\t// pressed_SETREF[i] = 0: button SETREF of station i is being released\nvar active[ST+1]; \t\t\t\t// number of active station\n \nvar<List> R;\t\t\t\t\t// list of CLOSED relays, initially it is empty\n \nvar relay_opened;\t\t\t\t// the latest opened relay\nvar relay_closed;\t\t\t\t// the latest closed relay\n \nvar msg_id;\t\t\t\t\t\t// station msg_id sends the msg\nvar msg_pos;\t\t\t\t\t// station with pos msg_pos sends the msg\nvar msg_state;\t\t\t\t\t// msg has state msg_state\n \nvar is_setref_pressed;\t\t\t// 0: no lift has pressed button SETREF; 1: there is some lift with button SETREF pressed\nvar has_active_station;\t\t\t// 0: no lift is in active state; 1: there is some lift in active state\n \n/*----------------------------Bus process-----------------------------*/\n/* The bus implemented a CAN protocol. \n** The CAN protocol allows several stations to claim the bus at the same time. \n** However, in the lift system, the stations are programmed in such a way that (during normal operation) the stations take\n** turns claiming the bus. They claim the bus in a fixed order, specified by pre[] & suc[] in this model.\n*/\nBus() =\treq ->  (stob_init -> Deliver(); open_relay -> update_r_list{R.Remove(relay_opened);} -> rel -> Bus()\n\t\t\t [] stob -> Deliver(); rel -> Bus()\n\t\t\t [] open_relay -> update_r_list{R.Remove(relay_opened);} -> rel -> Bus()\n\t\t\t [] close_relay -> update_r_list{R.Add(relay_closed);} -> rel -> Bus()\n\t\t\t [] rel -> Bus());\n \nDeliver() =\tif (msg_id == 1){//station 1 sending message to bus\n\t\t\t\tDeliver1()\n\t\t\t}else{\n\t\t\t\tif (msg_id == 2){//station 2 sending message to bus\n\t\t\t\t\tDeliver2()\n\t\t\t\t}else{//station 3 sending message to bus\n\t\t\t\t\tDeliver3()\n\t\t\t\t}\n\t\t\t};\n \n//bus broadcasting msg recieved from station 1\nDeliver1() =\tif ( (R.Contains(1) == true && R.Contains(2) == true) || (R.Contains(1) == true && R.Contains(3) == true) ){\n\t\t\t\t//relays 1 & 2 are closed, or, relays 1 and 3 are closed\n\t\t\t\t//bus recieves msg from station 1, and broadcasts the msg to station 2 & 3\n\t\t\t\t\tbtos.2 -> done_btos.2 -> btos.3 -> done_btos.3 -> Skip\n\t\t\t\t}else{\n\t\t\t\t\tif (R.Contains(2) == true && R.Contains(3) == true){\n\t\t\t\t\t//relays 2 & 3 are closed\n\t\t\t\t\t//bus recieves msg from station 1, and broadcasts the msg to station 2 & 3\n\t\t\t\t\t\tbtos.3 -> done_btos.3 -> btos.2 -> done_btos.2 -> Skip\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif ( R.Contains(1) == true ){\n\t\t\t\t\t\t\tbtos.2 -> done_btos.2 -> Skip\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif (R.Contains(3) == true){\n\t\t\t\t\t\t\t\tbtos.3 -> done_btos.3 -> Skip\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tSkip\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n \n//bus broadcasting msg recieved from station 2\t\nDeliver2() =\tif ( (R.Contains(1) == true && R.Contains(2) == true) || (R.Contains(2) == true && R.Contains(3) == true) ){\n\t\t\t\t\tbtos.3 -> done_btos.3 -> btos.1 -> done_btos.1 -> Skip\n\t\t\t\t}else{\n\t\t\t\t\tif (R.Contains(1) == true && R.Contains(3) == true){\n\t\t\t\t\t\tbtos.1 -> done_btos.1 -> btos.3 -> done_btos.3 -> Skip\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif ( R.Contains(1) == true ){\n\t\t\t\t\t\t\tbtos.1 -> done_btos.1 -> Skip\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif (R.Contains(2) == true){\n\t\t\t\t\t\t\t\tbtos.3 -> done_btos.3 -> Skip\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tSkip\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n \n//bus broadcasting msg recieved from station 3\nDeliver3() =\tif ( (R.Contains(1) == true && R.Contains(3) == true) || (R.Contains(2) == true && R.Contains(3) == true) ){\n\t\t\t\t\tbtos.1 -> done_btos.1 -> btos.2 -> done_btos.2 -> Skip \n\t\t\t\t}else{\n\t\t\t\t\tif (R.Contains(1) == true && R.Contains(2) == true){\n\t\t\t\t\t\tbtos.2 -> done_btos.2 -> btos.1 -> done_btos.1 -> Skip\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif ( R.Contains(2) == true ){\n\t\t\t\t\t\t\tbtos.2 -> done_btos.2 -> Skip\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif (R.Contains(3) == true){\n\t\t\t\t\t\t\t\tbtos.1 -> done_btos.1 -> Skip\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tSkip\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n \n/*---------------------Lift process--------------------------------------*/\nLift(i) =  [is_setref_pressed == 0]Setref(i) \n\t\t[] [is_setref_pressed == 1]Wait_init_phase(i);\n \n/* Lift i has its SETREF button pressed */\nSetref(i) = setref.i{is_setref_pressed = 1; pressed_SETREF[i] = 1; pos[i] = 1;} -> _STARTUP{state[i] = STARTUP;} \n\t\t\t-> req -> set_relay_close{relay_closed = i;} -> close_relay -> rel \n\t\t\t-> req -> set_message{msg_id = i; msg_pos = pos[i]; msg_state = STARTUP;} -> stob_init \n\t\t\t-> set_relay_open{relay_opened = i;} -> open_relay -> rel\n\t\t\t-> Wait_For_STARTUP(i); set_num.i{num[i] = pos[msg_id];} -> _STANDBY{state[i] = STANDBY;} -> done_btos.i /*wait for a startup msg*/\n\t\t\t-> req -> set_message{msg_id = i; msg_pos = pos[i]; msg_state = state[i];} -> stob -> rel -> NORMAL_OPR(i);\n \nWait_For_STARTUP(i) = btos.i -> ( [msg_state == STARTUP] (Skip) [] [msg_state != STARTUP] (done_btos.i -> Wait_For_STARTUP(i)));\n \n/* Lift i wait for a STARTUP msg to start */\nWait_init_phase(i) = Wait_For_STARTUP(i); set_pos.i{pos[i] = msg_pos + 1; num[i] = pos[i];} \n\t\t\t\t\t -> _STARTUP{state[i] = STARTUP;} -> done_btos.i\n\t\t\t\t\t -> req -> set_relay_close{relay_closed = i;} -> close_relay -> rel \n\t\t\t\t\t -> req -> set_message{msg_id = i; msg_pos = pos[i]; msg_state = STARTUP;} -> stob -> rel -> Wait_For_STANDBY(i);\n \n/*---------------------Wait_For_STANDBY process--------------------------------------*/\n/* After received a STARTUP msg, Lift i continues to receive STARTUP/STANDBY msg, and will go to STANDBY state while recieving a STANDBY msg */\nWait_For_STANDBY(i) = \tbtos.i -> ([msg_state == STARTUP]set_num.i{num[i] = pos[msg_id];} -> done_btos.i -> Wait_For_STANDBY(i) \n\t\t\t\t\t[] [msg_state == STANDBY]_STANDBY{state[i] = msg_state;} -> done_btos.i -> NORMAL_OPR(i)\n\t\t\t\t\t[] [msg_state != STARTUP && msg_state != STANDBY]done_btos.i -> Wait_For_STANDBY(i));\n \n/*---------------------NORMAL_OPR process--------------------------------------*/\n/* At STANDBY state, Lift i can initiate an operation or wait for SYNC msg for a operation */\nNORMAL_OPR(i) =  ( [has_active_station == 0] Active(i) )\n\t\t\t   []( [has_active_station == 1]Passive(i) );\n \nActive(i) =  req -> startActive.i->\t(\n\t\t\t\t\t\t\t\t\t\t(\t\tup.i{has_active_station = 1; active[i] = 1;} -> _UP{state[i] = UP;} -> rel \n\t\t\t\t\t\t\t\t\t\t\t->  req -> set_message{msg_id = i; msg_pos = pos[i]; msg_state = state[i];} -> stob -> rel\n\t\t\t\t\t\t\t\t\t\t\t-> \tActive_con(i)\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t[]\n\t\t\t\t\t\t\t\t\t\t(\t\tdown.i{has_active_station = 1; active[i] = 1;} -> _DOWN{state[i] = DOWN;} -> rel\n\t\t\t\t\t\t\t\t\t\t\t->  req -> set_message{msg_id = i; msg_pos = pos[i]; msg_state = state[i];} -> stob -> rel\n\t\t\t\t\t\t\t\t\t\t\t->  Active_con(i)\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t);\nPassive(i) =       btos.i \n\t\t\t\t-> if (msg_state == SYNC){\n\t\t\t\t   \t\t_SYNC{state[i] = msg_state;} -> move.i -> done_btos.i -> Passive(i)\n\t\t\t\t   }else{\n\t\t\t\t   \t\tif (msg_state == STANDBY){\n\t\t\t\t   \t\t\t_STANDBY{state[i] = msg_state;} -> done_btos.i -> NORMAL_OPR(i)\n\t\t\t\t   \t\t}else{\n\t\t\t   \t\t\t\tif ( i == suc[msg_id]){\n\t\t\t\t\t   \t\t\t   adopt_state{state[i] = msg_state;} -> done_btos.i\n\t\t\t\t\t   \t\t\t-> req -> set_message{msg_id = i; msg_pos = suc[msg_pos]; msg_state = state[i];} -> stob -> rel -> Passive(i)\n\t\t\t\t\t   \t\t}else {\n\t\t\t\t\t   \t\t\t   adopt_state{state[i] = msg_state;} -> done_btos.i -> Passive(i)\n\t\t\t\t\t   \t\t}\n\t\t\t\t   \t\t}\n\t\t\t\t   };\n \n/*---------------------Active_con process--------------------------------------*/\n/* After activating an operation, Lift i either releases the press button, or continues the operation by receiving msg or sending SYN */\n Active_con(i) =\tif (state[1] == STANDBY && state[2] == STANDBY && state[3] == STANDBY){\n \t\t\t\tRelease(i)\n \t\t\t}else{\n \t\t\t\tReceive_or_Sync(i)\n \t\t\t};\n \n Release(i) = req -> release.i{has_active_station = 0; active[i] = 0;} -> rel -> NORMAL_OPR(i);\n \n Receive_or_Sync(i) = \t\tbtos.i\n \t\t\t\t\t\t->  if (msg_state == state[i]){\n \t\t\t\t\t\t\t\tif ( i == suc[msg_id]){\n \t\t\t\t\t\t\t\t\tdone_btos.i\n\t\t->\treq -> _SYNC{state[i] = SYNC;} -> set_message{msg_id = i; msg_pos = pos[i]; msg_state = state[i];} -> stob -> move.i-> rel\n\t\t->  req -> _STANDBY{state[i] = STANDBY;} -> set_message{msg_id = i; msg_pos = pos[i]; msg_state = STANDBY;} -> stob -> rel\n\t\t->  Active_con(i)\n\t\t}else{\n\t\t\tdone_btos.i -> Receive_or_Sync(i)\n\t\t}\n\t}else{\n\t\tSkip\n\t};\n \n/*----------------------------System Process--------------------------------------------*/\nSystem () = Bus() || ( Lift(1) ||| Lift(2) ||| Lift(3) );",
        "property_desc": [
            "The system is deadlock-free",
            "All lifts will eventually always knows that the number of stations in the network is 3",
            "All lifts will eventually always obtains a correct position",
            "Station1 is able to change to active state",
            "Station2 is able to change to active state",
            "Station3 is able to change to active state",
            "At most 1 station is allowed to initiate an operation at a time",
            "Relays can not be all closed at the same time",
            "All lifts will move in the same direction",
            "All lifts will move in the same direction",
            "One lift can never move in a different direction from other lifts",
            "At most one lift can press the SETREF button at a time",
            "Only when there is an active lift can any lift moves up/down",
            "Lifts can start active infinitely often",
            "Check if one station got active first, the system also allows other stations to activate later",
            "Check whether system allows one station gets active continuously",
            "Check whether system allows every lift can move after one station gets active state"
        ],
        "properties": [
            "#assert System() deadlockfree;",
            "#define NUMSET num[1] == 3 && num[2] == 3 && num[3] == 3;\n#assert System |= <>[] NUMSET;",
            "#define POSSET (pos[1] !=  pos[2] && pos[1] !=  pos[3] && pos[3] !=  pos[2] \n\t\t\t\t&& pos[1] >= 1 && pos[1] <= 3 \n\t\t\t\t&& pos[2] >= 1 && pos[2] <= 3 \n\t\t\t\t&& pos[3] >= 1 && pos[3] <= 3 );\n#assert System |= <>[] POSSET;",
            "#define Active1 active[1] == 1;\n#define Active2 active[2] == 1;\n#define Active3 active[3] == 1;\n#assert System() reaches Active1;",
            "#assert System() reaches Active2;",
            "#assert System() reaches Active3;",
            "#define MultiActive active[1] + active[2] + active[3] > 1;\n#assert System |= [] (!MultiActive);",
            "#define AllRelaysAreClose (R.Count() == ST);\n#assert System() |= [](!AllRelaysAreClose);",
            "#define AllMoveUP state[1] == UP && state[2] == UP && state[3] == UP;\n#define AllMoveDown state[1] == DOWN && state[2] == DOWN && state[3] == DOWN;\n#assert System() |= [] (up.1 -> <> AllMoveUP);",
            "#assert System() |= [] (down.1 -> <> AllMoveDown);",
            "#define MoveUpOrDownDifferent \t ((state[1] == \t UP && state[2] == \t UP && state[3] == DOWN)\n\t\t\t\t\t\t\t\t||(state[1] == DOWN && state[2] == DOWN && state[3] == UP)\n\t\t\t\t\t\t\t\t||(state[2] == \t UP && state[3] == \t UP && state[1] == DOWN)\n\t\t\t\t\t\t\t\t||(state[2] == DOWN && state[3] == DOWN && state[1] == UP)\n\t\t\t\t\t\t\t\t||(state[1] == \t UP && state[3] == \t UP && state[2] == DOWN)\n\t\t\t\t\t\t\t\t||(state[1] == DOWN && state[3] == DOWN && state[2] == UP)\n\t\t\t\t\t\t\t\t );\n#assert System() |= [] (!MoveUpOrDownDifferent);",
            "#define MultiSETREF pressed_SETREF[1] + pressed_SETREF[2] + pressed_SETREF[3] > 1;\n#assert System() |= [](!MultiSETREF);",
            "#define MoveUP state[1] == UP || state[2] == UP || state[3] == UP;\n#define MoveDOWN state[1] == DOWN || state[2] == DOWN || state[3] == DOWN;\n#define ACTIVATED has_active_station == 1;\n#assert System() |= [](MoveUP -> ACTIVATED); // Alternatively, #assert System() |= []((!MoveUP) U ACTIVATED);",
            "#assert System() |= [](<>(startActive.1 || startActive.2 || startActive.3));",
            "/////Refinement Checking/////\nSystem_ACTIVE() = \tSystem() \\ {req, rel, \n\t\t\t\t\t\t\t\tstob,stob_init,\n\t\t\t\t\t\t\t\t_STARTUP,_STANDBY,_SYNC,_UP,_DOWN,\n\t\t\t\t\t\t\t\tset_pos.1,set_pos.2,set_pos.3,\n\t\t\t\t\t\t\t\tset_num.1,set_num.2,set_num.3,\n\t\t\t\t\t\t\t\topen_relay,close_relay,\n\t\t\t\t\t\t\t\tupdate_r_list,\n\t\t\t\t\t\t\t\tbtos.1, btos.2, btos.3,\n\t\t\t\t\t\t\t\tdone_btos.1, done_btos.2, done_btos.3,\n\t\t\t\t\t\t\t\tsetref.1, setref.2, setref.3,\n\t\t\t\t\t\t\t\tset_relay_close, set_relay_open,\n\t\t\t\t\t\t\t\tset_message,\n\t\t\t\t\t\t\t\tset_stable,\n\t\t\t\t\t\t\t\tendCheckProblem1,\n\t\t\t\t\t\t\t\tadopt_state,\n\t\t\t\t\t\t\t\tstable,\n\t\t\t\t\t\t\t\tup.1, up.2, up.3,\n\t\t\t\t\t\t\t\tdown.1, down.2, down.3,\n\t\t\t\t\t\t\t\tmove.1, move.2, move.3\t\t\t\t\n\t\t\t\t\t\t\t\t};\n\n\nACTIVE_ORDERED() = \t(startActive.1 -> release.1 -> startActive.2 -> release.2 -> startActive.3 -> release.3 -> ACTIVE_ORDERED())\n\t\t\t\t\t[]\n\t\t\t\t  \t(startActive.1 -> release.1 -> startActive.3 -> release.3 -> startActive.2 -> release.2 -> ACTIVE_ORDERED())\n\t\t\t\t  \t[]\n\t\t\t\t  \t(startActive.2 -> release.2 -> startActive.1 -> release.1 -> startActive.3 -> release.3 -> ACTIVE_ORDERED())\n\t\t\t\t  \t[]\n\t\t\t\t  \t(startActive.2 -> release.2 -> startActive.3 -> release.3 -> startActive.1 -> release.1 -> ACTIVE_ORDERED())\n\t\t\t\t  \t[]\n\t\t\t\t  \t(startActive.3 -> release.3 -> startActive.1 -> release.1 -> startActive.2 -> release.2 -> ACTIVE_ORDERED())\n\t\t\t\t  \t[]\n\t\t\t\t  \t(startActive.3 -> release.3 -> startActive.2 -> release.2 -> startActive.1 -> release.1 -> ACTIVE_ORDERED())\n\t\t\t\t\t;\n#assert ACTIVE_ORDERED()  refines System_ACTIVE();",
            "ACTIVE_RANDOMLY() = \t(startActive.1 -> release.1 -> ACTIVE_RANDOMLY())\n\t\t\t\t\t[]\n\t\t\t\t\t(startActive.2 -> release.2 -> ACTIVE_RANDOMLY())\n\t\t\t\t\t[]\n\t\t\t\t\t(startActive.3 -> release.3 -> ACTIVE_RANDOMLY())\n\t\t\t\t\t;\t\t\t\t\n#assert ACTIVE_RANDOMLY()  refines System_ACTIVE();",
            "System_MOVE() = \tSystem() \\ {req, rel, \n\t\t\t\t\t\t\t\tstob,stob_init,\n\t\t\t\t\t\t\t\t_STARTUP,_STANDBY,_SYNC,_UP,_DOWN,\n\t\t\t\t\t\t\t\tset_pos.1,set_pos.2,set_pos.3,\n\t\t\t\t\t\t\t\tset_num.1,set_num.2,set_num.3,\n\t\t\t\t\t\t\t\topen_relay,close_relay,\n\t\t\t\t\t\t\t\tbtos.1, btos.2, btos.3,\n\t\t\t\t\t\t\t\tdone_btos.1, done_btos.2, done_btos.3,\n\t\t\t\t\t\t\t\tsetref.1, setref.2, setref.3,\n\t\t\t\t\t\t\t\tset_relay_close, set_relay_open,\n\t\t\t\t\t\t\t\tset_message,set_stable,\n\t\t\t\t\t\t\t\tendCheckProblem1,\n\t\t\t\t\t\t\t\tadopt_state,stable,\n\t\t\t\t\t\t\t\tup.1, up.2, up.3,\n\t\t\t\t\t\t\t\tdown.1, down.2, down.3,update_r_list\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\nMOVE_After_ACTIVE() = \t(startActive.1 -> move.1 -> move.2 -> move.3 -> release.1 -> MOVE_After_ACTIVE())\n\t\t\t\t\t[]\n\t\t\t\t\t(startActive.1 -> move.1 -> move.3 -> move.2 -> release.1 -> MOVE_After_ACTIVE())\n\t\t\t\t\t[]\n\t\t\t\t\t(startActive.1 -> move.2 -> move.1 -> move.3 -> release.1 -> MOVE_After_ACTIVE())\n\t\t\t\t\t[]\n\t\t\t\t\t(startActive.1 -> move.2 -> move.3 -> move.1 -> release.1 -> MOVE_After_ACTIVE())\n\t\t\t\t\t[]\n\t\t\t\t\t(startActive.1 -> move.3 -> move.1 -> move.2 -> release.1 -> MOVE_After_ACTIVE())\n\t\t\t\t\t[]\n\t\t\t\t\t(startActive.1 -> move.3 -> move.2 -> move.1 -> release.1 -> MOVE_After_ACTIVE())\n\t\t\t\t\t[]\t\n\t\t\t\t\t(startActive.2 -> move.1 -> move.2 -> move.3 -> release.2 -> MOVE_After_ACTIVE())\n\t\t\t\t\t[]\n\t\t\t\t\t(startActive.2 -> move.1 -> move.3 -> move.2 -> release.2 -> MOVE_After_ACTIVE())\n\t\t\t\t\t[]\n\t\t\t\t\t(startActive.2 -> move.2 -> move.1 -> move.3 -> release.2 -> MOVE_After_ACTIVE())\n\t\t\t\t\t[]\n\t\t\t\t\t(startActive.2 -> move.2 -> move.3 -> move.1 -> release.2 -> MOVE_After_ACTIVE())\n\t\t\t\t\t[]\n\t\t\t\t\t(startActive.2 -> move.3 -> move.1 -> move.2 -> release.2 -> MOVE_After_ACTIVE())\n\t\t\t\t\t[]\n\t\t\t\t\t(startActive.2 -> move.3 -> move.2 -> move.1 -> release.2 -> MOVE_After_ACTIVE())\n\t\t\t\t\t[]\t\n\t\t\t\t\t(startActive.3 -> move.1 -> move.2 -> move.3 -> release.3 -> MOVE_After_ACTIVE())\n\t\t\t\t\t[]\n\t\t\t\t\t(startActive.3 -> move.1 -> move.3 -> move.2 -> release.3 -> MOVE_After_ACTIVE())\n\t\t\t\t\t[]\n\t\t\t\t\t(startActive.3 -> move.2 -> move.1 -> move.3 -> release.3 -> MOVE_After_ACTIVE())\n\t\t\t\t\t[]\n\t\t\t\t\t(startActive.3 -> move.2 -> move.3 -> move.1 -> release.3 -> MOVE_After_ACTIVE())\n\t\t\t\t\t[]\n\t\t\t\t\t(startActive.3 -> move.3 -> move.1 -> move.2 -> release.3 -> MOVE_After_ACTIVE())\n\t\t\t\t\t[]\n\t\t\t\t\t(startActive.3 -> move.3 -> move.2 -> move.1 -> release.3 -> MOVE_After_ACTIVE());\n#assert System_MOVE()  refines MOVE_After_ACTIVE();"
        ],
        "path": "pat_examples/csp_module/Real World Problems/Lifting Truck System.csp"
    },
    {
        "name": "Security Socket Layer (SSL) Protocol",
        "tags": [
            "Protocol",
            "Attacker"
        ],
        "use_non_container_lib": false,
        "description": "This model demonstrates how to re-uncover a flaw in the secure sockets layer protocol that allows attackers to inject text into encrypted traffic passing between two endpoints. \n\n  Handshake Protocol is used to establish sessions. This protocol allows the client and server to authenticate each other by sending a series of messages to each other. Handshake protocol uses four phases to complete its cycle. \n  - Phase-1: In Phase-1 both Client and Server send hello-packets to each other.\n  - Phase-2: Server sends his certificate and Server-key-exchange. The server end phase-2 by sending the Server-hello-end packet. \n  - Phase-3: In this phase, Client replies to the server by sending his certificate and Client-exchange-key. \n  - Phase-4: In Phase-4 Change-cipher suite occurs and after this the Handshake Protocol ends. \n  \n  SSL renegotiation is a process within the SSL/TLS protocol where the client and server agree to establish a new SSL connection using the existing one without interrupting the ongoing data transmission. This process is similar to the initial SSL handshake.\n  \n  The vulnerability in the transport layer security protocol allows man-in-the-middle attackers to surreptitiously introduce text at the beginning of an SSL session, said Marsh Ray, a security researcher who discovered the bug. A typical SSL transaction may be broken into multiple sessions, providing the attacker ample opportunity to sneak password resets and other commands into communications believed to be cryptographically authenticated.\n  the attacker intercepts the initial TLS handshake between a client and server. The attacker then establishes two separate TLS connections: one with the client, using a fake certificate that appears to be from the server, and another with the legitimate server, using the real certificate. This allows the attacker to decrypt, read, and potentially modify all data passing between the client and server in transit, while both parties believe they're communicating directly and securely with the intended recipient. The attacker acts as a transparent proxy, relaying communication between the parties and injecting themselves into the conversation without their knowledge.",
        "content": "enum{ServerHello,ServerCertificate,ServerKeyExchange,ServerCertificateRequest,\n        ServerHelloDone,ServerChangeCipherSpec,ServerFinished,HelloRequest,\n        Certificate,KeyExchange,CertificateVerify,ChangeCipherSpec,Finished,Hello,\n        Nobody, Client, Server, Attacker,\n        client_server_key, attacker_server_key};\n\nchannel network 0;\nchannel attackerBuffer 3;\n\nvar client_connects = Nobody;\nvar server_connects = Nobody;\nvar attacker_server_connected = false;\n\nClientProc() = ClientNegotiate();\nClientNegotiate() = \n   network!Client.Hello ->\n   network?ServerHello ->\n   network?ServerCertificate ->\n   network?ServerKeyExchange ->\n   network?ServerCertificateRequest ->\n   network?ServerHelloDone ->\n   network!Client.Certificate ->\n   network!Client.KeyExchange ->\n   network!Client.CertificateVerify ->\n   network!Client.ChangeCipherSpec ->\n   network!Client.Finished ->\n   network?ServerChangeCipherSpec ->\n   network?ServerFinished ->\n   clientconnected{client_connects = Server} ->\n   ClientConnected();\n   \nClientConnected() = network?client_server_key.HelloRequest -> ClientReNegotiate();\n\nClientReNegotiate() = \n   network!client_server_key.Client.Hello ->\n   network?client_server_key.ServerHello ->\n   network?client_server_key.ServerCertificate ->\n   network?client_server_key.ServerKeyExchange ->\n   network?client_server_key.ServerCertificateRequest ->\n   network?client_server_key.ServerHelloDone ->\n   network!client_server_key.Client.Certificate ->\n   network!client_server_key.Client.KeyExchange ->\n   network!client_server_key.Client.CertificateVerify ->\n   network!client_server_key.Client.ChangeCipherSpec ->\n   network!client_server_key.Client.Finished ->\n   network?client_server_key.ServerChangeCipherSpec ->\n   network?client_server_key.ServerFinished ->\n   ClientConnected();\n\nServerProc() = ServerNegotiate();\nServerNegotiate() = \n   network?x.Hello ->\n   network!ServerHello ->\n   network!ServerCertificate ->\n   network!ServerKeyExchange ->\n   network!ServerCertificateRequest ->\n   network!ServerHelloDone ->\n   network?x.Certificate ->\n   network?x.KeyExchange ->\n   network?x.CertificateVerify ->\n   network?x.ChangeCipherSpec ->\n   network?x.Finished ->\n   network!ServerChangeCipherSpec ->\n   network!ServerFinished ->\n   serverconnected{server_connects = x} ->\n   ServerConnected(x);\n\nServerConnected(x) =\n   if (x == Client) {\n       network!client_server_key.HelloRequest -> ServerReNegotiate(client_server_key)\n   }\n   else {\n       network!attacker_server_key.HelloRequest -> ServerReNegotiate(attacker_server_key)\n   };\n\nServerReNegotiate(x) = \n   network?x.y.Hello ->\n   network!x.ServerHello ->\n   network!x.ServerCertificate ->\n   network!x.ServerKeyExchange ->\n   network!x.ServerCertificateRequest ->\n   network!x.ServerHelloDone ->\n   network?x.y.Certificate ->\n   network?x.y.KeyExchange ->\n   network?x.y.CertificateVerify ->\n   network?x.y.ChangeCipherSpec ->\n   network?x.y.Finished ->\n   network!x.ServerChangeCipherSpec ->\n   network!x.ServerFinished ->\n   serverconnected{server_connects = y} ->\n   ServerConnected(y);\n\naSystem = ClientProc() ||| ServerProc();\nbSystem = AttackerProc() ||| ServerProc();\n\nAttackerProc() = AttackerNegotiate() [] AttackerAsServer() [] AttackerRelay() [] AttackerReNegotiate();\n\nAttackerRelay() = attackerBuffer?x.y -> network!attacker_server_key.x.y -> AttackerProc()\n               [] network?y.z -> attackerBuffer!y.z -> AttackerProc() \n               [] network?attacker_server_key.y -> network!y -> AttackerProc() \n               [] network?y.z -> network!attacker_server_key.y.z -> AttackerProc();\n\nAttackerAsServer() = network?Client.Hello -> attackerBuffer!Client.Hello -> AttackerProc();\n\nAttackerNegotiate() = \n   network!Attacker.Hello ->\n   network?ServerHello ->\n   network?ServerCertificate ->\n   network?ServerKeyExchange ->\n   network?ServerCertificateRequest ->\n   network?ServerHelloDone ->\n   network!Attacker.Certificate ->\n   network!Attacker.KeyExchange ->\n   network!Attacker.CertificateVerify ->\n   network!Attacker.ChangeCipherSpec ->\n   network!Attacker.Finished ->\n   network?ServerChangeCipherSpec ->\n   network?ServerFinished ->\n   attackerconnected{attacker_server_connected = true} ->\n   AttackerConnected();\n\nAttackerConnected() = network?attacker_server_key.HelloRequest -> AttackerProc();\n\nAttackerReNegotiate() = \n   network!attacker_server_key.Attacker.Hello ->\n   network?attacker_server_key.ServerHello ->\n   network?attacker_server_key.ServerCertificate ->\n   network?attacker_server_key.ServerKeyExchange ->\n   network?attacker_server_key.ServerCertificateRequest ->\n   network?attacker_server_key.ServerHelloDone ->\n   network!attacker_server_key.Attacker.Certificate ->\n   network!attacker_server_key.Attacker.KeyExchange ->\n   network!attacker_server_key.Attacker.CertificateVerify ->\n   network!attacker_server_key.Attacker.ChangeCipherSpec ->\n   network!attacker_server_key.Attacker.Finished ->\n   network?attacker_server_key.ServerChangeCipherSpec ->\n   network?attacker_server_key.ServerFinished ->\n   AttackerConnected();\n\nSpecificAttacker = \n   network?Client.Hello -> attackerBuffer!Client.Hello ->\n   network!Attacker.Hello ->\n   network?ServerHello ->\n   network?ServerCertificate ->\n   network?ServerKeyExchange ->\n   network?ServerCertificateRequest ->\n   network?ServerHelloDone ->\n   network!Attacker.Certificate ->\n   network!Attacker.KeyExchange ->\n   network!Attacker.CertificateVerify ->\n   network!Attacker.ChangeCipherSpec ->\n   network!Attacker.Finished ->\n   network?ServerChangeCipherSpec ->\n   network?ServerFinished ->\n   attackerconnected{attacker_server_connected = true} ->\n   network?attacker_server_key.HelloRequest ->\n   attackerBuffer?Client.Hello ->\n   network!attacker_server_key.Client.Hello -> \n   SpecificRelay();\n\nSpecificRelay() = network?attacker_server_key.y -> network!y -> SpecificRelay()\n               [] network?x.z -> network!attacker_server_key.x.z -> SpecificRelay();\n\nTLS = ServerProc() ||| AttackerProc() ||| ClientProc();\nTLSWithSpecificAttacker = ServerProc() ||| SpecificAttacker() ||| ClientProc();",
        "property_desc": [
            "The system is deadlock-free.",
            "The successful execution of the man-in-the-middle attack",
            "The successful execution of the man-in-the-middle attack"
        ],
        "properties": [
            "#assert TLS deadlockfree;",
            "#define violation attacker_server_connected && server_connects == Client && client_connects == Server;\n#assert TLS reaches violation;",
            "#assert TLSWithSpecificAttacker reaches violation;"
        ],
        "path": "pat_examples/csp_module/Real World Problems/Secure Sockets Layer (SSL) Protocol.csp"
    },
    {
        "name": "DBM Testing",
        "tags": [
            "Algorithm"
        ],
        "use_non_container_lib": true,
        "description": "A Difference Bound Matrix (DBM) is a mathematical representation used to model and analyze systems with constraints on differences between variables, particularly in the context of real-time systems and formal verification. It is a compact and efficient way to represent and manipulate difference constraints between pairs of variables.\n  This model is used for validating the correctness and reliability of DBM implementations.",
        "content": "#import \"PAT.Lib.DBM\";\n#import \"PAT.Lib.Set\";\n#import \"PAT.Math\";\n\n#define N 2;//the number of clocks of each DBM\n#define Ceiling 2;//the number of constraints added in each DBM\n#define Bound 4; //the timer bound\n\nvar<DBM> dbm1 = new DBM(Ceiling);\nvar<Set> timers1 = new Set();\nvar timerCount1 = 0;\nvar timerID1 = 1;\nvar result1 = false;\nvar isBounded = true;\nvar containsClock1 = false;\nvar stopped = false;\n\n\nDBMTest1() = ifa(timerCount1 < N) \n\t\t\t {\n\t\t\t\tnewTimerID{timerID1 = dbm1.GetNewTimerID();stopped=false} -> AddTimer.timerID1{dbm1.AddTimer(timerID1); timers1.Add(timerID1); timerCount1 = timers1.Count();} -> \n\t\t\t\t(Delay{dbm1.Delay()} -> \t\t\t\n\t\t\t\t(OneCycle1; \n\t\t\t\t\t check{result1 = dbm1.IsConstraintNotSatisfied(); isBounded=dbm1.IsTimersBounded(Bound);} ->\n\t\t\t\t\t ifa (!result1)\n\t\t\t\t\t {\n\t\t\t\t\t \tConstraintSatisfied -> (KeepTProcess1(timerCount1, call(Pow, 2, timerCount1)); (DBMTest1() [] ResetProcess1(timerCount1)))\n\t\t\t\t\t }\n\t\t\t\t\t else \n\t\t\t\t\t {\n\t\t\t\t\t \tConstraintNotSatisfied{dbm1 = new DBM(Ceiling); timers1 = new Set(); timerCount1 =0; timerID1 = 1;} -> DBMTest1()\n\t\t\t\t\t }\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\tstop{stopped =true;} -> DBMTest1()\n\t\t\t };\n\nOneCycle1() = (AddCProcess1(timerCount1); OneCycle1)\n\t\t      [] (Clone{dbm1.Clone()} -> OneCycle1)\n\t    \t  [] Skip;\n\t\t\t\nResetProcess1(size) = ifa(size > 0) { \n\t\t\t\t\t \t[]t:{0..size-1}@ResetTimer{dbm1.ResetTimer(timers1.Get(t))} -> DBMTest1()\n\t\t\t\t\t  } else {\n\t\t\t\t\t \t DBMTest1()\n\t\t\t\t\t  };\n\t\t\t\nKeepTProcess1(size, powset) =  ifa(size > 0) \n\t\t\t\t\t \t\t   {\n\t\t\t\t\t\t \t\t\tifa(powset ==1)\n\t\t\t\t\t\t \t\t\t{\n\t\t\t\t\t\t \t\t\t\tKeepTimers.1{dbm1 = dbm1.KeepTimers(timers1.GetSubsetByIndex(1)); timerCount1 = timers1.Count(); containsClock1=timers1.Contains(1); } -> Skip\n\t\t\t\t\t\t \t\t\t}\n\t\t\t\t\t\t \t        else\n\t\t\t\t\t\t \t\t\t{\n\t\t\t\t\t \t\t\t\t\t[] t:{1..powset-1}@KeepTimers.t{dbm1 = dbm1.KeepTimers(timers1.GetSubsetByIndex(t)); timerCount1 = timers1.Count(); containsClock1=timers1.Contains(1);} -> Skip\n\t\t\t\t\t\t \t\t\t}\n\t\t\t\t\t \t\t   };\t\t\t\t\t\n\nAddCProcess1(size) = ifa(size > 0) {\n\t\t\t\t\t\t([] t:{0..size-1}@ ([]op:{0..2}@ ([]value:{0..Ceiling}@ AddConstraint.t.op.value{dbm1.AddConstraint(timers1.Get(t), op, value);} -> Skip )))\n\t\t\t\t\t };",
        "property_desc": [
            "The model is deadlock-free.",
            "Check if the variable timerID1 will be 0.",
            "Check if the model is always time bounded.",
            "The algorithm reached the maximum timers or the clock with ID 1 is removed."
        ],
        "properties": [
            "#assert DBMTest1 deadlockfree;",
            "#define goal timerID1 == 0;\n#assert DBMTest1 reaches goal;",
            "#define goal1 isBounded == true;\n#assert DBMTest1 |= []goal1;",
            "#define goal2 stopped==true || containsClock1 == false;\n#assert DBMTest1 |= []<>goal2;"
        ],
        "path": "pat_examples/csp_module/Software Testing/DBM Testing.csp"
    }
]