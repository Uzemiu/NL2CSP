[
    {
        "name": "AMQP",
        "tags": [
            "Protocol"
        ],
        "use_non_container_lib": false,
        "description": "AMQP is a protocol used for message-oriented middleware, enabling systems to communicate asynchronously by sending and receiving messages through exchanges and queues.\n  The model contains 5 roles: Producer, Broker, Exchange, Queue and Consumer.",
        "pat_code": "// 2 consumers, 2 queues\n#define C 2;\n#define Q 2;\n\nchannel ComPE 0;\nchannel ComEQ[2] 5;\nchannel ComCQ[C*Q] 0; // Every consumer has a channel to Q.\n\nchannel ComCB 0; // Channel between consumer and agent to subscribe to a queue\n\nvar MSG_OF_C[2][5] = [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1];// Messages ids that the consumers received\nvar queue_msg = -1;// Message id received by the queue\nvar CList[Q][C]; // Indicates whether the consumer with cid C is subscribed to the Queue, 1 is subscribed, 0 is not subscribed\nvar ConsumerState[C][Q]; // Indicates the presence or absence of an open link between a consumer with consumer cid C and a queue with queue qid Q\nvar ComEQ_count = 0;\n\nvar c1_msg_index = 0;\nvar c2_msg_index = 0;\n\nvar IS_Q_EXISTS[Q];\n\nvar Consume_msg[C];\n\nenum {Nan1, Nan2, Nan3, Nan4, Nan5, Nan6, Nan7, Con, ConOK, ConClose, ConCloseOK, Sub, SubOK};\n\n#define get_ComCQ(cid,qid)\n{\n       cid*C+qid;\n};\n\n/*@Process: Producer\n  Producer is a component responsible for generating messages and transmitting them to the exchange. \n  1. The producer first establishes a connection between itself using the producer's id and the exchange's id.\n  2. It receives response from the exchange to confirm the successful establishment.\n  3. After establishing a connection with the exchange within the broker, the producer dispatches three messages in the row to the exchange, containing message id and routing key information. \n  4. When all messages are sent, it closes the connection between the producer and the exchange by sending a request and waiting for an acknowledgment.\n*/\nProducer(pid, eid, msgid1, msgid2, msgid3, rk) = \n    ComPE!pid.eid.Con -> ComPE?eid.pid.ConOK->\n    ComPE!pid.eid.msgid1.rk ->\n    ComPE!pid.eid.msgid2.rk ->\n    ComPE!pid.eid.msgid3.rk ->\n    ComPE!pid.eid.ConClose -> ComPE?pid.eid.ConCloseOK ->\n    Producer(pid, eid, msgid1, msgid2, msgid3, rk);\n\n/*@Process: Direct exchange\n  The direct exchange system has a producer a exchange two queues and two consumers, where the exchange and the two queues are bound by different binding keys, and one consumer subscribes to only one queue and the other consumer subscribes to all of the queues. \n  - It accepts connection requests and connection close requests from producers and send acknowledgment back.\n  - Or it accepts routes messages with message id from the producer and forward it to the appropriate queue based on the binding key.\n*/\nExchange(eid, bk) = ComPE?pid.eid.FIN -> if(FIN == Con)\n                                   {ComPE!eid.pid.ConOK -> Exchange(eid, bk)}\n                                   else if(FIN == ConClose)\n                                   {ComPE!eid.pid.ConCloseOK -> Exchange(eid, bk)}\n              []ComPE?pid.eid.msgid.rk -> if(rk == bk)\n                                        {ComEQ[rk]!msgid -> Exchange(eid, bk)}\n                                        else\n                                        {Exchange(eid, bk)};\n/*@Process: Fanout exchange     \n  The fanout exchange system is bound to one queue and one consumer subscribes to that queue. \n  - It accepts connection requests and connection close requests from producers and send acknowledgment back.\n  - Similar to Exchange, but broadcasts all messages to all queues regardless of the routing key.\n*/\nExchange2(eid) = ComPE?pid.eid.FIN -> if(FIN == Con)\n                                   {ComPE!eid.pid.ConOK -> Exchange2(eid)}\n                                   else if(FIN == ConClose)\n                                   {ComPE!eid.pid.ConCloseOK -> Exchange2(eid)}\n               []ComPE?pid.eid.msgid.rk -> ComEQ[0]!msgid -> Exchange2(eid);                         \n\n/*@Process: SUB1\n  Connection establishment between broker:\n  1. It sends a connection request to subscribe a consumer using its id and waits for acknowledgement\n  2. Then it sends to a broker a subscription request with the queue id and waits for acknowledgment. \n  3. It close the connection between the broker and waits for acknowledgement.\n*/\nSUB1(cid, qid) = ComCB!cid.Con -> ComCB?ConOK -> ComCB!cid.qid.Sub-> ComCB?cid.qid.SubOK -> ComCB!cid.ConClose -> ComCB?ConCloseOK -> Skip;\n/*@Process: CConnection1\n  Connection establishment between queue: \n  It sends a connection request to the queue using its id to a queue with the queue id and waits for acknowledgment and updates its internal state.\n*/\nCConnection1(cid, qid) = ComCQ[call(get_ComCQ,cid,qid)]!cid.qid.Con -> ComCQ[call(get_ComCQ,cid,qid)]?qid.cid.ConOK{ConsumerState[cid][qid] = 1;} -> Skip;\n/*@Process: RECEIVE1\n  Message receiving: \n  It receives messages from the queue, stores received messages and tracks the number of messages received.\n*/\nRECEIVE1(cid, qid) = if(c1_msg_index <= 4)\n                    {ComCQ[call(get_ComCQ,cid,qid)]?qid.cid.msgid {MSG_OF_C[cid][c1_msg_index] = msgid; c1_msg_index = c1_msg_index + 1; Consume_msg[cid] = 1; } -> RECEIVE1(cid, qid)}\n                    else\n                    {ComCQ[call(get_ComCQ,cid,qid)]?qid.cid.msgid -> RECEIVE1(cid, qid)};\n\n/*@Process: CConClose1\n  Connection close: \n  After receiving messages, it closes the connection between the queue by sending close request to the queue with the consumer's id and the queue id and waits for acknowledgment.\n*/\nCConClose1(cid, qid) = ComCQ[call(get_ComCQ,cid,qid)]!cid.qid.ConClose -> ComCQ[call(get_ComCQ,cid,qid)]?qid.cid.ConCloseOK {ConsumerState[cid][qid] = 0;} -> Skip;\n\n/*@Process: Consumer1\n  The consumer has four phase:\n  1. Connection establishment between broker\n  2. Connection establishment between queue\n  3. Message receiving\n  4. Connection close\n*/\nConsumer1(cid, qid) = SUB1(cid, qid); CConnection1(cid, qid); RECEIVE1(cid, qid); CConClose1(cid, qid); Consumer1(cid, qid);\n\n/*@Process: BrokerC\n  Broker: It is accountable for orchestrating the delivery of messages, comprising of exchanges and queues. \n  - Acccepts connection and disconnection requests from consumers and sends acknowledgment back.\n  - 1. Or accepts subscription requests from the consumer with the queue id.\n    2. It then creates the queue if the queue doesn'e exists sends subscription acknowledgment to consumers.\n    3. Or, updates the subscription list and sends subscription acknowledgment to consumers.\n*/\nBrokerC() = ComCB?cid.FIN -> if(FIN == Con)\n                              {ComCB!ConOK -> BrokerC()}\n                             else if(FIN == ConClose) \n                              {ComCB!ConCloseOK -> BrokerC()}\n          []ComCB?cid.qid.Sub -> if(IS_Q_EXISTS[qid] == 0)\n                                 {Create_and_sub_Q {IS_Q_EXISTS[qid] =1;CList[qid][cid] = 1} -> ComCB!cid.qid.SubOK -> BrokerC()}\n                                 else\n                                 {Sub_Q{CList[qid][cid] = 1} -> ComCB!cid.qid.SubOK -> BrokerC()};                       \n\n/*@Process: Queue\n  Queue: It is bound to exchanges and constitutes a component tasked with message storage and accepting messages dispatched by exchanges according to routing rules.\n  - It receives messages from the exchange, but only after the link is established. And it delivers messages to consumers subscribed to the queue\n  - It also handles connection and disconnection requests from different consumers and send acknowledgment back.\n*/\nQueue(qid) = if( CList[qid][0] == 1 &&  CList[qid][1] == 1 && ConsumerState[0][qid] == 1 && ConsumerState[1][qid] == 1)// Consumers subscribed to the queue will receive messages only after the link is established,are subscribed\n                                                                                                                       // ConsumerState ensures that the consumer link is established.\n               {ComEQ[qid]?msgid {queue_msg = msgid;} -> ComCQ[call(get_ComCQ, 0, qid)]!qid.0.msgid -> ComCQ[call(get_ComCQ, 1, qid)]!qid.1.msgid -> Queue(qid)}\n             else if(CList[qid][1] == 1 && ConsumerState[1][qid] == 1) // Only consumers with a cid of 1 can subscribe\n               {ComEQ[qid]?msgid {queue_msg = msgid;} -> ComCQ[call(get_ComCQ, 1, qid)]!qid.1.msgid -> Queue(qid)}\n             else if(CList[qid][0] == 1 && ConsumerState[0][qid] == 1) // Only consumers with a cid of 0 can subscribe\n               {ComEQ[qid]?msgid {queue_msg = msgid;} -> ComCQ[call(get_ComCQ, 0, qid)]!qid.0.msgid -> Queue(qid)}\n               else\n               {Queue(qid)}\n                                                                                                    \n        [](ComCQ[call(get_ComCQ, 0, qid)]?cid.qid.Con -> ComCQ[call(get_ComCQ, 0, qid)]!qid.cid.ConOK -> Queue(qid)\n         []ComCQ[call(get_ComCQ, 1, qid)]?cid.qid.Con -> ComCQ[call(get_ComCQ, 1, qid)]!qid.cid.ConOK -> Queue(qid))\n        [](ComCQ[call(get_ComCQ, 0, qid)]?cid.qid.ConClose -> ComCQ[call(get_ComCQ, 0, qid)]!qid.cid.ConCloseOK -> Queue(qid)\n         []ComCQ[call(get_ComCQ, 1, qid)]?cid.qid.ConClose -> ComCQ[call(get_ComCQ, 1, qid)]!qid.cid.ConCloseOK -> Queue(qid));\n\n/*@Process: System\n  The system is the parallel composition of the producer, the direct exchange, the queues, the consumers and the broker.\n*/       \nvar MSGID1 = 0;\nvar MSGID2 = 1;\nvar MSGID3 = 2;\n\nvar PID = 0;\nvar EID = 0;\nvar QID1 = 0;\nvar QID2 = 1;\nvar CID1 = 0;\nvar CID2 = 1;\nvar RK = 0; // Routing key of the producer to the exchange\nvar BK = 0; // Binding key for the queue bound to the exchange\n\n// direct exchange      \nSystem() =(Producer(PID,EID,MSGID1,MSGID2,MSGID3,RK)||Exchange(EID,BK)||Queue(QID1)||Consumer1(CID1,QID1||BrokerC());\n\n/*@Process: System2\n  The system2 is the parallel composition of the producer, the fanout exchange, the queue, the consumer and the broker.\n*/\n// fanout exchange\nSystem2() =(Producer(PID,EID,MSGID1,MSGID2,MSGID3,RK)||Exchange2(EID)||Queue(QID1)||Consumer1(CID1,QID1)||BrokerC());",
        "property_desc": [
            "The system is deadlock-free.",
            "For the system with direct exchange, the messages sent can be consumed.",
            "For the system with direct exchange, the order inwhich themessages are consumed by the consumer is the same as the order inwhich those are produced by the producer.",
            "For the system with direct exchange, AMQP supports concurrent operations, meaning producers can produce messages for multiple consumers, andmultiple consumers can consume messages as well.",
            "For the system with direct exchange, if a consumer subscribes to a non-existent queue, the queue is created before the subscription occurs.",
            "For the system with fanout exchange, the messages sent can be consumed.",
            "For the system with fanout exchange, the order inwhich themessages are consumed by the consumer is the same as the order inwhich those are produced by the producer.",
            "For the system with fanout exchange, AMQP supports concurrent operations, meaning producers can produce messages for multiple consumers, andmultiple consumers can consume messages as well.",
            "For the system with fanout exchange, if a consumer subscribes to a non-existent queue, the queue is created before the subscription occurs."
        ],
        "properties": [
            "#assert System() deadlockfree;",
            "#define Reachability {(MSG_OF_C[0][0] != -1 && MSG_OF_C[0][1] != -1 && MSG_OF_C[0][2] != -1 && MSG_OF_C[0][3] != -1 && MSG_OF_C[0][4] != -1 )\n                    ||(MSG_OF_C[1][0] != -1 && MSG_OF_C[1][1] != -1 && MSG_OF_C[1][2] != -1 && MSG_OF_C[1][3] != -1 && MSG_OF_C[1][4] != -1 )};\n#assert System() reaches Reachability;",
            "#define Sequentiality{MSG_OF_C[0][0] <= MSG_OF_C[0][1] \n                   && MSG_OF_C[0][1] <= MSG_OF_C[0][2]\n                   && MSG_OF_C[1][0] <= MSG_OF_C[1][1]\n                   && MSG_OF_C[1][1] <= MSG_OF_C[1][2]\n                   };\n#assert System() |=<> Sequentiality;",
            "#define Concurrency{Consume_msg[0] != 0 && Consume_msg[1] != 0};\n#assert System() reaches Concurrency;",
            "#define Scalability{IS_Q_EXISTS[0] != 0 || IS_Q_EXISTS[1] != 0};\n#assert System() reaches Scalability;",
            "#assert System2() deadlockfree;",
            "#assert System2() reaches Reachability;",
            "#assert System2() |=<> Sequentiality;",
            "#define Concurrency2{Consume_msg[0] != 0};\n#assert System2() reaches Concurrency2;",
            "#assert System2() reaches Scalability;"
        ],
        "processes": [
            {
                "name": "Producer",
                "description": "Producer is a component responsible for generating messages and transmitting them to the exchange. \n  1. The producer first establishes a connection between itself using the producer's id and the exchange's id.\n  2. It receives response from the exchange to confirm the successful establishment.\n  3. After establishing a connection with the exchange within the broker, the producer dispatches three messages in the row to the exchange, containing message id and routing key information. \n  4. When all messages are sent, it closes the connection between the producer and the exchange by sending a request and waiting for an acknowledgment.",
                "pat_code": "Producer(pid, eid, msgid1, msgid2, msgid3, rk) = \n    ComPE!pid.eid.Con -> ComPE?eid.pid.ConOK->\n    ComPE!pid.eid.msgid1.rk ->\n    ComPE!pid.eid.msgid2.rk ->\n    ComPE!pid.eid.msgid3.rk ->\n    ComPE!pid.eid.ConClose -> ComPE?pid.eid.ConCloseOK ->\n    Producer(pid, eid, msgid1, msgid2, msgid3, rk);"
            },
            {
                "name": "Direct exchange",
                "description": "The direct exchange system has a producer a exchange two queues and two consumers, where the exchange and the two queues are bound by different binding keys, and one consumer subscribes to only one queue and the other consumer subscribes to all of the queues. \n  - It accepts connection requests and connection close requests from producers and send acknowledgment back.\n  - Or it accepts routes messages with message id from the producer and forward it to the appropriate queue based on the binding key.",
                "pat_code": "Exchange(eid, bk) = ComPE?pid.eid.FIN -> if(FIN == Con)\n                                   {ComPE!eid.pid.ConOK -> Exchange(eid, bk)}\n                                   else if(FIN == ConClose)\n                                   {ComPE!eid.pid.ConCloseOK -> Exchange(eid, bk)}\n              []ComPE?pid.eid.msgid.rk -> if(rk == bk)\n                                        {ComEQ[rk]!msgid -> Exchange(eid, bk)}\n                                        else\n                                        {Exchange(eid, bk)};"
            },
            {
                "name": "Fanout exchange",
                "description": "The fanout exchange system is bound to one queue and one consumer subscribes to that queue. \n  - It accepts connection requests and connection close requests from producers and send acknowledgment back.\n  - Similar to Exchange, but broadcasts all messages to all queues regardless of the routing key.",
                "pat_code": "Exchange2(eid) = ComPE?pid.eid.FIN -> if(FIN == Con)\n                                   {ComPE!eid.pid.ConOK -> Exchange2(eid)}\n                                   else if(FIN == ConClose)\n                                   {ComPE!eid.pid.ConCloseOK -> Exchange2(eid)}\n               []ComPE?pid.eid.msgid.rk -> ComEQ[0]!msgid -> Exchange2(eid);"
            },
            {
                "name": "SUB1",
                "description": "Connection establishment between broker:\n  1. It sends a connection request to subscribe a consumer using its id and waits for acknowledgement\n  2. Then it sends to a broker a subscription request with the queue id and waits for acknowledgment. \n  3. It close the connection between the broker and waits for acknowledgement.",
                "pat_code": "SUB1(cid, qid) = ComCB!cid.Con -> ComCB?ConOK -> ComCB!cid.qid.Sub-> ComCB?cid.qid.SubOK -> ComCB!cid.ConClose -> ComCB?ConCloseOK -> Skip;"
            },
            {
                "name": "CConnection1",
                "description": "Connection establishment between queue: \n  It sends a connection request to the queue using its id to a queue with the queue id and waits for acknowledgment and updates its internal state.",
                "pat_code": "CConnection1(cid, qid) = ComCQ[call(get_ComCQ,cid,qid)]!cid.qid.Con -> ComCQ[call(get_ComCQ,cid,qid)]?qid.cid.ConOK{ConsumerState[cid][qid] = 1;} -> Skip;"
            },
            {
                "name": "RECEIVE1",
                "description": "Message receiving: \n  It receives messages from the queue, stores received messages and tracks the number of messages received.",
                "pat_code": "RECEIVE1(cid, qid) = if(c1_msg_index <= 4)\n                    {ComCQ[call(get_ComCQ,cid,qid)]?qid.cid.msgid {MSG_OF_C[cid][c1_msg_index] = msgid; c1_msg_index = c1_msg_index + 1; Consume_msg[cid] = 1; } -> RECEIVE1(cid, qid)}\n                    else\n                    {ComCQ[call(get_ComCQ,cid,qid)]?qid.cid.msgid -> RECEIVE1(cid, qid)};"
            },
            {
                "name": "CConClose1",
                "description": "Connection close: \n  After receiving messages, it closes the connection between the queue by sending close request to the queue with the consumer's id and the queue id and waits for acknowledgment.",
                "pat_code": "CConClose1(cid, qid) = ComCQ[call(get_ComCQ,cid,qid)]!cid.qid.ConClose -> ComCQ[call(get_ComCQ,cid,qid)]?qid.cid.ConCloseOK {ConsumerState[cid][qid] = 0;} -> Skip;"
            },
            {
                "name": "Consumer1",
                "description": "The consumer has four phase:\n  1. Connection establishment between broker\n  2. Connection establishment between queue\n  3. Message receiving\n  4. Connection close",
                "pat_code": "Consumer1(cid, qid) = SUB1(cid, qid); CConnection1(cid, qid); RECEIVE1(cid, qid); CConClose1(cid, qid); Consumer1(cid, qid);"
            },
            {
                "name": "BrokerC",
                "description": "Broker: It is accountable for orchestrating the delivery of messages, comprising of exchanges and queues. \n  - Acccepts connection and disconnection requests from consumers and sends acknowledgment back.\n  - 1. Or accepts subscription requests from the consumer with the queue id.\n    2. It then creates the queue if the queue doesn'e exists sends subscription acknowledgment to consumers.\n    3. Or, updates the subscription list and sends subscription acknowledgment to consumers.",
                "pat_code": "BrokerC() = ComCB?cid.FIN -> if(FIN == Con)\n                              {ComCB!ConOK -> BrokerC()}\n                             else if(FIN == ConClose) \n                              {ComCB!ConCloseOK -> BrokerC()}\n          []ComCB?cid.qid.Sub -> if(IS_Q_EXISTS[qid] == 0)\n                                 {Create_and_sub_Q {IS_Q_EXISTS[qid] =1;CList[qid][cid] = 1} -> ComCB!cid.qid.SubOK -> BrokerC()}\n                                 else\n                                 {Sub_Q{CList[qid][cid] = 1} -> ComCB!cid.qid.SubOK -> BrokerC()};"
            },
            {
                "name": "Queue",
                "description": "Queue: It is bound to exchanges and constitutes a component tasked with message storage and accepting messages dispatched by exchanges according to routing rules.\n  - It receives messages from the exchange, but only after the link is established. And it delivers messages to consumers subscribed to the queue\n  - It also handles connection and disconnection requests from different consumers and send acknowledgment back.",
                "pat_code": "Queue(qid) = if( CList[qid][0] == 1 &&  CList[qid][1] == 1 && ConsumerState[0][qid] == 1 && ConsumerState[1][qid] == 1)// Consumers subscribed to the queue will receive messages only after the link is established,are subscribed\n                                                                                                                       // ConsumerState ensures that the consumer link is established.\n               {ComEQ[qid]?msgid {queue_msg = msgid;} -> ComCQ[call(get_ComCQ, 0, qid)]!qid.0.msgid -> ComCQ[call(get_ComCQ, 1, qid)]!qid.1.msgid -> Queue(qid)}\n             else if(CList[qid][1] == 1 && ConsumerState[1][qid] == 1) // Only consumers with a cid of 1 can subscribe\n               {ComEQ[qid]?msgid {queue_msg = msgid;} -> ComCQ[call(get_ComCQ, 1, qid)]!qid.1.msgid -> Queue(qid)}\n             else if(CList[qid][0] == 1 && ConsumerState[0][qid] == 1) // Only consumers with a cid of 0 can subscribe\n               {ComEQ[qid]?msgid {queue_msg = msgid;} -> ComCQ[call(get_ComCQ, 0, qid)]!qid.0.msgid -> Queue(qid)}\n               else\n               {Queue(qid)}\n                                                                                                    \n        [](ComCQ[call(get_ComCQ, 0, qid)]?cid.qid.Con -> ComCQ[call(get_ComCQ, 0, qid)]!qid.cid.ConOK -> Queue(qid)\n         []ComCQ[call(get_ComCQ, 1, qid)]?cid.qid.Con -> ComCQ[call(get_ComCQ, 1, qid)]!qid.cid.ConOK -> Queue(qid))\n        [](ComCQ[call(get_ComCQ, 0, qid)]?cid.qid.ConClose -> ComCQ[call(get_ComCQ, 0, qid)]!qid.cid.ConCloseOK -> Queue(qid)\n         []ComCQ[call(get_ComCQ, 1, qid)]?cid.qid.ConClose -> ComCQ[call(get_ComCQ, 1, qid)]!qid.cid.ConCloseOK -> Queue(qid));"
            },
            {
                "name": "System",
                "description": "The system is the parallel composition of the producer, the direct exchange, the queues, the consumers and the broker.",
                "pat_code": "var MSGID1 = 0;\nvar MSGID2 = 1;\nvar MSGID3 = 2;\n\nvar PID = 0;\nvar EID = 0;\nvar QID1 = 0;\nvar QID2 = 1;\nvar CID1 = 0;\nvar CID2 = 1;\nvar RK = 0; // Routing key of the producer to the exchange\nvar BK = 0; // Binding key for the queue bound to the exchange\n\n// direct exchange      \nSystem() =(Producer(PID,EID,MSGID1,MSGID2,MSGID3,RK)||Exchange(EID,BK)||Queue(QID1)||Consumer1(CID1,QID1||BrokerC());"
            },
            {
                "name": "System2",
                "description": "The system2 is the parallel composition of the producer, the fanout exchange, the queue, the consumer and the broker.",
                "pat_code": "// fanout exchange\nSystem2() =(Producer(PID,EID,MSGID1,MSGID2,MSGID3,RK)||Exchange2(EID)||Queue(QID1)||Consumer1(CID1,QID1)||BrokerC());"
            }
        ],
        "global_definition": "// 2 consumers, 2 queues\n#define C 2;\n#define Q 2;\n\nchannel ComPE 0;\nchannel ComEQ[2] 5;\nchannel ComCQ[C*Q] 0; // Every consumer has a channel to Q.\n\nchannel ComCB 0; // Channel between consumer and agent to subscribe to a queue\n\nvar MSG_OF_C[2][5] = [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1];// Messages ids that the consumers received\nvar queue_msg = -1;// Message id received by the queue\nvar CList[Q][C]; // Indicates whether the consumer with cid C is subscribed to the Queue, 1 is subscribed, 0 is not subscribed\nvar ConsumerState[C][Q]; // Indicates the presence or absence of an open link between a consumer with consumer cid C and a queue with queue qid Q\nvar ComEQ_count = 0;\n\nvar c1_msg_index = 0;\nvar c2_msg_index = 0;\n\nvar IS_Q_EXISTS[Q];\n\nvar Consume_msg[C];\n\nenum {Nan1, Nan2, Nan3, Nan4, Nan5, Nan6, Nan7, Con, ConOK, ConClose, ConCloseOK, Sub, SubOK};\n\n#define get_ComCQ(cid,qid)\n{\n       cid*C+qid;\n};",
        "path": "handwrite/AMQP.csp"
    },
    {
        "name": "AUPS",
        "tags": [
            "Subscription-based IoT system"
        ],
        "use_non_container_lib": false,
        "description": "AUPS is a subscription-based IoT system.\n  AUPS has five roles: \n\t- Device: collects data from the environment and sends it to the device manager.\n\t- NOS: it is the device manager,which receives data sent by the device and associate the data with the corresponding service topic.\n\t- User: obtains the required service data by submitting a service subscription request to the proxy.\n  \t- Broker: responsible for processing user subscription requests and forwarding corresponding data to subscribers.\n  \t- EF: it is the security policy center which responsible for access control authentication of the AUPS system and uses a key table to manage temporary keys for environmental data.",
        "pat_code": "#define size 2;\n#define kT 1;\n\nchannel  ComDN 0; \nchannel  ComNB 0; \nchannel  ComUB 0; \nchannel  ComNE 0; \nchannel  ComBE 0;  \nchannel  GetE 0;\nchannel  FakeDN 0; \nchannel  FakeND 0; \nchannel  FakeUB 0; \nchannel  FakeBU 0;\n\nenum{skd,sku,ski};\nenum{pukn,pukb,puki};\nenum{prkn,prkb,prki};\nenum{idu,idd,idi};\nenum{KT,T,at};\nenum{d,i};\nenum{reqd,reqT,requ};\nenum{ack};\nenum{sidd,sidu};\n\nvar keyTable[size][4]=[1,1,10,1,2,2,20,2];\nvar data_available = false;\nvar data_leak = false;\nvar device_fake = false;  \nvar privacy_leak = false;\n\nvar sid_get;\nvar kT_get;\nvar id_get;\nvar data_get;\nvar data_pub;\nvar is_pass;\nvar kt;\n\n#define getSid(sku1,sk){ \n  if(sku1==sk){sid_get=true;}\n};\n \n#define getKT(sk,sku1){ \n  if(sk==sku1){kT_get=true;}\n};\n\n#define getData(k,KT1){ \n  if(k==KT1){data_get=true;}\n};\n\n#define getId(pukb1,prkb1){ \n  if(pukb1==prkb1){id_get=true;}\n};\n\n#define checkABAC(at1,T1){ \n  if(at1==T1){is_pass=true;}\n};\n\n#define findKey(at1){ \n  var j=0;\n  while(j<=size-1){\n    if (keyTable[j][3]==at1){kt=keyTable[j][1];kT_get=true;}\n  }\n};\n\n#define pubData(sk,skd1,sid,sid1){ \n\tif(sk==skd1&&sid==sid1){data_pub=true;}\n};\n\n#define genKey(k){ \n  var j=0;\n  while(j<=size-1){\n    if(keyTable[j][1]==k){kT_get=true;kt=keyTable[j][1];keyTable[j][2]=keyTable[j][2]+100;}\n  }\n};\n\n/*@Process: Device\n  The Device is responsible for collecting data from the environment and sending them to the device manager.\n  The Device's behavior is as follows:\n    - Behavior of registering devices:\n    \t1.The device first sends a registration request reqd to the device manager.\n    \t2.After receiving the public key pukn from the device manager, the device uses pukn to encrypt its own symmetric key skn and identity information idd, and sends the encrypted message to the device manager.\n    \t3.After receiving the reply message from the device manager, the device uses the symmetric key skn to decrypt the message and obtain the session identifier sidd.\n    \t4.The device encrypts the session identifier sidd and the collected data using the symmetric key skn and sends the encrypted message to the device manager for data release.\n    - Unregistered devices are not allowed to publish data to the device manager.\n*/\nDevice()=ComDN!reqd->ComDN?pukn->ComDN!pukn.skd.idd->\nComDN?skd.sidd{call(getSid,skd,skd)}->if(sid_get==true){\nComDN!skd.sidd.d->ComDN?ack->Device()}else{fail->Device()} \n[]ComDN!reqd->ComDN?fail->Device()\n[]FakeDN!reqd->FakeDN?pukn->FakeDN!pukn.ski.idi->FakeDN?ski.sidd{ \t\ncall(getSid,ski,ski)}->if(sid_get==true){FakeDN!ski.sidd.i->FakeDN?ack-> Device()}else{fail->Device()};\n\n/*@Process: NOS\n  The NOS is responsible for processing the data collected by the device and transmitting the data to the agent.\n  The NOS communicates with registered and unregistered devices as follows:\n  \t- Registered devices:\n\t    1.After receiving the device's registration request reqd, the device manager sends its public key pukn to the device.\n\t    2.After receiving the message containing the device key, the device manager uses its own private key prkn to decrypt the message and obtain the device key skd and identity information idd, then encrypts the session identifier sidd with skd and distributes it to the device.\n\t    3.After receiving the data release message from the device, the device manager uses the device's key skd to decrypt the message to obtain the session identifier sidd and data d, and then checks whether the device's identity is legitimate based on the session identifier sidd.\n\t    \t+ If the device is legitimate, the device manager assigns the data d to the topic T and sends a data key request reqK to the security policy center.\n\t    \t+ If the device is illegal, the device manager discards the data.\n\t    4.After receiving the key kT from the security policy center, the device manager encrypts the data d with the key kT and sends it to the broker.\n    - Unregistered devices are not allowed to publish data to the NOS.\n*/\nNOS()=ComDN?reqd->ComDN!pukn->ComDN?pukn.skd.idd{\ncall(getId,pukn,prkn)}->\nif(id_get==true){\n\tComDN!skd.sidd->ComDN?skd.sidd.d {call(pubData,skd,skd,sidd,sidd)}->\n\tif(data_pub==true){\n\t\tComDN!ack->NOS()\n\t}\n\telse{\n\t\tfail->NOS()\n\t}\n}\nelse{\n\tfail->NOS()\n}\n[]ComDN!reqd->ComDN?fail->NOS()\n[]FakeND?reqd->FakeND!puki->FakeND?puki.ski.idi{call(getId,puki,prki)}->\nif(id_get==true){FakeND!ski.sidd->FakeND?ski.sidd.i{ call(pubData,skd,skd,sidd,sidd)}->\nif(data_pub==true){FakeND!data_pub{device_fake=true}->NOS()} else{fail->NOS()}}else{fail->NOS()};\n\n/*@Process: User\n  The User can subscribe to IoT services and get corresponding data from the broker. \n  The behavior of registered and unregistered users is as follows:\n  \t- Registered users:\n\t    1.The user first sends a registration request requ to the broker and receives the broker's public key pukb.\n\t    2.The user uses the broker's public key pukp to encrypt his own symmetric key sku and identity information idu, and sends the encrypted message to the broker.\n\t    3.After receiving the message from the proxy assigning the session ID, the user uses the symmetric key sku to decrypt the message and obtain the session ID sidu and user attributes at.\n\t    4.The user initiates a service subscription request to the proxy. The user uses the symmetric key sku to encrypt the session identifier sidu, the user attribute at, and the service topic T to be subscribed, and sends the encrypted message to the proxy.\n\t    5.After successfully subscribing to the service, the user receives a message containing the data decryption key, and then uses the symmetric key sku to decrypt the message to obtain the data decryption key kT. The end user can use kT to decrypt the message containing the environmental data and obtain the data he subscribed to.\n    - Unregistered users cannot subscribe to IoT services.\n*/\nUser()=ComUB!requ->ComUB?pukb->ComUB!pukb.sku.idu-> \nComUB?sku.sidu.at{call(getSid,sku,sku)}->\n\tif(sid_get==true){\n\t\tComUB!sku.reqT.at.T->ComUB?sku.kT{call(getKT,sku,sku)}->\n\t\tif(kT_get==true){\n\t\t\tComUB?kT.d{call(getData,kT,kT)}->\n\t\t\tif(data_get==true){\n\t\t\t\tsuc{data_available=true}->User()\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfail->User()\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfail->User()\n\t\t}\t\n\t}\n\telse{\n\t\tfail->User()\n\t}\n[]ComUB!requ->ComUB?fail->User()\n[]FakeUB!requ->FakeUB?pukb->FakeUB!pukb.ski.idi->FakeUB?ski.sidu\n{call(getSid,ski,ski)}->\n\tif(sid_get==true){\n\t\tFakeUB!ski.reqT.at.T->FakeUB?ski.kT{call(getKT,ski,ski)}->\n\t\tif(kT_get==true){\n\t\t\tFakeUB?kT.d{call(getData,kT,kT)}->\n\t\t\tif(data_get==true){\n\t\t\t\tsuc{data_leak=true}->User()\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfail->User()\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfail->User()\n\t\t}\n\t}\n\telse{\n\t\tfail->User()\n\t};\n\n/*@Process: Broker\n  The Broker is responsible for processing the user's subscription request and forwarding the data to the subscriber.\n  The Broker communicates with registered and unregistered users as follows:\n  \t- Registered users:\n\t    1.After receiving the user's registration request, the broker sends its public key pukb to the user.\n\t    2.After receiving the message containing the user's key, the broker uses its own private key prkb to decrypt the message and obtain the user's symmetric key sku and identity information idu. It then uses sku to encrypt the session identifier sidu and attribute at, and sends the encrypted message to the user.\n\t    3.After receiving the user's subscription request, the broker first uses the user's key sku to decrypt the request and obtain the user's session identifier sidu, attribute at and the requested subscription topic T.\n\t    4.Send the user attribute at and topic T to the security policy center to check whether the user can subscribe to topic T.\n\t    \t+ If the verification result acc returned by the security policy center is true, the broker accepts the user's subscription request and then encrypts the corresponding data decryption key kT with the key sku and sends it to the user.\n\t    \t+ If acc is false, the broker rejects the user's subscription request.\n    - The Broker will reject subscription requests from unregistered users\n*/\nBroker()= ComUB?requ->ComUB!pukb->ComUB?pukb.sku.idu{call(getId,pukb,prkb)}-> \n\tif(id_get==true){\n\t\tComUB!sku.sidu.at->ComUB?sku.reqT.at.T{call(getSid,sku,sku)}->\n\t\tif(sid_get==true){\n\t\t\tComBE!sku.at.T->ComBE?acc->\n\t\t\tif(acc==true){\n\t\t\tComBE?kT->ComUB!sku.kT->ComNB?kT.d->ComUB!kT.d->Broker()\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfail->Broker()\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfail->Broker()\n\t\t}\n\t}\n\telse{\n\t\tfail->Broker()\n\t}\n[]ComUB!reqT->ComUB?fail->Broker()\n[]FakeBU?requ->FakeBU!puki->FakeBU?puki.ski.idi{call(getId,puki,prki)}-> \n\tif(id_get==true){\n\t\tFakeBU!ski.sidu.at{privacy_leak=true}->FakeBU?ski.at.T-> FakeBU!ski.kT->FakeBU!kT.d->Broker()\n\t}\n\telse{\n\t\tfail->Broker()\n\t};\n\n/*@Process: EF\n  The EF is the security strategy center,responsible for access control verification and key management of the AUPS system.\n  - The communication process between the EF and the NOS is as follows:\n      1.After receiving the key request reqK from the device manager, the security policy center sends the subject T to ProcessE to obtain the data encryption key of subject T.\n      2.Forward the received key kT to the device manager.\n  - The communication process between the EF and the Broker is as follows:    \n  \t  1.After receiving the access control verification request from the broker, the security policy center uses the checkABAC function to check whether the user with the attribute at has the access rights to the subject T.\n  \t  2.Send the verification result acc to the broker.\n  \t    + If the value of the verification result acc is true, the security policy center sends the subject T and the attribute at to the internal process ProcessE to obtain the data decryption key of the subject T, and then sends the received data decryption key kT to the broker.\n  \t    + If the verification result acc is true, the security policy center rejects the broker request.\n*/\nEF()=ComNE?reqK.T->GetE!reqK.T->GetE?kT.at->ComNE!kT->EF()   \n[]ComBE?sku.at.T{call(checkABAC,at,T)}->ComBE!is_pass->if(is_pass==true){ \nGetE!T.at->GetE?kT->ComBE!kT->EF()}else{fail->EF()};\n\n/*@Process: ProcessE\n  The ProcessE is the internal process of the security policy center.\n     1.After receiving the key request reqK from the security policy center, ProcessE first uses the findKey function to find the corresponding data encryption or decryption key kT.\n       -If ProcessE stores key kT in the key table, then ProcessE checks the validity of key kT.\n         + ProcessE obtains the current system time by communicating with Clock. If the key expiration time val is greater than the current time t, it means that the key kT has not expired. Then ProcessE forwards the key kT to the security policy center.\n         + If the key kT has expired, ProcessE generates a new data key using the genKe function and then forwards the new key to the EF process through the internal channel GetE.\n  \n*/\nProcessE()=GetE?reqK.T.at{call(findKey,at)}-> \nif(kT_get==true){GetE!KT->ProcessE()}\nelse{{call(genKey,KT)}->GetE!KT->ProcessE()};\n\n/*@Process: Intruder\n  The model also introduces the intruder,it simulates the following attack behaviors\n    1.It can intercept or forge messages transmitted on channels ComDN, ComNB and ComUB.\n    2.It can intercept messages through channels FakeDN, FakeND, FakeUB and FakeBU.\n*/\nIntruder()=FakeDN?reqd->FakeDN!pukn->FakeDN?pukn.ski.idi->FakeDN!ski.sidd-> FakeDN?ski.sidd.i->FakeDN!ack->Intruder()\n[]FakeND!reqd->FakeND?puki->FakeND!puki.ski.idi->FakeND?ski.sidd-> FakeND!ski.sidd.i->Intruder()\n[]FakeUB?requ->FakeUB!pukb->FakeUB?pukb.ski.idi->FakeUB!ski.sidd-> FakeUB?ski.at.T->FakeUB!ski.kT->FakeUB!kT.i->Intruder()\n[]FakeBU!requ->FakeBU?puki->FakeBU!puki.ski.idi->FakeBU?ski.sidu.at-> FakeBU!ski.at.T->FakeBU?ski.kT->FakeBU?kT.i->Intruder();\n\n/*@Process: System\n\tThe system comprises the following five entities: Device, NOS, User, Broker and EF. Meanwhile, the model contains ProcessE(the internal process of EF) and introduces a intruder.\n*/\nSystem()=Device()||NOS()||User()||Broker()||EF()||ProcessE()||Intruder();",
        "property_desc": [
            "The system is deadlock-free.",
            "The system satisfies data accessibility.",
            "The system satisfies data security.",
            "The system satisfies device security.",
            "The system satisfies user privacy and security."
        ],
        "properties": [
            "#assert System() deadlockfree;",
            "#define\tData_Availability data_available ==false;\n#assert\tSystem() reaches Data_Availability;",
            "#define Data_Leak_Success data_leak==false;\n#assert System() |=[]!Data_Leak_Success;",
            "#define Device_Fake_Success  device_fake==false;\n#assert\t System()  |=[]!Device_Fake_Success;",
            "#define User_Privacy_Leak privacy_leak==false;\n#assert\t System() |=[]! User_Privacy_Leak;"
        ],
        "processes": [
            {
                "name": "Device",
                "description": "The Device is responsible for collecting data from the environment and sending them to the device manager.\n  The Device's behavior is as follows:\n    - Behavior of registering devices:\n    \t1.The device first sends a registration request reqd to the device manager.\n    \t2.After receiving the public key pukn from the device manager, the device uses pukn to encrypt its own symmetric key skn and identity information idd, and sends the encrypted message to the device manager.\n    \t3.After receiving the reply message from the device manager, the device uses the symmetric key skn to decrypt the message and obtain the session identifier sidd.\n    \t4.The device encrypts the session identifier sidd and the collected data using the symmetric key skn and sends the encrypted message to the device manager for data release.\n    - Unregistered devices are not allowed to publish data to the device manager.",
                "pat_code": "Device()=ComDN!reqd->ComDN?pukn->ComDN!pukn.skd.idd->\nComDN?skd.sidd{call(getSid,skd,skd)}->if(sid_get==true){\nComDN!skd.sidd.d->ComDN?ack->Device()}else{fail->Device()} \n[]ComDN!reqd->ComDN?fail->Device()\n[]FakeDN!reqd->FakeDN?pukn->FakeDN!pukn.ski.idi->FakeDN?ski.sidd{ \t\ncall(getSid,ski,ski)}->if(sid_get==true){FakeDN!ski.sidd.i->FakeDN?ack-> Device()}else{fail->Device()};"
            },
            {
                "name": "NOS",
                "description": "The NOS is responsible for processing the data collected by the device and transmitting the data to the agent.\n  The NOS communicates with registered and unregistered devices as follows:\n  \t- Registered devices:\n\t    1.After receiving the device's registration request reqd, the device manager sends its public key pukn to the device.\n\t    2.After receiving the message containing the device key, the device manager uses its own private key prkn to decrypt the message and obtain the device key skd and identity information idd, then encrypts the session identifier sidd with skd and distributes it to the device.\n\t    3.After receiving the data release message from the device, the device manager uses the device's key skd to decrypt the message to obtain the session identifier sidd and data d, and then checks whether the device's identity is legitimate based on the session identifier sidd.\n\t    \t+ If the device is legitimate, the device manager assigns the data d to the topic T and sends a data key request reqK to the security policy center.\n\t    \t+ If the device is illegal, the device manager discards the data.\n\t    4.After receiving the key kT from the security policy center, the device manager encrypts the data d with the key kT and sends it to the broker.\n    - Unregistered devices are not allowed to publish data to the NOS.",
                "pat_code": "NOS()=ComDN?reqd->ComDN!pukn->ComDN?pukn.skd.idd{\ncall(getId,pukn,prkn)}->\nif(id_get==true){\n\tComDN!skd.sidd->ComDN?skd.sidd.d {call(pubData,skd,skd,sidd,sidd)}->\n\tif(data_pub==true){\n\t\tComDN!ack->NOS()\n\t}\n\telse{\n\t\tfail->NOS()\n\t}\n}\nelse{\n\tfail->NOS()\n}\n[]ComDN!reqd->ComDN?fail->NOS()\n[]FakeND?reqd->FakeND!puki->FakeND?puki.ski.idi{call(getId,puki,prki)}->\nif(id_get==true){FakeND!ski.sidd->FakeND?ski.sidd.i{ call(pubData,skd,skd,sidd,sidd)}->\nif(data_pub==true){FakeND!data_pub{device_fake=true}->NOS()} else{fail->NOS()}}else{fail->NOS()};"
            },
            {
                "name": "User",
                "description": "The User can subscribe to IoT services and get corresponding data from the broker. \n  The behavior of registered and unregistered users is as follows:\n  \t- Registered users:\n\t    1.The user first sends a registration request requ to the broker and receives the broker's public key pukb.\n\t    2.The user uses the broker's public key pukp to encrypt his own symmetric key sku and identity information idu, and sends the encrypted message to the broker.\n\t    3.After receiving the message from the proxy assigning the session ID, the user uses the symmetric key sku to decrypt the message and obtain the session ID sidu and user attributes at.\n\t    4.The user initiates a service subscription request to the proxy. The user uses the symmetric key sku to encrypt the session identifier sidu, the user attribute at, and the service topic T to be subscribed, and sends the encrypted message to the proxy.\n\t    5.After successfully subscribing to the service, the user receives a message containing the data decryption key, and then uses the symmetric key sku to decrypt the message to obtain the data decryption key kT. The end user can use kT to decrypt the message containing the environmental data and obtain the data he subscribed to.\n    - Unregistered users cannot subscribe to IoT services.",
                "pat_code": "User()=ComUB!requ->ComUB?pukb->ComUB!pukb.sku.idu-> \nComUB?sku.sidu.at{call(getSid,sku,sku)}->\n\tif(sid_get==true){\n\t\tComUB!sku.reqT.at.T->ComUB?sku.kT{call(getKT,sku,sku)}->\n\t\tif(kT_get==true){\n\t\t\tComUB?kT.d{call(getData,kT,kT)}->\n\t\t\tif(data_get==true){\n\t\t\t\tsuc{data_available=true}->User()\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfail->User()\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfail->User()\n\t\t}\t\n\t}\n\telse{\n\t\tfail->User()\n\t}\n[]ComUB!requ->ComUB?fail->User()\n[]FakeUB!requ->FakeUB?pukb->FakeUB!pukb.ski.idi->FakeUB?ski.sidu\n{call(getSid,ski,ski)}->\n\tif(sid_get==true){\n\t\tFakeUB!ski.reqT.at.T->FakeUB?ski.kT{call(getKT,ski,ski)}->\n\t\tif(kT_get==true){\n\t\t\tFakeUB?kT.d{call(getData,kT,kT)}->\n\t\t\tif(data_get==true){\n\t\t\t\tsuc{data_leak=true}->User()\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfail->User()\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfail->User()\n\t\t}\n\t}\n\telse{\n\t\tfail->User()\n\t};"
            },
            {
                "name": "Broker",
                "description": "The Broker is responsible for processing the user's subscription request and forwarding the data to the subscriber.\n  The Broker communicates with registered and unregistered users as follows:\n  \t- Registered users:\n\t    1.After receiving the user's registration request, the broker sends its public key pukb to the user.\n\t    2.After receiving the message containing the user's key, the broker uses its own private key prkb to decrypt the message and obtain the user's symmetric key sku and identity information idu. It then uses sku to encrypt the session identifier sidu and attribute at, and sends the encrypted message to the user.\n\t    3.After receiving the user's subscription request, the broker first uses the user's key sku to decrypt the request and obtain the user's session identifier sidu, attribute at and the requested subscription topic T.\n\t    4.Send the user attribute at and topic T to the security policy center to check whether the user can subscribe to topic T.\n\t    \t+ If the verification result acc returned by the security policy center is true, the broker accepts the user's subscription request and then encrypts the corresponding data decryption key kT with the key sku and sends it to the user.\n\t    \t+ If acc is false, the broker rejects the user's subscription request.\n    - The Broker will reject subscription requests from unregistered users",
                "pat_code": "Broker()= ComUB?requ->ComUB!pukb->ComUB?pukb.sku.idu{call(getId,pukb,prkb)}-> \n\tif(id_get==true){\n\t\tComUB!sku.sidu.at->ComUB?sku.reqT.at.T{call(getSid,sku,sku)}->\n\t\tif(sid_get==true){\n\t\t\tComBE!sku.at.T->ComBE?acc->\n\t\t\tif(acc==true){\n\t\t\tComBE?kT->ComUB!sku.kT->ComNB?kT.d->ComUB!kT.d->Broker()\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfail->Broker()\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfail->Broker()\n\t\t}\n\t}\n\telse{\n\t\tfail->Broker()\n\t}\n[]ComUB!reqT->ComUB?fail->Broker()\n[]FakeBU?requ->FakeBU!puki->FakeBU?puki.ski.idi{call(getId,puki,prki)}-> \n\tif(id_get==true){\n\t\tFakeBU!ski.sidu.at{privacy_leak=true}->FakeBU?ski.at.T-> FakeBU!ski.kT->FakeBU!kT.d->Broker()\n\t}\n\telse{\n\t\tfail->Broker()\n\t};"
            },
            {
                "name": "EF",
                "description": "The EF is the security strategy center,responsible for access control verification and key management of the AUPS system.\n  - The communication process between the EF and the NOS is as follows:\n      1.After receiving the key request reqK from the device manager, the security policy center sends the subject T to ProcessE to obtain the data encryption key of subject T.\n      2.Forward the received key kT to the device manager.\n  - The communication process between the EF and the Broker is as follows:    \n  \t  1.After receiving the access control verification request from the broker, the security policy center uses the checkABAC function to check whether the user with the attribute at has the access rights to the subject T.\n  \t  2.Send the verification result acc to the broker.\n  \t    + If the value of the verification result acc is true, the security policy center sends the subject T and the attribute at to the internal process ProcessE to obtain the data decryption key of the subject T, and then sends the received data decryption key kT to the broker.\n  \t    + If the verification result acc is true, the security policy center rejects the broker request.",
                "pat_code": "EF()=ComNE?reqK.T->GetE!reqK.T->GetE?kT.at->ComNE!kT->EF()   \n[]ComBE?sku.at.T{call(checkABAC,at,T)}->ComBE!is_pass->if(is_pass==true){ \nGetE!T.at->GetE?kT->ComBE!kT->EF()}else{fail->EF()};"
            },
            {
                "name": "ProcessE",
                "description": "The ProcessE is the internal process of the security policy center.\n     1.After receiving the key request reqK from the security policy center, ProcessE first uses the findKey function to find the corresponding data encryption or decryption key kT.\n       -If ProcessE stores key kT in the key table, then ProcessE checks the validity of key kT.\n         + ProcessE obtains the current system time by communicating with Clock. If the key expiration time val is greater than the current time t, it means that the key kT has not expired. Then ProcessE forwards the key kT to the security policy center.\n         + If the key kT has expired, ProcessE generates a new data key using the genKe function and then forwards the new key to the EF process through the internal channel GetE.",
                "pat_code": "ProcessE()=GetE?reqK.T.at{call(findKey,at)}-> \nif(kT_get==true){GetE!KT->ProcessE()}\nelse{{call(genKey,KT)}->GetE!KT->ProcessE()};"
            },
            {
                "name": "Intruder",
                "description": "The model also introduces the intruder,it simulates the following attack behaviors\n    1.It can intercept or forge messages transmitted on channels ComDN, ComNB and ComUB.\n    2.It can intercept messages through channels FakeDN, FakeND, FakeUB and FakeBU.",
                "pat_code": "Intruder()=FakeDN?reqd->FakeDN!pukn->FakeDN?pukn.ski.idi->FakeDN!ski.sidd-> FakeDN?ski.sidd.i->FakeDN!ack->Intruder()\n[]FakeND!reqd->FakeND?puki->FakeND!puki.ski.idi->FakeND?ski.sidd-> FakeND!ski.sidd.i->Intruder()\n[]FakeUB?requ->FakeUB!pukb->FakeUB?pukb.ski.idi->FakeUB!ski.sidd-> FakeUB?ski.at.T->FakeUB!ski.kT->FakeUB!kT.i->Intruder()\n[]FakeBU!requ->FakeBU?puki->FakeBU!puki.ski.idi->FakeBU?ski.sidu.at-> FakeBU!ski.at.T->FakeBU?ski.kT->FakeBU?kT.i->Intruder();"
            },
            {
                "name": "System",
                "description": "The system comprises the following five entities: Device, NOS, User, Broker and EF. Meanwhile, the model contains ProcessE(the internal process of EF) and introduces a intruder.",
                "pat_code": "System()=Device()||NOS()||User()||Broker()||EF()||ProcessE()||Intruder();"
            }
        ],
        "global_definition": "#define size 2;\n#define kT 1;\n\nchannel  ComDN 0; \nchannel  ComNB 0; \nchannel  ComUB 0; \nchannel  ComNE 0; \nchannel  ComBE 0;  \nchannel  GetE 0;\nchannel  FakeDN 0; \nchannel  FakeND 0; \nchannel  FakeUB 0; \nchannel  FakeBU 0;\n\nenum{skd,sku,ski};\nenum{pukn,pukb,puki};\nenum{prkn,prkb,prki};\nenum{idu,idd,idi};\nenum{KT,T,at};\nenum{d,i};\nenum{reqd,reqT,requ};\nenum{ack};\nenum{sidd,sidu};\n\nvar keyTable[size][4]=[1,1,10,1,2,2,20,2];\nvar data_available = false;\nvar data_leak = false;\nvar device_fake = false;  \nvar privacy_leak = false;\n\nvar sid_get;\nvar kT_get;\nvar id_get;\nvar data_get;\nvar data_pub;\nvar is_pass;\nvar kt;\n\n#define getSid(sku1,sk){ \n  if(sku1==sk){sid_get=true;}\n};\n \n#define getKT(sk,sku1){ \n  if(sk==sku1){kT_get=true;}\n};\n\n#define getData(k,KT1){ \n  if(k==KT1){data_get=true;}\n};\n\n#define getId(pukb1,prkb1){ \n  if(pukb1==prkb1){id_get=true;}\n};\n\n#define checkABAC(at1,T1){ \n  if(at1==T1){is_pass=true;}\n};\n\n#define findKey(at1){ \n  var j=0;\n  while(j<=size-1){\n    if (keyTable[j][3]==at1){kt=keyTable[j][1];kT_get=true;}\n  }\n};\n\n#define pubData(sk,skd1,sid,sid1){ \n\tif(sk==skd1&&sid==sid1){data_pub=true;}\n};\n\n#define genKey(k){ \n  var j=0;\n  while(j<=size-1){\n    if(keyTable[j][1]==k){kT_get=true;kt=keyTable[j][1];keyTable[j][2]=keyTable[j][2]+100;}\n  }\n};",
        "path": "handwrite/AUPS.csp"
    },
    {
        "name": "CHAP",
        "tags": [
            "Protocol"
        ],
        "use_non_container_lib": false,
        "description": "CHAP (ChallengeHandshake Authentication Protocol), as a challenge-response mechanism based authentication protocol, is widely used in network communications such as Point-to-Point Protocol (PPP).",
        "pat_code": "channel C_SR 0;   // Client -> server\nchannel S_CC 0;   // Server -> Client\nchannel C_SC 0;   // Client -> Server\nchannel S_CR 0;   // Server -> Client\nchannel C_SI 0;   // Client -> Server\nchannel S_CI 0;   // Server -> Client\n\nvar challenge = 3;\nvar client_name = 1;\nvar client_PK = 2;  \nvar client_PK2 = 4; \nvar ench = -1;\nvar dech = -1;\nvar msg = -1; \nvar verify_state = -1;\nvar verify_approve = -1;\n\n#define key 2;\n\n/*@Process: Client_Pre\n  1. The client initiates the authentication process by sending its public key to the server via the channel C_SR. This is a request to connect.\n  2. The client then waits to receive an encrypted challenge (ench) from the server via the channel S_CC.\n  3. If the server doesn't recognize the public key (indicated by ench == -1), the client retries the connection by calling Client_Pre() again.\n  4.1. Otherwise, if a valid encrypted challenge is received, the client decrypts it using the key. The key is a predefined constant.\n  4.2. The client sends the decrypted challenge back to the server and proceeds to Client_Post process.\n*/\nClient_Pre() =\n    C_SR!client_PK\n    -> S_CC?y { ench = y; }\n    -> if (ench == -1) { \n        Client_Pre() \n    } else {  \n        decryption_challenge { dech = ench / key; }  \n        -> C_SC!dech \n        -> Client_Post() \n    };\n\n/*@Process: Client_Post\n  Client_Post():\n  1. The client waits to receive the authentication result from the server.\n  2. If authentication fails, the client restarts the process by calling Client_Pre() again.\n  3. If authentication is successful, the client proceeds to the Client_Use() process.\n*/\nClient_Post() =\n    S_CR?y {verify_approve = y ;} \n    -> if (verify_approve == -1) { \n        Client_Pre() \n    } else { \n        Client_Use() \n    };\n\n/*@Process: Client_Use\n  Client_Use():\n  1. The client sends communication information (the value 65 in this model) to the server.\n  2. The client waits to receive a response from the server.\n  3. If the server returns an error, the client stops communicating.\n  4. Otherwise, the client interprets this as a successful reception and continues communication by calling Client_Use() again.\n*/\nClient_Use() =\n    C_SI!65 \n    -> S_CI?y{ msg=y; } \n    -> if (msg == -1) { \n        Stop\n    } else { \n        success_recv -> Client_Use() \n    };\n\n\n/*@Process: Server\n  The Server process handles different types of incoming messages. After processing each message, the server continues listening for requests.\n  - Receiving Public Key:\n    1. The server listens for a public key from the clientR.\n    2.1. If the received public key matches the expected client_PK, the server proceeds to encrypt a challenge.\n    2.2. The server encrypts a challenge using the pre-defined key.\n    2.3. The server sends the encrypted challenge to the client and continues listening.\n    3. If the received public key does not match, the server sends an error code to the client and continues listening.\n  - Receiving Decrypted Challenge:\n    1. The server listens for a decrypted challenge from the client.\n    2.1. If the decrypted challenge matches the original challenge, the server sets the verify_state variable to 1 (indicating successful verification).\n    2.2. The server sends a successful authentication message to the client and continues listening.\n    3. If the decrypted challenge does not match, the server sends an error code to the client and continues listening.\n  - Receiving Communication Information:\n    1. The server listens for communication information from the client .\n    2. If the server has not yet verified the client, it sends an error code to the client and continues listening .\n    3. Otherwise, the server sends the received message back to the client via the channel S_CI and continues listening.\n*/\nvar S_PK = -1;\nServer() =\n    ( C_SR?y{ S_PK=y; } \n    -> if (S_PK == client_PK) {  \n        encryption_challenge { ench = challenge * key; } \n        -> S_CC!ench\n        -> Server() \n    } else {\n        S_CC!(-1) \n        -> Server() \n    }\n    )\n    []\n    ( C_SC? y{ dech=y; }\n    -> if (dech == challenge) {\n        {verify_state = 1;} \n        -> S_CR!1 \n        -> Server()\n    } else {\n        S_CR!(-1) \n        -> Server()\n    }\n    )\n    []\n    ( C_SI?y{ msg=y; }\n    -> if (verify_state == -1) { \n        S_CI!(-1)\n        -> Server()\n    } else {\n        S_CI!msg\n        -> Server() \n    }\n    );\n\n/*@Process: CHAP\n  The overall system as the parallel composition of the Client_Pre and Server processes.\n*/\nCHAP() = Client_Pre() || Server();",
        "property_desc": [
            "The system is deadlock-free.",
            "The system is divergence-free.",
            "At least one successful data transmission happens after authentication"
        ],
        "properties": [
            "#assert CHAP() deadlockfree;",
            "#assert CHAP() divergencefree;",
            "#assert CHAP() |= []<>success_recv;"
        ],
        "processes": [
            {
                "name": "Client_Pre",
                "description": "1. The client initiates the authentication process by sending its public key to the server via the channel C_SR. This is a request to connect.\n  2. The client then waits to receive an encrypted challenge (ench) from the server via the channel S_CC.\n  3. If the server doesn't recognize the public key (indicated by ench == -1), the client retries the connection by calling Client_Pre() again.\n  4.1. Otherwise, if a valid encrypted challenge is received, the client decrypts it using the key. The key is a predefined constant.\n  4.2. The client sends the decrypted challenge back to the server and proceeds to Client_Post process.",
                "pat_code": "Client_Pre() =\n    C_SR!client_PK\n    -> S_CC?y { ench = y; }\n    -> if (ench == -1) { \n        Client_Pre() \n    } else {  \n        decryption_challenge { dech = ench / key; }  \n        -> C_SC!dech \n        -> Client_Post() \n    };"
            },
            {
                "name": "Client_Post",
                "description": "Client_Post():\n  1. The client waits to receive the authentication result from the server.\n  2. If authentication fails, the client restarts the process by calling Client_Pre() again.\n  3. If authentication is successful, the client proceeds to the Client_Use() process.",
                "pat_code": "Client_Post() =\n    S_CR?y {verify_approve = y ;} \n    -> if (verify_approve == -1) { \n        Client_Pre() \n    } else { \n        Client_Use() \n    };"
            },
            {
                "name": "Client_Use",
                "description": "Client_Use():\n  1. The client sends communication information (the value 65 in this model) to the server.\n  2. The client waits to receive a response from the server.\n  3. If the server returns an error, the client stops communicating.\n  4. Otherwise, the client interprets this as a successful reception and continues communication by calling Client_Use() again.",
                "pat_code": "Client_Use() =\n    C_SI!65 \n    -> S_CI?y{ msg=y; } \n    -> if (msg == -1) { \n        Stop\n    } else { \n        success_recv -> Client_Use() \n    };"
            },
            {
                "name": "Server",
                "description": "The Server process handles different types of incoming messages. After processing each message, the server continues listening for requests.\n  - Receiving Public Key:\n    1. The server listens for a public key from the clientR.\n    2.1. If the received public key matches the expected client_PK, the server proceeds to encrypt a challenge.\n    2.2. The server encrypts a challenge using the pre-defined key.\n    2.3. The server sends the encrypted challenge to the client and continues listening.\n    3. If the received public key does not match, the server sends an error code to the client and continues listening.\n  - Receiving Decrypted Challenge:\n    1. The server listens for a decrypted challenge from the client.\n    2.1. If the decrypted challenge matches the original challenge, the server sets the verify_state variable to 1 (indicating successful verification).\n    2.2. The server sends a successful authentication message to the client and continues listening.\n    3. If the decrypted challenge does not match, the server sends an error code to the client and continues listening.\n  - Receiving Communication Information:\n    1. The server listens for communication information from the client .\n    2. If the server has not yet verified the client, it sends an error code to the client and continues listening .\n    3. Otherwise, the server sends the received message back to the client via the channel S_CI and continues listening.",
                "pat_code": "var S_PK = -1;\nServer() =\n    ( C_SR?y{ S_PK=y; } \n    -> if (S_PK == client_PK) {  \n        encryption_challenge { ench = challenge * key; } \n        -> S_CC!ench\n        -> Server() \n    } else {\n        S_CC!(-1) \n        -> Server() \n    }\n    )\n    []\n    ( C_SC? y{ dech=y; }\n    -> if (dech == challenge) {\n        {verify_state = 1;} \n        -> S_CR!1 \n        -> Server()\n    } else {\n        S_CR!(-1) \n        -> Server()\n    }\n    )\n    []\n    ( C_SI?y{ msg=y; }\n    -> if (verify_state == -1) { \n        S_CI!(-1)\n        -> Server()\n    } else {\n        S_CI!msg\n        -> Server() \n    }\n    );"
            },
            {
                "name": "CHAP",
                "description": "The overall system as the parallel composition of the Client_Pre and Server processes.",
                "pat_code": "CHAP() = Client_Pre() || Server();"
            }
        ],
        "global_definition": "channel C_SR 0;   // Client -> server\nchannel S_CC 0;   // Server -> Client\nchannel C_SC 0;   // Client -> Server\nchannel S_CR 0;   // Server -> Client\nchannel C_SI 0;   // Client -> Server\nchannel S_CI 0;   // Server -> Client\n\nvar challenge = 3;\nvar client_name = 1;\nvar client_PK = 2;  \nvar client_PK2 = 4; \nvar ench = -1;\nvar dech = -1;\nvar msg = -1; \nvar verify_state = -1;\nvar verify_approve = -1;\n\n#define key 2;",
        "path": "handwrite/CHAP.csp"
    },
    {
        "name": "CoAP",
        "tags": [
            "Protocol",
            "Attacker"
        ],
        "use_non_container_lib": false,
        "description": "This model describes a COAP (Constrained Application Protocol) based system with several interacting entities: CA (Certificate Authority), RD (Resource Directory), C (Client), EM (Entity Manager), E (Entity), and S (Sensor).  \n  It also includes an INTRUDER process that attempts to compromise the system.",
        "pat_code": "channel ComCCA 0;\nchannel ComCRD 0;\nchannel ComCEM 0;\nchannel ComEMCA 0;\nchannel ComEMRD 0;\nchannel ComEEM 0;\nchannel ComSRD 0;\n\nchannel FakeCEM 0;\nchannel InterceptEMC 0;\nchannel FakeEMC 0;\nchannel InterceptCEM 0;\nchannel FakeEEM 0;\nchannel InterceptEME 0;\nchannel FakeEME 0;\nchannel InterceptEEM 0;\nchannel InterceptRDC 0;\nchannel FakeCRD 0;\nchannel InterceptCRD 0;\nchannel FakeRDC 0;\nchannel InterceptEMRD 0;\nchannel FakeEMRD 0;\nchannel InterceptRDEM 0;\nchannel FakeRDEM 0;\n\nvar data_leakage_success=false;\nvar client_fake_success=false;\nvar entitymanager_fake_success=false;\nvar data_reachability_success=false;\n\nvar check=false;\n\nvar Cert_C[3]=[C_id,C_kpub,C_e];\nvar Cert_EM[3]=[EM_id,EM_kpub,EM_e];\n\nvar enkey = false;\nvar enmackey = false;\nvar enckey = false;\nvar enemkey = false;\nvar VerC = false;\nvar VerEM = false;\nvar VerRSC = false;\nvar AckRD = true;\nvar AckEM = true;\n\nenum{C_id,EM_id,E_id};\nenum{C_e,EM_e};\nenum{C_kpub,EM_kpub,RD_kpub,CA_kpub,E_kpub,S_kpub};\nenum{C_kpri,EM_kpri,RD_kpri,CA_kpri,E_kpri,S_kpri};\nenum{Msg,Ack};\nenum{Msg_rsc}; \nenum{CertC,CertEM};\nenum{K_ECDHE,FK_ECDHE};\n\n//intruder\nenum{FC_kpub,FC_kpri,FEM_kpub,FEM_kpri};\nenum{FCertC,FCertEM};\nenum{FMsg,FAck};\nenum{FC_id,FEM_id};\nenum{Fkey};\n\n\n#define validC(certC){\n\tif(certC==CertC){\n\t\tVerC=true;\n\t}else{\n\t\tVerC=false;\n\t}\n};\n\n#define validEM(certEM){\n\tif(certEM==CertEM){\n\t\tVerEM=true;\n\t}else{\n\t\tVerEM=false;\n\t}\n};\n\n#define validRSC(msg_rsc){\n\tif(msg_rsc == Msg_rsc){\n\t\tVerRSC=true;\n\t}else{\n\t\tVerRSC=false;\n\t}\n};\n\n#define getM(key){  \n\tif(key==K_ECDHE){\n\t\tenkey=true;\n\t}else{\n\t\tenkey=false;\n\t}\n};\n\n#define getMWithMac(key){\nif(key == K_ECDHE){\n\t\tenmackey=true;\n\t}else{\n\t\tenmackey=false;\n\t}\n};\n\n#define DEM(c_kpub,c_kpri){ \n\tif(c_kpub==C_kpub&&c_kpri==C_kpri){\n\t\tenemkey=true;\n\t}else{\n\t\tenemkey=false;\n\t}\n};\n\n#define DC(em_kpub,em_kpri){  \n\tif(em_kpub==EM_kpub&&em_kpri==EM_kpri){\n\t\tenckey=true;\n\t}else{\n\t\tenckey=false;\n\t}\n};\n\n/*@Process: CA\n  CA (Certificate Authority): The CA validates certificates from the EM and the Client.\n  1. It receives the certificate of the entity manager from the client or receives a certificate from the entity manager.\n  2. It calls the function to check the certificate.\n  3. It sends the result of the validation back to the client or the entity manager.\n*/\nCA()=\nComCCA?certEM{call(validEM,certEM);}->ComCCA!CertEM.VerEM->CA()\n[]\nComEMCA?certC{call(validC,certC);}->ComEMCA!CertC.VerC->CA();\n\n/*@Process: RD\n  RD (Resource Directory): The RD manages resources and interacts with Sensors, Clients, and Entity Managers.\n  - 1. It performs ECDHE key generation with the sensor.\n    2. It then receives an encrypted message from the sensor. And decrypt the message using the negotiated ECDHE key.\n    3. If decryption is successful, it sends an acknowledgement to the sensor and loops. Otherwise, it fails.\n  - 1. Or, it performs ECDHE key generation with a Client.\n    2. It receives an encrypted message from the client and decrypts the message using the ECDHE key.\n    3. If decryption is successful, it sends the key back to the client, otherwise, it fails.\n  - 1. Or, it receives a resource message from an Entity Manager. It validates the message, and decrypts it.\n    2. If validation and decryption are successful, it sends an acknowledgement back to the resource manager and loops. Otherwise, it fails.\n  - 1. Or, it receives a resource message from a fake Entity Manager.\n    2. It validates the message and decrypts it. \n    3. If validation and decryption are successful, it sends an acknowledgement back. Otherwise, it fails.\n*/\nRD()=\n//Sensors reporting portrait to RD\nECDHE_key_generation1->ComSRD?k_ECDHE.msg{call(getM,K_ECDHE);}->\nif(enkey == true){ComSRD!AckRD->RD()}\nelse{fail1->RD()}\n[]\n//Client looking up resources from RD\nECDHE_key_generation2->ComCRD?k_ECDHE.msg{call(getM,K_ECDHE);}->\nif(enkey == true){ComCRD!K_ECDHE.msg->RD()}\nelse{fail2->RD()}\n[]\n//Entity Manager validating resources\nComEMRD?k_ECDHE.msg_rsc{call(validRSC,msg_rsc);call(getM,K_ECDHE);}->\nif(VerRSC==true && enkey == true){ComEMRD!AckRD->RD()}\nelse{fail4->RD()}\n[]\n//intercept Entity Manager\nFakeEMRD?k_ECDHE.msg_rsc{call(validRSC,msg_rsc);call(getM,K_ECDHE);}->\nif(VerRSC==true && enkey == true){InterceptRDEM!AckRD->RD}\nelse{fail5->RD()};\n\n/*@Process: C\n  C (Client): The Client interacts with the RD and EM to discover and use resources. It may performs following operations:\n  - 1. It performs ECDHE key generation with the RD.\n    2. It sends an encrypted message to the RD and receives an encrypted message back.\n    3. It decrypts the message.\n    4. If decryption is successful, it loops, otherwise it fails.\n  - 1. Or, the Client sends a certificate and a message to the EM.\n    2. And receives an acknowledgement, the EM's certificate, and a message back.\n    3. It decrypts the message from EM.\n    4. If decryption is successful, it sends EM's certificate to the CA, and gets the CA's validation result.\n    5. If the CA validates the EM's certificate, it succeeds, otherwise, it fails.\n    6. Or, if the initial decryption fails, the client goes to fail9 and loops.\n  - 1. Or, a fake Client sends the certificate and the message to the EM.\n    2. It receives an acknowledgement, the EM's certificate, and a message back from the fake entity manager.\n    3. It decrypts the message. If decryption is successful, it sends EM's certificate to the CA, which indicates client fake is viable.\n    4. performs the same thing as the process of receiving the certificate.\n  - 1. Or, a fake Client sends an Entity ID to the EM and receives an EM's certificate, an entity ID and a message back. \n    2. It decrypts the message. If decryption is successful, the data reachability succeeds, otherwise it fails.\n  - 2. Or, a fake Client sends an Entity ID to a fake Entity Manager via InterceptCEM and FakeEMC, it decrypts the message.\n    3. If decryption is successful, it succeds, otherwise it fails.\n*/\nC()=\n//Client looking up resources from RD\nECDHE_key_generation2->ComCRD!K_ECDHE.Msg->ComCRD?k_ECDHE.msg{call(getM,K_ECDHE);}->\nif(enkey == true){C()}\nelse{fail6->C()}\n[]\n//Client creating new group through Entity Manager\nComCEM!CertC.Msg->ComCEM?ackEM.certEM.msg{call(DEM,C_kpub,C_kpri);}->\nif(enemkey == true){\n\tComCCA!CertEM->ComCCA?certem.verem->\n\tif(verem == true) {success1->C()}\n\telse{fail8->C()}\n}\nelse{fail9->C()}\n[]\n//Fake Client\nInterceptCEM!CertC.Msg->FakeEMC?ackEM.certEM.msg{call(DEM,C_kpub,FC_kpri);}->\nif(enemkey == true){\n\tComCCA!CertEM{client_fake_success = true;}->ComCCA?certem.verem->\n\tif(verem == true){success2->C()}\n\telse{fail10->C()}\n}\nelse {fail11->C()}\n[]\n//Client collecting group info from Entity Manager\nComCEM!CertC.E_id->ComCEM?cert_em.e_id.msg{call(DEM,C_kpub,C_kpri);}->\nif(enemkey == true){success3{data_reachability_success = true;}->C()}\nelse{fail12->C()}\n[]\n//Fake Client\nInterceptCEM!CertC.E_id->FakeEMC?cert_em.e_id{call(DEM,C_kpub,FC_kpri);}->\nif(enemkey == true){success4->C()}\nelse{fail13->C()};\n\n/*@Process: EM\n  EM (Entity Manager): The EM manages entities, authenticates Clients, and interacts with the RD.\n  - 1. It performs MAC authentication, receives a Client's certificate and entity ID from client, sends the entity ID to the Entity, and receives a message back.\n    2. It decrypts the message.\n    3. If decryption is successful, it sends an EM certificate, entity ID, and message to the Client, otherwise it fails.\n  - 1. Or, a fake Entity Manager performs MAC authentication, receives a Client's certificate and entity ID, sends the entity ID to the Entity, and receives a message back.\n    2. It decrypts the message .\n    3. If decryption is successful, data leakage succeeds and a message is sent to the intercepting client, otherwise it fails.\n  - 1. Or, the EM receives a Client's certificate from the client.\n    2. It decrypts the message.\n    3. If decryption is successful, it sends the Client's certificate to the CA and gets the CA's validation result.\n    4. If the CA validates the Client's certificate, it sends an encrypted message to the RD and gets an acknowledgement back.\n    5. If the RD acknowledges, it sends an acknowledgement and its own certificate and a message back to the Client.\n    6. If any of the certificate is invalid, it fails.\n  - 1. Or, a fake Entity Manager receives a message from fake Client, it decrypts the message.\n    2. If the decryption is successful, which means the entity manager fake is success, it sends Client's certificate to the CA and gets CA's validation result.\n    3. If the CA validates the Client's certificate, the encrypted message sent to the RD is intercepted and gets an acknowledgement back from fake RD.\n    4. If the RD acknowledges, it sends an acknowledgement and its own certificate and a message back to the Intercepting client and loops.\n    5. If any of the certificate is invalid, it fails.\n*/\nEM()=\n//improved\nMAC_authentication1->ComCEM?certC.e_id->ComEEM!E_id->ComEEM?e_id.k_ECDHE.msg{call(getM,K_ECDHE);}->\nif(enkey == true){ComCEM!CertEM.E_id.msg->EM()}\nelse{fail141->EM()}\n[]\n//improved fake\nMAC_authentication2->FakeCEM?certC.e_id->InterceptEME!E_id->FakeEEM?e_id.k_ECDHE.msg{call(getMWithMac,FK_ECDHE);}->\nif(enmackey == true){DL{data_leakage_success = true;}->InterceptEMC!CertEM.E_id.Msg->EM()}\nelse{fail151->EM()}\n[]\n//Client creating new group through Entity Manager\nComCEM?certc.msg{call(DC,EM_kpub,EM_kpri);}->\nif(enckey == true){\n\tComEMCA!CertC->ComEMCA?certc.verc->\n\tif(verc == true){\n\t\tComEMRD!K_ECDHE.msg->ComEMRD?ackRD->\n\t\tif(ackRD == true){\n\t\t\tComCEM!AckEM.CertEM.msg->EM()\n\t\t}\n\t\telse{fail16->EM()}\n\t}\n\telse{fail17->EM()}\n}\nelse{fail18->EM()}\n[]\n//fake Entity Manager\nFakeCEM?certc.msg{call(DC,EM_kpub,FEM_kpri);}->\nif(enckey==true){\n\tComEMCA!CertC{entitymanager_fake_success=true;}->ComEMCA?certc.verc->\n\tif(verc == true){\n\t\tInterceptEMRD!K_ECDHE.msg->FakeRDEM?ackRD->\n\t\tif(ackRD==true){\n\t\t\tInterceptEMC!AckEM.CertEM.msg->EM()\n\t\t}\n\t\telse{fail19->EM()}\n\t}\n\telse{fail20->EM()}\n}\nelse{fail21->EM()}\n;\n\n/*@Process: E\n  E (Entity): The Entity provides resources and interacts with the EM.\n  - It performs MAC authentication and receives an entity ID from the entity manager. It sends the entity ID and an encrypted message to the entity manager.\n  - Or, a fake Entity performs MAC authentication and receives an entity ID and sends the entity ID and an encrypted message to the entity manager.\n*/\nE()=\n\tMAC_authentication1->ComEEM?e_id->ComEEM!E_id.K_ECDHE.Msg->E()\n\t[]\n\t//inproved fake\n\tMAC_authentication2->FakeEME?e_id->InterceptEEM!E_id.K_ECDHE.Msg->E();\n\n/*@Process: E\n  S (Sensor): \n  1. It performs ECDHE key generation with the RD\n  2. It sends an encrypted message to the RD and receives an acknowledgement back.\n*/\nS()=ECDHE_key_generation1->ComSRD!K_ECDHE.Msg->ComSRD?ack->S();\n\n/*@Process: INTRUDER\n  INTRUDER:\n  - 1. It sends a fake client a message to fake EM and tries to intercept EM's message.\n    2. If interception and decryption are successful, it sends a message to the fake RD and gets an acknowledgement back.\n  - 1. Or, a fake Entity Manager performs MAC authentication, receives a Client's certificate and entity ID, sends the entity ID to the Entity, and intercepts EM's message.\n  - 1. Or, the INTRUDER intercepts a client's message, decrypts it, and if successful, client fake succeeds.\n    2. Or, the INTRUDER intercepts a client message containing an entity id and sends a fake EM an entity ID.\n*/\nINTRUDER()=\n//fake Entity Manager in entity creation\nFakeCEM!CertC.Msg->InterceptEMRD?k_ECDHE.msg{call(getM,K_ECDHE);}->\nif(enkey == true){FakeRDEM!AckRD->INTRUDER()}\nelse{fail22->INTRUDER()}\n[]\n//improved fake\nMAC_authentication2->FakeCEM!CertC.E_id-> InterceptEME?e_id->FakeEEM!E_id.FK_ECDHE.Msg->InterceptEMC?certEM.e_id.msg->INTRUDER()\n[]\n//fake Client in entity creation\nInterceptCEM?cert_C.msg{call(DC,EM_kpub,FEM_kpri);}->\nif(enckey==true){\n\t{client_fake_success=true;}->INTRUDER()\n}\nelse{fail24->INTRUDER()}\n[]\n//fake Client in entity usage\nInterceptCEM?certC.e_id->FakeEMC!CertEM.E_id->INTRUDER();\n\n/*@Process: COAP\n  The system has several interacting entities: CA (Certificate Authority), RD (Resource Directory), C (Client), EM (Entity Manager), E (Entity), and S (Sensor).  \n  It also includes an INTRUDER process that attempts to compromise the system.\n*/\nCOAP()=CA()||RD()||C()||EM()||E()||S()||INTRUDER();",
        "property_desc": [
            "The system is deadlock-free.",
            "The system is divergence-free.",
            "Clients can successfully obtain the requested information",
            "If an intruder can decrypt the information obtained on the channel and get the content of the information",
            "The intruder successfully disguises itself as a user and communicates with other entities",
            "The intruder has the ability to pretend to be an entity manager and communicates with other entities"
        ],
        "properties": [
            "#assert COAP() deadlockfree;",
            "#assert COAP() divergencefree;",
            "#define Data_Reachability_Success data_reachability_success==true;\n#assert COAP() reaches Data_Reachability_Success;",
            "#define Data_Leakage_Success data_leakage_success==true;\n#assert COAP() reaches Data_Leakage_Success;",
            "#define Client_Fake_Success client_fake_success==true;\n#assert COAP() reaches Client_Fake_Success;",
            "#define Entitymanager_Fake_Success entitymanager_fake_success==true;\n#assert COAP() reaches Entitymanager_Fake_Success;"
        ],
        "processes": [
            {
                "name": "CA",
                "description": "CA (Certificate Authority): The CA validates certificates from the EM and the Client.\n  1. It receives the certificate of the entity manager from the client or receives a certificate from the entity manager.\n  2. It calls the function to check the certificate.\n  3. It sends the result of the validation back to the client or the entity manager.",
                "pat_code": "CA()=\nComCCA?certEM{call(validEM,certEM);}->ComCCA!CertEM.VerEM->CA()\n[]\nComEMCA?certC{call(validC,certC);}->ComEMCA!CertC.VerC->CA();"
            },
            {
                "name": "RD",
                "description": "RD (Resource Directory): The RD manages resources and interacts with Sensors, Clients, and Entity Managers.\n  - 1. It performs ECDHE key generation with the sensor.\n    2. It then receives an encrypted message from the sensor. And decrypt the message using the negotiated ECDHE key.\n    3. If decryption is successful, it sends an acknowledgement to the sensor and loops. Otherwise, it fails.\n  - 1. Or, it performs ECDHE key generation with a Client.\n    2. It receives an encrypted message from the client and decrypts the message using the ECDHE key.\n    3. If decryption is successful, it sends the key back to the client, otherwise, it fails.\n  - 1. Or, it receives a resource message from an Entity Manager. It validates the message, and decrypts it.\n    2. If validation and decryption are successful, it sends an acknowledgement back to the resource manager and loops. Otherwise, it fails.\n  - 1. Or, it receives a resource message from a fake Entity Manager.\n    2. It validates the message and decrypts it. \n    3. If validation and decryption are successful, it sends an acknowledgement back. Otherwise, it fails.",
                "pat_code": "RD()=\n//Sensors reporting portrait to RD\nECDHE_key_generation1->ComSRD?k_ECDHE.msg{call(getM,K_ECDHE);}->\nif(enkey == true){ComSRD!AckRD->RD()}\nelse{fail1->RD()}\n[]\n//Client looking up resources from RD\nECDHE_key_generation2->ComCRD?k_ECDHE.msg{call(getM,K_ECDHE);}->\nif(enkey == true){ComCRD!K_ECDHE.msg->RD()}\nelse{fail2->RD()}\n[]\n//Entity Manager validating resources\nComEMRD?k_ECDHE.msg_rsc{call(validRSC,msg_rsc);call(getM,K_ECDHE);}->\nif(VerRSC==true && enkey == true){ComEMRD!AckRD->RD()}\nelse{fail4->RD()}\n[]\n//intercept Entity Manager\nFakeEMRD?k_ECDHE.msg_rsc{call(validRSC,msg_rsc);call(getM,K_ECDHE);}->\nif(VerRSC==true && enkey == true){InterceptRDEM!AckRD->RD}\nelse{fail5->RD()};"
            },
            {
                "name": "C",
                "description": "C (Client): The Client interacts with the RD and EM to discover and use resources. It may performs following operations:\n  - 1. It performs ECDHE key generation with the RD.\n    2. It sends an encrypted message to the RD and receives an encrypted message back.\n    3. It decrypts the message.\n    4. If decryption is successful, it loops, otherwise it fails.\n  - 1. Or, the Client sends a certificate and a message to the EM.\n    2. And receives an acknowledgement, the EM's certificate, and a message back.\n    3. It decrypts the message from EM.\n    4. If decryption is successful, it sends EM's certificate to the CA, and gets the CA's validation result.\n    5. If the CA validates the EM's certificate, it succeeds, otherwise, it fails.\n    6. Or, if the initial decryption fails, the client goes to fail9 and loops.\n  - 1. Or, a fake Client sends the certificate and the message to the EM.\n    2. It receives an acknowledgement, the EM's certificate, and a message back from the fake entity manager.\n    3. It decrypts the message. If decryption is successful, it sends EM's certificate to the CA, which indicates client fake is viable.\n    4. performs the same thing as the process of receiving the certificate.\n  - 1. Or, a fake Client sends an Entity ID to the EM and receives an EM's certificate, an entity ID and a message back. \n    2. It decrypts the message. If decryption is successful, the data reachability succeeds, otherwise it fails.\n  - 2. Or, a fake Client sends an Entity ID to a fake Entity Manager via InterceptCEM and FakeEMC, it decrypts the message.\n    3. If decryption is successful, it succeds, otherwise it fails.",
                "pat_code": "C()=\n//Client looking up resources from RD\nECDHE_key_generation2->ComCRD!K_ECDHE.Msg->ComCRD?k_ECDHE.msg{call(getM,K_ECDHE);}->\nif(enkey == true){C()}\nelse{fail6->C()}\n[]\n//Client creating new group through Entity Manager\nComCEM!CertC.Msg->ComCEM?ackEM.certEM.msg{call(DEM,C_kpub,C_kpri);}->\nif(enemkey == true){\n\tComCCA!CertEM->ComCCA?certem.verem->\n\tif(verem == true) {success1->C()}\n\telse{fail8->C()}\n}\nelse{fail9->C()}\n[]\n//Fake Client\nInterceptCEM!CertC.Msg->FakeEMC?ackEM.certEM.msg{call(DEM,C_kpub,FC_kpri);}->\nif(enemkey == true){\n\tComCCA!CertEM{client_fake_success = true;}->ComCCA?certem.verem->\n\tif(verem == true){success2->C()}\n\telse{fail10->C()}\n}\nelse {fail11->C()}\n[]\n//Client collecting group info from Entity Manager\nComCEM!CertC.E_id->ComCEM?cert_em.e_id.msg{call(DEM,C_kpub,C_kpri);}->\nif(enemkey == true){success3{data_reachability_success = true;}->C()}\nelse{fail12->C()}\n[]\n//Fake Client\nInterceptCEM!CertC.E_id->FakeEMC?cert_em.e_id{call(DEM,C_kpub,FC_kpri);}->\nif(enemkey == true){success4->C()}\nelse{fail13->C()};"
            },
            {
                "name": "EM",
                "description": "EM (Entity Manager): The EM manages entities, authenticates Clients, and interacts with the RD.\n  - 1. It performs MAC authentication, receives a Client's certificate and entity ID from client, sends the entity ID to the Entity, and receives a message back.\n    2. It decrypts the message.\n    3. If decryption is successful, it sends an EM certificate, entity ID, and message to the Client, otherwise it fails.\n  - 1. Or, a fake Entity Manager performs MAC authentication, receives a Client's certificate and entity ID, sends the entity ID to the Entity, and receives a message back.\n    2. It decrypts the message .\n    3. If decryption is successful, data leakage succeeds and a message is sent to the intercepting client, otherwise it fails.\n  - 1. Or, the EM receives a Client's certificate from the client.\n    2. It decrypts the message.\n    3. If decryption is successful, it sends the Client's certificate to the CA and gets the CA's validation result.\n    4. If the CA validates the Client's certificate, it sends an encrypted message to the RD and gets an acknowledgement back.\n    5. If the RD acknowledges, it sends an acknowledgement and its own certificate and a message back to the Client.\n    6. If any of the certificate is invalid, it fails.\n  - 1. Or, a fake Entity Manager receives a message from fake Client, it decrypts the message.\n    2. If the decryption is successful, which means the entity manager fake is success, it sends Client's certificate to the CA and gets CA's validation result.\n    3. If the CA validates the Client's certificate, the encrypted message sent to the RD is intercepted and gets an acknowledgement back from fake RD.\n    4. If the RD acknowledges, it sends an acknowledgement and its own certificate and a message back to the Intercepting client and loops.\n    5. If any of the certificate is invalid, it fails.",
                "pat_code": "EM()=\n//improved\nMAC_authentication1->ComCEM?certC.e_id->ComEEM!E_id->ComEEM?e_id.k_ECDHE.msg{call(getM,K_ECDHE);}->\nif(enkey == true){ComCEM!CertEM.E_id.msg->EM()}\nelse{fail141->EM()}\n[]\n//improved fake\nMAC_authentication2->FakeCEM?certC.e_id->InterceptEME!E_id->FakeEEM?e_id.k_ECDHE.msg{call(getMWithMac,FK_ECDHE);}->\nif(enmackey == true){DL{data_leakage_success = true;}->InterceptEMC!CertEM.E_id.Msg->EM()}\nelse{fail151->EM()}\n[]\n//Client creating new group through Entity Manager\nComCEM?certc.msg{call(DC,EM_kpub,EM_kpri);}->\nif(enckey == true){\n\tComEMCA!CertC->ComEMCA?certc.verc->\n\tif(verc == true){\n\t\tComEMRD!K_ECDHE.msg->ComEMRD?ackRD->\n\t\tif(ackRD == true){\n\t\t\tComCEM!AckEM.CertEM.msg->EM()\n\t\t}\n\t\telse{fail16->EM()}\n\t}\n\telse{fail17->EM()}\n}\nelse{fail18->EM()}\n[]\n//fake Entity Manager\nFakeCEM?certc.msg{call(DC,EM_kpub,FEM_kpri);}->\nif(enckey==true){\n\tComEMCA!CertC{entitymanager_fake_success=true;}->ComEMCA?certc.verc->\n\tif(verc == true){\n\t\tInterceptEMRD!K_ECDHE.msg->FakeRDEM?ackRD->\n\t\tif(ackRD==true){\n\t\t\tInterceptEMC!AckEM.CertEM.msg->EM()\n\t\t}\n\t\telse{fail19->EM()}\n\t}\n\telse{fail20->EM()}\n}\nelse{fail21->EM()}\n;"
            },
            {
                "name": "E",
                "description": "E (Entity): The Entity provides resources and interacts with the EM.\n  - It performs MAC authentication and receives an entity ID from the entity manager. It sends the entity ID and an encrypted message to the entity manager.\n  - Or, a fake Entity performs MAC authentication and receives an entity ID and sends the entity ID and an encrypted message to the entity manager.",
                "pat_code": "E()=\n\tMAC_authentication1->ComEEM?e_id->ComEEM!E_id.K_ECDHE.Msg->E()\n\t[]\n\t//inproved fake\n\tMAC_authentication2->FakeEME?e_id->InterceptEEM!E_id.K_ECDHE.Msg->E();"
            },
            {
                "name": "E",
                "description": "S (Sensor): \n  1. It performs ECDHE key generation with the RD\n  2. It sends an encrypted message to the RD and receives an acknowledgement back.",
                "pat_code": "S()=ECDHE_key_generation1->ComSRD!K_ECDHE.Msg->ComSRD?ack->S();"
            },
            {
                "name": "INTRUDER",
                "description": "INTRUDER:\n  - 1. It sends a fake client a message to fake EM and tries to intercept EM's message.\n    2. If interception and decryption are successful, it sends a message to the fake RD and gets an acknowledgement back.\n  - 1. Or, a fake Entity Manager performs MAC authentication, receives a Client's certificate and entity ID, sends the entity ID to the Entity, and intercepts EM's message.\n  - 1. Or, the INTRUDER intercepts a client's message, decrypts it, and if successful, client fake succeeds.\n    2. Or, the INTRUDER intercepts a client message containing an entity id and sends a fake EM an entity ID.",
                "pat_code": "INTRUDER()=\n//fake Entity Manager in entity creation\nFakeCEM!CertC.Msg->InterceptEMRD?k_ECDHE.msg{call(getM,K_ECDHE);}->\nif(enkey == true){FakeRDEM!AckRD->INTRUDER()}\nelse{fail22->INTRUDER()}\n[]\n//improved fake\nMAC_authentication2->FakeCEM!CertC.E_id-> InterceptEME?e_id->FakeEEM!E_id.FK_ECDHE.Msg->InterceptEMC?certEM.e_id.msg->INTRUDER()\n[]\n//fake Client in entity creation\nInterceptCEM?cert_C.msg{call(DC,EM_kpub,FEM_kpri);}->\nif(enckey==true){\n\t{client_fake_success=true;}->INTRUDER()\n}\nelse{fail24->INTRUDER()}\n[]\n//fake Client in entity usage\nInterceptCEM?certC.e_id->FakeEMC!CertEM.E_id->INTRUDER();"
            },
            {
                "name": "COAP",
                "description": "The system has several interacting entities: CA (Certificate Authority), RD (Resource Directory), C (Client), EM (Entity Manager), E (Entity), and S (Sensor).  \n  It also includes an INTRUDER process that attempts to compromise the system.",
                "pat_code": "COAP()=CA()||RD()||C()||EM()||E()||S()||INTRUDER();"
            }
        ],
        "global_definition": "channel ComCCA 0;\nchannel ComCRD 0;\nchannel ComCEM 0;\nchannel ComEMCA 0;\nchannel ComEMRD 0;\nchannel ComEEM 0;\nchannel ComSRD 0;\n\nchannel FakeCEM 0;\nchannel InterceptEMC 0;\nchannel FakeEMC 0;\nchannel InterceptCEM 0;\nchannel FakeEEM 0;\nchannel InterceptEME 0;\nchannel FakeEME 0;\nchannel InterceptEEM 0;\nchannel InterceptRDC 0;\nchannel FakeCRD 0;\nchannel InterceptCRD 0;\nchannel FakeRDC 0;\nchannel InterceptEMRD 0;\nchannel FakeEMRD 0;\nchannel InterceptRDEM 0;\nchannel FakeRDEM 0;\n\nvar data_leakage_success=false;\nvar client_fake_success=false;\nvar entitymanager_fake_success=false;\nvar data_reachability_success=false;\n\nvar check=false;\n\nvar Cert_C[3]=[C_id,C_kpub,C_e];\nvar Cert_EM[3]=[EM_id,EM_kpub,EM_e];\n\nvar enkey = false;\nvar enmackey = false;\nvar enckey = false;\nvar enemkey = false;\nvar VerC = false;\nvar VerEM = false;\nvar VerRSC = false;\nvar AckRD = true;\nvar AckEM = true;\n\nenum{C_id,EM_id,E_id};\nenum{C_e,EM_e};\nenum{C_kpub,EM_kpub,RD_kpub,CA_kpub,E_kpub,S_kpub};\nenum{C_kpri,EM_kpri,RD_kpri,CA_kpri,E_kpri,S_kpri};\nenum{Msg,Ack};\nenum{Msg_rsc}; \nenum{CertC,CertEM};\nenum{K_ECDHE,FK_ECDHE};\n\n//intruder\nenum{FC_kpub,FC_kpri,FEM_kpub,FEM_kpri};\nenum{FCertC,FCertEM};\nenum{FMsg,FAck};\nenum{FC_id,FEM_id};\nenum{Fkey};\n\n\n#define validC(certC){\n\tif(certC==CertC){\n\t\tVerC=true;\n\t}else{\n\t\tVerC=false;\n\t}\n};\n\n#define validEM(certEM){\n\tif(certEM==CertEM){\n\t\tVerEM=true;\n\t}else{\n\t\tVerEM=false;\n\t}\n};\n\n#define validRSC(msg_rsc){\n\tif(msg_rsc == Msg_rsc){\n\t\tVerRSC=true;\n\t}else{\n\t\tVerRSC=false;\n\t}\n};\n\n#define getM(key){  \n\tif(key==K_ECDHE){\n\t\tenkey=true;\n\t}else{\n\t\tenkey=false;\n\t}\n};\n\n#define getMWithMac(key){\nif(key == K_ECDHE){\n\t\tenmackey=true;\n\t}else{\n\t\tenmackey=false;\n\t}\n};\n\n#define DEM(c_kpub,c_kpri){ \n\tif(c_kpub==C_kpub&&c_kpri==C_kpri){\n\t\tenemkey=true;\n\t}else{\n\t\tenemkey=false;\n\t}\n};\n\n#define DC(em_kpub,em_kpri){  \n\tif(em_kpub==EM_kpub&&em_kpri==EM_kpri){\n\t\tenckey=true;\n\t}else{\n\t\tenckey=false;\n\t}\n};",
        "path": "handwrite/CoAP.csp"
    },
    {
        "name": "Coco Epoch Commit",
        "tags": [
            "Protocol",
            "Distributed System"
        ],
        "use_non_container_lib": false,
        "description": "The commit protocol is used to commit completed transactions at the end of the current epoch.",
        "pat_code": "#define Yes true;\n#define No false;\n#define N 3; // num of participant \n#define M 2; // num of replica\n#define Commit true;\n#define Abort false;\n\nvar epochNumber = 0;\nvar commit = true; // transaction in coordiantor can commit\nvar released = false; // record lock needs to be released\nvar commitSucceed = 0;\nvar finished = false;\nvar hasNo = false; // message No in participant\n\nchannel CorPat 0; // coordiantor <-> participant\nchannel inform 0;\nchannel ComPRTS[N+1] 0; // primary -> transaction\nchannel ComPRPA[N+1] 0; // primary -> replica\nchannel ComPAPR[N+1] 0; // replica -> primary\n\nenum {replica};\n\n/*@Process: CommitProtocol\n  The Coco Epoch Commit consists of a coordinator process and N participant processes. \n*/\nCommitProtocol() = Coord() || (||| {N} @Part());\n\n/*@Process: CommitProtocol\n  The coordinator process consists of N subprocesses: \n\t1. The subprocesses first send prepare messages to the corresponding participant nodes. \n\t2. Then, they receive acknowledgement messages from all participant nodes through the CorPat channel after sending prepare messages to all participant nodes. \n\t3. After receiving the acknowledgement message ack performs a check and if ack is No, the commit fails. \n\t4. If all participants confirm that the transaction can be committed, then the coordinator node enters the commit phase with the choice. \n*/\nCoord() = (||| {N} @ prepare -> Skip);\n\t(||| {N} @ CorPat?ack -> Check{\n\t\tif(ack == No) {\n\t\t\tcommit = false;\n        }\n    } -> Skip);\n    decide -> CordComPhase(commit);\n/*@Process: CordComPhase\n  In the commit phase:\n\t1. If all the participants agree to commit, then the coordinator records the commit log and adds the time slice serial number. \n\t2. It then sends a commit command to all other participant nodes and receives an acknowledgement message. \n\t3. After receiving the acknowledgement message from all the nodes release all the data locks and then complete the commit. \n\t4. If there is a participant who does not agree to commit, the coordinator process sends an abort command to all participant nodes. \n\t5. Finally, the coordinator process receives all the abort acknowledgement messages and finish this session.\n*/\nCordComPhase(choice) = if(choice == Commit) {\n\t(logCommitRecord{commitSucceed++;} -> increaseEpochNumber{epochNumber++;} -> Skip);\n\t(||| {N} @ inform!Commit -> Skip);\n\t(||| {N} @ CommitACK -> Skip);\n\treleaseResults{released = true;} -> finish{finished = true;} -> Skip\n} else {\n\t(||| {N} @ inform!Abort -> Skip);\n\t(||| {N} @ AbortACK -> Skip);\n\tfinish{finished = true;} -> Skip\n};\n\n/*@Process: Part\n  The participant:\n\t1. The participant node first receives the ready message from the coordinator node and records the write log.\n\t2. Then the participant sends a Yes or No acknowledgement message through the CorPat channel and then enters the commit phase. \n*/\nPart() = prepare -> logWriteRecord \n\t-> (CorPat!Yes -> PartComPhase(Yes)\n\t\t[] CorPat!No{hasNo = true} -> PartComPhase(No));\n/*@Process: PartComPhase\n  In the commit phase, the participant node receives commands from the coordinator process\n\t  1.1. if the command is Commit, it executes the commit transaction and sends an acknowledgement message to the coordinator node\n\t\t1.2. if the command is Abort, it executes the abort transaction and sends an abort acknowledgement message.\n*/\nPartComPhase(Ans) = inform?vote \n\t-> (([vote == Commit](commited{commitSucceed++;} -> CommitACK -> Skip))\n\t\t[] ([vote == Abort](informAbort -> aborted -> AbortACK -> Skip)));",
        "property_desc": [
            "The protocol is deadlock-free.",
            "Every request in a distributed system can be responded to.",
            "When a node or network partition in a distributed system fails, the entire system can still provide external services that satisfy consistency and availability."
        ],
        "properties": [
            "#assert CommitProtocol() deadlockfree;",
            "#define Availability (hasNo == true && finished == true);\n#assert CommitProtocol() reaches Availability;",
            "#define PartitionTolerance (finished == true);\n#assert CommitProtocol() reaches PartitionTolerance;"
        ],
        "processes": [
            {
                "name": "CommitProtocol",
                "description": "The Coco Epoch Commit consists of a coordinator process and N participant processes.",
                "pat_code": "CommitProtocol() = Coord() || (||| {N} @Part());"
            },
            {
                "name": "CommitProtocol",
                "description": "The coordinator process consists of N subprocesses: \n\t1. The subprocesses first send prepare messages to the corresponding participant nodes. \n\t2. Then, they receive acknowledgement messages from all participant nodes through the CorPat channel after sending prepare messages to all participant nodes. \n\t3. After receiving the acknowledgement message ack performs a check and if ack is No, the commit fails. \n\t4. If all participants confirm that the transaction can be committed, then the coordinator node enters the commit phase with the choice.",
                "pat_code": "Coord() = (||| {N} @ prepare -> Skip);\n\t(||| {N} @ CorPat?ack -> Check{\n\t\tif(ack == No) {\n\t\t\tcommit = false;\n        }\n    } -> Skip);\n    decide -> CordComPhase(commit);"
            },
            {
                "name": "CordComPhase",
                "description": "In the commit phase:\n\t1. If all the participants agree to commit, then the coordinator records the commit log and adds the time slice serial number. \n\t2. It then sends a commit command to all other participant nodes and receives an acknowledgement message. \n\t3. After receiving the acknowledgement message from all the nodes release all the data locks and then complete the commit. \n\t4. If there is a participant who does not agree to commit, the coordinator process sends an abort command to all participant nodes. \n\t5. Finally, the coordinator process receives all the abort acknowledgement messages and finish this session.",
                "pat_code": "CordComPhase(choice) = if(choice == Commit) {\n\t(logCommitRecord{commitSucceed++;} -> increaseEpochNumber{epochNumber++;} -> Skip);\n\t(||| {N} @ inform!Commit -> Skip);\n\t(||| {N} @ CommitACK -> Skip);\n\treleaseResults{released = true;} -> finish{finished = true;} -> Skip\n} else {\n\t(||| {N} @ inform!Abort -> Skip);\n\t(||| {N} @ AbortACK -> Skip);\n\tfinish{finished = true;} -> Skip\n};"
            },
            {
                "name": "Part",
                "description": "The participant:\n\t1. The participant node first receives the ready message from the coordinator node and records the write log.\n\t2. Then the participant sends a Yes or No acknowledgement message through the CorPat channel and then enters the commit phase.",
                "pat_code": "Part() = prepare -> logWriteRecord \n\t-> (CorPat!Yes -> PartComPhase(Yes)\n\t\t[] CorPat!No{hasNo = true} -> PartComPhase(No));"
            },
            {
                "name": "PartComPhase",
                "description": "In the commit phase, the participant node receives commands from the coordinator process\n\t  1.1. if the command is Commit, it executes the commit transaction and sends an acknowledgement message to the coordinator node\n\t\t1.2. if the command is Abort, it executes the abort transaction and sends an abort acknowledgement message.",
                "pat_code": "PartComPhase(Ans) = inform?vote \n\t-> (([vote == Commit](commited{commitSucceed++;} -> CommitACK -> Skip))\n\t\t[] ([vote == Abort](informAbort -> aborted -> AbortACK -> Skip)));"
            }
        ],
        "global_definition": "#define Yes true;\n#define No false;\n#define N 3; // num of participant \n#define M 2; // num of replica\n#define Commit true;\n#define Abort false;\n\nvar epochNumber = 0;\nvar commit = true; // transaction in coordiantor can commit\nvar released = false; // record lock needs to be released\nvar commitSucceed = 0;\nvar finished = false;\nvar hasNo = false; // message No in participant\n\nchannel CorPat 0; // coordiantor <-> participant\nchannel inform 0;\nchannel ComPRTS[N+1] 0; // primary -> transaction\nchannel ComPRPA[N+1] 0; // primary -> replica\nchannel ComPAPR[N+1] 0; // replica -> primary\n\nenum {replica};",
        "path": "handwrite/Coco Epoch Commit.csp"
    },
    {
        "name": "Coco OCC",
        "tags": [
            "Protocol",
            "Distributed System"
        ],
        "use_non_container_lib": false,
        "description": "The Optimistic concurrency control algorithm has three phases which are lock recording phase, validation phase and data write back phase. The concurrency control process consists of multiple transaction processes and a Primary process, after successfully writing to the Primary node, the concurrency control mechanism automatically runs the data replication protocol to synchronize all the replicas.",
        "pat_code": "#define Yes true;\n#define No false;\n#define N 3; // num of participant \n#define M 2; // num of replica\n\nvar existCrash = false;\nvar available = true;\n\nchannel ComPRTS[N+1] 0; // primary -> transaction\nchannel ComPRPA[N+1] 0; // primary -> replica\nchannel ComPAPR[N+1] 0; // replica -> primary\n\nenum {replica};\n\n/*@Process: Replication\n   \tThe data replication protocol is a mechanism that ensures data synchronization between multiple replicas of the COCO distributed database. The data replication protocol consists of a Primary process and M Replica processes.\n*/\nReplication() = Primary() || (|||x:{1..M}@Replica(x));\n/*@Process: Primary\n  The replication Primary process:\n\t1. It sends a data synchronization command to the replica through the ComPRPA channel after updating the local data\n\t2. It then receives an acknowledgement message through the ComPAPR channel.\n*/\nPrimary() = |||x:{1..M}@(ComPRPA[x]!replica.x -> ComPAPR[x]?replicateACK -> Skip);\n/*@Process: Replica\n  The ith Replica process:\n\t1. It receives the ith synchronization data and transaction ID and other information sent by the Primary process through comPRPA. \n\t2. Then it writes the received message locally and sends an acknowledgement message through the comPAPR channel according to the writing situation, Yes means that the data has been successfully synchronized, and No means that the data synchronization execution has failed.\n*/\nReplica(i) = ComPRPA[i]?rep.tid -> writeData -> ComPAPR[i]!Yes -> Skip\n\t\t\t\t\t\t\t\t\t\t\t\t[] ComPAPR[i]!No -> Skip;\n\n/*@Process: OCC\n\tThe Transaction process OCC with a primary process ahd N transactions has three phases: Lock phase, Validation and Write Back.\n*/\nOCC() = (|||i:{1..N}@Transaction(i)) || OCCPrimary();\n/*@Process: Transaction\n  Lock phase:\n\t1. In the first phase the process first locks the data items to be modified.\n\t2. Then it receives an acknowledgement message ACK from the Primary process through the ComPRTS channel. \n\t3. If ACK is Yes, it check the write set and proceeds, otherwise it releases all the locks and aborts the transaction.\n\t4. Next the transaction process sends the Modify Data Item command and receives the verify confirmation message from the CompRTS channel, \n\t\t4.1. If the message is Yes, the locking phase is completed and the validation phase proceeds. \n\t\t4.2. Otherwise, the data items in the write collection are released and the transaction is aborted.\n*/\nTransaction(i) = LockWriteSet -> ComPRTS[i]?lockACK -> if(lockACK == Yes) {\n\t\tCheckWriteSet -> ComPRTS[i]?checkACK -> if(checkACK == Yes) {\n\t\t\tLockSuccess -> TransValidPhase(i)\n\t\t} else {\n\t\t\tUnlockWS -> Aborted -> Skip\n\t\t}\n\t} else {\n\t\tUnlockWS -> Aborted -> Skip\n\t};\n/*@Process: TransValidPhase\n  Validation:\n\t1. During the validation phase, the transaction process sends a validate read command to the Primary process and receives an acknowledgement message validACK over CompRTS. \n\t2. If validACK is Yes, it sends a check read data command otherwise it releases all locks and aborts the transaction.\n\t3. If the validation is successful, it enters the writeback phase; otherwise, it releases all occupied locks and aborts the transaction.\n*/\nTransValidPhase(i) = ValidReadSet -> ComPRTS[i]?validACK -> if(validACK == Yes) {\n\t\tCheckReadSet -> ComPRTS[i]?checkVersionACK -> if(checkVersionACK == Yes) {\n\t\t\tValidSuccess -> TransWritePhase(i)\n\t\t} else {\n\t\t\tUnlockRS -> Aborted -> Skip\n\t\t}\n\t} else {\n\t\tUnlockRS -> Aborted -> Skip\n\t};\n/*@Process: TransWritePhase\n  Write Back:\n\t1. In the write-back phase, the transaction process first sends a write-back command to the Primary process and receives an acknowledgement message through the ComPRTS channel. \n\t2. It releases the locks after receiving the acknowledgement message.\n*/\nTransWritePhase(i) = WriteBack -> ComPRTS[i]?writeACK -> Unlock -> Skip;\n\n/*@Process: OCCPrimary\n  The Primary process is similar to that of transaction process and is also divided into three phases: lock phase, validation phase and write back phase. It has N subprocesses.\nLock phase:\n\t1. The Primary process first receives lock requests from multiple transaction processes \n\t2. It then sends lock confirmation messages and if the lock fails, releases the lock after sending the confirmation message.\n  3. After receiving the command to check the write set from the transaction process, the Primary process performs the check, sends the check result to the transaction process and enters the transaction verification phase. If the check fails, all locks are released after sending an acknowledgement message.\n*/\nOCCPrimary() = (|||i:{1..N}@(LockWriteSet -> (ComPRTS[i]!Yes -> CheckWriteSet -> ((ComPRTS[i]?No -> UnlockWS -> Skip)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   [] (ComPRTS[i]!Yes -> PrimaryValidPhase(i)))\n\t\t\t\t\t\t\t\t\t\t\t  [] ComPRTS[i]!No -> UnlockWS -> Skip)));\n\n/*@Process: PrimaryValidPhase\n  Validation:\n  1. In the validation phase, the Primary process receives the command to validate the read set from the transaction process and performs the validation of the read set.\n\t2. It sends the validation result to the transaction process, if the validation is successful, then it enters the write back phase, otherwise the process will release all locks.\n*/\nPrimaryValidPhase(i) = ValidReadSet -> (ComPRTS[i]!Yes -> CheckReadSet -> ((ComPRTS[i]!No -> UnlockRS -> Skip\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t[] (ComPRTS[i]!Yes -> PrimaryWritePhase(i))))\n\t\t\t\t\t\t\t\t\t\t[] ComPRTS[i]!No -> UnlockRS -> Skip);\n\n/*@Process: PrimaryWritePhase\n\tWrite Back:\n\t1. In the write-back phase, the Primary process receives the write-back command from the transaction, writes the data and sends the result to the transaction process. \n\t2. After successful writing, the data replication protocol is executed to synchronize the newly written data to other copies to maintain data consistency.\n*/\nPrimaryWritePhase(i) = (WriteBack -> ComPRTS[i]!Yes -> Unlock -> Skip); Replication();",
        "property_desc": [
            "The protocol is deadlock-free.",
            "When some failures occur in the system, the system can still guarantee the normal execution of most transactions."
        ],
        "properties": [
            "#assert OCC() deadlockfree;",
            "#define BasicallyAvailability (existCrash && available);\n#assert OCC() |= BasicallyAvailability;"
        ],
        "processes": [
            {
                "name": "Replication",
                "description": "The data replication protocol is a mechanism that ensures data synchronization between multiple replicas of the COCO distributed database. The data replication protocol consists of a Primary process and M Replica processes.",
                "pat_code": "Replication() = Primary() || (|||x:{1..M}@Replica(x));"
            },
            {
                "name": "Primary",
                "description": "The replication Primary process:\n\t1. It sends a data synchronization command to the replica through the ComPRPA channel after updating the local data\n\t2. It then receives an acknowledgement message through the ComPAPR channel.",
                "pat_code": "Primary() = |||x:{1..M}@(ComPRPA[x]!replica.x -> ComPAPR[x]?replicateACK -> Skip);"
            },
            {
                "name": "Replica",
                "description": "The ith Replica process:\n\t1. It receives the ith synchronization data and transaction ID and other information sent by the Primary process through comPRPA. \n\t2. Then it writes the received message locally and sends an acknowledgement message through the comPAPR channel according to the writing situation, Yes means that the data has been successfully synchronized, and No means that the data synchronization execution has failed.",
                "pat_code": "Replica(i) = ComPRPA[i]?rep.tid -> writeData -> ComPAPR[i]!Yes -> Skip\n\t\t\t\t\t\t\t\t\t\t\t\t[] ComPAPR[i]!No -> Skip;"
            },
            {
                "name": "OCC",
                "description": "The Transaction process OCC with a primary process ahd N transactions has three phases: Lock phase, Validation and Write Back.",
                "pat_code": "OCC() = (|||i:{1..N}@Transaction(i)) || OCCPrimary();"
            },
            {
                "name": "Transaction",
                "description": "Lock phase:\n\t1. In the first phase the process first locks the data items to be modified.\n\t2. Then it receives an acknowledgement message ACK from the Primary process through the ComPRTS channel. \n\t3. If ACK is Yes, it check the write set and proceeds, otherwise it releases all the locks and aborts the transaction.\n\t4. Next the transaction process sends the Modify Data Item command and receives the verify confirmation message from the CompRTS channel, \n\t\t4.1. If the message is Yes, the locking phase is completed and the validation phase proceeds. \n\t\t4.2. Otherwise, the data items in the write collection are released and the transaction is aborted.",
                "pat_code": "Transaction(i) = LockWriteSet -> ComPRTS[i]?lockACK -> if(lockACK == Yes) {\n\t\tCheckWriteSet -> ComPRTS[i]?checkACK -> if(checkACK == Yes) {\n\t\t\tLockSuccess -> TransValidPhase(i)\n\t\t} else {\n\t\t\tUnlockWS -> Aborted -> Skip\n\t\t}\n\t} else {\n\t\tUnlockWS -> Aborted -> Skip\n\t};"
            },
            {
                "name": "TransValidPhase",
                "description": "Validation:\n\t1. During the validation phase, the transaction process sends a validate read command to the Primary process and receives an acknowledgement message validACK over CompRTS. \n\t2. If validACK is Yes, it sends a check read data command otherwise it releases all locks and aborts the transaction.\n\t3. If the validation is successful, it enters the writeback phase; otherwise, it releases all occupied locks and aborts the transaction.",
                "pat_code": "TransValidPhase(i) = ValidReadSet -> ComPRTS[i]?validACK -> if(validACK == Yes) {\n\t\tCheckReadSet -> ComPRTS[i]?checkVersionACK -> if(checkVersionACK == Yes) {\n\t\t\tValidSuccess -> TransWritePhase(i)\n\t\t} else {\n\t\t\tUnlockRS -> Aborted -> Skip\n\t\t}\n\t} else {\n\t\tUnlockRS -> Aborted -> Skip\n\t};"
            },
            {
                "name": "TransWritePhase",
                "description": "Write Back:\n\t1. In the write-back phase, the transaction process first sends a write-back command to the Primary process and receives an acknowledgement message through the ComPRTS channel. \n\t2. It releases the locks after receiving the acknowledgement message.",
                "pat_code": "TransWritePhase(i) = WriteBack -> ComPRTS[i]?writeACK -> Unlock -> Skip;"
            },
            {
                "name": "OCCPrimary",
                "description": "The Primary process is similar to that of transaction process and is also divided into three phases: lock phase, validation phase and write back phase. It has N subprocesses.\nLock phase:\n\t1. The Primary process first receives lock requests from multiple transaction processes \n\t2. It then sends lock confirmation messages and if the lock fails, releases the lock after sending the confirmation message.\n  3. After receiving the command to check the write set from the transaction process, the Primary process performs the check, sends the check result to the transaction process and enters the transaction verification phase. If the check fails, all locks are released after sending an acknowledgement message.",
                "pat_code": "OCCPrimary() = (|||i:{1..N}@(LockWriteSet -> (ComPRTS[i]!Yes -> CheckWriteSet -> ((ComPRTS[i]?No -> UnlockWS -> Skip)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   [] (ComPRTS[i]!Yes -> PrimaryValidPhase(i)))\n\t\t\t\t\t\t\t\t\t\t\t  [] ComPRTS[i]!No -> UnlockWS -> Skip)));"
            },
            {
                "name": "PrimaryValidPhase",
                "description": "Validation:\n  1. In the validation phase, the Primary process receives the command to validate the read set from the transaction process and performs the validation of the read set.\n\t2. It sends the validation result to the transaction process, if the validation is successful, then it enters the write back phase, otherwise the process will release all locks.",
                "pat_code": "PrimaryValidPhase(i) = ValidReadSet -> (ComPRTS[i]!Yes -> CheckReadSet -> ((ComPRTS[i]!No -> UnlockRS -> Skip\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t[] (ComPRTS[i]!Yes -> PrimaryWritePhase(i))))\n\t\t\t\t\t\t\t\t\t\t[] ComPRTS[i]!No -> UnlockRS -> Skip);"
            },
            {
                "name": "PrimaryWritePhase",
                "description": "Write Back:\n\t1. In the write-back phase, the Primary process receives the write-back command from the transaction, writes the data and sends the result to the transaction process. \n\t2. After successful writing, the data replication protocol is executed to synchronize the newly written data to other copies to maintain data consistency.",
                "pat_code": "PrimaryWritePhase(i) = (WriteBack -> ComPRTS[i]!Yes -> Unlock -> Skip); Replication();"
            }
        ],
        "global_definition": "#define Yes true;\n#define No false;\n#define N 3; // num of participant \n#define M 2; // num of replica\n\nvar existCrash = false;\nvar available = true;\n\nchannel ComPRTS[N+1] 0; // primary -> transaction\nchannel ComPRPA[N+1] 0; // primary -> replica\nchannel ComPAPR[N+1] 0; // replica -> primary\n\nenum {replica};",
        "path": "handwrite/Coco OCC.csp"
    },
    {
        "name": "Delegate Contract Signing Mechanism",
        "tags": [
            "Protocol"
        ],
        "use_non_container_lib": false,
        "description": "The mechanism framework based on smart contracts consists of the following six entities: \n\tContract Issuer (CI), Financial Investment Smart Contract (FISC), Delegate Authorization Smart Contract (DASC), Sale Manager (SM), Client (C), Arbitration Institution (AI)",
        "pat_code": "#define Message 10;\nvar gMessage = 0;\nenum{ciEOA,fEOA,dEOA,sEOA,cEOA,aEOA};\nenum{ciEPK,fEPK,dEPK,sEPK,cEPK,aEPK};\nenum{ciSIG,fSIG,dSIG,sSIG,cSIG,aSIG};\nenum{Initialization,Process,Fraud,End};\nenum{sidentity,cidentity};\nenum{ciid,sid,aid,cid};\nenum{address_d,address_f};\nenum{deposit};\n\nchannel ComFCI 0; //Contract issuer&&Financial smart contract\nchannel ComDCI 0; //Delegate authorization smart contract&&Contract issuer\nchannel ComFAI 0; //Financial smart contract&&Arbitration institution\nchannel ComDS 0; //Delegate authorization smart contract&&Sale manager\nchannel ComFSM 0; //Financial smart contract&&Sale manager\nchannel ComFC 0; //Financial smart contract&&Client\nchannel ComDC 0; //Delegate authorization smart contract&&Client\nchannel ComSMC 0; //Sale manager&&Client\nchannel ComFD 0; //Financial smart contract&&Delegate authorization smart contract\n\nvar state = Initialization;\nvar dsig_success = false;\nvar fsig_success = false;\nvar cisig_success = false;\nvar ssig_success = false;\nvar csig_success = false;\nvar isOK = true; \nvar fraud_free = false;\nvar Authorized = false;\nvar reachable_flag = false;\nvar signing_correct_flag = false;\nvar fraud_free_flag = false;\nvar dispute_resolution_flag  = false;\nvar response_challenge_flag = false;  \n\n#define DVerifySig(deoa,depk,dsig)\n{if(deoa == dEOA && depk == dEPK && dsig == dSIG)\n{dsig_success = true}\n};\n#define FVerifySig(feoa,fepk,fsig)\n{if(feoa == fEOA && fepk == fEPK && fsig == fSIG)\n{fsig_success = true}\n};\n#define CIVerifySig(cieoa,ciepk,cisig) \n{if(cieoa == ciEOA && ciepk == ciEPK && cisig == ciSIG)\n{cisig_success = true}\n};\n#define SVerifySig(seoa,sepk,ssig)\n{if(seoa == sEOA && sepk == sEPK && ssig == sSIG)\n{ssig_success = true}\n};\n#define CVerifySig(ceoa,cepk,csig)\n{if(ceoa == cEOA && cepk == cEPK && csig == cSIG)\n{csig_success = true}\n};\n#define SGenerateMessage(message,seoa,sepk)\n{if(seoa == sEOA && sepk == sEPK)\n\t{gMessage = message}\n};\n\n/*@Process: Contract_Issuer\n\tContract Issuer (CI): It is a smart contract issuance organization that can create and deploy smart contracts.\n\t1. It first sends contract details (ID, EOA, EPK, SIG) to the FISC.\n  2. Pays a financial deposit and deploys the smart contract on the blockchain.\n  3. Receives the delegate's address, sale manager's ID and identity, and delegate's signature from the DASC.\n  4. Verifies the delegate's signature. If verification fails, the process stops.\n  5. If verification succeds, sends its contract ID, the sale manager's ID and identity, and its own EOA/EPK/SIG to the DASC, instructing it to add the Sale Manager.\n  6. Receives the financial smart contract's address and signature from FISC and verifies the it. If verification fails, the process stops, otherwise, it proceeds.\n  7. If the user isn't satisfied with the contract's financial content, the CI receives the financial smart contract's address, the arbitration institution's id, and client's id with financial smart contract's signature from FISC.\n\t8. Then it receives the financial smart contract's address and the AI's id with the financial smart contract's signature and verifies it, if the verification fails, the process stops. \n*/\nContract_Issuer() = ComFCI!ciid.ciEOA.ciEPK.ciSIG -> payFDeposit -> deployChain ->\n  ComDCI?address_d.sid.sidentity.deoa.depk.dsig{call(DVerifySig,deoa,depk,dsig)} -> \n\tif(dsig_success == false){\n\t\tStop\n\t} else { \n\t\tComDCI!ciid.sid.sidentity.ciEOA.ciEPK.ciSIG -> addSaleManager{state = Process} ->\n\t\tComFCI?address_f.feoa.fepk.fsig{call(FVerifySig,feoa,fepk,fsig)} -> \n\t\tif(fsig_success == false){ \n\t\t\tStop\n\t\t} else if(isOK == false){\n\t\t\tComFCI?address_f.aid.cid.feoa.fepk.fsig -> \n\t\t\tComFCI?address_f.aid.feoa.fepk.fsig{call(FVerifySig,feoa,fepk,fsig)}->\n\t\t\tif(fsig_success == false){\n\t\t\t\tStop\n\t\t\t} else {\n\t\t\t\tContract_Issuer()\n\t\t\t} \n\t\t} else {Contract_Issuer()}\n  };\n\n/*@Process: Financial_Investment_SmartContract\n\tFinancial Investment Smart Contract (FISC): It has the content of financial investment contracts.\n  1. It starts by receiving CI's ID and signature.\n  2. Verifies the contract issuer's signature. If verification fails, the process stops, otherwise, it proceeds.\n  3. Sends address and signature to the SM and the Client.\n  4. Receives the Client's ID, identity, and signature and verifies it. If verification fails, the process stops, otherwise, it proceeds.\n\t5. If user isn't satisfied with the contract:\n\t5.1. Sends its own address and signature to CI, then sends its own address and signature to SM.\n\t5.2. Sends its address, arbitration ID, and client ID to CI and AI.\n\t5.3. Receives the arbitration institution's ID, signature.\n  5.4. If there is no fraud: Sends its address and signature to CI and the Client and then sends to DASC, its own signature and arbitration id and execute settlement. \n  5.5. If fraud is confirmed: Sends its address and signature to CI and the Client and execute Penalty. \n  6. If Client isn satisfied with the contract:\n  6.1. Sends its address and signature to CI and SM. And sends its address, arbitration ID, and client ID to AI.\n  6.2. Receives the client's ID, identity, and signature.\n  6.3. It initiates SignedByClient.\n  6.4. Receives the SM's ID, identity, and signature and verifies the signature. If verification fails, the process stops, otherwise, it proceeds.\n\t6.5. It initiates SignedBySalesmanager.\n*/\nFinancial_Investment_SmartContract() = \n\tComFCI?ciid.cieoa.ciepk.cisig{call(CIVerifySig,cieoa,ciepk,cisig)}-> \n\tif(cisig_success == false){\n\t\tStop\n\t} else{\n\t\tComFSM!address_f.fEOA.fEPK.fSIG -> ComFC!address_f.fEOA.fEPK.fSIG->\n\t\tComFC?cid.cidentity.ceoa.cepk.csig{call(CVerifySig,ceoa,cepk,csig)} -> \n\t\tif(csig_success == false){\n\t\t\tStop\n\t\t} else if(isOK == false){\n\t\t\tComFCI!address_f.fEOA.fEPK.fSIG -> ComFSM!address_f.fEOA.fEPK.fSIG -> \n\t\t\tComFCI!address_f.aid.cid.fEOA.fEPK.fSIG -> ComFAI!address_f.aid.cid.fEOA.fEPK.fSIG -> \n\t\t\tComFAI?aid.aeoa.aepk.asig -> \n\t\t\tif(fraud_free == true){\n\t\t\t\tComFCI!address_f.aid.fEOA.fEPK.fSIG -> ComFC!address_f.aid.fEOA.fEPK.fSIG -> \n\t\t\t\tComFD!address_f.fEOA.fEPK.fSIG.aid -> settlement{state = End;reachable_flag = true;fraud_free_flag = true} -> \n\t\t\t\tFinancial_Investment_SmartContract()\n\t\t\t} else {\n\t\t\t\tComFCI!address_f.aid.fEOA.fEPK.fSIG -> ComFC!address_f.aid.fEOA.fEPK.fSIG -> \n\t\t\t\tPenalty{state = End;reachable_flag = true;dispute_resolution_flag = true} -> \n\t\t\t\tFinancial_Investment_SmartContract()\n\t\t\t}\n\t\t} else {\n\t\t\tComFCI!address_f.fEOA.fEPK.fSIG-> ComFSM!address_f.fEOA.fEPK.fSIG -> \n\t\t\tComFAI!address_f.aid.cid.fEOA.fEPK.fSIG -> ComFC?cid.cidentity.ceoa.cepk.csig -> \n\t\t\tSignedByClient -> ComFSM?sid.sidentity.seoa.sepk.ssig{call(SVerifySig,seoa,sepk,ssig)} -> \n\t\t\tif(ssig_success == false){\n\t\t\t\tStop\n\t\t\t} else{\n\t\t\t\tSignedBySalesmanager{reachable_flag = true;signing_correct_flag = true;state = End; Authorized = false} -> \n\t\t\t\tFinancial_Investment_SmartContract()\n\t\t\t} \n\t\t}\n\t};\n\t  \n/*@Process: Sale_Manager\n  Sale Manager (SM): It is the entity authorized by the CI to sign financial investment contracts.\n  1. It receives the financial smart contract's address and signature and verifies the signature. If verification fails, the process stops, otherwise, it proceeds.\n  2. Requests a delegate and sends SM's ID, identity, and signature to the DASC.\n  3. Receives the delegate's address, the SM's ID and identity, the delegate's signature, and the CI's ID from the DASC.\n  4. Verifies the delegate's signature. If verification fails, the process stops, otherwise, it proceeds.\n  5. Receives the client's ID, identity, and signature and verifies it. If client's signature verification fails, then stop, otherwise, it proceeds.\n  6. Sends its own ID, identity, and signature to the Client, receives an arbitrary random message and generates a data signature using its private key\n\t7. Sends the generated signature to the client and receives messages from the DASC.\n  8. Sends the financial contract's address to the client with signature, and waits for the verification result from the client. If the result is invalid, it stops.\n  9. If the user isn't satisfied with the contract's financial content, then loops to Sale_Manager().\n  10. Otherwise, sends the its own ID, identity, and signature to final smart contractthen loops to Sale_Manager().\n*/\nSale_Manager() = ComFSM?address_f.feoa.fepk.fsig{call(FVerifySig,feoa,fepk,fsig)}-> if(fsig_success == false){\n\t\tStop\n\t} else{ \n\t\tRequestDelegate->ComDS!sid.sidentity.sEOA.sEPK.sSIG -> \n\t\tComDS?address_d.sid.sidentity.deoa.depk.dsig.ciid{call(DVerifySig,deoa,depk,dsig)} -> \n\t\tif(dsig_success == false){ \n\t\t\tStop\n\t\t} else {\n\t\t\tComSMC?cid.cidentity.ceoa.cepk.csig{call(CVerifySig,ceoa,cepk,csig)} -> \n\t\t  if(csig_success == false){Stop}\n\t\t\telse {\n\t\t\t\tComSMC!sid.sidentity.sEOA -> ComSMC?Message.seoa.sepk{call(SGenerateMessage,Message,seoa,sepk)} -> \n\t\t\t\tComSMC!sid.sidentity.sEOA.sEPK.sSIG.gMessage -> ComDS?address_d.cid.deposit.deoa.depk.dsig -> \n\t\t\t\tComSMC!address_f.fEOA{state = Fraud} ->ComFSM?address_f.feoa.fepk.fsig{call(FVerifySig,feoa,fepk,fsig)} -> \n\t\t\t\tif(fsig_success == false){Stop} \n \t      else if(isOK==false){Sale_Manager()}\n \t      else {ComFSM!sid.sidentity.sEOA.sEPK.sSIG{state = End} -> Sale_Manager()}\n \t\t  }\n  \t}\n  };\n\n/*@Process: Delegate_Authorization_SmartContract\n\tDelegate Authorization Smart Contract (DASC): It has detailed information about creating delegated authorization for the sales manager.\n  1. Receives the SM's ID, identity, and signature.\n  2. Verifies the sale manager's signature. If verification fails, the process stops, otherwise, it proceeds.\n  3. Then, sends delegate's address and its own signature to CI.\n  4. Receives the CI's ID, the sale manager's ID and identity, and the CI's signature from CI.\n  5. Verifies the CI's signature. If verification fails, the process stops, otherwise, it proceeds.\n  6. Sends delegate's address and its own signature to SM.\n  7. Receives client's ID, identity, and signature from the Client and verifies it. If client's signature verification fails, then stop, otherwise, it proceeds.\n  8. Performs Identity Verification and receives client's identity and signature.\n  9. Requests signing. Sends the delegate's address, the client's id and deposit to the SM. And send notice.\n  10. If the user isn't satisfied with the contract and if fraud is confirmed, it needs to receive the contract's information and verifies the signature. If it fails, then stop. \n*/\nDelegate_Authorization_SmartContract() = \n\tComDS?sid.sidentity.seoa.sepk.ssig{call(SVerifySig,seoa,sepk,ssig)} ->\n\tif(ssig_success == false){Stop} \n\telse {\n\t\tComDCI!address_d.sid.sidentity.dEOA.dEPK.dSIG-> \n\t\tComDCI?ciid.sid.sidentity.cieoa.ciepk.cisig{call(CIVerifySig,cieoa,ciepk,cisig)} -> \n\t\tif(cisig_success == false){ Stop} \n\t  else {\n\t\t\tComDS!address_d.sid.sidentity.dEOA.dEPK.dSIG.ciid{Authorized = true} -> \n\t\t\tComDC?cid.cidentity.sid.sidentity.seoa.ceoa.cepk.csig{call(CVerifySig,ceoa,cepk,csig)} -> \n\t\t\tif(csig_success == false){Stop}\n      else {\n\t\t\t\tIdetityVerification -> ComDC?cid.cidentity.ceoa.cepk.csig -> \n\t\t\t\tRequestSigning -> ComDS!address_d.cid.deposit.dEOA.dEPK.dSIG ->notice->\n        if(isOK == false){\n\t\t\t\t\tif(fraud_free == true ){\n\t\t\t\t\t\tComFD?address_f.feoa.fepk.fsig.aid{call(FVerifySig,feoa,fepk,fsig)} ->\n\t\t\t\t\t  if(fsig_success == false){Stop} \n      \t  } else {\n\t\t\t\t\t\tDelegate_Authorization_SmartContract()\n\t\t\t\t\t}\n      \t} else {\n\t\t\t\t\tDelegate_Authorization_SmartContract()\n\t\t\t\t}\n      }\n    }\n\t};\n\n/*@Process: Client\n  Client (C): It is an entity with financial investment needs that signs financial investment contracts through a delegation contract signing mechanism.\n  1. It first receives the financial smart contract's address and signature and verifies it. If verification fails, the process stops, otherwise, it proceeds.\n  2. Sends client's ID, identity, and signature to SM, and then receives SM's id and identity from SM.\n  3. Sends client's ID, identity, and signature to DASC, and then sends a message to the SM.\n  4. It receives delegate's signature and message with sale manager's identification data from SM and verifies it. If fails, it stops, otherwise, proceeds.\n  5. It performs ReponseVerify. Checks if the received message matches the expected message.\n  6. If the messages match: Sends client's ID, identity, and signature to DASC, and the receives contract's address from SM. \n\t7. Sends the client's ID, identity, and signature to the FISC.\n  8. If the user isn't satisfied with the contract: it receives contract's address from DASC.\n  9. Otherwise: sends client's ID, identity, and signature to contract again.\n*/\nClient() = ComFC?address_f.feoa.fepk.fsig{call(FVerifySig,feoa,fepk,fsig)} -> \n  if(fsig_success == false){\n\t\tStop\n\t} else {\n\t\tComSMC!cid.cidentity.cEOA.cEPK.cSIG -> ComSMC?sid.sidentity.seoa -> \n\t\tComDC!cid.cidentity.sid.sidentity.sEOA.cEOA.cEPK.cSIG -> ComSMC!Message.sEOA.sEPK -> \n\t\tComSMC?sid.sidentity.seoa.sepk.ssig.gmessage{call(SVerifySig,seoa,sepk,ssig)} -> \n\t\tif(ssig_success == false ){ \n\t\t\tStop\n\t\t} else{\n\t\t\tReponseVerify -> \n\t\t\tif(gMessage == Message){ \n\t\t\t\tComDC!cid.cidentity.cEOA.cEPK.cSIG{response_challenge_flag = true} -> \n\t\t\t\tComSMC?address_f.feoa ->ComFC!cid.cidentity.cEOA.cEPK.cSIG -> \n\t\t\t\tif(isOK == false){\n\t\t\t\t\tComFC?address_f.aid.feoa.fepk.fsig -> Client()\n\t\t\t\t} else {\n\t\t\t\t\tComFC!cid.cidentity.cEOA.cEPK.cSIG -> Client()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n  };\n\n/*@Process: Arbitration_Institution\n  Arbitration Institution (AI): It is an entity trusted by the contract issuer, sales manager, and traders.\n  1. It first receives the financial smart contract's address, id, and client's id from the FISC with its signature, and verifies it. If fails, stop, otherwise, it proceeds.\n  2. If the user isn't satisfied with the contract's financial content, sends its own id and signature to the FISC.\n*/\nArbitration_Institution() = ComFAI?address_f.aid.cid.feoa.fepk.fsig{call(FVerifySig,feoa,fepk,fsig)}-> \n\tif(fsig_success == false ){Stop} \n\telse if(isOK == false) {ComFAI!aid.aEOA.aEPK.aSIG-> Arbitration_Institution()}\n\telse{middle18 -> Arbitration_Institution()};\n\n/*@Process: System\n  The mechanism framework based on smart contracts consists of the following six entities: \n\tContract Issuer (CI), Financial Investment Smart Contract (FISC), Delegate Authorization Smart Contract (DASC), Sale Manager (SM), Client (C), Arbitration Institution (AI)\n*/\nSystem()=Contract_Issuer()||Financial_Investment_SmartContract()||Sale_Manager()||Delegate_Authorization_SmartContract()||Client()||Arbitration_Institution();",
        "property_desc": [
            "The system is deadlock-free.",
            "The system is divergencefree.",
            "All data can be transferred between the entities during the communication process after successful signing.",
            "All data can be transferred between the entities during the communication process when fraud free.",
            "All data can be transferred between the entities during the communication process when fraud exists.",
            "Consistency between the message sent by the client to the sale manager in the challenge-response mechanism"
        ],
        "properties": [
            "#define Data_Reachable reachable_flag == true;\n#define Signing_Correct_Flag signing_correct_flag == true;\n#define Fraud_Free_Flag fraud_free_flag == true;\n#define Dispute_Resolution_Flag dispute_resolution_flag == true;\n#define Response_Challenge_Success_Flag response_challenge_flag == true;\n\n#assert System() deadlockfree;",
            "#assert System() divergencefree;",
            "#assert System() reaches Signing_Correct_Flag;",
            "#assert System() reaches Fraud_Free_Flag;",
            "#assert System() reaches Dispute_Resolution_Flag;",
            "#assert System() |=<> Response_Challenge_Success_Flag;"
        ],
        "processes": [
            {
                "name": "Contract_Issuer",
                "description": "Contract Issuer (CI): It is a smart contract issuance organization that can create and deploy smart contracts.\n\t1. It first sends contract details (ID, EOA, EPK, SIG) to the FISC.\n  2. Pays a financial deposit and deploys the smart contract on the blockchain.\n  3. Receives the delegate's address, sale manager's ID and identity, and delegate's signature from the DASC.\n  4. Verifies the delegate's signature. If verification fails, the process stops.\n  5. If verification succeds, sends its contract ID, the sale manager's ID and identity, and its own EOA/EPK/SIG to the DASC, instructing it to add the Sale Manager.\n  6. Receives the financial smart contract's address and signature from FISC and verifies the it. If verification fails, the process stops, otherwise, it proceeds.\n  7. If the user isn't satisfied with the contract's financial content, the CI receives the financial smart contract's address, the arbitration institution's id, and client's id with financial smart contract's signature from FISC.\n\t8. Then it receives the financial smart contract's address and the AI's id with the financial smart contract's signature and verifies it, if the verification fails, the process stops.",
                "pat_code": "Contract_Issuer() = ComFCI!ciid.ciEOA.ciEPK.ciSIG -> payFDeposit -> deployChain ->\n  ComDCI?address_d.sid.sidentity.deoa.depk.dsig{call(DVerifySig,deoa,depk,dsig)} -> \n\tif(dsig_success == false){\n\t\tStop\n\t} else { \n\t\tComDCI!ciid.sid.sidentity.ciEOA.ciEPK.ciSIG -> addSaleManager{state = Process} ->\n\t\tComFCI?address_f.feoa.fepk.fsig{call(FVerifySig,feoa,fepk,fsig)} -> \n\t\tif(fsig_success == false){ \n\t\t\tStop\n\t\t} else if(isOK == false){\n\t\t\tComFCI?address_f.aid.cid.feoa.fepk.fsig -> \n\t\t\tComFCI?address_f.aid.feoa.fepk.fsig{call(FVerifySig,feoa,fepk,fsig)}->\n\t\t\tif(fsig_success == false){\n\t\t\t\tStop\n\t\t\t} else {\n\t\t\t\tContract_Issuer()\n\t\t\t} \n\t\t} else {Contract_Issuer()}\n  };"
            },
            {
                "name": "Financial_Investment_SmartContract",
                "description": "Financial Investment Smart Contract (FISC): It has the content of financial investment contracts.\n  1. It starts by receiving CI's ID and signature.\n  2. Verifies the contract issuer's signature. If verification fails, the process stops, otherwise, it proceeds.\n  3. Sends address and signature to the SM and the Client.\n  4. Receives the Client's ID, identity, and signature and verifies it. If verification fails, the process stops, otherwise, it proceeds.\n\t5. If user isn't satisfied with the contract:\n\t5.1. Sends its own address and signature to CI, then sends its own address and signature to SM.\n\t5.2. Sends its address, arbitration ID, and client ID to CI and AI.\n\t5.3. Receives the arbitration institution's ID, signature.\n  5.4. If there is no fraud: Sends its address and signature to CI and the Client and then sends to DASC, its own signature and arbitration id and execute settlement. \n  5.5. If fraud is confirmed: Sends its address and signature to CI and the Client and execute Penalty. \n  6. If Client isn satisfied with the contract:\n  6.1. Sends its address and signature to CI and SM. And sends its address, arbitration ID, and client ID to AI.\n  6.2. Receives the client's ID, identity, and signature.\n  6.3. It initiates SignedByClient.\n  6.4. Receives the SM's ID, identity, and signature and verifies the signature. If verification fails, the process stops, otherwise, it proceeds.\n\t6.5. It initiates SignedBySalesmanager.",
                "pat_code": "Financial_Investment_SmartContract() = \n\tComFCI?ciid.cieoa.ciepk.cisig{call(CIVerifySig,cieoa,ciepk,cisig)}-> \n\tif(cisig_success == false){\n\t\tStop\n\t} else{\n\t\tComFSM!address_f.fEOA.fEPK.fSIG -> ComFC!address_f.fEOA.fEPK.fSIG->\n\t\tComFC?cid.cidentity.ceoa.cepk.csig{call(CVerifySig,ceoa,cepk,csig)} -> \n\t\tif(csig_success == false){\n\t\t\tStop\n\t\t} else if(isOK == false){\n\t\t\tComFCI!address_f.fEOA.fEPK.fSIG -> ComFSM!address_f.fEOA.fEPK.fSIG -> \n\t\t\tComFCI!address_f.aid.cid.fEOA.fEPK.fSIG -> ComFAI!address_f.aid.cid.fEOA.fEPK.fSIG -> \n\t\t\tComFAI?aid.aeoa.aepk.asig -> \n\t\t\tif(fraud_free == true){\n\t\t\t\tComFCI!address_f.aid.fEOA.fEPK.fSIG -> ComFC!address_f.aid.fEOA.fEPK.fSIG -> \n\t\t\t\tComFD!address_f.fEOA.fEPK.fSIG.aid -> settlement{state = End;reachable_flag = true;fraud_free_flag = true} -> \n\t\t\t\tFinancial_Investment_SmartContract()\n\t\t\t} else {\n\t\t\t\tComFCI!address_f.aid.fEOA.fEPK.fSIG -> ComFC!address_f.aid.fEOA.fEPK.fSIG -> \n\t\t\t\tPenalty{state = End;reachable_flag = true;dispute_resolution_flag = true} -> \n\t\t\t\tFinancial_Investment_SmartContract()\n\t\t\t}\n\t\t} else {\n\t\t\tComFCI!address_f.fEOA.fEPK.fSIG-> ComFSM!address_f.fEOA.fEPK.fSIG -> \n\t\t\tComFAI!address_f.aid.cid.fEOA.fEPK.fSIG -> ComFC?cid.cidentity.ceoa.cepk.csig -> \n\t\t\tSignedByClient -> ComFSM?sid.sidentity.seoa.sepk.ssig{call(SVerifySig,seoa,sepk,ssig)} -> \n\t\t\tif(ssig_success == false){\n\t\t\t\tStop\n\t\t\t} else{\n\t\t\t\tSignedBySalesmanager{reachable_flag = true;signing_correct_flag = true;state = End; Authorized = false} -> \n\t\t\t\tFinancial_Investment_SmartContract()\n\t\t\t} \n\t\t}\n\t};"
            },
            {
                "name": "Sale_Manager",
                "description": "Sale Manager (SM): It is the entity authorized by the CI to sign financial investment contracts.\n  1. It receives the financial smart contract's address and signature and verifies the signature. If verification fails, the process stops, otherwise, it proceeds.\n  2. Requests a delegate and sends SM's ID, identity, and signature to the DASC.\n  3. Receives the delegate's address, the SM's ID and identity, the delegate's signature, and the CI's ID from the DASC.\n  4. Verifies the delegate's signature. If verification fails, the process stops, otherwise, it proceeds.\n  5. Receives the client's ID, identity, and signature and verifies it. If client's signature verification fails, then stop, otherwise, it proceeds.\n  6. Sends its own ID, identity, and signature to the Client, receives an arbitrary random message and generates a data signature using its private key\n\t7. Sends the generated signature to the client and receives messages from the DASC.\n  8. Sends the financial contract's address to the client with signature, and waits for the verification result from the client. If the result is invalid, it stops.\n  9. If the user isn't satisfied with the contract's financial content, then loops to Sale_Manager().\n  10. Otherwise, sends the its own ID, identity, and signature to final smart contractthen loops to Sale_Manager().",
                "pat_code": "Sale_Manager() = ComFSM?address_f.feoa.fepk.fsig{call(FVerifySig,feoa,fepk,fsig)}-> if(fsig_success == false){\n\t\tStop\n\t} else{ \n\t\tRequestDelegate->ComDS!sid.sidentity.sEOA.sEPK.sSIG -> \n\t\tComDS?address_d.sid.sidentity.deoa.depk.dsig.ciid{call(DVerifySig,deoa,depk,dsig)} -> \n\t\tif(dsig_success == false){ \n\t\t\tStop\n\t\t} else {\n\t\t\tComSMC?cid.cidentity.ceoa.cepk.csig{call(CVerifySig,ceoa,cepk,csig)} -> \n\t\t  if(csig_success == false){Stop}\n\t\t\telse {\n\t\t\t\tComSMC!sid.sidentity.sEOA -> ComSMC?Message.seoa.sepk{call(SGenerateMessage,Message,seoa,sepk)} -> \n\t\t\t\tComSMC!sid.sidentity.sEOA.sEPK.sSIG.gMessage -> ComDS?address_d.cid.deposit.deoa.depk.dsig -> \n\t\t\t\tComSMC!address_f.fEOA{state = Fraud} ->ComFSM?address_f.feoa.fepk.fsig{call(FVerifySig,feoa,fepk,fsig)} -> \n\t\t\t\tif(fsig_success == false){Stop} \n \t      else if(isOK==false){Sale_Manager()}\n \t      else {ComFSM!sid.sidentity.sEOA.sEPK.sSIG{state = End} -> Sale_Manager()}\n \t\t  }\n  \t}\n  };"
            },
            {
                "name": "Delegate_Authorization_SmartContract",
                "description": "Delegate Authorization Smart Contract (DASC): It has detailed information about creating delegated authorization for the sales manager.\n  1. Receives the SM's ID, identity, and signature.\n  2. Verifies the sale manager's signature. If verification fails, the process stops, otherwise, it proceeds.\n  3. Then, sends delegate's address and its own signature to CI.\n  4. Receives the CI's ID, the sale manager's ID and identity, and the CI's signature from CI.\n  5. Verifies the CI's signature. If verification fails, the process stops, otherwise, it proceeds.\n  6. Sends delegate's address and its own signature to SM.\n  7. Receives client's ID, identity, and signature from the Client and verifies it. If client's signature verification fails, then stop, otherwise, it proceeds.\n  8. Performs Identity Verification and receives client's identity and signature.\n  9. Requests signing. Sends the delegate's address, the client's id and deposit to the SM. And send notice.\n  10. If the user isn't satisfied with the contract and if fraud is confirmed, it needs to receive the contract's information and verifies the signature. If it fails, then stop.",
                "pat_code": "Delegate_Authorization_SmartContract() = \n\tComDS?sid.sidentity.seoa.sepk.ssig{call(SVerifySig,seoa,sepk,ssig)} ->\n\tif(ssig_success == false){Stop} \n\telse {\n\t\tComDCI!address_d.sid.sidentity.dEOA.dEPK.dSIG-> \n\t\tComDCI?ciid.sid.sidentity.cieoa.ciepk.cisig{call(CIVerifySig,cieoa,ciepk,cisig)} -> \n\t\tif(cisig_success == false){ Stop} \n\t  else {\n\t\t\tComDS!address_d.sid.sidentity.dEOA.dEPK.dSIG.ciid{Authorized = true} -> \n\t\t\tComDC?cid.cidentity.sid.sidentity.seoa.ceoa.cepk.csig{call(CVerifySig,ceoa,cepk,csig)} -> \n\t\t\tif(csig_success == false){Stop}\n      else {\n\t\t\t\tIdetityVerification -> ComDC?cid.cidentity.ceoa.cepk.csig -> \n\t\t\t\tRequestSigning -> ComDS!address_d.cid.deposit.dEOA.dEPK.dSIG ->notice->\n        if(isOK == false){\n\t\t\t\t\tif(fraud_free == true ){\n\t\t\t\t\t\tComFD?address_f.feoa.fepk.fsig.aid{call(FVerifySig,feoa,fepk,fsig)} ->\n\t\t\t\t\t  if(fsig_success == false){Stop} \n      \t  } else {\n\t\t\t\t\t\tDelegate_Authorization_SmartContract()\n\t\t\t\t\t}\n      \t} else {\n\t\t\t\t\tDelegate_Authorization_SmartContract()\n\t\t\t\t}\n      }\n    }\n\t};"
            },
            {
                "name": "Client",
                "description": "Client (C): It is an entity with financial investment needs that signs financial investment contracts through a delegation contract signing mechanism.\n  1. It first receives the financial smart contract's address and signature and verifies it. If verification fails, the process stops, otherwise, it proceeds.\n  2. Sends client's ID, identity, and signature to SM, and then receives SM's id and identity from SM.\n  3. Sends client's ID, identity, and signature to DASC, and then sends a message to the SM.\n  4. It receives delegate's signature and message with sale manager's identification data from SM and verifies it. If fails, it stops, otherwise, proceeds.\n  5. It performs ReponseVerify. Checks if the received message matches the expected message.\n  6. If the messages match: Sends client's ID, identity, and signature to DASC, and the receives contract's address from SM. \n\t7. Sends the client's ID, identity, and signature to the FISC.\n  8. If the user isn't satisfied with the contract: it receives contract's address from DASC.\n  9. Otherwise: sends client's ID, identity, and signature to contract again.",
                "pat_code": "Client() = ComFC?address_f.feoa.fepk.fsig{call(FVerifySig,feoa,fepk,fsig)} -> \n  if(fsig_success == false){\n\t\tStop\n\t} else {\n\t\tComSMC!cid.cidentity.cEOA.cEPK.cSIG -> ComSMC?sid.sidentity.seoa -> \n\t\tComDC!cid.cidentity.sid.sidentity.sEOA.cEOA.cEPK.cSIG -> ComSMC!Message.sEOA.sEPK -> \n\t\tComSMC?sid.sidentity.seoa.sepk.ssig.gmessage{call(SVerifySig,seoa,sepk,ssig)} -> \n\t\tif(ssig_success == false ){ \n\t\t\tStop\n\t\t} else{\n\t\t\tReponseVerify -> \n\t\t\tif(gMessage == Message){ \n\t\t\t\tComDC!cid.cidentity.cEOA.cEPK.cSIG{response_challenge_flag = true} -> \n\t\t\t\tComSMC?address_f.feoa ->ComFC!cid.cidentity.cEOA.cEPK.cSIG -> \n\t\t\t\tif(isOK == false){\n\t\t\t\t\tComFC?address_f.aid.feoa.fepk.fsig -> Client()\n\t\t\t\t} else {\n\t\t\t\t\tComFC!cid.cidentity.cEOA.cEPK.cSIG -> Client()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n  };"
            },
            {
                "name": "Arbitration_Institution",
                "description": "Arbitration Institution (AI): It is an entity trusted by the contract issuer, sales manager, and traders.\n  1. It first receives the financial smart contract's address, id, and client's id from the FISC with its signature, and verifies it. If fails, stop, otherwise, it proceeds.\n  2. If the user isn't satisfied with the contract's financial content, sends its own id and signature to the FISC.",
                "pat_code": "Arbitration_Institution() = ComFAI?address_f.aid.cid.feoa.fepk.fsig{call(FVerifySig,feoa,fepk,fsig)}-> \n\tif(fsig_success == false ){Stop} \n\telse if(isOK == false) {ComFAI!aid.aEOA.aEPK.aSIG-> Arbitration_Institution()}\n\telse{middle18 -> Arbitration_Institution()};"
            },
            {
                "name": "System",
                "description": "The mechanism framework based on smart contracts consists of the following six entities: \n\tContract Issuer (CI), Financial Investment Smart Contract (FISC), Delegate Authorization Smart Contract (DASC), Sale Manager (SM), Client (C), Arbitration Institution (AI)",
                "pat_code": "System()=Contract_Issuer()||Financial_Investment_SmartContract()||Sale_Manager()||Delegate_Authorization_SmartContract()||Client()||Arbitration_Institution();"
            }
        ],
        "global_definition": "#define Message 10;\nvar gMessage = 0;\nenum{ciEOA,fEOA,dEOA,sEOA,cEOA,aEOA};\nenum{ciEPK,fEPK,dEPK,sEPK,cEPK,aEPK};\nenum{ciSIG,fSIG,dSIG,sSIG,cSIG,aSIG};\nenum{Initialization,Process,Fraud,End};\nenum{sidentity,cidentity};\nenum{ciid,sid,aid,cid};\nenum{address_d,address_f};\nenum{deposit};\n\nchannel ComFCI 0; //Contract issuer&&Financial smart contract\nchannel ComDCI 0; //Delegate authorization smart contract&&Contract issuer\nchannel ComFAI 0; //Financial smart contract&&Arbitration institution\nchannel ComDS 0; //Delegate authorization smart contract&&Sale manager\nchannel ComFSM 0; //Financial smart contract&&Sale manager\nchannel ComFC 0; //Financial smart contract&&Client\nchannel ComDC 0; //Delegate authorization smart contract&&Client\nchannel ComSMC 0; //Sale manager&&Client\nchannel ComFD 0; //Financial smart contract&&Delegate authorization smart contract\n\nvar state = Initialization;\nvar dsig_success = false;\nvar fsig_success = false;\nvar cisig_success = false;\nvar ssig_success = false;\nvar csig_success = false;\nvar isOK = true; \nvar fraud_free = false;\nvar Authorized = false;\nvar reachable_flag = false;\nvar signing_correct_flag = false;\nvar fraud_free_flag = false;\nvar dispute_resolution_flag  = false;\nvar response_challenge_flag = false;  \n\n#define DVerifySig(deoa,depk,dsig)\n{if(deoa == dEOA && depk == dEPK && dsig == dSIG)\n{dsig_success = true}\n};\n#define FVerifySig(feoa,fepk,fsig)\n{if(feoa == fEOA && fepk == fEPK && fsig == fSIG)\n{fsig_success = true}\n};\n#define CIVerifySig(cieoa,ciepk,cisig) \n{if(cieoa == ciEOA && ciepk == ciEPK && cisig == ciSIG)\n{cisig_success = true}\n};\n#define SVerifySig(seoa,sepk,ssig)\n{if(seoa == sEOA && sepk == sEPK && ssig == sSIG)\n{ssig_success = true}\n};\n#define CVerifySig(ceoa,cepk,csig)\n{if(ceoa == cEOA && cepk == cEPK && csig == cSIG)\n{csig_success = true}\n};\n#define SGenerateMessage(message,seoa,sepk)\n{if(seoa == sEOA && sepk == sEPK)\n\t{gMessage = message}\n};",
        "path": "handwrite/Delegate Contract Signing Mechanism.csp"
    },
    {
        "name": "Distributed autonomous driving system",
        "tags": [
            "Protocol",
            "Distributed System"
        ],
        "use_non_container_lib": false,
        "description": "The model decompose the autonomous driving system into four key components: Station, Path Planner (PP), Vehicle Core (VC), and State Manager (SM).\n\n  The complete vehicle system is composed of the parallel execution of the Path Planner, Vehicle Core, Station, and State Manager processes.",
        "pat_code": "channel ReqGPS 0;\nchannel ReqGPSInf 0;\nchannel GPSInf 0;\nchannel StationNotice 0;\nchannel ReqStation 0;\nchannel StationInf 0;\nchannel DriveCommand 0;\n\n#define GPS 5; var RS_S;\nvar SN_S; var SI_S; var RG_S; var DC_S; var GI_S; var RGI_S;\nvar sequence_num; var vehicle_state; var SN_state = -1; var RS_state =\t\t-1; var SI_state =\t-1; var RG_state = -1; var RGI_state = -1; var GI_state = -1; var DC_state = -1;\n\n/*@Process: Station\n  Station: Represents a base station or infrastructure component, which has two behaviors.\n  - 1. It starts by resetting the state related to the Station Notice to 0.\n    2. It then sends a StationNotice message (SN_S) through the StationNotice channel and loops back to the beginning.\n  - 1. Or listens for a ReqStation request (RS_R) on the ReqStation channel.\n    2. Upon receiving the request, it resets the station information state (SI_state)\n    3. Sends StationInf message (SI_S) through the StationInf channel, and loops back to the beginning.\n*/\nStation = snReset{SN_state = 0;} -> StationNotice!SN_S -> Station []ReqStation?RS_R{RS_state = 1;} -> siReset{SI_state = 0;} -> StationInf!SI_S -> Station;\n\n/*@Process: VC\n  Vehicle Core (VC): Represents the core control system of the vehicle.\n  1. It starts by receiving a StationNotice message (SN_R) on the StationNotice channel and set the StationNotice state to 1.\n  2. It resets its ReqStation state (RS_state).\n  3. It then sends a ReqStation message (RS_S) to the ReqStation channel to request information from the station.\n  4. It receives the station information SI_R through the StationInf channel and sets SI_state to 1 and proceeds to the initialization of the VC. \n*/\nVC = StationNotice?SN_R{SN_state = 1;} -> rsReset{RS_state = 0;} -> ReqStation!RS_S -> StationInf?SI_R{SI_state = 1;} -> VCInit;\n\n/*@Process: VCInit\n  Initialization of VC: This process is responsible for the vehicle's driving logic based on sequence number and GPS information.\n  - If sequence_num is greater than 0 and less than GPS (5):\n    1. It receives GPS information GI_R on the GPSInf channel. \n    2. It resets the DriveCommand state (DC_state).\n    3. And sends a DriveCommand (DC_S) through the DriveCommand channel and loops back to itself.\n  - If sequence_num is 0:\n    1. It resets the ReqGPS state (RG_state).\n    2. And, sends a ReqGPS request (RG_S) on the ReqGPS channel. \n    3. Then it receives requested GPS information RGI_R on the ReqGPSInf channel and set the RGI state to 1.\n    4. After that it resets the DriveCommand state (DC_state)\n    5. Finally, it sends a DriveCommand (DC_S) through the DriveCommand channel and loops back to itself.\n  - If sequence_num equals GPS (5). The vehicle has arrived. It resets sequence_num to 0, and all states to -1, and loops back to VC.\n*/\nVCInit = [sequence_num > 0 && sequence_num < GPS]GPSInf?GI_R{GI_state = 1;} -> dcReset{DC_state = 0;} -> DriveCommand!DC_S -> VCInit\n[][sequence_num == 0]rgReset{RG_state = 0;} -> ReqGPS!RG_S -> ReqGPSInf?RGI_R{RGI_state = 1;} -> dcReset{DC_state = 0;} -> DriveCommand!DC_S -> VCInit\n[][sequence_num == GPS]arrive{sequence_num = 0;SN_state = -1;RS_state = -1;SI_state = -1;RG_state = -1;RGI_state = -1;GI_state = -1;DC_state = -1;} -> VC;\n\n/*@Process: SM\nState Manager (SM): It starts in the Start state, setting the vehicle_state to 1. Then proceeds to init process.\n*/\nSM = Start{vehicle_state = 1;} -> SMInit;\n\n/*@Process: SMInit\n  SMInit:\n  - If sequence_num equals GPS, the vehicle is instructed to park, setting vehicle_state to 0.\n  - Or waits to receive a DriveCommand (DC_R) through the DriveCommand channel. \n    Upon receiving the command, sets DC_state to 1, transitions to Drive state, setting vehicle_state to 2, and returns to SMInit.\n*/\nSMInit = [sequence_num == GPS]Parking{vehicle_state = 0;} -> SM []DriveCommand?DC_R{DC_state = 1;} -> Drive{vehicle_state = 2;} ->SMInit;\n\n/*@Process: PP\n  Path Planner (PP): Responsible for planning the vehicle's path based on GPS information.\n  - If sequence_num is greater than 0 and less than GPS:\n    1. It resets the GPSInf state (GI_state)\n    2. And sends the GPS information GI_S via GPSInf channel, incrementing the sequence_num, and loops back to itself.\n  - If sequence_num is 0, it means a path needs to be planned from the start:\n    1. It waits to receive ReqGPS request (RG_R) on the ReqGPS channel. Upon receiving the request, it resets the RG state\n    2. Then, it resets the RGI state.\n    3. Then, it sends a ReqGPSInf message (RGI_S) on the ReqGPSInf channel, and loops back to the beginning.\n*/\nPP = [sequence_num > 0 && sequence_num < GPS]giReset{GI_state = 0;} ->\nGPSInf!GI_S{sequence_num = sequence_num + 1;} -> PP\n[][sequence_num == 0]ReqGPS?RG_R{RG_state = 1;} -> rgiReset{RGI_state = 0;} -> ReqGPSInf!RGI_S -> PP;\n\n/*@Process: Vehicle\n  The complete vehicle system is composed of the parallel execution of the Path Planner, Vehicle Core, Station, and State Manager processes.\n*/\nVehicle = PP || VC || Station || SM;",
        "property_desc": [
            "The vehicle will not reach an improper sequence between ReqStation and ReqGPS where ReqStation has not sent its request yet, while ReqGPS\u2019s request has already been completed.",
            "The vehicle will not reach an improper sequence between ReqGPS and GPSInf where VC has not sent the ReqGPS request yet, but GPSInf has already been received.",
            "The vehicle will not reach an improper sequence between ReqGPSInf and DriveCommand where the drive command has been sent without receiving road guidance information."
        ],
        "properties": [
            "#define fault1 (RS_state == -1 && RG_state == 1); \n#assert Vehicle |= []!fault1;",
            "#define fault2 (RG_state == -1 && GI_state == 1);\n#assert Vehicle |= []!fault2;",
            "#define fault3 (RGI_state == -1 && GI_state == -1 && DC_state == 1);\n#assert Vehicle |= []!fault3;"
        ],
        "processes": [
            {
                "name": "Station",
                "description": "Station: Represents a base station or infrastructure component, which has two behaviors.\n  - 1. It starts by resetting the state related to the Station Notice to 0.\n    2. It then sends a StationNotice message (SN_S) through the StationNotice channel and loops back to the beginning.\n  - 1. Or listens for a ReqStation request (RS_R) on the ReqStation channel.\n    2. Upon receiving the request, it resets the station information state (SI_state)\n    3. Sends StationInf message (SI_S) through the StationInf channel, and loops back to the beginning.",
                "pat_code": "Station = snReset{SN_state = 0;} -> StationNotice!SN_S -> Station []ReqStation?RS_R{RS_state = 1;} -> siReset{SI_state = 0;} -> StationInf!SI_S -> Station;"
            },
            {
                "name": "VC",
                "description": "Vehicle Core (VC): Represents the core control system of the vehicle.\n  1. It starts by receiving a StationNotice message (SN_R) on the StationNotice channel and set the StationNotice state to 1.\n  2. It resets its ReqStation state (RS_state).\n  3. It then sends a ReqStation message (RS_S) to the ReqStation channel to request information from the station.\n  4. It receives the station information SI_R through the StationInf channel and sets SI_state to 1 and proceeds to the initialization of the VC.",
                "pat_code": "VC = StationNotice?SN_R{SN_state = 1;} -> rsReset{RS_state = 0;} -> ReqStation!RS_S -> StationInf?SI_R{SI_state = 1;} -> VCInit;"
            },
            {
                "name": "VCInit",
                "description": "Initialization of VC: This process is responsible for the vehicle's driving logic based on sequence number and GPS information.\n  - If sequence_num is greater than 0 and less than GPS (5):\n    1. It receives GPS information GI_R on the GPSInf channel. \n    2. It resets the DriveCommand state (DC_state).\n    3. And sends a DriveCommand (DC_S) through the DriveCommand channel and loops back to itself.\n  - If sequence_num is 0:\n    1. It resets the ReqGPS state (RG_state).\n    2. And, sends a ReqGPS request (RG_S) on the ReqGPS channel. \n    3. Then it receives requested GPS information RGI_R on the ReqGPSInf channel and set the RGI state to 1.\n    4. After that it resets the DriveCommand state (DC_state)\n    5. Finally, it sends a DriveCommand (DC_S) through the DriveCommand channel and loops back to itself.\n  - If sequence_num equals GPS (5). The vehicle has arrived. It resets sequence_num to 0, and all states to -1, and loops back to VC.",
                "pat_code": "VCInit = [sequence_num > 0 && sequence_num < GPS]GPSInf?GI_R{GI_state = 1;} -> dcReset{DC_state = 0;} -> DriveCommand!DC_S -> VCInit\n[][sequence_num == 0]rgReset{RG_state = 0;} -> ReqGPS!RG_S -> ReqGPSInf?RGI_R{RGI_state = 1;} -> dcReset{DC_state = 0;} -> DriveCommand!DC_S -> VCInit\n[][sequence_num == GPS]arrive{sequence_num = 0;SN_state = -1;RS_state = -1;SI_state = -1;RG_state = -1;RGI_state = -1;GI_state = -1;DC_state = -1;} -> VC;"
            },
            {
                "name": "SM",
                "description": "State Manager (SM): It starts in the Start state, setting the vehicle_state to 1. Then proceeds to init process.",
                "pat_code": "SM = Start{vehicle_state = 1;} -> SMInit;"
            },
            {
                "name": "SMInit",
                "description": "SMInit:\n  - If sequence_num equals GPS, the vehicle is instructed to park, setting vehicle_state to 0.\n  - Or waits to receive a DriveCommand (DC_R) through the DriveCommand channel. \n    Upon receiving the command, sets DC_state to 1, transitions to Drive state, setting vehicle_state to 2, and returns to SMInit.",
                "pat_code": "SMInit = [sequence_num == GPS]Parking{vehicle_state = 0;} -> SM []DriveCommand?DC_R{DC_state = 1;} -> Drive{vehicle_state = 2;} ->SMInit;"
            },
            {
                "name": "PP",
                "description": "Path Planner (PP): Responsible for planning the vehicle's path based on GPS information.\n  - If sequence_num is greater than 0 and less than GPS:\n    1. It resets the GPSInf state (GI_state)\n    2. And sends the GPS information GI_S via GPSInf channel, incrementing the sequence_num, and loops back to itself.\n  - If sequence_num is 0, it means a path needs to be planned from the start:\n    1. It waits to receive ReqGPS request (RG_R) on the ReqGPS channel. Upon receiving the request, it resets the RG state\n    2. Then, it resets the RGI state.\n    3. Then, it sends a ReqGPSInf message (RGI_S) on the ReqGPSInf channel, and loops back to the beginning.",
                "pat_code": "PP = [sequence_num > 0 && sequence_num < GPS]giReset{GI_state = 0;} ->\nGPSInf!GI_S{sequence_num = sequence_num + 1;} -> PP\n[][sequence_num == 0]ReqGPS?RG_R{RG_state = 1;} -> rgiReset{RGI_state = 0;} -> ReqGPSInf!RGI_S -> PP;"
            },
            {
                "name": "Vehicle",
                "description": "The complete vehicle system is composed of the parallel execution of the Path Planner, Vehicle Core, Station, and State Manager processes.",
                "pat_code": "Vehicle = PP || VC || Station || SM;"
            }
        ],
        "global_definition": "channel ReqGPS 0;\nchannel ReqGPSInf 0;\nchannel GPSInf 0;\nchannel StationNotice 0;\nchannel ReqStation 0;\nchannel StationInf 0;\nchannel DriveCommand 0;\n\n#define GPS 5; var RS_S;\nvar SN_S; var SI_S; var RG_S; var DC_S; var GI_S; var RGI_S;\nvar sequence_num; var vehicle_state; var SN_state = -1; var RS_state =\t\t-1; var SI_state =\t-1; var RG_state = -1; var RGI_state = -1; var GI_state = -1; var DC_state = -1;",
        "path": "handwrite/Distribute Autonomous Driving System.csp"
    },
    {
        "name": "DPSTMv2",
        "tags": [
            "Protocol"
        ],
        "use_non_container_lib": false,
        "description": "The entire DPSTM architecture is divided into three parts: the application process, the transaction coordiantor process, and the data storage and service process, and the modeling focuses on the communication process between these three modules.",
        "pat_code": "#define N 2;\n#define M 3;\n\nvar put_finished[M] = [0,0,0];\nvar value[M][3] = [0(M*3)];\nvar version[M][3] = [0(M*3)];\nvar Consistency[M][3] = [1(M*3)];\nvar content = false;\nvar read_val; var read_ver;\nvar data_val; var data_ver;\nvar scnt = 0;var ecnt = 0;\nvar first = false;var second = false;\n\nchannel ComTRDP[N] 0;\nchannel ComDPTS[N] 0;\nchannel ComTSDC 0; channel ComDCDS[M] 0;\nchannel ComDSDI[M] 0; channel ComDPDS[M] 0;\n\nchannel ComDPTR[N] 0; channel ComTSDP[N] 0;\nchannel ComDCTS 0; channel ComDSDC[M] 0;\nchannel ComDIDS[M] 0; channel ComDSDP[M] 0;\n\n//enum{MSGreq, resp};\n//enum{keys, values, versions};\n//enum{content, rtn};\nenum{req, resp};\n\n\t\n/*@Process: TC\n\tThe transaction coordiantor process consists of the TC stub and the DS client running concurrently\n*/\nTC() = TC_stub() || DS_client();\n\n/*@Process: TC_stub\nTC Stub:\n  1. It first receives a request from the DPSTM client over the channel and then forwards the request to the DS client. \n\t2. Then it receives from the channel a response message from the DS client, including an rtn indicating the result of the transaction execution, and forwards the response message to the corresponding application process.\n*/\nTC_stub()=|||i:{1..N}@(\n\tComDPTS[i]?MSGreq.mode.operator.vars ->\n\tComTSDC!MSGreq.mode.operator.vars -> ComDCTS?MSGresp.rtn ->\n\tComTSDP[i]!MSGresp.rtn -> TC_stub()\n);\n\n/*@Process: DS_client\nDS Client: The DS client process is the component that is linked to the data service process\n  1. It first receiving requests forwarded by TCstub including the execution mode, DPSTM API and request data items and ct, which indicates the ID of the data service process\n*/\nDS_client()=ComTSDC?MSGreq.mode.operator.vars -> Replication(MSGreq,mode,operator,vars,1);\n\n/*@Process: Replication\n  2. When ct is less then the number of data server processes, the DS client forwards the request to the data server process to receive the response. \n\t3. If the transaction is executed successfully and operator=3 (indicating that a read operation is executed) then the response is forwarded directly to TCstub and the loop is terminated, otherwise ct+1 and then the Replication is executed in a loop. \n\t4. When ct is equal to the number of data server processes, the DS client receives the response message from the data service process after forwarding the request and forwards the response to TCstub and then terminates the loop.\n*/\nReplication(MSGreq,mode,operator,vars,ct)=\n\tif(ct<M){\n\t\tComDCDS[ct]!MSGreq.mode.operator.vars -> ComDSDC[ct]?MSGresp.rtn ->\n\t\tif(operator==3 && rtn==1){\n\t\t\tComDCTS!MSGresp.rtn -> DS_client()\n\t\t} else{\n\t\t\tReplication(MSGreq,mode,operator,vars,ct+1)\n\t\t}\n\t} else if(ct==M){\n\t\tComDCDS[ct]!MSGreq.mode.operator.vars -> \n\t\tComDSDC[ct]?MSGresp.rtn -> ComDCTS!MSGresp.rtn -> DS_client()\n\t};\n\n/*@Process: Data_Server\n  The data server process consists of two concurrent processes, DS stub and Dictionary.\n*/\nData_Server(i) = DS_stub(i) || Dictionary(i);\n\n/*@Process: DS_stub\n  DS stub:\n\t1. The DS stub process receives request messages from either the ComDSDI or ComDPDS channel, where the ComDSDI process connects to the DS client process and the ComDPDS connects to the DPSTM client.\n\t2.1. When a request is received from the DS client process, the request is forwarded to the Dictionary. \n\t2.2. After receiving the response message, the former is forwarded to the DS client.\n\t3.1. If the request is received from a DPSTM client, it goes to the DS_DP process.\n\t3.2. After receiving the response message, it is forwarded to the DPSTM client.\n*/\nDS_stub(i) = \n    ComDCDS[i]?MSGreq.mode.operator.vars -> ComDSDI[i]!MSGreq.mode.operator.vars -> ComDIDS[i]?MSGresp.rtn -> ComDSDC[i]!MSGresp.rtn -> DS_stub(i)\n    []\n    ComDPDS[i]?MSGreq.mode.operator.vars -> ComDSDI[i]!MSGreq.mode.operator.vars -> ComDIDS[i]?MSGresp.rtn -> ComDSDP[i]!MSGresp.rtn -> DS_stub(i);\n\n/*@Process: Dictionary\n  The Dictionary process receives the request message and enters the CallAPI process, which calls different APIs to execute the transaction according to the operator value of the request and forwards the result to the DS stub.\n*/\nDictionary(i)=ComDSDI[i]?MSGreq.mode.operator.vars -> callApi.i.mode.operator.vars -> Skip;\n\n/*@Process: Application0\n\tThe application process consists of two processes Transaction and DPSTM client running concurrently: the transaction process and the DPSTM client.\n*/\nApplication0(i, mode,operator, vars) = Transaction(i,mode,operator, vars)||DPSTM_client(i);\n\n/*@Process: Transaction\n\tThe Transaction process represents the specific transaction to be executed in the application process:\n  1. Transaction first sends a request to the DPSTM client through the ComTRDP channel, the requested message includes the transaction execution mode, the DPSTMAPI to be called and the requested data vars, \n\t2. It then receives a response message through the ComDPTR channel, including the result of the transaction execution.\n*/\nTransaction(i, mode, operator, vars) =\n  ComTRDP[i]!req.mode.operator.vars -> ComDPTR[i]?MSGresp.rtn -> Skip;\n\n/*@Process: DPSTM_client\n  \tThe DPSTM Client:\n  1. The DPSTM client first receives the request from the transaction through the channel ComDPTS\n\t2. It judges the mode of the thing execution according to the mode in the request message\n\t  2.1. When mode=0, the DPSTM client sends the request message to the transaction coordiantor process.\n    2.2. Otherwise the process will determine whether the DPSTMAPI called by the transaction execution is getVars or cmpVars through operator, if it is, then send the request to the local data service process, otherwise send the request to the DPSTM client.\n*/\nDPSTM_client(i)=ComTRDP[i]?req.mode.operator.vars->\n\tif(mode==0){\n\t\tComDPTS[i]!req.mode.operator.vars -> \n\t\tComTSDP[i]?MSGresp.rtn -> ComDPTR[i]!MSGresp.rtn -> Skip\n\t} else{\n\t\tif(operator==3||operator==5){\n\t\t\tComDPDS[i]!req.mode.operator.vars ->\n\t\t\tComDSDP[i]?MSGresp.rtn -> ComDPTR[i]!MSGresp.rtn -> Skip\n\t\t}\n\t\telse{\n\t\t\tComDPTS[i]!req.mode.operator.vars ->\n\t\t\tComTSDP[i]?MSGresp.rtn -> ComDPTR[i]!MSGresp.rtn -> Skip\n\t\t}\n\t};\n\n/*@Process: System\n  The system consists of N application interacting with the TC\n*/\nSystem() = (|||i:{0..N-1}@Application0(i,0,0,0)) || TC();",
        "property_desc": [
            "The system is deadlock-free"
        ],
        "properties": [
            "#assert System() deadlockfree;"
        ],
        "processes": [
            {
                "name": "TC",
                "description": "The transaction coordiantor process consists of the TC stub and the DS client running concurrently",
                "pat_code": "TC() = TC_stub() || DS_client();"
            },
            {
                "name": "TC_stub",
                "description": "TC Stub:\n  1. It first receives a request from the DPSTM client over the channel and then forwards the request to the DS client. \n\t2. Then it receives from the channel a response message from the DS client, including an rtn indicating the result of the transaction execution, and forwards the response message to the corresponding application process.",
                "pat_code": "TC_stub()=|||i:{1..N}@(\n\tComDPTS[i]?MSGreq.mode.operator.vars ->\n\tComTSDC!MSGreq.mode.operator.vars -> ComDCTS?MSGresp.rtn ->\n\tComTSDP[i]!MSGresp.rtn -> TC_stub()\n);"
            },
            {
                "name": "DS_client",
                "description": "DS Client: The DS client process is the component that is linked to the data service process\n  1. It first receiving requests forwarded by TCstub including the execution mode, DPSTM API and request data items and ct, which indicates the ID of the data service process",
                "pat_code": "DS_client()=ComTSDC?MSGreq.mode.operator.vars -> Replication(MSGreq,mode,operator,vars,1);"
            },
            {
                "name": "Replication",
                "description": "2. When ct is less then the number of data server processes, the DS client forwards the request to the data server process to receive the response. \n\t3. If the transaction is executed successfully and operator=3 (indicating that a read operation is executed) then the response is forwarded directly to TCstub and the loop is terminated, otherwise ct+1 and then the Replication is executed in a loop. \n\t4. When ct is equal to the number of data server processes, the DS client receives the response message from the data service process after forwarding the request and forwards the response to TCstub and then terminates the loop.",
                "pat_code": "Replication(MSGreq,mode,operator,vars,ct)=\n\tif(ct<M){\n\t\tComDCDS[ct]!MSGreq.mode.operator.vars -> ComDSDC[ct]?MSGresp.rtn ->\n\t\tif(operator==3 && rtn==1){\n\t\t\tComDCTS!MSGresp.rtn -> DS_client()\n\t\t} else{\n\t\t\tReplication(MSGreq,mode,operator,vars,ct+1)\n\t\t}\n\t} else if(ct==M){\n\t\tComDCDS[ct]!MSGreq.mode.operator.vars -> \n\t\tComDSDC[ct]?MSGresp.rtn -> ComDCTS!MSGresp.rtn -> DS_client()\n\t};"
            },
            {
                "name": "Data_Server",
                "description": "The data server process consists of two concurrent processes, DS stub and Dictionary.",
                "pat_code": "Data_Server(i) = DS_stub(i) || Dictionary(i);"
            },
            {
                "name": "DS_stub",
                "description": "DS stub:\n\t1. The DS stub process receives request messages from either the ComDSDI or ComDPDS channel, where the ComDSDI process connects to the DS client process and the ComDPDS connects to the DPSTM client.\n\t2.1. When a request is received from the DS client process, the request is forwarded to the Dictionary. \n\t2.2. After receiving the response message, the former is forwarded to the DS client.\n\t3.1. If the request is received from a DPSTM client, it goes to the DS_DP process.\n\t3.2. After receiving the response message, it is forwarded to the DPSTM client.",
                "pat_code": "DS_stub(i) = \n    ComDCDS[i]?MSGreq.mode.operator.vars -> ComDSDI[i]!MSGreq.mode.operator.vars -> ComDIDS[i]?MSGresp.rtn -> ComDSDC[i]!MSGresp.rtn -> DS_stub(i)\n    []\n    ComDPDS[i]?MSGreq.mode.operator.vars -> ComDSDI[i]!MSGreq.mode.operator.vars -> ComDIDS[i]?MSGresp.rtn -> ComDSDP[i]!MSGresp.rtn -> DS_stub(i);"
            },
            {
                "name": "Dictionary",
                "description": "The Dictionary process receives the request message and enters the CallAPI process, which calls different APIs to execute the transaction according to the operator value of the request and forwards the result to the DS stub.",
                "pat_code": "Dictionary(i)=ComDSDI[i]?MSGreq.mode.operator.vars -> callApi.i.mode.operator.vars -> Skip;"
            },
            {
                "name": "Application0",
                "description": "The application process consists of two processes Transaction and DPSTM client running concurrently: the transaction process and the DPSTM client.",
                "pat_code": "Application0(i, mode,operator, vars) = Transaction(i,mode,operator, vars)||DPSTM_client(i);"
            },
            {
                "name": "Transaction",
                "description": "The Transaction process represents the specific transaction to be executed in the application process:\n  1. Transaction first sends a request to the DPSTM client through the ComTRDP channel, the requested message includes the transaction execution mode, the DPSTMAPI to be called and the requested data vars, \n\t2. It then receives a response message through the ComDPTR channel, including the result of the transaction execution.",
                "pat_code": "Transaction(i, mode, operator, vars) =\n  ComTRDP[i]!req.mode.operator.vars -> ComDPTR[i]?MSGresp.rtn -> Skip;"
            },
            {
                "name": "DPSTM_client",
                "description": "The DPSTM Client:\n  1. The DPSTM client first receives the request from the transaction through the channel ComDPTS\n\t2. It judges the mode of the thing execution according to the mode in the request message\n\t  2.1. When mode=0, the DPSTM client sends the request message to the transaction coordiantor process.\n    2.2. Otherwise the process will determine whether the DPSTMAPI called by the transaction execution is getVars or cmpVars through operator, if it is, then send the request to the local data service process, otherwise send the request to the DPSTM client.",
                "pat_code": "DPSTM_client(i)=ComTRDP[i]?req.mode.operator.vars->\n\tif(mode==0){\n\t\tComDPTS[i]!req.mode.operator.vars -> \n\t\tComTSDP[i]?MSGresp.rtn -> ComDPTR[i]!MSGresp.rtn -> Skip\n\t} else{\n\t\tif(operator==3||operator==5){\n\t\t\tComDPDS[i]!req.mode.operator.vars ->\n\t\t\tComDSDP[i]?MSGresp.rtn -> ComDPTR[i]!MSGresp.rtn -> Skip\n\t\t}\n\t\telse{\n\t\t\tComDPTS[i]!req.mode.operator.vars ->\n\t\t\tComTSDP[i]?MSGresp.rtn -> ComDPTR[i]!MSGresp.rtn -> Skip\n\t\t}\n\t};"
            },
            {
                "name": "System",
                "description": "The system consists of N application interacting with the TC",
                "pat_code": "System() = (|||i:{0..N-1}@Application0(i,0,0,0)) || TC();"
            }
        ],
        "global_definition": "#define N 2;\n#define M 3;\n\nvar put_finished[M] = [0,0,0];\nvar value[M][3] = [0(M*3)];\nvar version[M][3] = [0(M*3)];\nvar Consistency[M][3] = [1(M*3)];\nvar content = false;\nvar read_val; var read_ver;\nvar data_val; var data_ver;\nvar scnt = 0;var ecnt = 0;\nvar first = false;var second = false;\n\nchannel ComTRDP[N] 0;\nchannel ComDPTS[N] 0;\nchannel ComTSDC 0; channel ComDCDS[M] 0;\nchannel ComDSDI[M] 0; channel ComDPDS[M] 0;\n\nchannel ComDPTR[N] 0; channel ComTSDP[N] 0;\nchannel ComDCTS 0; channel ComDSDC[M] 0;\nchannel ComDIDS[M] 0; channel ComDSDP[M] 0;\n\n//enum{MSGreq, resp};\n//enum{keys, values, versions};\n//enum{content, rtn};\nenum{req, resp};",
        "path": "handwrite/DPSTM.csp"
    },
    {
        "name": "DSRC Based ETC",
        "tags": [
            "Protocol"
        ],
        "use_non_container_lib": false,
        "description": "DSRC (Dedicated Short Range Communication) is an important wireless communication technology in the field of Intelligent Transportation System (ITS).\n\tThe model describes the DSRC based ETC system, which mainly consists of two parts: Road Side Unit (RSU) and On Board Unit (OBU). The two parts are executed parallelly.",
        "pat_code": "#define RN 1;\n#define ON 1;\n#define Bal 200;\n#define Mon 100;\n\nchannel public 0;\nchannel requServ 0;\nchannel requHand 0;\nchannel rechServ 0;\nchannel payServ 0;\nchannel private 0;\n\nenum{car,bus};\n\n/*@Process: OBU\n\tThe OBU process simulates the behavior of an On-Board Unit in a vehicle.\n  1. It first receives a broadcast signal (with RSU id and OBU id) over the public channel.\n  2. It then sends a service request containing its ID, a road ID, its current balance, the amount to be charged, and its vehicle type over the requServ channel.\n  3. Finally, it receives an updated signal (with RSU id and OBU id) with balance over the private channel.\n*/\nOBU() = public?r1.o1 -> requServ!0.1.200.100.car -> private?r1.o1.balance -> Skip;\n\n/*@Process: Broadcast\n  \tThe Broadcast process simulates a broadcast signal from the RSU. It sends a signal(r1.o1) over the public channel and terminates successfully.\n*/\nBroadcast() = public!1.0 -> Skip;  //r1.o1\n\n/*@Process: InfoBuffer\n  The InfoBuffer process acts as a buffer within the RSU to store incoming service requests.\n  1. It first receives a service request (containing data o1, r1, balance, money and type) from the OBU.\n  2. It assigns the received values (OBU ID, balance, money, and vehicle type) to the info array.\n  3. It then sends OBU's ID, its current balance, the amount to be charged, and its vehicle type to the IdenCheck process for identity verification and further processing.\n  4. After sending the data, it resets the corresponding elements in the info array back to -1 and terminates successfully.\n*/\nvar info[2][4] = [-1,-1,-1,-1,-1,-1,-1,-1];\nInfoBuffer() = requServ?o1.r1.balance.money.type ->\nassign{\n\tinfo[0][0] = o1;\n\tinfo[0][1] = balance;\n\tinfo[0][2] = money;\n\tinfo[0][3] = type;\n} ->\nrequHand!0.200.100.car ->\nremove{\n\tinfo[0][0] = -1;\n\tinfo[0][1] = -1;\n\tinfo[0][2] = -1;\n\tinfo[0][3] = -1;\n} ->\nSkip;\n\n/*@Process: IdenCheck\n\tThe IdenCheck process handles the identity verification and initiates either a recharge or payment service based on the vehicle's information and requested transaction.\n  1. It receives the OBU ID, balance, amount, and vehicle type from the InfoBuffer.\n  2. It checks if the received OBU ID is present in the valid OBU id array.\n  3. If the OBU ID is valid and ff the amount (money) is positive (indicating a recharge), it sends recharge information with OBU id, balance and money to the rechServ channel.\n  4. Otherwise (if money is non-positive, implying a payment), it sends payment information with OBU id, balance and car type to the PayService.\n*/\nvar idHouse[5] = [0,1,2,3,4];\nvar flag = -1;\nIdenCheck() = requHand?o1.balance.money.type ->\nmatch{\n\tvar x = 0;\n\twhile(x<5){\n\t\tif(o1 == idHouse[x]){\n\t\t\tflag = 1;\n\t\t\tx = x + 5;\n\t\t}\n\t\tx++;\n\t}\n} ->\nif(flag == 1){\n\tif(money>0){\n\t\trechServ!0.200.100 -> Skip\n\t}\n\telse{\n\t\tpayServ!0.200.car -> Skip\n\t}\n}else{\n\tSkip\n};\n\n/*@Process: Recharge\n  The Recharge process handles the recharge operation.\n  1. It receives the OBU ID, balance, and amount to be recharged from the IdenCheck process.\n  2. It adds the money to the balance and assigns the result to the value variable.\n  3. It then sends an updated balance (with RSU id and OBU id and balance)to the OBU through the private channel.\n*/\nvar value = 0;\nRecharge() = rechServ?o1.balance.money ->\nadd{\n\tvalue = balance + money;\n} ->\nprivate!1.0.value -> Skip;\n\n/*@Process: RSU\n  The RSU process is defined as the parallel composition of Broadcast, InfoBuffer, IdenCheck, and Recharge processes.\n*/\nRSU() = Broadcast() || InfoBuffer() || IdenCheck() || Recharge();\n/*@Process: System\nThe model describes the DSRC based ETC system, which mainly consists of two parts: Road Side Unit (RSU) and On Board Unit (OBU). The two parts are executed parallelly.\n\n*/\nSystem() = OBU() || RSU();",
        "property_desc": [
            "The system is deadlock-free.",
            "The system is divergence-free.",
            "The recharge amount should be correct.",
            "The balance cannot be negative.",
            "The info buffer stores data correctly."
        ],
        "properties": [
            "#assert System deadlockfree;",
            "#assert System divergencefree;",
            "#define CorrectRecharge value == (Bal + Mon);\n#define NonNegativeBalance value >= 0;  \n#define InfoBufferCorrect info[0][0] != -1;\n\n#assert System reaches CorrectRecharge;",
            "#assert System reaches NonNegativeBalance;",
            "#assert System reaches InfoBufferCorrect;"
        ],
        "processes": [
            {
                "name": "OBU",
                "description": "The OBU process simulates the behavior of an On-Board Unit in a vehicle.\n  1. It first receives a broadcast signal (with RSU id and OBU id) over the public channel.\n  2. It then sends a service request containing its ID, a road ID, its current balance, the amount to be charged, and its vehicle type over the requServ channel.\n  3. Finally, it receives an updated signal (with RSU id and OBU id) with balance over the private channel.",
                "pat_code": "OBU() = public?r1.o1 -> requServ!0.1.200.100.car -> private?r1.o1.balance -> Skip;"
            },
            {
                "name": "Broadcast",
                "description": "The Broadcast process simulates a broadcast signal from the RSU. It sends a signal(r1.o1) over the public channel and terminates successfully.",
                "pat_code": "Broadcast() = public!1.0 -> Skip;  //r1.o1"
            },
            {
                "name": "InfoBuffer",
                "description": "The InfoBuffer process acts as a buffer within the RSU to store incoming service requests.\n  1. It first receives a service request (containing data o1, r1, balance, money and type) from the OBU.\n  2. It assigns the received values (OBU ID, balance, money, and vehicle type) to the info array.\n  3. It then sends OBU's ID, its current balance, the amount to be charged, and its vehicle type to the IdenCheck process for identity verification and further processing.\n  4. After sending the data, it resets the corresponding elements in the info array back to -1 and terminates successfully.",
                "pat_code": "var info[2][4] = [-1,-1,-1,-1,-1,-1,-1,-1];\nInfoBuffer() = requServ?o1.r1.balance.money.type ->\nassign{\n\tinfo[0][0] = o1;\n\tinfo[0][1] = balance;\n\tinfo[0][2] = money;\n\tinfo[0][3] = type;\n} ->\nrequHand!0.200.100.car ->\nremove{\n\tinfo[0][0] = -1;\n\tinfo[0][1] = -1;\n\tinfo[0][2] = -1;\n\tinfo[0][3] = -1;\n} ->\nSkip;"
            },
            {
                "name": "IdenCheck",
                "description": "The IdenCheck process handles the identity verification and initiates either a recharge or payment service based on the vehicle's information and requested transaction.\n  1. It receives the OBU ID, balance, amount, and vehicle type from the InfoBuffer.\n  2. It checks if the received OBU ID is present in the valid OBU id array.\n  3. If the OBU ID is valid and ff the amount (money) is positive (indicating a recharge), it sends recharge information with OBU id, balance and money to the rechServ channel.\n  4. Otherwise (if money is non-positive, implying a payment), it sends payment information with OBU id, balance and car type to the PayService.",
                "pat_code": "var idHouse[5] = [0,1,2,3,4];\nvar flag = -1;\nIdenCheck() = requHand?o1.balance.money.type ->\nmatch{\n\tvar x = 0;\n\twhile(x<5){\n\t\tif(o1 == idHouse[x]){\n\t\t\tflag = 1;\n\t\t\tx = x + 5;\n\t\t}\n\t\tx++;\n\t}\n} ->\nif(flag == 1){\n\tif(money>0){\n\t\trechServ!0.200.100 -> Skip\n\t}\n\telse{\n\t\tpayServ!0.200.car -> Skip\n\t}\n}else{\n\tSkip\n};"
            },
            {
                "name": "Recharge",
                "description": "The Recharge process handles the recharge operation.\n  1. It receives the OBU ID, balance, and amount to be recharged from the IdenCheck process.\n  2. It adds the money to the balance and assigns the result to the value variable.\n  3. It then sends an updated balance (with RSU id and OBU id and balance)to the OBU through the private channel.",
                "pat_code": "var value = 0;\nRecharge() = rechServ?o1.balance.money ->\nadd{\n\tvalue = balance + money;\n} ->\nprivate!1.0.value -> Skip;"
            },
            {
                "name": "RSU",
                "description": "The RSU process is defined as the parallel composition of Broadcast, InfoBuffer, IdenCheck, and Recharge processes.",
                "pat_code": "RSU() = Broadcast() || InfoBuffer() || IdenCheck() || Recharge();"
            },
            {
                "name": "System",
                "description": "The model describes the DSRC based ETC system, which mainly consists of two parts: Road Side Unit (RSU) and On Board Unit (OBU). The two parts are executed parallelly.",
                "pat_code": "System() = OBU() || RSU();"
            }
        ],
        "global_definition": "#define RN 1;\n#define ON 1;\n#define Bal 200;\n#define Mon 100;\n\nchannel public 0;\nchannel requServ 0;\nchannel requHand 0;\nchannel rechServ 0;\nchannel payServ 0;\nchannel private 0;\n\nenum{car,bus};",
        "path": "handwrite/DSRC Based ETC.csp"
    },
    {
        "name": "Graphene",
        "tags": [
            "Protocol",
            "Attacker"
        ],
        "use_non_container_lib": false,
        "description": "Graphene is a new secure cloud communication architecture based on TCP and UDP, focusing on the security of communication (TCP/UDP) channels and related transmitted data. It utilizes a novel protocol to establish communication, capable of protecting communication channels from the most common attacks. \n  \n\tKey notations and meanings:\n\t- PRCKS: Private key of the central key server\n  - PUCKS: Public key of the central key server\n\t- PURCU: Root public key of the cloud user\n\t- PRRCU: Root private key of the cloud user\n\t- PURCI: Root public key of the cloud server instance\n\t- PRRCI: Root private key of the cloud server instance\n\t- PUTCUR: Temporary public key of the cloud user(RSA)\n\t- PRTCUR: Temporary private key of the cloud user(RSA)\n\t- PUTCUD: Temporary public key of the cloud user(DHE)\n\t- PRTCUD: Temporary private key of the cloud user(DHE)\n\t- PUTCIR: Temporary public key of the cloud server instance(RSA)\n\t- PRTCIR: Temporary private key of the cloud server instance(RSA)\n\t- PUTCID: Temporary public key of the cloud server instance(DHE)\n\t- PRTCID: Temporary private key of the cloud server instance(DHE)",
        "pat_code": "// cloud user and cks \nchannel ComUS 0;\n// cloud user and cloud instance \nchannel ComUI 0;\n// cloud instance and cks\nchannel ComIS 0;\n// Cloud Instance share secret channel\nchannel ComIK 0;\n// Cloud User share secret channel\nchannel ComUK 0;\n// Fake Cloud User share secret channel\nchannel FakeUK 0;\n// Fake Cloud Instance share secret channel\nchannel FakeIK 0;\n// Intruder fake user and cks\nchannel FakeUS 0;\n// intruder fake cloud instance and cks\nchannel FakeIS 0;\n// intruder and user\nchannel FakeU 0;\n// Intruder and cloud instance\nchannel FakeI 0;\n\nvar purci_get = false;\nvar comkey_cu_get = false;\nvar fakekey_cu_get = false;\nvar fakekey_ci_get = false;\nvar comkey_ci_get = false;\nvar purcu_get=false;\nvar putci_get=false;\nvar putcu_get=false;\nvar req_payload_get=false;\nvar res_payload_get=false;\nvar purci_fake_get=false;\nvar purcu_fake_get=false;\nvar completement = false;\nvar user_fake_success=false;\nvar server_fake_success=false;\nvar instance_fake_success=false;\n\n\n/*\nPUCKS public key for cks\nPRCKS private key for cks\nPURCU public root key cloud user\nPRRCU private root key cloud user\nPRTCUR private temporary cloud user(RSA)\nPUTCUR public temporary cloud user(RSA)\nPUTCUD public temporary cloud user(RSA)(DH)\n\nPURCI public root key cloud instance\nPRRCI private root key cloud instance\nPRTCIR private temporary cloud instance(RSA)\nPUTCIR public temporary cloud instance(RSA)\nPUTCID public temporary cloud instance(DH)\n*/\nenum{req_ci_rk,req_cu_rk};\nenum{pucks,purcu,putcur,purci,putcir,putcid,putcud,pri,purci_fake,purcu_fake};\nenum{prcks,prrcu,prtcur,prrci,prtcir,prtcid,prtcud,pui};\nenum{fakekey,comkey};\nenum{req_payload,res_payload,pub_payload,ack_payload};\n\n\n#define getpurci(PRCKS,PUCKS)\n{\n\tif(PRCKS==PUCKS){\n\t\tpurci_get=true;\n\t\t}\n\telse{\n\t\tpurci_get=false;\t\n\t};\n};\n\n#define getfakepurci(PRCKS,PUCKS)\n{\n\tif(PRCKS==PUCKS){\n\t\tpurci_fake_get=true;\n\t\t}\n\telse{\n\t\tpurci_fake_get=false;\t\n\t};\n};\n#define getfakepurcu(PRCKS,PUCKS)\n{\n\tif(PRCKS==PUCKS){\n\t\tpurcu_fake_get=true;\n\t\t}\n\telse{\n\t\tpurcu_fake_get=false;\t\n\t};\n};\n\n#define getpurcu(PRCKS,PUCKS){\n\tif(PRCKS==PUCKS){\n\t\tpurcu_get=true;\n\t\t}\n\telse{\n\t\tpurcu_get=false;\n\t\t};\n};\n#define getputci(PRRCI,PURCI){\n\tif(PURCI==PRRCI){\n\t\tputci_get=true;\n\t\t}else{\n\t\tputci_get=false;\n\t\t};\n};\n\n#define getputcu(PRRCU,PURCU){\n\tif(PURCU==PRRCU){\n\t\tputcu_get=true;\n\t\t}else{\n\t\tputcu_get=false;\n\t\t};\n};\n#define getcucomkey(PUTCID,PUTCID_1,PUTCUD,PUTCUD_1,PRTCD,PRTCUD){\n\tif(PUTCID==PUTCID_1&&PUTCUD==PUTCUD_1&&(PRTCD==PRTCUD)){\n\t\tcomkey_cu_get=true;\n\t  };\n};\n#define getcicomkey(PUTCID,PUTCID_1,PUTCUD,PUTCUD_1,PRTCD,PRTCID){\n\tif(PUTCID==PUTCID_1&&PUTCUD==PUTCUD_1&&(PRTCD==PRTCID)){\n\t\tcomkey_ci_get=true;\n\t  };\n};\n#define getcufakekey(PUTCID,PUTCID_1,PUTCUD,PUTCUD_1,PRTCD,PRTCID){\n\tif(PUTCID==PUTCID_1&&PUTCUD==PUTCUD_1&&(PRTCD==PRTCID)){\n\t\tfakekey_cu_get=true;\n\t  };\n};\n#define getcifakekey(PUTCID,PUTCID_1,PUTCUD,PUTCUD_1,PRTCD,PRTCID){\n\tif(PUTCID==PUTCID_1&&PUTCUD==PUTCUD_1&&(PRTCD==PRTCID)){\n\t\tfakekey_ci_get=true;\n\t  };\n};\n\n#define getresdata(PUTCUR,COM_KEY_CU,PUTCUR_1,COM_KEY_CI){\n\tif(PUTCUR==PUTCUR_1&&COM_KEY_CU==COM_KEY_CI)\n\t\t{\n\t\t\tres_payload_get=true;\n\t\t}\n\t\telse{\n\t\t\tres_payload_get=false;\n\t\t}\n};\n\n#define getreqdata(PUTCUR,COM_KEY_CU,PUTCUR_1,COM_KEY_CI){\n\tif(PUTCUR==PUTCUR_1&&COM_KEY_CU==COM_KEY_CI)\n\t\t{\n\t\t\treq_payload_get=true;\n\t\t}else{\n\t\t\treq_payload_get=false;\n\t\t}\n};\n\n/*@Process: CloudInstance\n\tCloud Server Instance (CI): The server-side in the Graphene architecture is responsible for processing requests and returning responses, and it also provides actual computing resources in the cloud environment.\n  1. It first receive a PUB request with signed (PUTCUD, PUTCUR) from CU.\n\t2. After the CI receives the CU\u2019s packet, the CI requests the CU\u2019s root public key (PURCU) from the CKS.\n\t3. After receive response from CKS, the CI verifies the authenticity of PUCKS and PURCU to authenticate the payloads. Upon success, it stores (PUTCUD, PUTCUR) in the session.\n  4. If verified, the CI sends ACK to CU, signing (PUTCID, PUTCIR) with PRRCI for payload authenticity and integrity.\n  5. After the secure session establishment, the CI receives REQ messages from the CU. \n\t5. After receiving the REQ from the CU, the CI verifies using PUTCUR. On success, it decrypts with ck.\n\t6. Upon decrypting REQ, the CI replies with RES. It encrypts resData with ck, signs with PRTCIR, and transmits. After transmission, the CI terminates session with the CU.\n*/\nCloudInstance()=\n\t\tComUI?PRRCU.PUTCUR.PUTCUD.PUB_PAYLOAD->\n\t\tComIS!req_cu_rk->\n\t\tComIS?PRCKS.PURCU->\n\t\t{call(getpurcu,PRCKS,pucks)}->\n\t\tif(purcu_get==true){{call(getputcu,PURCU,PRRCU)}-> \n\t\tif(putcu_get==true){ComIK!putcid.PUTCUD.prtcid->ComIK?COM_KEY_CI->ComUI!prrci.putcir.putcid.ack_payload->ComUI?PUTCIR.COM_KEY_CU.REQ_PAYLOAD->{call(getreqdata,PUTCIR,COM_KEY_CU,prtcir,COM_KEY_CI)}->\n\t\tif(req_payload_get==true){ComUI!putcur.COM_KEY_CI.res_payload->CloudInstance()}\n\t\telse{skip->CloudInstance()}}\n\t\telse{skip->CloudInstance()}}\n\t\telse{skip->CloudInstance()}\n\t  []FakeU?PRRCU.PUTCUR.PUTCUD.PUB_PAYLOAD->\n\t\tFakeIS!req_cu_rk->\n\t\tFakeIS?PRCKS.PURCU->\n\t\t{call(getpurcu,PRCKS,pucks)}->\n\t\tif(purcu_get==true){{call(getputcu,PURCU,PRRCU)}->\n\t\tif(putcu_get==true){FakeIK!putcid.PUTCUD.pri->FakeIK?COM_KEY_CI->FakeU!pri.putcir.putcid.ack_payload->FakeU?PUTCIR.COM_KEY_CU.REQ_PAYLOAD->{call(getreqdata,PUTCIR,COM_KEY_CU,prtcir,COM_KEY_CI)}->\n\t\tif(req_payload_get==true){{instance_fake_success=true;}->FakeU!putcur.COM_KEY_CI.res_payload->CloudInstance()}\n\t\telse{skip->CloudInstance()}}\n\t\telse{skip->CloudInstance()}}\n\t\telse{skip->CloudInstance()};\n\t\n/*@Process: CloudUser\n\tCloud User (CU): The cloud user serves as the initiator of requests and recipient of responses. When a cloud user wishes to obtain data from cloud server instance, the following series of events takes place:\n  1. Firstly, the CU initializes the cloud connection and generates two temporary key pairs, each comprising a public and a private key\n\t2. After the connection is initialized, the CU requests the PURCI from the CKS.\n\t3. The CU retrieves the PURCI signed by PRCKS that is returned from the CKS.\n  4. The CU utilizes PUCKS to verify the authenticity and integrity of the PURCI received from the CKS, preventing identity spoofing and data tampering.\n\t5. If verified, the CU first communicates with CI, it sends a PUB request with signed (PUTCUD, PUTCUR) using PRRCU, ensuring payload authenticity and integrity.\n  6. The CU receives ACK from CI, signing (PUTCID, PUTCIR) with PRRCI for payload authenticity and integrity.\n  7. Upon receiving the encrypted and signed ACK, the CU verifies payload authenticity and integrity, then stores (PUTCID, PUTCIR) in the session. \n\t   If verified, the secure session is established. After session establishment, the CU and the CI generate a common key (ck) through a temporary key exchange (DHE/ECDHE) to establish a secure encrypted channel.\n\t8. After the secure session establishment, the CU sends REQ messages to the CI. It encrypts the request payload (reqData) with ck for confidentiality and signs with PRTCUR (paired with PUTCUR) for authenticity and integrity using the auxiliary process CommonKeyGenerate.\n  9. Receiving RES from CI, the CU verifies signature with PUTCIR. If valid, the CU then decrypts content with ck.\n*/\nCloudUser()=\n\t\tComUS!req_ci_rk->\n\t\tComUS?PRCKS.PURCI->\n\t\t{call(getpurci,PRCKS,pucks)}\n\t\t->if(purci_get==true){ComUI!prrcu.putcur.putcud.pub_payload->ComUI?PRRCI.PUTCIR.PUTCID.ACK_PAYLOAD->{call(getputci,PRRCI,purci)}\n\t\t->if(putci_get==true){ComUK!PUTCID.putcud.prtcud->ComUK?COM_KEY_CU->ComUI!putcir.COM_KEY_CU.req_payload->ComUI?PUTCUR.COM_KEY_CI.RES_PAYLOAD->{call(getresdata,PUTCUR,COM_KEY_CI,prtcur,COM_KEY_CU)}\n\t\t->if(res_payload_get==true){{completement=true}->CloudUser()}\n\t\telse{skip->CloudUser()}}\n\t\telse{skip->CloudUser()}}\n\t\telse{skip->CloudUser()}\n\t  []FakeUS!req_ci_rk-> \n\t\tFakeUS?PRCKS.PURCI->\n\t\t{call(getpurci,PRCKS,pucks)}\n\t\t->if(purci_get==true){FakeI!pri.putcur.putcud.pub_payload->FakeI?PRRCI.PUTCIR.PUTCID.ACK_PAYLOAD->{call(getputci,PRRCI,purci)}\n\t\t->if(putci_get==true){FakeUK!PUTCID.putcud.pri->FakeUK?COM_KEY_CU->FakeI!putcir.COM_KEY_CU.req_payload->FakeI?PUTCUR.COM_KEY_CI.RES_PAYLOAD->{call(getresdata,PUTCUR,COM_KEY_CI,prtcur,COM_KEY_CU)}\n\t\t->if(res_payload_get==true){{user_fake_success=true;completement=true}->CloudUser()}\n\t\telse{skip->CloudUser()}}\n\t\telse{skip->CloudUser()}}\n\t\telse{skip->CloudUser()};\n\n/*@Process: CentralKeyServer\n  Central Key Server (CKS): Its main functions are securely storing and distributing root public keys. Cloud entities must first register their root public keys with the CKS and install the CKS public key (PUCKS).\n  - When receiving the request from CU to obtain the PURCI, it responses with PURCI signed by PRCKS.\n\t- When receiving the request from CI to obtain the PURCU, the CKS returns the requested public key signed by PRCKS.\n*/\nCentralKeyServer()=\n\t\tComUS?REQ_CI_RK->ComUS!prcks.purci->CentralKeyServer()\n\t  []ComIS?REQ_CU_RK->ComIS!prcks.purcu->CentralKeyServer()\n\t  []FakeI?REQ_CI_RK->FakeI!pri.purci_fake->CentralKeyServer()\n\t  []FakeU?REQ_CU_RK->FakeU!pri.purcu_fake->CentralKeyServer();\n\t  \n/*@Process: CommonKeyGenerate\nExcept these three processes, the model introduces an auxiliary process CommonKeyGenerate to encrypt data.\n\t1. It receives public keys (PUTCID, PUTCUD, PRTCD) from the cloud user or cloud instance.\n\t2. Verifies the keys using the getcucomkey or getcicomkey macros.\n  3. If the keys are valid, it generates and sends a common key to the requester.\n*/\n// DH/ECDHE Algorithm\nCommonKeyGenerate()=ComUK?PUTCID.PUTCUD.PRTCD->{call(getcucomkey,PUTCID,putcid,PUTCUD,putcud,PRTCD,prtcud)}->\n\t\t\t\t\tif(comkey_cu_get==true){ComUK!comkey->CommonKeyGenerate()}\n\t\t\t\t\telse{skip->CommonKeyGenerate()}\n\t\t\t\t  []FakeUK?PUTCID.PUTCUD.PRTCD->{call(getcufakekey,PUTCID,putcid,PUTCUD,putcud,PRTCD,pri)}->\n\t\t\t\t\tif(fakekey_cu_get==true){FakeUK!fakekey->CommonKeyGenerate()}\n\t\t\t\t\telse{skip->CommonKeyGenerate()}\n\t\t\t\t  []ComIK?PUTCID.PUTCUD.PRTCD->{call(getcicomkey,PUTCID,putcid,PUTCUD,putcud,PRTCD,prtcid)}->\n\t\t\t\t\tif(comkey_ci_get==true){ComIK!comkey->CommonKeyGenerate()}\n\t\t\t\t\telse{skip->CommonKeyGenerate()}\n\t\t\t\t  []FakeIK?PUTCID.PUTCUD.PRTCD->{call(getcifakekey,PUTCID,putcid,PUTCUD,putcud,PRTCD,pri)}->\n\t\t\t\t\tif(fakekey_ci_get==true){FakeIK!fakekey->CommonKeyGenerate()}\n\t\t\t\t\telse{skip->CommonKeyGenerate()};\n\n/*@Process: intruder\n\tThe model also introduces the intruder: This process represents an intruder attempting to compromise the communication between the cloud user, cloud instance, and CKS. It performs the following tasks:\n  1. Sends fake requests to the CKS (FakeUS, FakeU) to obtain fake root public keys (prcks.purci, prcks.purcu).\n  2. It attempts to impersonate the cloud user or cloud instance by sending fake public keys (PRRCU_FAKE.PUTCUR.PUTCUD.PUB_PAYLOAD, PRRCI_FAKE.PUTCIR.PUTCID.ACK_PAYLOAD).\n  3. It verifies the success of its attacks using the getputcu, getputci, getreqdata, and getresdata macros.\n\t4. If the attack succeeds, it sets the corresponding success flags.\n*/\nintruder() = FakeUS?REQ_CI_RK->FakeUS!prcks.purci->FakeI?PRRCU_FAKE.PUTCUR.PUTCUD.PUB_PAYLOAD->{call(getputcu,purcu,PRRCU_FAKE)}->\n\t\t\t if(putcu_get==true){{user_fake_success=true;}->FakeI!prrci.putcir.putcid.ack_payload->FakeI?putcir.COM_KEY_CU.req_payload->FakeI!putcur.fakekey.res_payload->intruder()}\n\t\t\t else{FakeI!prrci.putcir.putcid.ack_payload->FakeI?PUTCIR.COM_KEY_CU.req_payload->{call(getreqdata,PUTCIR,COM_KEY_CU,prtcir,comkey)}->\n\t\t\t if(req_payload_get==true){{user_fake_success=true;}->FakeI!putcur.fakekey.res_payload->intruder()}\n\t\t\t else{FakeI!putcur.comkey.res_payload->intruder()}}\n\t\t   []FakeU!prrcu.putcur.putcud.pub_payload->\n\t\t\t FakeIS?REQ_CU_RK->FakeIS!prcks.purcu->FakeU?PRRCI_FAKE.PUTCIR.PUTCID.ACK_PAYLOAD->{call(getputci,purci,PRRCI_FAKE)}->\n\t\t     if(putci_get==true){{instance_fake_success=true;}->FakeU!putcir.fakekey.req_payload->FakeU?PUTCUR.COM_KEY_CI.RES_PAYLOAD->intruder()}\n\t\t     else{FakeU!putcir.comkey.req_payload->intruder()}\n\t\t   []FakeI!req_ci_rk->FakeI?PRCKS.PURCI->{call(getfakepurci,PRCKS,pucks)}->\n\t\t     if(purci_fake_get==true){{server_fake_success=true;}->intruder()}\n\t\t     else{fail->intruder()}\n\t\t   []FakeU!req_cu_rk->FakeU?PRCKS.PURCU->{call(getfakepurcu,PRCKS,pucks)}->\n\t\t     if(purcu_fake_get==true){{server_fake_success=true;}->\n\t\t     intruder()}else{fail->intruder()};\n\n\n/*@Process: Graphene\n\tThe architecture comprises the following three entities: cloud user, central key server and cloud server instance. Meanwhile, the model introduces a intruder.\n*/\nGraphene()=CloudUser()||CloudInstance()||CentralKeyServer()||CommonKeyGenerate()||intruder();",
        "property_desc": [
            "The protocol is deadlock-free.",
            "The protocol is divergence-free.",
            "The data sent by CU can be received.",
            "Whether the intruder can successfully impersonate the cloud user.",
            "Whether the intruder can successfully impersonate the cloud instance.",
            "Whether the intruder can successfully compromise the Central Key Server (CKS)."
        ],
        "properties": [
            "#assert Graphene() deadlockfree;",
            "#assert Graphene() divergencefree;",
            "#define Data_Reachability completement==true;\n#assert Graphene reaches Data_Reachability;",
            "//intruder\n#define User_Fake_Success user_fake_success==true;\n#assert Graphene() |=[] User_Fake_Success;",
            "#define Instance_Fake_Success instance_fake_success==true;\n#assert Graphene() |=[]! Instance_Fake_Success;",
            "#define Server_Fake_Success server_fake_success==true;\n#assert Graphene() |=[]! Server_Fake_Success;"
        ],
        "processes": [
            {
                "name": "CloudInstance",
                "description": "Cloud Server Instance (CI): The server-side in the Graphene architecture is responsible for processing requests and returning responses, and it also provides actual computing resources in the cloud environment.\n  1. It first receive a PUB request with signed (PUTCUD, PUTCUR) from CU.\n\t2. After the CI receives the CU\u2019s packet, the CI requests the CU\u2019s root public key (PURCU) from the CKS.\n\t3. After receive response from CKS, the CI verifies the authenticity of PUCKS and PURCU to authenticate the payloads. Upon success, it stores (PUTCUD, PUTCUR) in the session.\n  4. If verified, the CI sends ACK to CU, signing (PUTCID, PUTCIR) with PRRCI for payload authenticity and integrity.\n  5. After the secure session establishment, the CI receives REQ messages from the CU. \n\t5. After receiving the REQ from the CU, the CI verifies using PUTCUR. On success, it decrypts with ck.\n\t6. Upon decrypting REQ, the CI replies with RES. It encrypts resData with ck, signs with PRTCIR, and transmits. After transmission, the CI terminates session with the CU.",
                "pat_code": "CloudInstance()=\n\t\tComUI?PRRCU.PUTCUR.PUTCUD.PUB_PAYLOAD->\n\t\tComIS!req_cu_rk->\n\t\tComIS?PRCKS.PURCU->\n\t\t{call(getpurcu,PRCKS,pucks)}->\n\t\tif(purcu_get==true){{call(getputcu,PURCU,PRRCU)}-> \n\t\tif(putcu_get==true){ComIK!putcid.PUTCUD.prtcid->ComIK?COM_KEY_CI->ComUI!prrci.putcir.putcid.ack_payload->ComUI?PUTCIR.COM_KEY_CU.REQ_PAYLOAD->{call(getreqdata,PUTCIR,COM_KEY_CU,prtcir,COM_KEY_CI)}->\n\t\tif(req_payload_get==true){ComUI!putcur.COM_KEY_CI.res_payload->CloudInstance()}\n\t\telse{skip->CloudInstance()}}\n\t\telse{skip->CloudInstance()}}\n\t\telse{skip->CloudInstance()}\n\t  []FakeU?PRRCU.PUTCUR.PUTCUD.PUB_PAYLOAD->\n\t\tFakeIS!req_cu_rk->\n\t\tFakeIS?PRCKS.PURCU->\n\t\t{call(getpurcu,PRCKS,pucks)}->\n\t\tif(purcu_get==true){{call(getputcu,PURCU,PRRCU)}->\n\t\tif(putcu_get==true){FakeIK!putcid.PUTCUD.pri->FakeIK?COM_KEY_CI->FakeU!pri.putcir.putcid.ack_payload->FakeU?PUTCIR.COM_KEY_CU.REQ_PAYLOAD->{call(getreqdata,PUTCIR,COM_KEY_CU,prtcir,COM_KEY_CI)}->\n\t\tif(req_payload_get==true){{instance_fake_success=true;}->FakeU!putcur.COM_KEY_CI.res_payload->CloudInstance()}\n\t\telse{skip->CloudInstance()}}\n\t\telse{skip->CloudInstance()}}\n\t\telse{skip->CloudInstance()};"
            },
            {
                "name": "CloudUser",
                "description": "Cloud User (CU): The cloud user serves as the initiator of requests and recipient of responses. When a cloud user wishes to obtain data from cloud server instance, the following series of events takes place:\n  1. Firstly, the CU initializes the cloud connection and generates two temporary key pairs, each comprising a public and a private key\n\t2. After the connection is initialized, the CU requests the PURCI from the CKS.\n\t3. The CU retrieves the PURCI signed by PRCKS that is returned from the CKS.\n  4. The CU utilizes PUCKS to verify the authenticity and integrity of the PURCI received from the CKS, preventing identity spoofing and data tampering.\n\t5. If verified, the CU first communicates with CI, it sends a PUB request with signed (PUTCUD, PUTCUR) using PRRCU, ensuring payload authenticity and integrity.\n  6. The CU receives ACK from CI, signing (PUTCID, PUTCIR) with PRRCI for payload authenticity and integrity.\n  7. Upon receiving the encrypted and signed ACK, the CU verifies payload authenticity and integrity, then stores (PUTCID, PUTCIR) in the session. \n\t   If verified, the secure session is established. After session establishment, the CU and the CI generate a common key (ck) through a temporary key exchange (DHE/ECDHE) to establish a secure encrypted channel.\n\t8. After the secure session establishment, the CU sends REQ messages to the CI. It encrypts the request payload (reqData) with ck for confidentiality and signs with PRTCUR (paired with PUTCUR) for authenticity and integrity using the auxiliary process CommonKeyGenerate.\n  9. Receiving RES from CI, the CU verifies signature with PUTCIR. If valid, the CU then decrypts content with ck.",
                "pat_code": "CloudUser()=\n\t\tComUS!req_ci_rk->\n\t\tComUS?PRCKS.PURCI->\n\t\t{call(getpurci,PRCKS,pucks)}\n\t\t->if(purci_get==true){ComUI!prrcu.putcur.putcud.pub_payload->ComUI?PRRCI.PUTCIR.PUTCID.ACK_PAYLOAD->{call(getputci,PRRCI,purci)}\n\t\t->if(putci_get==true){ComUK!PUTCID.putcud.prtcud->ComUK?COM_KEY_CU->ComUI!putcir.COM_KEY_CU.req_payload->ComUI?PUTCUR.COM_KEY_CI.RES_PAYLOAD->{call(getresdata,PUTCUR,COM_KEY_CI,prtcur,COM_KEY_CU)}\n\t\t->if(res_payload_get==true){{completement=true}->CloudUser()}\n\t\telse{skip->CloudUser()}}\n\t\telse{skip->CloudUser()}}\n\t\telse{skip->CloudUser()}\n\t  []FakeUS!req_ci_rk-> \n\t\tFakeUS?PRCKS.PURCI->\n\t\t{call(getpurci,PRCKS,pucks)}\n\t\t->if(purci_get==true){FakeI!pri.putcur.putcud.pub_payload->FakeI?PRRCI.PUTCIR.PUTCID.ACK_PAYLOAD->{call(getputci,PRRCI,purci)}\n\t\t->if(putci_get==true){FakeUK!PUTCID.putcud.pri->FakeUK?COM_KEY_CU->FakeI!putcir.COM_KEY_CU.req_payload->FakeI?PUTCUR.COM_KEY_CI.RES_PAYLOAD->{call(getresdata,PUTCUR,COM_KEY_CI,prtcur,COM_KEY_CU)}\n\t\t->if(res_payload_get==true){{user_fake_success=true;completement=true}->CloudUser()}\n\t\telse{skip->CloudUser()}}\n\t\telse{skip->CloudUser()}}\n\t\telse{skip->CloudUser()};"
            },
            {
                "name": "CentralKeyServer",
                "description": "Central Key Server (CKS): Its main functions are securely storing and distributing root public keys. Cloud entities must first register their root public keys with the CKS and install the CKS public key (PUCKS).\n  - When receiving the request from CU to obtain the PURCI, it responses with PURCI signed by PRCKS.\n\t- When receiving the request from CI to obtain the PURCU, the CKS returns the requested public key signed by PRCKS.",
                "pat_code": "CentralKeyServer()=\n\t\tComUS?REQ_CI_RK->ComUS!prcks.purci->CentralKeyServer()\n\t  []ComIS?REQ_CU_RK->ComIS!prcks.purcu->CentralKeyServer()\n\t  []FakeI?REQ_CI_RK->FakeI!pri.purci_fake->CentralKeyServer()\n\t  []FakeU?REQ_CU_RK->FakeU!pri.purcu_fake->CentralKeyServer();"
            },
            {
                "name": "CommonKeyGenerate",
                "description": "Except these three processes, the model introduces an auxiliary process CommonKeyGenerate to encrypt data.\n\t1. It receives public keys (PUTCID, PUTCUD, PRTCD) from the cloud user or cloud instance.\n\t2. Verifies the keys using the getcucomkey or getcicomkey macros.\n  3. If the keys are valid, it generates and sends a common key to the requester.",
                "pat_code": "// DH/ECDHE Algorithm\nCommonKeyGenerate()=ComUK?PUTCID.PUTCUD.PRTCD->{call(getcucomkey,PUTCID,putcid,PUTCUD,putcud,PRTCD,prtcud)}->\n\t\t\t\t\tif(comkey_cu_get==true){ComUK!comkey->CommonKeyGenerate()}\n\t\t\t\t\telse{skip->CommonKeyGenerate()}\n\t\t\t\t  []FakeUK?PUTCID.PUTCUD.PRTCD->{call(getcufakekey,PUTCID,putcid,PUTCUD,putcud,PRTCD,pri)}->\n\t\t\t\t\tif(fakekey_cu_get==true){FakeUK!fakekey->CommonKeyGenerate()}\n\t\t\t\t\telse{skip->CommonKeyGenerate()}\n\t\t\t\t  []ComIK?PUTCID.PUTCUD.PRTCD->{call(getcicomkey,PUTCID,putcid,PUTCUD,putcud,PRTCD,prtcid)}->\n\t\t\t\t\tif(comkey_ci_get==true){ComIK!comkey->CommonKeyGenerate()}\n\t\t\t\t\telse{skip->CommonKeyGenerate()}\n\t\t\t\t  []FakeIK?PUTCID.PUTCUD.PRTCD->{call(getcifakekey,PUTCID,putcid,PUTCUD,putcud,PRTCD,pri)}->\n\t\t\t\t\tif(fakekey_ci_get==true){FakeIK!fakekey->CommonKeyGenerate()}\n\t\t\t\t\telse{skip->CommonKeyGenerate()};"
            },
            {
                "name": "intruder",
                "description": "The model also introduces the intruder: This process represents an intruder attempting to compromise the communication between the cloud user, cloud instance, and CKS. It performs the following tasks:\n  1. Sends fake requests to the CKS (FakeUS, FakeU) to obtain fake root public keys (prcks.purci, prcks.purcu).\n  2. It attempts to impersonate the cloud user or cloud instance by sending fake public keys (PRRCU_FAKE.PUTCUR.PUTCUD.PUB_PAYLOAD, PRRCI_FAKE.PUTCIR.PUTCID.ACK_PAYLOAD).\n  3. It verifies the success of its attacks using the getputcu, getputci, getreqdata, and getresdata macros.\n\t4. If the attack succeeds, it sets the corresponding success flags.",
                "pat_code": "intruder() = FakeUS?REQ_CI_RK->FakeUS!prcks.purci->FakeI?PRRCU_FAKE.PUTCUR.PUTCUD.PUB_PAYLOAD->{call(getputcu,purcu,PRRCU_FAKE)}->\n\t\t\t if(putcu_get==true){{user_fake_success=true;}->FakeI!prrci.putcir.putcid.ack_payload->FakeI?putcir.COM_KEY_CU.req_payload->FakeI!putcur.fakekey.res_payload->intruder()}\n\t\t\t else{FakeI!prrci.putcir.putcid.ack_payload->FakeI?PUTCIR.COM_KEY_CU.req_payload->{call(getreqdata,PUTCIR,COM_KEY_CU,prtcir,comkey)}->\n\t\t\t if(req_payload_get==true){{user_fake_success=true;}->FakeI!putcur.fakekey.res_payload->intruder()}\n\t\t\t else{FakeI!putcur.comkey.res_payload->intruder()}}\n\t\t   []FakeU!prrcu.putcur.putcud.pub_payload->\n\t\t\t FakeIS?REQ_CU_RK->FakeIS!prcks.purcu->FakeU?PRRCI_FAKE.PUTCIR.PUTCID.ACK_PAYLOAD->{call(getputci,purci,PRRCI_FAKE)}->\n\t\t     if(putci_get==true){{instance_fake_success=true;}->FakeU!putcir.fakekey.req_payload->FakeU?PUTCUR.COM_KEY_CI.RES_PAYLOAD->intruder()}\n\t\t     else{FakeU!putcir.comkey.req_payload->intruder()}\n\t\t   []FakeI!req_ci_rk->FakeI?PRCKS.PURCI->{call(getfakepurci,PRCKS,pucks)}->\n\t\t     if(purci_fake_get==true){{server_fake_success=true;}->intruder()}\n\t\t     else{fail->intruder()}\n\t\t   []FakeU!req_cu_rk->FakeU?PRCKS.PURCU->{call(getfakepurcu,PRCKS,pucks)}->\n\t\t     if(purcu_fake_get==true){{server_fake_success=true;}->\n\t\t     intruder()}else{fail->intruder()};"
            },
            {
                "name": "Graphene",
                "description": "The architecture comprises the following three entities: cloud user, central key server and cloud server instance. Meanwhile, the model introduces a intruder.",
                "pat_code": "Graphene()=CloudUser()||CloudInstance()||CentralKeyServer()||CommonKeyGenerate()||intruder();"
            }
        ],
        "global_definition": "// cloud user and cks \nchannel ComUS 0;\n// cloud user and cloud instance \nchannel ComUI 0;\n// cloud instance and cks\nchannel ComIS 0;\n// Cloud Instance share secret channel\nchannel ComIK 0;\n// Cloud User share secret channel\nchannel ComUK 0;\n// Fake Cloud User share secret channel\nchannel FakeUK 0;\n// Fake Cloud Instance share secret channel\nchannel FakeIK 0;\n// Intruder fake user and cks\nchannel FakeUS 0;\n// intruder fake cloud instance and cks\nchannel FakeIS 0;\n// intruder and user\nchannel FakeU 0;\n// Intruder and cloud instance\nchannel FakeI 0;\n\nvar purci_get = false;\nvar comkey_cu_get = false;\nvar fakekey_cu_get = false;\nvar fakekey_ci_get = false;\nvar comkey_ci_get = false;\nvar purcu_get=false;\nvar putci_get=false;\nvar putcu_get=false;\nvar req_payload_get=false;\nvar res_payload_get=false;\nvar purci_fake_get=false;\nvar purcu_fake_get=false;\nvar completement = false;\nvar user_fake_success=false;\nvar server_fake_success=false;\nvar instance_fake_success=false;\n\n\n/*\nPUCKS public key for cks\nPRCKS private key for cks\nPURCU public root key cloud user\nPRRCU private root key cloud user\nPRTCUR private temporary cloud user(RSA)\nPUTCUR public temporary cloud user(RSA)\nPUTCUD public temporary cloud user(RSA)(DH)\n\nPURCI public root key cloud instance\nPRRCI private root key cloud instance\nPRTCIR private temporary cloud instance(RSA)\nPUTCIR public temporary cloud instance(RSA)\nPUTCID public temporary cloud instance(DH)\n*/\nenum{req_ci_rk,req_cu_rk};\nenum{pucks,purcu,putcur,purci,putcir,putcid,putcud,pri,purci_fake,purcu_fake};\nenum{prcks,prrcu,prtcur,prrci,prtcir,prtcid,prtcud,pui};\nenum{fakekey,comkey};\nenum{req_payload,res_payload,pub_payload,ack_payload};\n\n\n#define getpurci(PRCKS,PUCKS)\n{\n\tif(PRCKS==PUCKS){\n\t\tpurci_get=true;\n\t\t}\n\telse{\n\t\tpurci_get=false;\t\n\t};\n};\n\n#define getfakepurci(PRCKS,PUCKS)\n{\n\tif(PRCKS==PUCKS){\n\t\tpurci_fake_get=true;\n\t\t}\n\telse{\n\t\tpurci_fake_get=false;\t\n\t};\n};\n#define getfakepurcu(PRCKS,PUCKS)\n{\n\tif(PRCKS==PUCKS){\n\t\tpurcu_fake_get=true;\n\t\t}\n\telse{\n\t\tpurcu_fake_get=false;\t\n\t};\n};\n\n#define getpurcu(PRCKS,PUCKS){\n\tif(PRCKS==PUCKS){\n\t\tpurcu_get=true;\n\t\t}\n\telse{\n\t\tpurcu_get=false;\n\t\t};\n};\n#define getputci(PRRCI,PURCI){\n\tif(PURCI==PRRCI){\n\t\tputci_get=true;\n\t\t}else{\n\t\tputci_get=false;\n\t\t};\n};\n\n#define getputcu(PRRCU,PURCU){\n\tif(PURCU==PRRCU){\n\t\tputcu_get=true;\n\t\t}else{\n\t\tputcu_get=false;\n\t\t};\n};\n#define getcucomkey(PUTCID,PUTCID_1,PUTCUD,PUTCUD_1,PRTCD,PRTCUD){\n\tif(PUTCID==PUTCID_1&&PUTCUD==PUTCUD_1&&(PRTCD==PRTCUD)){\n\t\tcomkey_cu_get=true;\n\t  };\n};\n#define getcicomkey(PUTCID,PUTCID_1,PUTCUD,PUTCUD_1,PRTCD,PRTCID){\n\tif(PUTCID==PUTCID_1&&PUTCUD==PUTCUD_1&&(PRTCD==PRTCID)){\n\t\tcomkey_ci_get=true;\n\t  };\n};\n#define getcufakekey(PUTCID,PUTCID_1,PUTCUD,PUTCUD_1,PRTCD,PRTCID){\n\tif(PUTCID==PUTCID_1&&PUTCUD==PUTCUD_1&&(PRTCD==PRTCID)){\n\t\tfakekey_cu_get=true;\n\t  };\n};\n#define getcifakekey(PUTCID,PUTCID_1,PUTCUD,PUTCUD_1,PRTCD,PRTCID){\n\tif(PUTCID==PUTCID_1&&PUTCUD==PUTCUD_1&&(PRTCD==PRTCID)){\n\t\tfakekey_ci_get=true;\n\t  };\n};\n\n#define getresdata(PUTCUR,COM_KEY_CU,PUTCUR_1,COM_KEY_CI){\n\tif(PUTCUR==PUTCUR_1&&COM_KEY_CU==COM_KEY_CI)\n\t\t{\n\t\t\tres_payload_get=true;\n\t\t}\n\t\telse{\n\t\t\tres_payload_get=false;\n\t\t}\n};\n\n#define getreqdata(PUTCUR,COM_KEY_CU,PUTCUR_1,COM_KEY_CI){\n\tif(PUTCUR==PUTCUR_1&&COM_KEY_CU==COM_KEY_CI)\n\t\t{\n\t\t\treq_payload_get=true;\n\t\t}else{\n\t\t\treq_payload_get=false;\n\t\t}\n};",
        "path": "handwrite/Graphene.csp"
    },
    {
        "name": "HDFS",
        "tags": [
            "Protocol",
            "Distrubuted System",
            "Attacker"
        ],
        "use_non_container_lib": false,
        "description": "HDFS provides distributed storage for huge amounts of data. It can read and write data at high transmission rate in the form of data flow in the applications which possess big data sets. \n  From the aspect of architecture, HDFS has typical master-slave structure in which it has a single master called NameNode and multiple salve nodes called DataNode.",
        "pat_code": "//Model1\nchannel ComCN1 0;\nchannel ComCN2 0;\nchannel ComNC 0;\nchannel ComCD1 0;\nchannel ComD1C 0;\nchannel ComD1D2 0;\nchannel ComD2D1 0;\nchannel ComD2C 0;\nchannel ComCD2 0;\nchannel FakeCN1 0;\nchannel FakeCN2 0;\nchannel InterceptNC 0;\nchannel FakeCD1 0;\nchannel InterceptD1C 0;\nchannel FakeCD2 0;\nchannel InterceptD2C 0;\nchannel FakeNC 0;\nchannel InterceptCN1 0;\nchannel InterceptCN2 0;\nchannel InterceptCD1 0;\nchannel FakeD1C 0;\nchannel FakeD2C 0;\nchannel InterceptCD2 0;\nenum {req_write,req_read,req_data,data,complete,ack,DNs};\nvar client_fake_success=false;\nvar namenode_fake_success=false;\nvar datanode_fake_success=false;\n\n/*@Process: CLIENT\nThe client can initiate either a write request or a read request.\n  - For write request, it can send a genuine write request to the Namenode, and receives the responses of DataNodes, then transitions to CLIENT1.\n  - For read requests: it can send a genuine read request and receives the responses of DataNodes, proceeds to CLIENT2.\n  - (Attacker) Or, the attacker can fake the client sending a fake write or read request to Namenode via the fake channel and intercept the responses from the Namenode and proceeds accordingly.\n  - (Attacker) Or, the attacker can intercept the read or write request and send it to a fake NameNode via fake channel.\n*/\nCLIENT()=(\n\t\t   (FakeCN1!req_write{client_fake_success=true}->InterceptNC?DNS->CLIENT1())\n         [](FakeCN2!req_read{client_fake_success=true}->InterceptNC?DNS->CLIENT2()) //FakeClient\n         [](ComCN1!req_write->ComNC?DNS->CLIENT1())\n         [](ComCN2!req_read->ComNC?DNS->CLIENT2()) //Client\n         [](InterceptCN1!req_write->FakeNC?DNS->CLIENT1())\n         [](InterceptCN2!req_read->FakeNC?DNS->CLIENT2()));\n\n/*@Process: CLIENT1\n  CLIENT1 handles the writing of data:\n  - It sends a genuine data write request to the DataNode and receives the responses from the DataNode.\n  - (Attacker)Or, the attacker can fake the client sending a fake data write request via the fake channel and intercept the responses.\n  - (Attacker)Or, an attacker can intercept the data write request and send it to a fake DataNode via fake channel.\n  \n*/\nCLIENT1()=(\n           (FakeCD2!req_data{client_fake_success=true}->InterceptD2C?DATA->CLIENT()) //FakeClient\n         [](ComCD2!req_data->ComD2C?DATA->CLIENT()) //Client\n         [](InterceptCD2!req_data->FakeD2C?DATA->CLIENT())); //Client2Fake\n       \n/*@Process: CLIENT2\n  CLIENT2 handles the reading of data:\n  - It sends a genuine data read request to the DataNode and receives the responses from the DataNode and sends the complete signal to the NameNode.\n  - (Attacker)Or, the attacker can fake the client sending a fake data read request via the fake channel and intercept the responses and sends the complete signal to the NameNode via fake channel.\n  - (Attacker)Or, an attacker can intercept the data read request and send it to a fake DataNode via fake channel and intercept the complete signal to the NameNode.\n*/\nCLIENT2()=(\n           (FakeCD1!data{client_fake_success=true}->InterceptD1C?ACK-> FakeCN1!complete{client_fake_success=true}->CLIENT()) //FakeClient\n         [](ComCD1!data->ComD1C?ACK->ComCN1!complete->CLIENT()) //Client\n         [](InterceptCD1!data->FakeD1C?ACK->InterceptCN1!complete->CLIENT())); //Client2Fake\n\n/*@Process: NAMENODE\n  The NAMENODE process manages the metadata of the file system:\n  - (Attacker)It may receive a intercepted write request and send datanode address to a fake datanode and receives a completion signal.\n  - (Attacker)It may receive a intercepted read request and send datanode address to a fake datanode.\n  - It can receive a genuine write request and send datanode address to a client and receives a completion signal.\n  - It can receive a genuine read request  and send datanode address to a client.\n  - It can receive a fake write request and send datanode address to the attacker, and receivs a completion signal from the attacker.\n  - It can receive a fake read request and send datanode address to the attacker.\n\n*/\nNAMENODE()=(\n             InterceptCN1?REQ->FakeNC!DNs{namenode_fake_success=true}->InterceptCN1?COMPLETE->NAMENODE()\n           []InterceptCN2?REQ_READ->FakeNC!DNs{namenode_fake_success=true}->NAMENODE() //FakeNameNode\n           []ComCN1?REQ->ComNC!DNs->ComCN1?COMPLETE->NAMENODE()\n           []ComCN2?REQ_READ->ComNC!DNs->NAMENODE() //NameNode\n\t\t   []FakeCN1?REQ->InterceptNC!DNs->FakeCN1?COMPLETE->NAMENODE() \n           []FakeCN2?REQ_READ->InterceptNC!DNs->NAMENODE());\n    \n/*@Process: DATANODE1\n  DATANODE1 handles the read request from the client:\n  - (Attacker)It can receive intercepted data, forward it to DATANODE2, receive acknowledgement from DATANODE2, and send acknowledgement to the fake client.\n  - It can receive genuine data, forward it to DATANODE2, receive acknowledgement from DATANODE2, and send acknowledgement to the genuine client.\n  - It can receive fake data, forward it to DATANODE2, receive acknowledgement from DATANODE2, and send acknowledgement to the attacker.\n*/\nDATANODE1()=(\n\t\t\tInterceptCD1?DATA->ComD1D2!data->ComD2D1?ACK->FakeD1C!ack{datanode_fake_success=true}->DATANODE1() //FakeDataNode\n\t\t  []ComCD1?DATA->ComD1D2!data->ComD2D1?ACK->ComD1C!ack->DATANODE1() //DataNode\n\t\t  []FakeCD1?DATA->ComD1D2!data->ComD2D1?ACK->InterceptD1C!ack->DATANODE1()); //DataNode2Fake\n\n/*@Process: DATANODE2 \nDATANODE2 handles the write request from the client or from the DATANODE1:\n  - (Attacker)It can receive a intercepted data request from the attacker and send the requested data to a faked client.\n  - It can receive a genuine data request and send the requested data to the client.\n  - It can receive data from DATANODE1, send an acknowledgement back to DATANODE1\n  - It can receive a fake data request and send the requested data to the attacker.\n*/\nDATANODE2()=(\n            (InterceptCD2?REQ_DATA->FakeD2C!data{datanode_fake_success=true}->DATANODE2()) //FakeDataNode\n          [](ComCD2?REQ_DATA->ComD2C!data->DATANODE2()) //DataNode\n          [](ComD1D2?DATA->ComD2D1!ack->DATANODE2())\n          [](FakeCD2?REQ_DATA->InterceptD2C!data->DATANODE2())); //DataNode2Fake\n          \n/*@Process: SYSTEM\n  The system consists of a client, a Namenode, and two Datanodes (DATANODE1 and DATANODE2) executing in parallel.\n*/\nSYSTEM()=CLIENT()||NAMENODE()||DATANODE1()||DATANODE2();",
        "property_desc": [
            "The intruder has successfully pretended to be a legal Client.",
            "The intruder has successfully pretended to be a legal NameNode.",
            "The intruder has successfully pretended to be a legal DataNode.",
            "The system is deadlock-free."
        ],
        "properties": [
            "#define Client_Fake_Success client_fake_success==true;\n#define NameNode_Fake_Success namenode_fake_success==true;\n#define DataNode_Fake_Success datanode_fake_success==true;\n#assert SYSTEM() reaches Client_Fake_Success;",
            "#assert SYSTEM() reaches NameNode_Fake_Success;",
            "#assert SYSTEM() reaches DataNode_Fake_Success;",
            "#assert SYSTEM() deadlockfree;"
        ],
        "processes": [
            {
                "name": "CLIENT",
                "description": "The client can initiate either a write request or a read request.\n  - For write request, it can send a genuine write request to the Namenode, and receives the responses of DataNodes, then transitions to CLIENT1.\n  - For read requests: it can send a genuine read request and receives the responses of DataNodes, proceeds to CLIENT2.\n  - (Attacker) Or, the attacker can fake the client sending a fake write or read request to Namenode via the fake channel and intercept the responses from the Namenode and proceeds accordingly.\n  - (Attacker) Or, the attacker can intercept the read or write request and send it to a fake NameNode via fake channel.",
                "pat_code": "CLIENT()=(\n\t\t   (FakeCN1!req_write{client_fake_success=true}->InterceptNC?DNS->CLIENT1())\n         [](FakeCN2!req_read{client_fake_success=true}->InterceptNC?DNS->CLIENT2()) //FakeClient\n         [](ComCN1!req_write->ComNC?DNS->CLIENT1())\n         [](ComCN2!req_read->ComNC?DNS->CLIENT2()) //Client\n         [](InterceptCN1!req_write->FakeNC?DNS->CLIENT1())\n         [](InterceptCN2!req_read->FakeNC?DNS->CLIENT2()));"
            },
            {
                "name": "CLIENT1",
                "description": "CLIENT1 handles the writing of data:\n  - It sends a genuine data write request to the DataNode and receives the responses from the DataNode.\n  - (Attacker)Or, the attacker can fake the client sending a fake data write request via the fake channel and intercept the responses.\n  - (Attacker)Or, an attacker can intercept the data write request and send it to a fake DataNode via fake channel.",
                "pat_code": "CLIENT1()=(\n           (FakeCD2!req_data{client_fake_success=true}->InterceptD2C?DATA->CLIENT()) //FakeClient\n         [](ComCD2!req_data->ComD2C?DATA->CLIENT()) //Client\n         [](InterceptCD2!req_data->FakeD2C?DATA->CLIENT())); //Client2Fake"
            },
            {
                "name": "CLIENT2",
                "description": "CLIENT2 handles the reading of data:\n  - It sends a genuine data read request to the DataNode and receives the responses from the DataNode and sends the complete signal to the NameNode.\n  - (Attacker)Or, the attacker can fake the client sending a fake data read request via the fake channel and intercept the responses and sends the complete signal to the NameNode via fake channel.\n  - (Attacker)Or, an attacker can intercept the data read request and send it to a fake DataNode via fake channel and intercept the complete signal to the NameNode.",
                "pat_code": "CLIENT2()=(\n           (FakeCD1!data{client_fake_success=true}->InterceptD1C?ACK-> FakeCN1!complete{client_fake_success=true}->CLIENT()) //FakeClient\n         [](ComCD1!data->ComD1C?ACK->ComCN1!complete->CLIENT()) //Client\n         [](InterceptCD1!data->FakeD1C?ACK->InterceptCN1!complete->CLIENT())); //Client2Fake"
            },
            {
                "name": "NAMENODE",
                "description": "The NAMENODE process manages the metadata of the file system:\n  - (Attacker)It may receive a intercepted write request and send datanode address to a fake datanode and receives a completion signal.\n  - (Attacker)It may receive a intercepted read request and send datanode address to a fake datanode.\n  - It can receive a genuine write request and send datanode address to a client and receives a completion signal.\n  - It can receive a genuine read request  and send datanode address to a client.\n  - It can receive a fake write request and send datanode address to the attacker, and receivs a completion signal from the attacker.\n  - It can receive a fake read request and send datanode address to the attacker.",
                "pat_code": "NAMENODE()=(\n             InterceptCN1?REQ->FakeNC!DNs{namenode_fake_success=true}->InterceptCN1?COMPLETE->NAMENODE()\n           []InterceptCN2?REQ_READ->FakeNC!DNs{namenode_fake_success=true}->NAMENODE() //FakeNameNode\n           []ComCN1?REQ->ComNC!DNs->ComCN1?COMPLETE->NAMENODE()\n           []ComCN2?REQ_READ->ComNC!DNs->NAMENODE() //NameNode\n\t\t   []FakeCN1?REQ->InterceptNC!DNs->FakeCN1?COMPLETE->NAMENODE() \n           []FakeCN2?REQ_READ->InterceptNC!DNs->NAMENODE());"
            },
            {
                "name": "DATANODE1",
                "description": "DATANODE1 handles the read request from the client:\n  - (Attacker)It can receive intercepted data, forward it to DATANODE2, receive acknowledgement from DATANODE2, and send acknowledgement to the fake client.\n  - It can receive genuine data, forward it to DATANODE2, receive acknowledgement from DATANODE2, and send acknowledgement to the genuine client.\n  - It can receive fake data, forward it to DATANODE2, receive acknowledgement from DATANODE2, and send acknowledgement to the attacker.",
                "pat_code": "DATANODE1()=(\n\t\t\tInterceptCD1?DATA->ComD1D2!data->ComD2D1?ACK->FakeD1C!ack{datanode_fake_success=true}->DATANODE1() //FakeDataNode\n\t\t  []ComCD1?DATA->ComD1D2!data->ComD2D1?ACK->ComD1C!ack->DATANODE1() //DataNode\n\t\t  []FakeCD1?DATA->ComD1D2!data->ComD2D1?ACK->InterceptD1C!ack->DATANODE1()); //DataNode2Fake"
            },
            {
                "name": "DATANODE2",
                "description": "DATANODE2 handles the write request from the client or from the DATANODE1:\n  - (Attacker)It can receive a intercepted data request from the attacker and send the requested data to a faked client.\n  - It can receive a genuine data request and send the requested data to the client.\n  - It can receive data from DATANODE1, send an acknowledgement back to DATANODE1\n  - It can receive a fake data request and send the requested data to the attacker.",
                "pat_code": "DATANODE2()=(\n            (InterceptCD2?REQ_DATA->FakeD2C!data{datanode_fake_success=true}->DATANODE2()) //FakeDataNode\n          [](ComCD2?REQ_DATA->ComD2C!data->DATANODE2()) //DataNode\n          [](ComD1D2?DATA->ComD2D1!ack->DATANODE2())\n          [](FakeCD2?REQ_DATA->InterceptD2C!data->DATANODE2())); //DataNode2Fake"
            },
            {
                "name": "SYSTEM",
                "description": "The system consists of a client, a Namenode, and two Datanodes (DATANODE1 and DATANODE2) executing in parallel.",
                "pat_code": "SYSTEM()=CLIENT()||NAMENODE()||DATANODE1()||DATANODE2();"
            }
        ],
        "global_definition": "//Model1\nchannel ComCN1 0;\nchannel ComCN2 0;\nchannel ComNC 0;\nchannel ComCD1 0;\nchannel ComD1C 0;\nchannel ComD1D2 0;\nchannel ComD2D1 0;\nchannel ComD2C 0;\nchannel ComCD2 0;\nchannel FakeCN1 0;\nchannel FakeCN2 0;\nchannel InterceptNC 0;\nchannel FakeCD1 0;\nchannel InterceptD1C 0;\nchannel FakeCD2 0;\nchannel InterceptD2C 0;\nchannel FakeNC 0;\nchannel InterceptCN1 0;\nchannel InterceptCN2 0;\nchannel InterceptCD1 0;\nchannel FakeD1C 0;\nchannel FakeD2C 0;\nchannel InterceptCD2 0;\nenum {req_write,req_read,req_data,data,complete,ack,DNs};\nvar client_fake_success=false;\nvar namenode_fake_success=false;\nvar datanode_fake_success=false;",
        "path": "handwrite/HDFS.csp"
    },
    {
        "name": "ICC",
        "tags": [
            "Protocol"
        ],
        "use_non_container_lib": true,
        "description": "The ICC mechanism is the mechanism in Android that allows components to communicate with each other, and is the key for apps to communicate with each other.\n  In an Android app, the four main components that are its main logical units are the activity, the service, the broadcast receiver, and the content provider.\n  The ICC mechanism consists of two parts, one for Intra-App Communication (IAC) and the other for Inter-App Communication (IAC). \n  In this model, ICC will be used to refer to these two cases, while IAC will be used to refer to the latter case.",
        "pat_code": "#import \"Intent\";\n#import \"RegisterTable\";\n\n#define N 2;\n#define MM 2;\nvar M[N]=[2,2];\nvar a[N]=[0,0];\nvar b[N]=[0,0];\nvar c[N]=[0,0];\nvar d[N]=[0,0];\nvar xR;\nvar xU;\nvar xM;\n\nenum{install,uninstall,start,terminate};\nenum{success,fail};\nenum{Msg1,Msg2,Msg3,Msg4};\nenum{SRC_APP,SRC_AS,ac0,ac1};\nenum{startAc,processData,retData};\n\nchannel C_Operation[N] 0;\nchannel C_Show[N] 0;\nchannel C_Register[N] 0;\nchannel C_Unregister[N] 0;\nchannel Ret_AS[N] 0;\nchannel Com_APP_To_Ac[N*MM] 0;\nchannel Ret_Ac[N*MM] 0;\nchannel Com_Ac_To_Ac[N*MM*MM]0;\nchannel Com_Ac_To_AS[N*MM] 0;\nchannel Com_AS_To_Ac[N*MM] 0;\n\nvar userMsg =0;\nvar intruderMsg =0;\nvar msgTemp=0;\nvar <Intent> intentTemp =new Intent(0,0,0,0,0);\nvar <RegisterTable> rt =new RegisterTable();\nvar ac[N]=[ac0,ac1];\nvar userCMD[N]=[install,install];\n\n#define process(data,ID){\n msgTemp=data*10+ID;\n };\n \n/*@Process: User\n  The User process can both send commands to and receive messages from the APPs process.\n  Therefore, we define two processes, Send and Rec.\n  The User process runs either the Send process or the Rec process at the discretion of the environment, and the choice is repeated over and over again.\n*/\nUser()=Send;User()[]Rec;User();\n/*@Process: Send\n  The Send process can send commands to each APP process through multiple channels C_Operarioni, i denotes the number of APP in the system;\n*/\n Send =[]i :{0..N-1}@(C_Operation[i]!userCMD[i]->nxtCMD{userCMD[i]=(userCMD[i]+1)%4}->Skip);\n/*@Process: Rec\n  The Rec process receives messages from each APPs process via multiple channels C_Showi.\n*/\n Rec =[]i :{0..N-1}@(C_Show[i]?msg -> rec{userMsg =msg}->Skip);\n \n/*@Process: Apps\n  APPs are the parallel results of all APPi and n is the number of APP processes in the model.\n  The app in the model only has the functions of sending data, receiving data and processing data.\n  And it also only has five states: initial, installed, installed, running and uninstalled.\n*/\nAPPs()=||i :{0..N-1}@APP(i);\n/*@Process: App\n  When the APP process is in the initial state, it can receive the installation command from User through channel C_Operationi and send the registration request to the AS process using channel C_Registeri, and then enter the state of installation in progress.\n  APP(i) denotes that the ith APP process is in the initial state, in which it listens for messages on the C_Operationi channel, and if it receives an instruction to install, it sends a registration message to the AS process via the channel C_Registeri and runs APP1(i).\n*/\nAPP(i)= C_Operation[i]?cmd -> if(cmd==install){C_Register[i]!a[i].b[i].c[i].d[i]->APP1(i)}\n \t\t\t\t\t\t\t\telse{Stop};\n/*@Process: APP1\n  APP1(i) indicates that the ith APP process is in the installing state, in which it listens for messages on the channel Ret_ASi and sends them to the User process via C_Showi. Meanwhile, if the return message is SUCCESS, run APP2(i), otherwise run APP(i).\n*/\nAPP1(i)=Ret_AS[i]?ret ->C_Show[i]!ret -> if (ret ==success){APP2(i)}\n \t\t\t\t\t\t\t\t\t\t\telse{APP(i)};\n/*@Process: APP2\n  APP2(i) means the ith APP process is in the installation completion state, in this state it will listen to the C_Operationi channel, if the received instruction is start, it will send the startup intent to its MainActivity through the channel Com_App_to_Ac(i,0), and then run the APP3(i);\n  If the received instruction is uninstall, it will run APP4(i).\n*/\n APP2(i) = C_Operation[i]?cmd -> if (cmd==start){\n \t\t\t\t\t\t\t\t\tatomic{startI{intentTemp = new Intent(0,i*MM+0,startAc,1*MM+1,5)}->Com_APP_To_Ac[i*MM+0]!Msg1.intentTemp ->Skip};App3(i)}\n \t\t\t\t\t\t\t\telse if (cmd ==uninstall){\n \t\t\t\t\t\t\t\t\tC_Unregister[i]!a[i]-> App4(i)}\n \t\t\t\t\t\t\t\telse{Stop};\n/*@Process: App3\n  APP3(i) denotes that the ith APP process is in the running state, which first listens for messages on the channel Ret_Ac(i,j) and sends them to the User process via C_Showi. \n  Then, if it continues to receive messages on channel Ret_Ac(i,j), it repeats the above actions until it receives an instruction from the User on channel C_Operationi. \n  If the instruction is terminate, run APP2(i), otherwise run APP3(i).\n*/\nApp3(i) = []j:{0..MM}@Ret_Ac[i*MM+j]?msg->C_Show[i]!msg->\n\t\t\t(App3(i)[]C_Operation[i]?cmd->(if(cmd==terminate){APP2(i)}else{App3(i)}));\n/*@Process: App4\n  APP4(i) indicates that the ith APP process is in the unloading-in-progress state, in which it listens for messages on the channel Ret_AS(i) and sends the messages to the User process via C_Showi. \n  Meanwhile, if the return message is SUCCESS, run APP(i), otherwise run APP2(i).\n*/\nApp4(i) = Ret_AS[i]?ret->C_Show[i]!ret->\n\t\t\tif(ret==success){APP(i)}else{APP2(i)};\n\n/*@Process: Activities\n  In the model, we simplify the lifecycle of an activity into two states, the initial state and the running state, and the function of the activity is retained only to process data.\n  Activities is the parallel result of all Activity(i,j), n is the number of APPs in the model, MM is the number of Activity in the ith APP.\n*/\nActivities()=||i :{0..N-1}; j :{0..MM-1}@Activity(i,j);\n/*@Process: Activity\n  Activity(i,j) denotes that the jth Activity process in the ith APP process is in the initial state, and it will perform one of the following three behaviors depending on the environment. \n  If the intents marked with Msg1 on channel Com_APP_To_Ac(i,j) are received, run Activitiy1(i,j)(intent,SRC_APP);\n  If it receives any one of the intents labeled Msg2 on channel Com_Ac_To_Ac(i,k,j), run Activity1(i,j)(intent,ack), where k denotes the number of the Activity that started it in the APP; \n  if it receives the intents labeled Msg4 on channel Com_AS_To_Ac(i,j), run Activitiy1(i,j)(intent,SRC_AS); \n*/\nActivity(i, j)= ([]k :{0..MM-1}@(Com_Ac_To_Ac[i *MM*MM+k*MM+j]?Msg2.intent ->Activity1(i, j,intent,ac[k]))) [](Com_AS_To_Ac[i *MM+j]?Msg4.intent -> Activity1(i,j,intent,SRC_AS))[](Com_APP_To_Ac[i*MM+j]?Msg1.intent -> Activity1(i,j,intent,SRC_APP));\n/*@Process: Activity1\n  Activity1(i,j)(intent,src) denotes that the jth Activity in the ith APP is in running state, where the parameter intent denotes the intent that starts it, and the parameter src denotes the source of the intent. \n  It executes different behaviors according to the instructions contained in the intent. \n  If the instruction is to open Activity number k within the same app, it sends an intent2 labeled Msg2 through channel Com_Ac_to_Ac(i,j,k), which holds information for starting the next Activity, and then receives another intent from channel Com_Ac_to_Ac(i,k,j) labeled another intent3 of Msg2. \n  Then it runs Process(intent3), Ret(i,j)(intent,src,msg) and Activity(i,j) in turn. \n  If the instruction is to open an Activity under a different APP, it sends the information marked with Msg3 intent2 and wait for the return of the intent3 marked Msg4 by the channel Com_AS_to_Ac(i,j). \n  Then it will run Process(intent3), Ret(i,j)(intent,src,msg) and Activity(i,j) in sequence. \n  If the instruction is to process the data, then it will run directly in sequence Process(intent), Ret(i,j)(intent,src,msg) and Activity(i,j).\n*/\nActivity1(i, j,intent,src) = if (intent.getCmd()==startAc){\n \t\t\t\t\t\t\t\tif (intent.getTargetI() ==i){\n \t\t\t\t\t\t\t\t\tatomic{acI{intentTemp = new Intent(i*MM+j,intent.getTarget(),processData,0,intent.getData())}->Com_Ac_To_Ac[i*MM*MM+j*MM+intent.getTargetJ()]!Msg2.intentTemp ->Skip};\n\t\t\t\t\t\t\t\t\tCom_Ac_To_Ac[i*MM*MM+intent.getTargetJ()*MM+j]?Msg2.intent2->atomic{p{call(process,intent2.getData(),intent2.getDes())}->Ret(i, j,intent,src,msgTemp)};\n\t\t\t\t\t\t\t\t\tActivity(i, j)}\n\t\t\t\t\t\t\t\telse{\n \t\t\t\t\t\t\t\t\tatomic{acI2{intentTemp = new Intent(i*MM+j,intent.getTarget(),processData,0,intent.getData())}->Com_Ac_To_AS[i*MM+j]!Msg3.intentTemp->Skip};\n \t\t\t\t\t\t\t\t\tCom_AS_To_Ac[i*MM+j]?Msg4.intent2->atomic{p2{call(process,intent2.getData(),intent2.getDes())}->Ret(i, j,intent,src,msgTemp)};Activity(i, j)}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse if (intent.getCmd()==processData){\n \t\t\t\t\t\t\t\tatomic{p3{call(process,intent.getData(),intent.getDes())}->Ret(i, j,intent,src,msgTemp)};Activity(i, j)}\n \t\t\t\t\t\t\telse{Activity(i, j)};\n/*@Process: Ret\n  Ret(i,j,intent,src,msg) denotes that the jth Activity in the ith APP is returning the message msg, which performs different behaviors according to the parameter src respectively. \n  If src is APP, it returns msg directly through channel Ret_Ac(i,j). \n  If src is AS, it first creates an intent2 with msg information, and then sends intent2 tagged with Msg3 through channel Com_Ac_to_AS(i,j). \n  If src is Aci,k, then create an intent2 with msg message and send the intent2 tagged Msg2 via channel Com_Ac_to_Ac(i,j,k).\n*/\nRet(i, j,intent,src,msg)= if (src ==SRC_APP){\n \t\t\t\t\t\t\t\tRet_Ac[i*MM+j]!msg ->Skip}\n \t\t\t\t\t\t\telse if(src==SRC_AS){\n \t\t\t\t\t\t\t\tatomic{reI{intentTemp = new Intent(i*MM+j,intent.getSrc(),retData,0,msg)}->Com_Ac_To_AS[i*MM+j]!Msg3.intentTemp->Skip}}\n \t\t\t\t\t\t\telse{\n \t\t\t\t\t\t\t\tatomic{reI2{intentTemp = new Intent(i*MM+j,intent.getSrc(),retData,0,msg)}->Com_Ac_To_Ac[i*MM*MM+j*MM+(src-2)]!Msg2.intentTemp->Skip}};\n\n/*@Process: AS\n  Android is the basis and guarantee of the IAC mechanism. \n  On the one hand, it handles registration and deregistration requests to maintain the registry of the INTENT filter.\n  On the other hand, it sends the intents to the correct location by comparing the information in the intents with the registry.\n  Process AS consists of Register(), Unregister() and Matcher() running in parallel.\n*/\nAS()=Register()||Unregister()||Matcher();\n/*@Process: Register\n  Register receives registration requests from APPs processes through channel C_Registeri.\n  If the information is correct and not duplicated, it records them in the registry and returns a success message to the APPs process using channel Ret_ASi;\n  otherwise it returns a failure message and the registry is not updated.\n*/\nRegister() = []i : {0..N-1}@C_Register[i]?a1.b1.c1.d1->Register1(i,a1,b1,c1,d1);\n/*@Process: Register1\n  If the information is correct and not duplicated, it records them in the registry and returns a success message to the APPs process using channel Ret_ASi;\n  otherwise it returns a failure message and the registry is not updated.\n*/\nRegister1(i,a1,b1,c1,d1)= seR{xR=rt.search(a1,b1,c1,d1)}->if(xR==0){in{rt.insert(a1,b1,c1,d1)}->Ret_AS[i]!success->Register()}else{Ret_AS[i]!fail->Register()};\n/*@Process: Unregister\n  The Unregister process decides, based on its environment, to receive the message a on one of the channels C_Unregister[i] and then runs Unregister1(i,a).\n*/\nUnregister()=([]i :{0..N-1}@C_Unregister[i]?a1->Unregister1(i,a1));\n/*@Process: Unregister1\n  The Unregister1(i,appPackage) process first executes the action seU, which searches the registry rt to see if there is any data in the registry rt whose AppPackage attribute is equal to appPackage. \n  If there is, the process will execute the action de, which deletes all the corresponding data in the registry rt, and then sends a success message through the channel Ret_AS[i], and then executes the Unregister process. \n  If there is no corresponding data, the uninstallation fails and the process sends a fail message through channel Ret_AS[i] and then executes the Unregister process.\n*/\nUnregister1(i,appPackage)= seU{xU =rt.searchAppPackage(appPackage)}-> if (xU >0){de{rt.delete(appPackage)}->Ret_AS[i]!success->Unregister()}else{Ret_AS[i]!fail->Unregister()};\n/*@Process: Matcher\n  The Matcher process decides, based on the environment, to receive the intent with the Msg3 tag on channel Com_Ac_To_AS[id]. \n  It then runs the Matcher1(id,intent) process.\n*/\nMatcher()=([]id :{0..N*MM-1}@(Com_Ac_To_AS[id]?Msg3.intent->Matcher1(id,intent)));\n/*@Process: Matcher\n  The Matcher1(id,intent) process first performs the action seM, which searches the registry rt for the corresponding data based on the Action and Category within the intent.\n  If it matches the corresponding data, it executes the action ge and gets the ID of one of the data, and then according to the ID, it forwards the intent tagged with Msg4 to the corresponding component through the channel Com_AS_To_Ac[xM].\n  Finally, the Matcher process is run again. \n  If no match is found, a fail message is returned via channel Com_AS_To_Ac[id] and the Matcher process is run again.\n*/\nMatcher1(id,intent)=seM{xM =rt.searchActionAndCategory(intent.getAction(),intent.getCategory())}->\n\t\t\t\t\tif (xM >0){ge{xM =rt.getID(intent.getAction(),intent.getCategory())}->\n\t\t\t\t\t\tif (xM <N*MM){Com_AS_To_Ac[xM]!Msg4.intent->Matcher()}}\n \t\t\t\t\telse{Com_AS_To_Ac[id]!fail->Matcher()};\n\n/*@Process: System\n  The System process is run concurrently by processes User, Apps, Activities and AS.\n*/\nSystem()=User()|| APPs()|| Activities()|| AS();",
        "property_desc": [
            "The system is deadlock-free."
        ],
        "properties": [
            "#assert System() deadlockfree;"
        ],
        "processes": [
            {
                "name": "User",
                "description": "The User process can both send commands to and receive messages from the APPs process.\n  Therefore, we define two processes, Send and Rec.\n  The User process runs either the Send process or the Rec process at the discretion of the environment, and the choice is repeated over and over again.",
                "pat_code": "User()=Send;User()[]Rec;User();"
            },
            {
                "name": "Send",
                "description": "The Send process can send commands to each APP process through multiple channels C_Operarioni, i denotes the number of APP in the system;",
                "pat_code": "Send =[]i :{0..N-1}@(C_Operation[i]!userCMD[i]->nxtCMD{userCMD[i]=(userCMD[i]+1)%4}->Skip);"
            },
            {
                "name": "Rec",
                "description": "The Rec process receives messages from each APPs process via multiple channels C_Showi.",
                "pat_code": "Rec =[]i :{0..N-1}@(C_Show[i]?msg -> rec{userMsg =msg}->Skip);"
            },
            {
                "name": "Apps",
                "description": "APPs are the parallel results of all APPi and n is the number of APP processes in the model.\n  The app in the model only has the functions of sending data, receiving data and processing data.\n  And it also only has five states: initial, installed, installed, running and uninstalled.",
                "pat_code": "APPs()=||i :{0..N-1}@APP(i);"
            },
            {
                "name": "App",
                "description": "When the APP process is in the initial state, it can receive the installation command from User through channel C_Operationi and send the registration request to the AS process using channel C_Registeri, and then enter the state of installation in progress.\n  APP(i) denotes that the ith APP process is in the initial state, in which it listens for messages on the C_Operationi channel, and if it receives an instruction to install, it sends a registration message to the AS process via the channel C_Registeri and runs APP1(i).",
                "pat_code": "APP(i)= C_Operation[i]?cmd -> if(cmd==install){C_Register[i]!a[i].b[i].c[i].d[i]->APP1(i)}\n \t\t\t\t\t\t\t\telse{Stop};"
            },
            {
                "name": "APP1",
                "description": "APP1(i) indicates that the ith APP process is in the installing state, in which it listens for messages on the channel Ret_ASi and sends them to the User process via C_Showi. Meanwhile, if the return message is SUCCESS, run APP2(i), otherwise run APP(i).",
                "pat_code": "APP1(i)=Ret_AS[i]?ret ->C_Show[i]!ret -> if (ret ==success){APP2(i)}\n \t\t\t\t\t\t\t\t\t\t\telse{APP(i)};"
            },
            {
                "name": "APP2",
                "description": "APP2(i) means the ith APP process is in the installation completion state, in this state it will listen to the C_Operationi channel, if the received instruction is start, it will send the startup intent to its MainActivity through the channel Com_App_to_Ac(i,0), and then run the APP3(i);\n  If the received instruction is uninstall, it will run APP4(i).",
                "pat_code": "APP2(i) = C_Operation[i]?cmd -> if (cmd==start){\n \t\t\t\t\t\t\t\t\tatomic{startI{intentTemp = new Intent(0,i*MM+0,startAc,1*MM+1,5)}->Com_APP_To_Ac[i*MM+0]!Msg1.intentTemp ->Skip};App3(i)}\n \t\t\t\t\t\t\t\telse if (cmd ==uninstall){\n \t\t\t\t\t\t\t\t\tC_Unregister[i]!a[i]-> App4(i)}\n \t\t\t\t\t\t\t\telse{Stop};"
            },
            {
                "name": "App3",
                "description": "APP3(i) denotes that the ith APP process is in the running state, which first listens for messages on the channel Ret_Ac(i,j) and sends them to the User process via C_Showi. \n  Then, if it continues to receive messages on channel Ret_Ac(i,j), it repeats the above actions until it receives an instruction from the User on channel C_Operationi. \n  If the instruction is terminate, run APP2(i), otherwise run APP3(i).",
                "pat_code": "App3(i) = []j:{0..MM}@Ret_Ac[i*MM+j]?msg->C_Show[i]!msg->\n\t\t\t(App3(i)[]C_Operation[i]?cmd->(if(cmd==terminate){APP2(i)}else{App3(i)}));"
            },
            {
                "name": "App4",
                "description": "APP4(i) indicates that the ith APP process is in the unloading-in-progress state, in which it listens for messages on the channel Ret_AS(i) and sends the messages to the User process via C_Showi. \n  Meanwhile, if the return message is SUCCESS, run APP(i), otherwise run APP2(i).",
                "pat_code": "App4(i) = Ret_AS[i]?ret->C_Show[i]!ret->\n\t\t\tif(ret==success){APP(i)}else{APP2(i)};"
            },
            {
                "name": "Activities",
                "description": "In the model, we simplify the lifecycle of an activity into two states, the initial state and the running state, and the function of the activity is retained only to process data.\n  Activities is the parallel result of all Activity(i,j), n is the number of APPs in the model, MM is the number of Activity in the ith APP.",
                "pat_code": "Activities()=||i :{0..N-1}; j :{0..MM-1}@Activity(i,j);"
            },
            {
                "name": "Activity",
                "description": "Activity(i,j) denotes that the jth Activity process in the ith APP process is in the initial state, and it will perform one of the following three behaviors depending on the environment. \n  If the intents marked with Msg1 on channel Com_APP_To_Ac(i,j) are received, run Activitiy1(i,j)(intent,SRC_APP);\n  If it receives any one of the intents labeled Msg2 on channel Com_Ac_To_Ac(i,k,j), run Activity1(i,j)(intent,ack), where k denotes the number of the Activity that started it in the APP; \n  if it receives the intents labeled Msg4 on channel Com_AS_To_Ac(i,j), run Activitiy1(i,j)(intent,SRC_AS);",
                "pat_code": "Activity(i, j)= ([]k :{0..MM-1}@(Com_Ac_To_Ac[i *MM*MM+k*MM+j]?Msg2.intent ->Activity1(i, j,intent,ac[k]))) [](Com_AS_To_Ac[i *MM+j]?Msg4.intent -> Activity1(i,j,intent,SRC_AS))[](Com_APP_To_Ac[i*MM+j]?Msg1.intent -> Activity1(i,j,intent,SRC_APP));"
            },
            {
                "name": "Activity1",
                "description": "Activity1(i,j)(intent,src) denotes that the jth Activity in the ith APP is in running state, where the parameter intent denotes the intent that starts it, and the parameter src denotes the source of the intent. \n  It executes different behaviors according to the instructions contained in the intent. \n  If the instruction is to open Activity number k within the same app, it sends an intent2 labeled Msg2 through channel Com_Ac_to_Ac(i,j,k), which holds information for starting the next Activity, and then receives another intent from channel Com_Ac_to_Ac(i,k,j) labeled another intent3 of Msg2. \n  Then it runs Process(intent3), Ret(i,j)(intent,src,msg) and Activity(i,j) in turn. \n  If the instruction is to open an Activity under a different APP, it sends the information marked with Msg3 intent2 and wait for the return of the intent3 marked Msg4 by the channel Com_AS_to_Ac(i,j). \n  Then it will run Process(intent3), Ret(i,j)(intent,src,msg) and Activity(i,j) in sequence. \n  If the instruction is to process the data, then it will run directly in sequence Process(intent), Ret(i,j)(intent,src,msg) and Activity(i,j).",
                "pat_code": "Activity1(i, j,intent,src) = if (intent.getCmd()==startAc){\n \t\t\t\t\t\t\t\tif (intent.getTargetI() ==i){\n \t\t\t\t\t\t\t\t\tatomic{acI{intentTemp = new Intent(i*MM+j,intent.getTarget(),processData,0,intent.getData())}->Com_Ac_To_Ac[i*MM*MM+j*MM+intent.getTargetJ()]!Msg2.intentTemp ->Skip};\n\t\t\t\t\t\t\t\t\tCom_Ac_To_Ac[i*MM*MM+intent.getTargetJ()*MM+j]?Msg2.intent2->atomic{p{call(process,intent2.getData(),intent2.getDes())}->Ret(i, j,intent,src,msgTemp)};\n\t\t\t\t\t\t\t\t\tActivity(i, j)}\n\t\t\t\t\t\t\t\telse{\n \t\t\t\t\t\t\t\t\tatomic{acI2{intentTemp = new Intent(i*MM+j,intent.getTarget(),processData,0,intent.getData())}->Com_Ac_To_AS[i*MM+j]!Msg3.intentTemp->Skip};\n \t\t\t\t\t\t\t\t\tCom_AS_To_Ac[i*MM+j]?Msg4.intent2->atomic{p2{call(process,intent2.getData(),intent2.getDes())}->Ret(i, j,intent,src,msgTemp)};Activity(i, j)}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse if (intent.getCmd()==processData){\n \t\t\t\t\t\t\t\tatomic{p3{call(process,intent.getData(),intent.getDes())}->Ret(i, j,intent,src,msgTemp)};Activity(i, j)}\n \t\t\t\t\t\t\telse{Activity(i, j)};"
            },
            {
                "name": "Ret",
                "description": "Ret(i,j,intent,src,msg) denotes that the jth Activity in the ith APP is returning the message msg, which performs different behaviors according to the parameter src respectively. \n  If src is APP, it returns msg directly through channel Ret_Ac(i,j). \n  If src is AS, it first creates an intent2 with msg information, and then sends intent2 tagged with Msg3 through channel Com_Ac_to_AS(i,j). \n  If src is Aci,k, then create an intent2 with msg message and send the intent2 tagged Msg2 via channel Com_Ac_to_Ac(i,j,k).",
                "pat_code": "Ret(i, j,intent,src,msg)= if (src ==SRC_APP){\n \t\t\t\t\t\t\t\tRet_Ac[i*MM+j]!msg ->Skip}\n \t\t\t\t\t\t\telse if(src==SRC_AS){\n \t\t\t\t\t\t\t\tatomic{reI{intentTemp = new Intent(i*MM+j,intent.getSrc(),retData,0,msg)}->Com_Ac_To_AS[i*MM+j]!Msg3.intentTemp->Skip}}\n \t\t\t\t\t\t\telse{\n \t\t\t\t\t\t\t\tatomic{reI2{intentTemp = new Intent(i*MM+j,intent.getSrc(),retData,0,msg)}->Com_Ac_To_Ac[i*MM*MM+j*MM+(src-2)]!Msg2.intentTemp->Skip}};"
            },
            {
                "name": "AS",
                "description": "Android is the basis and guarantee of the IAC mechanism. \n  On the one hand, it handles registration and deregistration requests to maintain the registry of the INTENT filter.\n  On the other hand, it sends the intents to the correct location by comparing the information in the intents with the registry.\n  Process AS consists of Register(), Unregister() and Matcher() running in parallel.",
                "pat_code": "AS()=Register()||Unregister()||Matcher();"
            },
            {
                "name": "Register",
                "description": "Register receives registration requests from APPs processes through channel C_Registeri.\n  If the information is correct and not duplicated, it records them in the registry and returns a success message to the APPs process using channel Ret_ASi;\n  otherwise it returns a failure message and the registry is not updated.",
                "pat_code": "Register() = []i : {0..N-1}@C_Register[i]?a1.b1.c1.d1->Register1(i,a1,b1,c1,d1);"
            },
            {
                "name": "Register1",
                "description": "If the information is correct and not duplicated, it records them in the registry and returns a success message to the APPs process using channel Ret_ASi;\n  otherwise it returns a failure message and the registry is not updated.",
                "pat_code": "Register1(i,a1,b1,c1,d1)= seR{xR=rt.search(a1,b1,c1,d1)}->if(xR==0){in{rt.insert(a1,b1,c1,d1)}->Ret_AS[i]!success->Register()}else{Ret_AS[i]!fail->Register()};"
            },
            {
                "name": "Unregister",
                "description": "The Unregister process decides, based on its environment, to receive the message a on one of the channels C_Unregister[i] and then runs Unregister1(i,a).",
                "pat_code": "Unregister()=([]i :{0..N-1}@C_Unregister[i]?a1->Unregister1(i,a1));"
            },
            {
                "name": "Unregister1",
                "description": "The Unregister1(i,appPackage) process first executes the action seU, which searches the registry rt to see if there is any data in the registry rt whose AppPackage attribute is equal to appPackage. \n  If there is, the process will execute the action de, which deletes all the corresponding data in the registry rt, and then sends a success message through the channel Ret_AS[i], and then executes the Unregister process. \n  If there is no corresponding data, the uninstallation fails and the process sends a fail message through channel Ret_AS[i] and then executes the Unregister process.",
                "pat_code": "Unregister1(i,appPackage)= seU{xU =rt.searchAppPackage(appPackage)}-> if (xU >0){de{rt.delete(appPackage)}->Ret_AS[i]!success->Unregister()}else{Ret_AS[i]!fail->Unregister()};"
            },
            {
                "name": "Matcher",
                "description": "The Matcher process decides, based on the environment, to receive the intent with the Msg3 tag on channel Com_Ac_To_AS[id]. \n  It then runs the Matcher1(id,intent) process.",
                "pat_code": "Matcher()=([]id :{0..N*MM-1}@(Com_Ac_To_AS[id]?Msg3.intent->Matcher1(id,intent)));"
            },
            {
                "name": "Matcher",
                "description": "The Matcher1(id,intent) process first performs the action seM, which searches the registry rt for the corresponding data based on the Action and Category within the intent.\n  If it matches the corresponding data, it executes the action ge and gets the ID of one of the data, and then according to the ID, it forwards the intent tagged with Msg4 to the corresponding component through the channel Com_AS_To_Ac[xM].\n  Finally, the Matcher process is run again. \n  If no match is found, a fail message is returned via channel Com_AS_To_Ac[id] and the Matcher process is run again.",
                "pat_code": "Matcher1(id,intent)=seM{xM =rt.searchActionAndCategory(intent.getAction(),intent.getCategory())}->\n\t\t\t\t\tif (xM >0){ge{xM =rt.getID(intent.getAction(),intent.getCategory())}->\n\t\t\t\t\t\tif (xM <N*MM){Com_AS_To_Ac[xM]!Msg4.intent->Matcher()}}\n \t\t\t\t\telse{Com_AS_To_Ac[id]!fail->Matcher()};"
            },
            {
                "name": "System",
                "description": "The System process is run concurrently by processes User, Apps, Activities and AS.",
                "pat_code": "System()=User()|| APPs()|| Activities()|| AS();"
            }
        ],
        "global_definition": "#import \"Intent\";\n#import \"RegisterTable\";\n\n#define N 2;\n#define MM 2;\nvar M[N]=[2,2];\nvar a[N]=[0,0];\nvar b[N]=[0,0];\nvar c[N]=[0,0];\nvar d[N]=[0,0];\nvar xR;\nvar xU;\nvar xM;\n\nenum{install,uninstall,start,terminate};\nenum{success,fail};\nenum{Msg1,Msg2,Msg3,Msg4};\nenum{SRC_APP,SRC_AS,ac0,ac1};\nenum{startAc,processData,retData};\n\nchannel C_Operation[N] 0;\nchannel C_Show[N] 0;\nchannel C_Register[N] 0;\nchannel C_Unregister[N] 0;\nchannel Ret_AS[N] 0;\nchannel Com_APP_To_Ac[N*MM] 0;\nchannel Ret_Ac[N*MM] 0;\nchannel Com_Ac_To_Ac[N*MM*MM]0;\nchannel Com_Ac_To_AS[N*MM] 0;\nchannel Com_AS_To_Ac[N*MM] 0;\n\nvar userMsg =0;\nvar intruderMsg =0;\nvar msgTemp=0;\nvar <Intent> intentTemp =new Intent(0,0,0,0,0);\nvar <RegisterTable> rt =new RegisterTable();\nvar ac[N]=[ac0,ac1];\nvar userCMD[N]=[install,install];\n\n#define process(data,ID){\n msgTemp=data*10+ID;\n };",
        "path": "handwrite/ICC.csp"
    },
    {
        "name": "ICN-IoT",
        "tags": [
            "Protocol",
            "Attacker"
        ],
        "use_non_container_lib": false,
        "description": "ICN-IoT is an Internet of Things system based on information-centric network.\n  ICN-IoT has five roles: \n\t- Device: collects data from the environment and sends it to the aggregator.\n\t- Aggregator: responsible for receiving and processing data collected by the device.\n\t- User: subscribes to IoT services and obtain required data by communicating with the server.\n  - Server: manages user subscription requests according to the system's service subscription policy.\n  - Local Service Gateway: responsible for connecting the local IoT system to the global IoT system and assigning a network name to the device to identify it.",
        "pat_code": "channel ComDA 0; \nchannel ComAL 0; \nchannel ComSL 0;  \nchannel ComUS 0;  \nchannel FakeAD 0; \nchannel FakeDA 0; \nchannel FakeUS 0;  \nchannel FakeSU 0;\n\nenum{cerk,cern};\nenum{pukd,prkd};\nenum{puku,prku};\nenum{puki,prki};\nenum{req,data,ack};\nenum{akd,aku};\nenum{reqName,i,reqDname,reqS,reqkey,reqReg,d,pwd,reqData};\n\nvar data_available = false; \nvar key_leak = false;\nvar device_fake = false;\nvar\tuser_fake = false;\n\nvar key_get;\nvar cer_get;\nvar data_pub;\nvar is_legal;\nvar data_get;\nvar PWD;\n\n#define getKey(pu,pr){\n  if (pu==pr){\n    key_get=true;\n   }\n };\n \n#define getCer(akd1,key){ \n   if(akd1==key) {\n     cer_get=true;\n   }\n  };\n  \n#define getData(aku1,key){ if(aku1==key)\n{data_get=true;}\n};\n\n  \n#define pubData(pu,pr,akd1,key,cer,cern1){\n\tif (pu==pr&&akd1==key&&cer==cern1)\n\t{data_pub=true;}\n};\n\t\n#define modifyPWD(pwd1){\n \tPWD=pwd1+1;\n};\n\n#define isLegalUser(aku1,key,pu,pr){ if(aku1==key&&pu==pr)\n{is_legal =true;}\n};\n\n/*@Process: Device\n  The Device is responsible for collecting data in the environment and sending the data to the Aggregator. \n  The Device's behavior is as follows:\n    1.First, use the private key prkd to encrypt the device discovery request.\n    2.Send the request to the Aggregator.\n    3.Receive the encrypted message packet replied by the Aggregator.\n    4.Use the public key pukd to decrypt the message and obtain the session key akd.\n    5.Send a name request reqName to the Aggregator.\n    6.Use the session key akd to decrypt the message replied by the aggregator to obtain the name certificate cern.\n    7.Use session key akd to encrypt the data it collects and private key prkd to encrypt the name certificate cern.\n    8.Send the encrypted message to the Aggregator for data publishing.\n*/\nDevice()=ComDA!prkd.req.cerk->ComDA?prkd.akd{ \ncall(getKey,pukd,prkd)}->if(key_get==true){ComDA!reqName->  \nComDA?akd.cern{call(getCer,akd,akd)}->\nif(cer_get==true){ComDA!prkd.cern.akd.data->ComDA?ack->Device()}\nelse{fail->Device()}}else{fail->Device()}\n[]FakeDA!prki.req.cerk->FakeDA?prki.akd{call(getKey,puki,prki)}->\nif(key_get==true){FakeDA!reqName{key_leak=true}->FakeDA?akd.cern{\ncall(getCer,akd,akd)}->if(cer_get==true){FakeDA!prki.cern.akd.i->Device()} \nelse{fail->Device()}}else{fail->Device()};\n\n/*@Process: Aggregator\n  The Aggregator is responsible for processing device naming requests and receiving data published by the Device.\n  The Aggregator's behavior is as follows:\n    1.After receiving the discovery request from the device, the aggregator uses the device's public key pukd to decrypt the request.\n    2.After successful decryption, the aggregator allows the device to join the ICN-IoT system and encrypts the session key akd with the device private key prkd and distributes it to the device.\n    3.After receiving the device's name request reqName, it sends a name request reqDname to the local service gateway and obtains the name certificate cern assigned by the system to the device.\n    4.Encrypt the name certificate cern with the session key akd and send it to the device.\n    5.After receiving the data release message from the device, the aggregator first uses the device public key pukd to decrypt the message and obtain the device's name certificate cern.\n    6.The device's identity is verified based on the certificate. \n      -If the device is legitimate, the aggregator uses the decryption function to obtain the data published by the device. \n      -If the device fails to pass the verification, the aggregator discards the data publishing message.\n    7.After receiving the data request from the local service gateway, the aggregator sends the data to the local service gateway.\n \n*/\nAggregator()=ComDA?prkd.req.cerk{call(getKey,pukd,prkd)}-> \nif(key_get==true){ComDA!prkd.akd->ComDA?reqName->ComAL!reqDname-> \nComAL?cern->ComDA!akd.cern->ComDA?prkd.cern.akd.data{\ncall(pubData,prkd,pukd,akd,akd,cern,cern)}->\nif(data_pub==true){ComDA!ack->ComAL?reqData->\nComAL!data->Aggregator()}else{fail->Aggregator()}}else{fail->Aggregator()} \n[]FakeAD?prki.req.cerk{call(getKey,prki,puki)}->\nif(key_get==true){FakeAD!prki.akd->FakeAD?reqName->FakeAD!reqDname-> \nFakeAD?prki.cern.akd.i{call(pubData,prki,puki,akd,akd,cern,cern)}->\nif(data_pub==true){suc{device_fake=true}->Aggregator()} \nelse{fail->Aggregator()}}else{fail->Aggregator()};\n\n/*@Process: User\n  The User subscribes to IoT services and obtain the required environmental data by communicating with the server.\n  The User's behavior is as follows:\n    1.First, send a registration request reqReg to the server, and receive a temporary password pwd from the server.\n    2.The user changes the password and sends a key request reqKey to the server.\n    3.After receiving the encrypted message packet from the server, use the public key puku to decrypt the message and obtain the session key aku.\n    4.Use the private key prku to sign the service subscription request, then use the session key aku to encrypt the signed subscription request and send the encrypted message to the server.\n    5.After successfully subscribing to the IoT service, the encrypted message containing the environmental data can be decrypted using the session key aku to obtain the required data.\n*/\nUser()=ComUS!reqReg->ComUS?pwd{call(modifyPWD,pwd)}->\nComUS!reqkey->ComUS?prku.aku{call(getKey,aku,prku)}->\nif(key_get==true){ComUS!aku.prku.reqS->\nComUS?aku.d{call(getData,aku,aku)}->if(data_get==true)\n{suc{data_available =true}->User()}else{fail->User()}}else{fail->User()} \n[]FakeUS!reqReg->FakeUS?pwd{call(modifyPWD,pwd)}->FakeUS!reqkey->\nFakeUS?prki.aku{call(getKey,prki,puki)}->\nif(key_get==true){FakeUS!aku.prki.reqS{key_leak=true}->FakeUS?aku.d{ \ncall(getData,aku,aku)}->if(data_get==true){suc{user_fake=true}->User()}  \nelse{fail->User()}}else{fail->User()};\n\n/*@Process: Server\n  The Server subscribes to IoT services and obtain the required environmental data by communicating with the server.\n  The Server's behavior is as follows:\n    1.After receiving the user's registration request reqReg, assign a temporary password pwd to the user.\n    2.After receiving the user's key request reqKey, the server uses the user's private key prku to encrypt the session key aku, and then sends the encrypted message to the user.\n    3.After receiving the user's service subscription request, the server first uses the session key aku to decrypt the message, and then uses the user's public key puku to verify the user's signature to check whether the user's identity is legal.\n      -If the user is legitimate, the server allows the user to subscribe to the IoT service and requests the corresponding data from the local service gateway through the secure channel ComSL. The received data is then encrypted with the session key aku and sent to the user.\n      -If the user is illegal, the server rejects the user's subscription request.\n*/\nServer()=ComUS?reqReg->ComUS!pwd->ComUS?reqkey->\nComUS!prku.aku->ComUS?aku.prku.reqS{call(isLegalUser,aku,aku,puku,prku)}-> \nif(is_legal ==true){ComSL?reqdatas->\nComSL?data->ComUS!aku.d->Server()}else{fail->Server()}\n[]FakeSU?reqReg->FakeSU!pwd->FakeSU?reqkey->FakeSU!prki.aku->\nFakeSU?aku.prki.reqS{call(isLegalUser,aku,aku,puki,prki)}->\nif(is_legal ==true){FakeSU!aku.d{user_fake=true}->Server()} else{fail->Server()};\n\n/*@Process: LSG\n  The LSG is responsible for assigning network names to devices and forwarding environmental data collected by the devices to the server.\n  The LSG's behavior is as follows:\n    1.After receiving the name request reqDname from the aggregator process, the local service gateway process assigns a network name to the device, which will be used as the device's identification in the system.\n    2.The local service gateway sends the name certificate cern to the aggregator.\n    3.After receiving the data request req_data from the server, the local service gateway requests the corresponding data from the aggregator.\n    4.After receiving the data from the aggregator, forward the data to the server.\n*/\nLSG()=ComAL?reqDname->ComAL!cern->ComSL?reqdatas-> ComAL!reqData->ComAL?data->ComSL!data->LSG();\n\n/*@Process: Intruder\n  The model also introduces the intruder,it simulates the following attack behaviors\n    1.It can eavesdrop on or tamper with messages on ComDA and ComUS channels and make inferences, possibly deriving session keys for devices or users.\n    2.It can pretend to be a device or user and communicate with other entities through FakeDA, FakeAD, FakeUS and FakeSU channels..\n*/\nIntruder()=FakeDA?prki.req.cerk->FakeDA!prki.akd->\nFakeDA?reqName->FakeDA!akd.cern->FakeDA?prki.cern.akd.i->Intruder()\n[]FakeAD!prki.req.cerk->FakeAD?prki.akd->FakeAD!reqName-> FakeAD?akd.cern->FakeAD!prki.cern.akd.i->Intruder()\n[]FakeUS?reqReg->FakeUS!pwd->FakeUS?reqkey->FakeUS!prki.aku-> FakeUS?aku.prki.reqS->FakeUS!aku.d->Intruder()\n[]FakeSU!reqReg->FakeSU?pwd->FakeSU!reqkey->FakeSU?prku.aku-> FakeSU!aku.prki.reqS->FakeSU?aku.d->Intruder();\n\n/*@Process: System\n\tThe system comprises the following five entities: device, aggregator, local service gateway, server and user. Meanwhile, the model introduces a intruder.\n*/\nSystem()= Device()|| Aggregator()||LSG()||Server()||User()||Intruder();",
        "property_desc": [
            "The system is deadlock-free.",
            "Users can get subscribed data.",
            "The system will not have session key leakage issues.",
            "Intruders cannot disguise themselves as legitimate devices to attack the system.",
            "Intruders cannot disguise themselves as legitimate user to attack the system."
        ],
        "properties": [
            "#assert System() deadlockfree;",
            "#define\tData_Availability data_available ==false;\n#assert\tSystem() reaches Data_Availability;",
            "#define  ActionKeys_Leak_Success key_leak==false; \n#assert  System() |=[]! ActionKeys_Leak_Success;",
            "#define Device_Fake_Success  device_fake==false;\n#assert\t System()  |=[]!Device_Fake_Success;",
            "#define User_Fake_Success user_fake==false;\n#assert\t System() |=[]! User_Fake_Success;"
        ],
        "processes": [
            {
                "name": "Device",
                "description": "The Device is responsible for collecting data in the environment and sending the data to the Aggregator. \n  The Device's behavior is as follows:\n    1.First, use the private key prkd to encrypt the device discovery request.\n    2.Send the request to the Aggregator.\n    3.Receive the encrypted message packet replied by the Aggregator.\n    4.Use the public key pukd to decrypt the message and obtain the session key akd.\n    5.Send a name request reqName to the Aggregator.\n    6.Use the session key akd to decrypt the message replied by the aggregator to obtain the name certificate cern.\n    7.Use session key akd to encrypt the data it collects and private key prkd to encrypt the name certificate cern.\n    8.Send the encrypted message to the Aggregator for data publishing.",
                "pat_code": "Device()=ComDA!prkd.req.cerk->ComDA?prkd.akd{ \ncall(getKey,pukd,prkd)}->if(key_get==true){ComDA!reqName->  \nComDA?akd.cern{call(getCer,akd,akd)}->\nif(cer_get==true){ComDA!prkd.cern.akd.data->ComDA?ack->Device()}\nelse{fail->Device()}}else{fail->Device()}\n[]FakeDA!prki.req.cerk->FakeDA?prki.akd{call(getKey,puki,prki)}->\nif(key_get==true){FakeDA!reqName{key_leak=true}->FakeDA?akd.cern{\ncall(getCer,akd,akd)}->if(cer_get==true){FakeDA!prki.cern.akd.i->Device()} \nelse{fail->Device()}}else{fail->Device()};"
            },
            {
                "name": "Aggregator",
                "description": "The Aggregator is responsible for processing device naming requests and receiving data published by the Device.\n  The Aggregator's behavior is as follows:\n    1.After receiving the discovery request from the device, the aggregator uses the device's public key pukd to decrypt the request.\n    2.After successful decryption, the aggregator allows the device to join the ICN-IoT system and encrypts the session key akd with the device private key prkd and distributes it to the device.\n    3.After receiving the device's name request reqName, it sends a name request reqDname to the local service gateway and obtains the name certificate cern assigned by the system to the device.\n    4.Encrypt the name certificate cern with the session key akd and send it to the device.\n    5.After receiving the data release message from the device, the aggregator first uses the device public key pukd to decrypt the message and obtain the device's name certificate cern.\n    6.The device's identity is verified based on the certificate. \n      -If the device is legitimate, the aggregator uses the decryption function to obtain the data published by the device. \n      -If the device fails to pass the verification, the aggregator discards the data publishing message.\n    7.After receiving the data request from the local service gateway, the aggregator sends the data to the local service gateway.",
                "pat_code": "Aggregator()=ComDA?prkd.req.cerk{call(getKey,pukd,prkd)}-> \nif(key_get==true){ComDA!prkd.akd->ComDA?reqName->ComAL!reqDname-> \nComAL?cern->ComDA!akd.cern->ComDA?prkd.cern.akd.data{\ncall(pubData,prkd,pukd,akd,akd,cern,cern)}->\nif(data_pub==true){ComDA!ack->ComAL?reqData->\nComAL!data->Aggregator()}else{fail->Aggregator()}}else{fail->Aggregator()} \n[]FakeAD?prki.req.cerk{call(getKey,prki,puki)}->\nif(key_get==true){FakeAD!prki.akd->FakeAD?reqName->FakeAD!reqDname-> \nFakeAD?prki.cern.akd.i{call(pubData,prki,puki,akd,akd,cern,cern)}->\nif(data_pub==true){suc{device_fake=true}->Aggregator()} \nelse{fail->Aggregator()}}else{fail->Aggregator()};"
            },
            {
                "name": "User",
                "description": "The User subscribes to IoT services and obtain the required environmental data by communicating with the server.\n  The User's behavior is as follows:\n    1.First, send a registration request reqReg to the server, and receive a temporary password pwd from the server.\n    2.The user changes the password and sends a key request reqKey to the server.\n    3.After receiving the encrypted message packet from the server, use the public key puku to decrypt the message and obtain the session key aku.\n    4.Use the private key prku to sign the service subscription request, then use the session key aku to encrypt the signed subscription request and send the encrypted message to the server.\n    5.After successfully subscribing to the IoT service, the encrypted message containing the environmental data can be decrypted using the session key aku to obtain the required data.",
                "pat_code": "User()=ComUS!reqReg->ComUS?pwd{call(modifyPWD,pwd)}->\nComUS!reqkey->ComUS?prku.aku{call(getKey,aku,prku)}->\nif(key_get==true){ComUS!aku.prku.reqS->\nComUS?aku.d{call(getData,aku,aku)}->if(data_get==true)\n{suc{data_available =true}->User()}else{fail->User()}}else{fail->User()} \n[]FakeUS!reqReg->FakeUS?pwd{call(modifyPWD,pwd)}->FakeUS!reqkey->\nFakeUS?prki.aku{call(getKey,prki,puki)}->\nif(key_get==true){FakeUS!aku.prki.reqS{key_leak=true}->FakeUS?aku.d{ \ncall(getData,aku,aku)}->if(data_get==true){suc{user_fake=true}->User()}  \nelse{fail->User()}}else{fail->User()};"
            },
            {
                "name": "Server",
                "description": "The Server subscribes to IoT services and obtain the required environmental data by communicating with the server.\n  The Server's behavior is as follows:\n    1.After receiving the user's registration request reqReg, assign a temporary password pwd to the user.\n    2.After receiving the user's key request reqKey, the server uses the user's private key prku to encrypt the session key aku, and then sends the encrypted message to the user.\n    3.After receiving the user's service subscription request, the server first uses the session key aku to decrypt the message, and then uses the user's public key puku to verify the user's signature to check whether the user's identity is legal.\n      -If the user is legitimate, the server allows the user to subscribe to the IoT service and requests the corresponding data from the local service gateway through the secure channel ComSL. The received data is then encrypted with the session key aku and sent to the user.\n      -If the user is illegal, the server rejects the user's subscription request.",
                "pat_code": "Server()=ComUS?reqReg->ComUS!pwd->ComUS?reqkey->\nComUS!prku.aku->ComUS?aku.prku.reqS{call(isLegalUser,aku,aku,puku,prku)}-> \nif(is_legal ==true){ComSL?reqdatas->\nComSL?data->ComUS!aku.d->Server()}else{fail->Server()}\n[]FakeSU?reqReg->FakeSU!pwd->FakeSU?reqkey->FakeSU!prki.aku->\nFakeSU?aku.prki.reqS{call(isLegalUser,aku,aku,puki,prki)}->\nif(is_legal ==true){FakeSU!aku.d{user_fake=true}->Server()} else{fail->Server()};"
            },
            {
                "name": "LSG",
                "description": "The LSG is responsible for assigning network names to devices and forwarding environmental data collected by the devices to the server.\n  The LSG's behavior is as follows:\n    1.After receiving the name request reqDname from the aggregator process, the local service gateway process assigns a network name to the device, which will be used as the device's identification in the system.\n    2.The local service gateway sends the name certificate cern to the aggregator.\n    3.After receiving the data request req_data from the server, the local service gateway requests the corresponding data from the aggregator.\n    4.After receiving the data from the aggregator, forward the data to the server.",
                "pat_code": "LSG()=ComAL?reqDname->ComAL!cern->ComSL?reqdatas-> ComAL!reqData->ComAL?data->ComSL!data->LSG();"
            },
            {
                "name": "Intruder",
                "description": "The model also introduces the intruder,it simulates the following attack behaviors\n    1.It can eavesdrop on or tamper with messages on ComDA and ComUS channels and make inferences, possibly deriving session keys for devices or users.\n    2.It can pretend to be a device or user and communicate with other entities through FakeDA, FakeAD, FakeUS and FakeSU channels..",
                "pat_code": "Intruder()=FakeDA?prki.req.cerk->FakeDA!prki.akd->\nFakeDA?reqName->FakeDA!akd.cern->FakeDA?prki.cern.akd.i->Intruder()\n[]FakeAD!prki.req.cerk->FakeAD?prki.akd->FakeAD!reqName-> FakeAD?akd.cern->FakeAD!prki.cern.akd.i->Intruder()\n[]FakeUS?reqReg->FakeUS!pwd->FakeUS?reqkey->FakeUS!prki.aku-> FakeUS?aku.prki.reqS->FakeUS!aku.d->Intruder()\n[]FakeSU!reqReg->FakeSU?pwd->FakeSU!reqkey->FakeSU?prku.aku-> FakeSU!aku.prki.reqS->FakeSU?aku.d->Intruder();"
            },
            {
                "name": "System",
                "description": "The system comprises the following five entities: device, aggregator, local service gateway, server and user. Meanwhile, the model introduces a intruder.",
                "pat_code": "System()= Device()|| Aggregator()||LSG()||Server()||User()||Intruder();"
            }
        ],
        "global_definition": "channel ComDA 0; \nchannel ComAL 0; \nchannel ComSL 0;  \nchannel ComUS 0;  \nchannel FakeAD 0; \nchannel FakeDA 0; \nchannel FakeUS 0;  \nchannel FakeSU 0;\n\nenum{cerk,cern};\nenum{pukd,prkd};\nenum{puku,prku};\nenum{puki,prki};\nenum{req,data,ack};\nenum{akd,aku};\nenum{reqName,i,reqDname,reqS,reqkey,reqReg,d,pwd,reqData};\n\nvar data_available = false; \nvar key_leak = false;\nvar device_fake = false;\nvar\tuser_fake = false;\n\nvar key_get;\nvar cer_get;\nvar data_pub;\nvar is_legal;\nvar data_get;\nvar PWD;\n\n#define getKey(pu,pr){\n  if (pu==pr){\n    key_get=true;\n   }\n };\n \n#define getCer(akd1,key){ \n   if(akd1==key) {\n     cer_get=true;\n   }\n  };\n  \n#define getData(aku1,key){ if(aku1==key)\n{data_get=true;}\n};\n\n  \n#define pubData(pu,pr,akd1,key,cer,cern1){\n\tif (pu==pr&&akd1==key&&cer==cern1)\n\t{data_pub=true;}\n};\n\t\n#define modifyPWD(pwd1){\n \tPWD=pwd1+1;\n};\n\n#define isLegalUser(aku1,key,pu,pr){ if(aku1==key&&pu==pr)\n{is_legal =true;}\n};",
        "path": "handwrite/ICN-IoT.csp"
    },
    {
        "name": "Kafka",
        "tags": [
            "Protocol"
        ],
        "use_non_container_lib": false,
        "description": "Apache Kafka, developed by LinkedIn, is a distributed messaging system based on the publish-subscribe model.Kafka has the advantages of high throughput and high availability, and is very suitable for real-time computation in the field of big data, as well as log collection and other needs. \n  A typical Kafka messaging system contains multiple producers, multiple servers, and multiple consumer groups. \n  In a Kafka system, a producer publishes data to the master replica of each topic partition distributed on servers, a consumer subscribes to the data in the topic and consumes the data from the master replica of the corresponding partition of the subscribed topic in a \u201cpull\u201d mode, and there exists a coordinator for each consumer group who is responsible for load balancing among all members of the consumer group. \n  There is a coordinator for each consumer group who is responsible for the load balancing of all members of the consumer group.",
        "pat_code": "#define P 1;\n#define T 1;\n#define LPA 2;\n#define FPA 2;\n#define GC 1;\n#define C 2;\n#define seqq 2;\n#define PA 1;\n#define F 1;\n\nvar Data[LPA][C]=[0,0,0,0];\nvar DataF[LPA][FPA][C]=[0,0,0,0,0,0,0,0];\nvar DataS[LPA][C][seqq]=[0,0,0,0,0,0,0,0];\nvar P_ack[LPA] = [0,0];\nvar state_F[T][LPA][FPA]=[0,0,0,0];\nvar F_Ack[T][LPA]=[0,0];\nvar consumerS[C] = [0,0];\nvar S_Ack[C] = [0,0];\nvar Seq[LPA][GC][C]=[0,0,0,0];\nvar D_ack;\nvar C_Ack;\nvar seq;\nvar consumerL[C]=[0,0];\nvar consumer[2][2]=[0,0,0,0];\nvar consumerJ[C]=[0,0];\n\nenum {Request, Response, Dataa};\nenum {Producer_id, Topic_id, Partition_id, LeaderBroker_id,CLeadID,TID,LPAID,CID,PID,FPAID};\nenum {P_ackk, F_ack, NULL };\nenum {JoinGroup, SyncGroup, Consumer_id, ConsumerLead};\n\nchannel ComPL [P*T*PA] 0;\nchannel ComLF [P*T*PA*F] 0;\nchannel ComLC [PA*C] 0;\nchannel ComFC [PA*F*C] 0;\nchannel ComGC [C] 0;\n\n#define GetStateF(tid,lpaid,fpaid){\n \tvar ackj=0; var j=0;\n \twhile(j!=F){\n \t\tif(state_F[tid][lpaid][j]==1)\n \t\t\t{ackj++;}\n\t\tj++;\n \t}\n\tif(ackj==F)\n\t\t{F_Ack[tid][lpaid]=1;}\n};\n\n#define GetStateS(gcid,cid){\n\tC_Ack=1;//?\n};\n\n#define GetSync(gcid,cid){\n\tvar acks=0; var s=0;\n \twhile(s<C){\n \t\tif(consumerS[s]==1)\n \t\t\t{acks++;}\n \t\ts++;\n \t}\n \tif(acks==C)\n \t\t{S_Ack=true;}\n};\n\n#define Get_Seq(lpaid,gcid,cid){\n \tif(cid ==0){\n \t\tif(Seq[lpaid][gcid][cid]< seq){\n \t\t\tD_ack =true;\n \t\t\tseq =Seq[lpaid][gcid][cid];\n \t\t\tDataS[lpaid][cid][seq]=1;\n \t\t\tSeq[lpaid][gcid][cid]++;}\n }};\n/*@Process: Producer\n  The producer process first transfers the data to the partition on the server under the specified topic (i.e., the primary replica process) and ensures that the message for that partition was successfully written to the server by receiving a response message.\n*/\nProducer(pid,tid,lpaid)=ComPL[pid*P+tid*T+lpaid]!PID.TID.LPAID.Dataa->Producer(pid,tid,lpaid) [] ComPL[pid*P+tid*T +lpaid]?p_ack -> Producer(pid,tid,lpaid);\n/*@Process: LPartition\n  The LPartition process executes LPartF or LPartC.\n  Each topic has multiple partitions, but each partition has only one primary replica process. \n  The primary replica process, that is LPartition process here, as the main component for storing data, needs to communicate with the producer process, the consumer process, and the backup replica process at the same time.\n*/\nLPartition(pid,tid,lpaid, fpaid,gcid,cid)=LPartF(pid,tid,lpaid,fpaid) [] LPartC(tid,lpaid,gcid,cid);\n/*@Process: LPartF\n  We define the LPartF process to portray the writing of the backup copy and the reception of the feedback message.\n  The process obtains the status of all backup copy processes of a primary copy process to confirm whether its backup copy processes have stored data. \n  If F_Ack[lpaid]=1, then not only has the master copy process for the subject partition finished storing data, but all backup copy processes for that partition have also finished storing that data.\n*/\nLPartF(pid,tid,lpaid,fpaid)=ComPL[pid*P+tid*T +lpaid]?pid.tid.lpaid.data -> ComLF[pid*P+tid*T +lpaid*PA+fpaid]?fpaid.tid.lpaid.request ->ComLF[pid*P+tid*T +lpaid*PA+fpaid]!Dataa.Response ->\n \t\t\t\t\t\t\tComLF[pid*P+tid*T +lpaid*PA+fpaid]?f_ack{call(GetStateF,tid,lpaid, fpaid)} -> \n \t\t\t\t\t\t\tif(F_Ack[tid][lpaid]==1){ComPL[pid*P+tid*T +lpaid]!P_ack[lpaid]{P_ack[lpaid]=1} -> Skip}else{Skip};\n\t\t\t\t\t\t\tLPartF(pid,tid,lpaid,fpaid);\n/*@Process: LPartC\n  We define the LPartC process to represent the process by which data in a topic partition is consumed.\n*/\nLPartC(tid,lpaid,gcid,cid)=ComLC[tid*T+lpaid*PA+gcid*GC+cid]?data.request{call(Get_Seq,lpaid,gcid,cid)}->\n \t\t\t\t\t\t\tif(D_ack==true&&P_ack[lpaid]==1){ComLC[tid*T+lpaid*PA+gcid*GC+cid]!Dataa.Response->Skip}else{Skip};\n\t\t\t\t\t\t\tLPartC(tid,lpaid,cid,cid);\n/*@Process: FPartition\n  Data can be replicated to the server of the backup copy to prevent data loss due to failure of the server where the primary copy resides.\n  Through the channel ComLF[j], the backup replica process, that is the FPartition process here, can pull data published by the producer from the primary replica process under the same topic partition and store it locally, and send a response message to the primary replica process.\n*/\nFPartition(pid,tid,lpaid,fpaid,gcid,cid)= (ComLF[pid*P+tid*T+lpaid*PA+fpaid]!FPAID.TID.LPAID.Request->ComLF[pid*P+tid*T+lpaid*PA+fpaid]?data.repsonse{state_F[tid][lpaid][fpaid]=1}->\n\t\t\t\t\t\t\t\t\t\t\tComLF[pid*P+tid*T+lpaid*PA+fpaid]!F_ack->FPartition(pid,tid,lpaid,fpaid,gcid,cid))\n \t\t\t\t\t\t\t\t\t\t[](ComFC[tid*T+lpaid*PA+fpaid*F+gcid*GC+cid]?data.request->ComFC[tid*T+lpaid*PA+fpaid*F+gcid*GC+cid]!Dataa.Response->FPartition(pid,tid,lpaid,fpaid,gcid,cid));\n/*@Process: GroupCoordinator\n  The consumer GroupCoordinator process is the manager of each consumer group. \n  First, the process, after receiving a consumer's request message to join a group and collecting information from all consumers in this group, selects one consumer to become the master consumer and transmits membership information as well as topic partition information to the master consumer along with a reply message, while transmitting only reply messages to the other consumers. \n  Next, the coordinator transmits the partition assignment result of the master consumer to each consumer in the group after receiving the synchronization request message from the consumers.\n*/\nGroupCoordinator(gcid,cid)=ComGC[gcid*GC+cid]?joinGroup.request{\n\t\t\t\t\t\t\tcall(GetStateS,gcid,cid);\n\t\t\t\t\t\t\tif (C_Ack==true){consumerL[0]=1}} ->\n\t\t\t\t\t\t\tif(C_Ack ==true&&consumerL[cid]==1){\n \t\t\t\t\t\t\t\tComGC[gcid*GC+cid]!JoinGroup.Response.CLeadID.CID.TID.LPAID->ComGC[gcid*GC+cid]?syncGroup.request.cid.tid.lpaid->ComGC[gcid*GC+cid]!SyncGroup.Response.CID.TID.LPAID->Skip} \n \t\t\t\t\t\t\t\telse if(C_Ack ==true&&consumerL[cid]==0){\n \t\t\t\t\t\t\t\t\tComGC[gcid*GC+cid]!JoinGroup.Response.CLeadID.CID->\n \t\t\t\t\t\t\t\t\tComGC[gcid*GC+cid]?syncGroup.request->\n \t\t\t\t\t\t\t\t\tComGC[gcid*GC+cid]!SyncGroup.Response.CID.TID.LPAID->Skip} \n \t\t\t\t\t\t\t\telse{Skip};\n\t\t\t\t\t\t     GroupCoordinator(gcid,cid);\n/*@Process: Consumer\n  The process is divide into two parts.\n  The first part is the process GroupProcess where the consumer applies to join the group.\n  The second part is the process ComsumeProcess where the consumer consumes the data. The two processes are executed sequentially.\n*/\nConsumer(tid,lpaid,fpaid,gcid,cid)=GroupProcess(gcid,cid);ConsumerProcess(tid,lpaid,fpaid,gcid,cid);\n/*@Process: GroupProcess\n  The GroupProcess process handles the messages transmitted between the consumer applying to join a consumer group and the coordinator. \n  First, the consumer sends a message requesting to join the consumer group, and after receiving a feedback message from the coordinator, it determines whether the consumer is the primary consumer.\n  And if it is the primary consumer, then it needs to perform the topic partition allocation and send the result and the synchronization request message to the group coordinator, while the other consumers only need to send the synchronization request message.\n*/\nGroupProcess(gcid,cid)=ComGC[gcid*GC+cid]!JoinGroup.Request{consumerJ[cid]=1;}->\n\t\t\t\t\t\t(ComGC[gcid*GC+cid]?joinGroup.response.cleadid.cid.tid.lpaid{consumer[0][0]=1;consumer[1][1]=1}->\n \t\t\t\t\t\tComGC[gcid*GC+cid]!SyncGroup.Request.CID.TID.LPAID->\n\t\t\t\t\t\tComGC[gcid*GC+cid]?syncGroup.response.cid.tid.lpaid{consumerS[gcid*GC+cid]=1} -> Skip\n \t\t\t\t\t [] ComGC[gcid*GC+cid]?joinGroup.response.cleadid.cid->ComGC[gcid*GC+cid]!SyncGroup.Request.CID.TID.LPAID->\n \t\t\t\t\t \tComGC[gcid*GC+cid]?syncGroup.response.cid.tid.lpaid{consumerS[gcid*GC+cid]=1}-> Skip);\n/*@Process: ComsumeProcess\n  The ComsumeProcess process handles the messages transmitted between the consumer consuming data and the server. \n  First, all members of the consumer group in which the consumer resides need to complete group synchronization, and then the consumer can pull data from the master replica process of the corresponding partition based on the partition allocation.\n*/\nConsumerProcess(tid,lpaid,fpaid,gcid,cid)={call(GetSync,gcid,cid)}->\n \t\t\t\t\t\t\t\t\t\t\tif(S_Ack ==true&&consumer[tid*T+lpaid][gcid*GC+cid]==1){\n \t\t\t\t\t\t\t\t\t\t\t\t(ComLC[tid*T+lpaid*PA+cid]!Dataa.Request->ComLC[tid*T+lpaid*PA+cid]?data.response{Data[lpaid][cid]=1}->ConsumerProcess(tid,lpaid,fpaid,gcid,cid)\n\t\t\t\t\t\t\t\t\t [] ComFC[tid*T+lpaid*PA+fpaid*F+gcid*GC+cid]!Dataa.Request->\n \t\t\t\t\t\t\t\t\t\tComFC[tid*T+lpaid*PA+fpaid*F+gcid*GC+cid]?data.response{DataF[lpaid][fpaid][cid]=1}->\n \t\t\t\t\t\t\t\t\t\tConsumerProcess(tid,lpaid,fpaid,gcid,cid))} \n \t\t\t\t\t\t\t\t\t\telse{Skip;ConsumerProcess(tid,lpaid,fpaid,gcid,cid)};\n/*@Process: System\n  The overall model consists of concurrent Producer process, LPartition processes, FPartition processes, GroupCoordinator processes and Consumer processes, while utilizing the interspersed execution notation ||| for multiple processes of the same type.\n*/\nSystem()= ||| pid :{0..P-1};tid:{0..T-1}; lpaid :{0..PA-1}; fpaid :{0..F-1};gcid:{0..GC-1};cid :{0..C-1}\n \t\t\t@(Producer(pid,tid,lpaid) || LPartition(pid,tid,lpaid,fpaid,gcid,cid) || FPartition(pid,tid,lpaid, fpaid,gcid,cid) || GroupCoordinator(gcid,cid)|| Consumer(tid,lpaid,fpaid,gcid,cid));",
        "property_desc": [
            "The system is deadlock-free."
        ],
        "properties": [
            "#assert System() deadlockfree;"
        ],
        "processes": [
            {
                "name": "Producer",
                "description": "The producer process first transfers the data to the partition on the server under the specified topic (i.e., the primary replica process) and ensures that the message for that partition was successfully written to the server by receiving a response message.",
                "pat_code": "Producer(pid,tid,lpaid)=ComPL[pid*P+tid*T+lpaid]!PID.TID.LPAID.Dataa->Producer(pid,tid,lpaid) [] ComPL[pid*P+tid*T +lpaid]?p_ack -> Producer(pid,tid,lpaid);"
            },
            {
                "name": "LPartition",
                "description": "The LPartition process executes LPartF or LPartC.\n  Each topic has multiple partitions, but each partition has only one primary replica process. \n  The primary replica process, that is LPartition process here, as the main component for storing data, needs to communicate with the producer process, the consumer process, and the backup replica process at the same time.",
                "pat_code": "LPartition(pid,tid,lpaid, fpaid,gcid,cid)=LPartF(pid,tid,lpaid,fpaid) [] LPartC(tid,lpaid,gcid,cid);"
            },
            {
                "name": "LPartF",
                "description": "We define the LPartF process to portray the writing of the backup copy and the reception of the feedback message.\n  The process obtains the status of all backup copy processes of a primary copy process to confirm whether its backup copy processes have stored data. \n  If F_Ack[lpaid]=1, then not only has the master copy process for the subject partition finished storing data, but all backup copy processes for that partition have also finished storing that data.",
                "pat_code": "LPartF(pid,tid,lpaid,fpaid)=ComPL[pid*P+tid*T +lpaid]?pid.tid.lpaid.data -> ComLF[pid*P+tid*T +lpaid*PA+fpaid]?fpaid.tid.lpaid.request ->ComLF[pid*P+tid*T +lpaid*PA+fpaid]!Dataa.Response ->\n \t\t\t\t\t\t\tComLF[pid*P+tid*T +lpaid*PA+fpaid]?f_ack{call(GetStateF,tid,lpaid, fpaid)} -> \n \t\t\t\t\t\t\tif(F_Ack[tid][lpaid]==1){ComPL[pid*P+tid*T +lpaid]!P_ack[lpaid]{P_ack[lpaid]=1} -> Skip}else{Skip};\n\t\t\t\t\t\t\tLPartF(pid,tid,lpaid,fpaid);"
            },
            {
                "name": "LPartC",
                "description": "We define the LPartC process to represent the process by which data in a topic partition is consumed.",
                "pat_code": "LPartC(tid,lpaid,gcid,cid)=ComLC[tid*T+lpaid*PA+gcid*GC+cid]?data.request{call(Get_Seq,lpaid,gcid,cid)}->\n \t\t\t\t\t\t\tif(D_ack==true&&P_ack[lpaid]==1){ComLC[tid*T+lpaid*PA+gcid*GC+cid]!Dataa.Response->Skip}else{Skip};\n\t\t\t\t\t\t\tLPartC(tid,lpaid,cid,cid);"
            },
            {
                "name": "FPartition",
                "description": "Data can be replicated to the server of the backup copy to prevent data loss due to failure of the server where the primary copy resides.\n  Through the channel ComLF[j], the backup replica process, that is the FPartition process here, can pull data published by the producer from the primary replica process under the same topic partition and store it locally, and send a response message to the primary replica process.",
                "pat_code": "FPartition(pid,tid,lpaid,fpaid,gcid,cid)= (ComLF[pid*P+tid*T+lpaid*PA+fpaid]!FPAID.TID.LPAID.Request->ComLF[pid*P+tid*T+lpaid*PA+fpaid]?data.repsonse{state_F[tid][lpaid][fpaid]=1}->\n\t\t\t\t\t\t\t\t\t\t\tComLF[pid*P+tid*T+lpaid*PA+fpaid]!F_ack->FPartition(pid,tid,lpaid,fpaid,gcid,cid))\n \t\t\t\t\t\t\t\t\t\t[](ComFC[tid*T+lpaid*PA+fpaid*F+gcid*GC+cid]?data.request->ComFC[tid*T+lpaid*PA+fpaid*F+gcid*GC+cid]!Dataa.Response->FPartition(pid,tid,lpaid,fpaid,gcid,cid));"
            },
            {
                "name": "GroupCoordinator",
                "description": "The consumer GroupCoordinator process is the manager of each consumer group. \n  First, the process, after receiving a consumer's request message to join a group and collecting information from all consumers in this group, selects one consumer to become the master consumer and transmits membership information as well as topic partition information to the master consumer along with a reply message, while transmitting only reply messages to the other consumers. \n  Next, the coordinator transmits the partition assignment result of the master consumer to each consumer in the group after receiving the synchronization request message from the consumers.",
                "pat_code": "GroupCoordinator(gcid,cid)=ComGC[gcid*GC+cid]?joinGroup.request{\n\t\t\t\t\t\t\tcall(GetStateS,gcid,cid);\n\t\t\t\t\t\t\tif (C_Ack==true){consumerL[0]=1}} ->\n\t\t\t\t\t\t\tif(C_Ack ==true&&consumerL[cid]==1){\n \t\t\t\t\t\t\t\tComGC[gcid*GC+cid]!JoinGroup.Response.CLeadID.CID.TID.LPAID->ComGC[gcid*GC+cid]?syncGroup.request.cid.tid.lpaid->ComGC[gcid*GC+cid]!SyncGroup.Response.CID.TID.LPAID->Skip} \n \t\t\t\t\t\t\t\telse if(C_Ack ==true&&consumerL[cid]==0){\n \t\t\t\t\t\t\t\t\tComGC[gcid*GC+cid]!JoinGroup.Response.CLeadID.CID->\n \t\t\t\t\t\t\t\t\tComGC[gcid*GC+cid]?syncGroup.request->\n \t\t\t\t\t\t\t\t\tComGC[gcid*GC+cid]!SyncGroup.Response.CID.TID.LPAID->Skip} \n \t\t\t\t\t\t\t\telse{Skip};\n\t\t\t\t\t\t     GroupCoordinator(gcid,cid);"
            },
            {
                "name": "Consumer",
                "description": "The process is divide into two parts.\n  The first part is the process GroupProcess where the consumer applies to join the group.\n  The second part is the process ComsumeProcess where the consumer consumes the data. The two processes are executed sequentially.",
                "pat_code": "Consumer(tid,lpaid,fpaid,gcid,cid)=GroupProcess(gcid,cid);ConsumerProcess(tid,lpaid,fpaid,gcid,cid);"
            },
            {
                "name": "GroupProcess",
                "description": "The GroupProcess process handles the messages transmitted between the consumer applying to join a consumer group and the coordinator. \n  First, the consumer sends a message requesting to join the consumer group, and after receiving a feedback message from the coordinator, it determines whether the consumer is the primary consumer.\n  And if it is the primary consumer, then it needs to perform the topic partition allocation and send the result and the synchronization request message to the group coordinator, while the other consumers only need to send the synchronization request message.",
                "pat_code": "GroupProcess(gcid,cid)=ComGC[gcid*GC+cid]!JoinGroup.Request{consumerJ[cid]=1;}->\n\t\t\t\t\t\t(ComGC[gcid*GC+cid]?joinGroup.response.cleadid.cid.tid.lpaid{consumer[0][0]=1;consumer[1][1]=1}->\n \t\t\t\t\t\tComGC[gcid*GC+cid]!SyncGroup.Request.CID.TID.LPAID->\n\t\t\t\t\t\tComGC[gcid*GC+cid]?syncGroup.response.cid.tid.lpaid{consumerS[gcid*GC+cid]=1} -> Skip\n \t\t\t\t\t [] ComGC[gcid*GC+cid]?joinGroup.response.cleadid.cid->ComGC[gcid*GC+cid]!SyncGroup.Request.CID.TID.LPAID->\n \t\t\t\t\t \tComGC[gcid*GC+cid]?syncGroup.response.cid.tid.lpaid{consumerS[gcid*GC+cid]=1}-> Skip);"
            },
            {
                "name": "ComsumeProcess",
                "description": "The ComsumeProcess process handles the messages transmitted between the consumer consuming data and the server. \n  First, all members of the consumer group in which the consumer resides need to complete group synchronization, and then the consumer can pull data from the master replica process of the corresponding partition based on the partition allocation.",
                "pat_code": "ConsumerProcess(tid,lpaid,fpaid,gcid,cid)={call(GetSync,gcid,cid)}->\n \t\t\t\t\t\t\t\t\t\t\tif(S_Ack ==true&&consumer[tid*T+lpaid][gcid*GC+cid]==1){\n \t\t\t\t\t\t\t\t\t\t\t\t(ComLC[tid*T+lpaid*PA+cid]!Dataa.Request->ComLC[tid*T+lpaid*PA+cid]?data.response{Data[lpaid][cid]=1}->ConsumerProcess(tid,lpaid,fpaid,gcid,cid)\n\t\t\t\t\t\t\t\t\t [] ComFC[tid*T+lpaid*PA+fpaid*F+gcid*GC+cid]!Dataa.Request->\n \t\t\t\t\t\t\t\t\t\tComFC[tid*T+lpaid*PA+fpaid*F+gcid*GC+cid]?data.response{DataF[lpaid][fpaid][cid]=1}->\n \t\t\t\t\t\t\t\t\t\tConsumerProcess(tid,lpaid,fpaid,gcid,cid))} \n \t\t\t\t\t\t\t\t\t\telse{Skip;ConsumerProcess(tid,lpaid,fpaid,gcid,cid)};"
            },
            {
                "name": "System",
                "description": "The overall model consists of concurrent Producer process, LPartition processes, FPartition processes, GroupCoordinator processes and Consumer processes, while utilizing the interspersed execution notation ||| for multiple processes of the same type.",
                "pat_code": "System()= ||| pid :{0..P-1};tid:{0..T-1}; lpaid :{0..PA-1}; fpaid :{0..F-1};gcid:{0..GC-1};cid :{0..C-1}\n \t\t\t@(Producer(pid,tid,lpaid) || LPartition(pid,tid,lpaid,fpaid,gcid,cid) || FPartition(pid,tid,lpaid, fpaid,gcid,cid) || GroupCoordinator(gcid,cid)|| Consumer(tid,lpaid,fpaid,gcid,cid));"
            }
        ],
        "global_definition": "#define P 1;\n#define T 1;\n#define LPA 2;\n#define FPA 2;\n#define GC 1;\n#define C 2;\n#define seqq 2;\n#define PA 1;\n#define F 1;\n\nvar Data[LPA][C]=[0,0,0,0];\nvar DataF[LPA][FPA][C]=[0,0,0,0,0,0,0,0];\nvar DataS[LPA][C][seqq]=[0,0,0,0,0,0,0,0];\nvar P_ack[LPA] = [0,0];\nvar state_F[T][LPA][FPA]=[0,0,0,0];\nvar F_Ack[T][LPA]=[0,0];\nvar consumerS[C] = [0,0];\nvar S_Ack[C] = [0,0];\nvar Seq[LPA][GC][C]=[0,0,0,0];\nvar D_ack;\nvar C_Ack;\nvar seq;\nvar consumerL[C]=[0,0];\nvar consumer[2][2]=[0,0,0,0];\nvar consumerJ[C]=[0,0];\n\nenum {Request, Response, Dataa};\nenum {Producer_id, Topic_id, Partition_id, LeaderBroker_id,CLeadID,TID,LPAID,CID,PID,FPAID};\nenum {P_ackk, F_ack, NULL };\nenum {JoinGroup, SyncGroup, Consumer_id, ConsumerLead};\n\nchannel ComPL [P*T*PA] 0;\nchannel ComLF [P*T*PA*F] 0;\nchannel ComLC [PA*C] 0;\nchannel ComFC [PA*F*C] 0;\nchannel ComGC [C] 0;\n\n#define GetStateF(tid,lpaid,fpaid){\n \tvar ackj=0; var j=0;\n \twhile(j!=F){\n \t\tif(state_F[tid][lpaid][j]==1)\n \t\t\t{ackj++;}\n\t\tj++;\n \t}\n\tif(ackj==F)\n\t\t{F_Ack[tid][lpaid]=1;}\n};\n\n#define GetStateS(gcid,cid){\n\tC_Ack=1;//?\n};\n\n#define GetSync(gcid,cid){\n\tvar acks=0; var s=0;\n \twhile(s<C){\n \t\tif(consumerS[s]==1)\n \t\t\t{acks++;}\n \t\ts++;\n \t}\n \tif(acks==C)\n \t\t{S_Ack=true;}\n};\n\n#define Get_Seq(lpaid,gcid,cid){\n \tif(cid ==0){\n \t\tif(Seq[lpaid][gcid][cid]< seq){\n \t\t\tD_ack =true;\n \t\t\tseq =Seq[lpaid][gcid][cid];\n \t\t\tDataS[lpaid][cid][seq]=1;\n \t\t\tSeq[lpaid][gcid][cid]++;}\n }};",
        "path": "handwrite/Kafka.csp"
    },
    {
        "name": "Kerberos",
        "tags": [
            "Protocol"
        ],
        "use_non_container_lib": false,
        "description": "Kerberos is a network authentication protocol. It is designed to provide strong authentication for client/server applications by using secret-key cryptography.",
        "pat_code": "enum{fail};\nenum{VALID};\nenum{Ticket_c_tgs, Ticket_c_s, K_TGS, K_client, K_server};\n\n#define E(k,b) {k*b + b};\n#define D(k,s) {s % k};\n\n// clock\nvar t;\n// client\nvar cTGT;\nvar cCST;\nvar cSK_c_tgs;\nvar cSK_c_s;\n\nvar authenticator;\n// server\n\n\nchannel clk 0;\nchannel CtoAS 0;\nchannel AStoC 0;\nchannel CtoTGS 0;\nchannel TGStoC 0;\nchannel CtoS 0;\nchannel StoC 0;\n\n/*@Process: Clock\n  The clock repeatly sends current time to others and increases the time.\n*/\nClock() = clk!t{t++;} -> Clock();\n\n/*@Process: Client\nThere are three phases in Kerberos client: CASAuth, CTGAuth and CSAuth\n*/\nClient(id) = CASAuth(id); CTGAuth(id); CSAuth(id);\n\n/*@Process: CASAuth\n  The CASAuth phase:\n  1. First, the client request the clock server to get the timestamp.\n\t2. Then, the client sends its information to the authentication server, including the client ID and timestamp and waits for response.\n\t3. - If the response is fail, then the process enters the STOP state. \n\t\t - Otherwise, the client will receive the SK_TGS and TGT messages sent by the AS and decrypts the SK_TGS to get the TGS session key by using the client key K_client. Then the client proceeds to next phase.\n*/\nCASAuth(id) = clk?lifeCAS -> CtoAS!id.lifeCAS -> (\n\t\tAStoC?fail -> Stop\n\t\t[]\n\t\tAStoC?tgt.sk_tgs -> {cTGT=tgt; cSK_c_tgs = call(D, K_client, sk_tgs);} -> Skip\n\t);\n\n/*@Process: CTGAuth\n  The CTGSAuth phase, the client authenticates to TGS:\n\t1. The client gets the timestamp from the clock server.\n\t2. Then, it encrypts the id and timestamp information by using TGS session key SK_{c,tgs} to get Auenticator\n\t3. After that, it sends Auenticator and TGT to TGS and waits for the reply. \n\t4.1. If TGS reply fails, the authentication fails. \n\t4.2. Otherwise the client receives two messages CST and CSK, and the client decrypts the message with TGS session key to get the server session key SKc_{c,tgs} and proceeds to next phase.\n*/\nCTGAuth(id) = clk?lifeCTGS -> {authenticator = call(E, cSK_c_tgs, id*10+lifeCTGS);} ->\n\tCtoAS!authenticator.cTGT -> (\n\t\tTGStoC?fail -> Stop\n\t\t[]\n\t\tTGStoC?cst.csk -> {cCST = cst; cSK_c_s = call(D, cSK_c_tgs, csk);} -> Skip\n\t);\n\n/*@Process: CSAuth\n\tThe CSAuth phase, the client authenticates with the server: \n\t1. It first obtain the system timestamp for this authentication message. \n\t2. Use the server session key SK_{c,s} to encrypt the client's id, the timestamp to get the Auenticator. \n\t3. Then, it sends the Auenticator and CST to the server and wait for a response. \n\t4.1. If the server returns fail then the authentication fails\n\t4.2. Or else it receives the SrvRes from the server, and uses the information to update the timestamp and the communication between the server is established.\n*/\nvar newTs;\nCSAuth(id) = clk?lifeCS -> {authenticator = call(E, cSK_c_s, id*10 + lifeCS)} -> \n\tCtoS!authenticator.cCST -> (\n\t\tStoC?fail -> Stop\n\t\t[]\n\t\tStoC?srvRes -> {newTs = call(D, cSK_c_s, srvRes);} -> update_newTs -> Skip\n\t);\n\n/*@Process: Server\n\tThere are three servers, the authentication server(AS), the ticket granting server(TGS) and the communicating server.\n*/\nServer() = ASSrv() || TGSSrv() || SSrv();\n\n/*@Process: ASSrv\n The Authentication Server(AS):\n  1. The AS first receives the id and timestamp from the client and then gets the system time from the Clock. \n\t2. The process first determines: if the timestamp is legitimate if not, it discards it and waits again for a message from the client. \n\t3. If the timestamp is legal, the process will judge whether the client id is legal or not, if not, it will send fail to inform the client that the authentication fails\n\t4. If it is legal, it will generate the TGS session key SK_{c,tgs}, encrypt the ticket between the client and the TGS with the TGS key K_TGS, encrypt SK_{c,tgs} with the client's key to get SK_TGS\n\t5. Finally, it sends SK_TGS and TGT to the client.\n*/\nvar sTGT;\nvar sSK_TGS;\nvar sSK_c_tgs;\nASSrv() = CtoAS?id.lifeCAS -> clk?ts -> if(lifeCAS > ts) {\n\t\tAStoC!fail -> ASSrv()\n\t} else if(id == VALID){\n\t\t{\n\t\t\tsTGT = call(E, K_TGS, Ticket_c_tgs);\n\t\t\tsSK_TGS = call(E, K_client, sSK_c_tgs);\n\t\t} -> AStoC!sTGT.sSK_TGS -> ASSrv()\n\t} else {\n\t\tAStoC!fail -> ASSrv()\n\t};\n\n/*@Process: TGSSrv\n\tThe Ticket Granting Server(TGS):\n\t1. TGS receives two messages Auenticator and TGT from the client\n\t2. Then, it obtains the system clock\n\t3. After that, it decrypts TGT by using the key K_TGS to get the timestamp of the AS authentication message, the client id and the TGS session key contained in TGT\n\t4. And then decrypts Auenticator to get the timestamp of the TGS authentication message and the client id by using the TGS session key. \n\t5. TGS first checks if both timestamps are legal, if at least one of them is not legal, then it discards the message and wait for the client to resend it. \n\t6.1. If both timestamps are legal, check whether the two ids are equal, if they are not equal, the authentication fails and return client fail message, \n\t6.2. If the ids are equal, the authentication succeeds, TGS generates the server session key SK_{c,s}, encrypts the ticket between the client and the server with the server key to get the CST message, and encrypts the server session key with TGS to get the CSK message.\n\t7. Finally, sends CST and CSK to client.\n*/\nvar id1; var id2;\nvar slifeCAS; var slifeCTGS;\nvar sSK_c_s;\nvar sCST;\nvar sCSK;\nTGSSrv() = CtoTGS?auth.tgt -> clk?ts -> \n\tdec_ticket_c_tgs{\n\t\tid1 = call(D, K_TGS, tgt);\n\t\tslifeCAS = call(D, K_TGS, tgt);\n\t\tsSK_c_s = call(D, K_TGS, tgt);\n\t} -> dec_auth{\n\t\tid2 = call(D, sSK_c_tgs, auth);\n\t\tslifeCTGS = call(D, sSK_c_tgs, auth);\n\t} -> if(slifeCAS > ts || slifeCTGS > ts) {\n\t\tAStoC!fail -> TGSSrv()\n\t} else if(id1 != id2) {\n\t\tAStoC!fail -> TGSSrv()\n\t} else {\n\t\tenc{\n\t\t\tsCST = call(E, K_server, Ticket_c_s);\n\t\t\tsCSK = call(E, sSK_c_tgs, sSK_c_s);\n\t\t} -> TGStoC!sCST.sCSK -> TGSSrv()\n\t};\n\n/*@Process: SSrv\n\tThe server communicates with the client:\n  1. The server receives the Auenticator and CST from the client\n\t2. Then gets the system clock\n\t3. Decrypts the CST with the server key K_server to get the session key SK_{c,s}, client id, timestamp of the ticket. \n\t4. Then decrypt Auenticator with the session key to get the timestamp of the server authentication message, client id. \n\t5. The server determines whether the two timestamps are legal or not, if not, the authentication fails and return client fail message. \n\t6. If they are legal, the server will check whether the two ids are the same, if they are not, the authentication will fail and return the fail message.\n  7. If ids are consistent, the authentication is successful, and the timestamp is sent to the client to update its timestamp.\n*/\nvar slifeT; var slifeCS;\nvar sSrvRes;\nSSrv() = CtoS?auth.cts -> clk?ts -> \n\tdec_cst{\n\t\tid1 = call(D, K_TGS, cts);\n\t\tslifeT = call(D, K_TGS, cts);\n\t\tsSK_c_s = call(D, K_TGS, cts);\n\t} -> dec_auth{\n\t\tid2 = call(D, sSK_c_s, auth);\n\t\tslifeCS = call(D, sSK_c_s, auth);\n\t} -> if(slifeT > ts || slifeCS > ts) {\n\t\tStoC!fail -> SSrv()\n\t} else if(id1 != id2){\n\t\tStoC!fail -> SSrv()\n\t} else {\n\t\tenc{sSrvRes = call(E, sSK_c_s, slifeCS);} -> StoC!sSrvRes -> SSrv()\n\t};\n\n/*@Process: System\n\tThe whole system can be modeled in three parts: the client, the server and the clock.\n*/\nSystem() = Client(VALID) || Server() || Clock();",
        "property_desc": [
            "The system is deadlock-free."
        ],
        "properties": [
            "#assert System() deadlockfree;"
        ],
        "processes": [
            {
                "name": "Clock",
                "description": "The clock repeatly sends current time to others and increases the time.",
                "pat_code": "Clock() = clk!t{t++;} -> Clock();"
            },
            {
                "name": "Client",
                "description": "There are three phases in Kerberos client: CASAuth, CTGAuth and CSAuth",
                "pat_code": "Client(id) = CASAuth(id); CTGAuth(id); CSAuth(id);"
            },
            {
                "name": "CASAuth",
                "description": "The CASAuth phase:\n  1. First, the client request the clock server to get the timestamp.\n\t2. Then, the client sends its information to the authentication server, including the client ID and timestamp and waits for response.\n\t3. - If the response is fail, then the process enters the STOP state. \n\t\t - Otherwise, the client will receive the SK_TGS and TGT messages sent by the AS and decrypts the SK_TGS to get the TGS session key by using the client key K_client. Then the client proceeds to next phase.",
                "pat_code": "CASAuth(id) = clk?lifeCAS -> CtoAS!id.lifeCAS -> (\n\t\tAStoC?fail -> Stop\n\t\t[]\n\t\tAStoC?tgt.sk_tgs -> {cTGT=tgt; cSK_c_tgs = call(D, K_client, sk_tgs);} -> Skip\n\t);"
            },
            {
                "name": "CTGAuth",
                "description": "The CTGSAuth phase, the client authenticates to TGS:\n\t1. The client gets the timestamp from the clock server.\n\t2. Then, it encrypts the id and timestamp information by using TGS session key SK_{c,tgs} to get Auenticator\n\t3. After that, it sends Auenticator and TGT to TGS and waits for the reply. \n\t4.1. If TGS reply fails, the authentication fails. \n\t4.2. Otherwise the client receives two messages CST and CSK, and the client decrypts the message with TGS session key to get the server session key SKc_{c,tgs} and proceeds to next phase.",
                "pat_code": "CTGAuth(id) = clk?lifeCTGS -> {authenticator = call(E, cSK_c_tgs, id*10+lifeCTGS);} ->\n\tCtoAS!authenticator.cTGT -> (\n\t\tTGStoC?fail -> Stop\n\t\t[]\n\t\tTGStoC?cst.csk -> {cCST = cst; cSK_c_s = call(D, cSK_c_tgs, csk);} -> Skip\n\t);"
            },
            {
                "name": "CSAuth",
                "description": "The CSAuth phase, the client authenticates with the server: \n\t1. It first obtain the system timestamp for this authentication message. \n\t2. Use the server session key SK_{c,s} to encrypt the client's id, the timestamp to get the Auenticator. \n\t3. Then, it sends the Auenticator and CST to the server and wait for a response. \n\t4.1. If the server returns fail then the authentication fails\n\t4.2. Or else it receives the SrvRes from the server, and uses the information to update the timestamp and the communication between the server is established.",
                "pat_code": "var newTs;\nCSAuth(id) = clk?lifeCS -> {authenticator = call(E, cSK_c_s, id*10 + lifeCS)} -> \n\tCtoS!authenticator.cCST -> (\n\t\tStoC?fail -> Stop\n\t\t[]\n\t\tStoC?srvRes -> {newTs = call(D, cSK_c_s, srvRes);} -> update_newTs -> Skip\n\t);"
            },
            {
                "name": "Server",
                "description": "There are three servers, the authentication server(AS), the ticket granting server(TGS) and the communicating server.",
                "pat_code": "Server() = ASSrv() || TGSSrv() || SSrv();"
            },
            {
                "name": "ASSrv",
                "description": "The Authentication Server(AS):\n  1. The AS first receives the id and timestamp from the client and then gets the system time from the Clock. \n\t2. The process first determines: if the timestamp is legitimate if not, it discards it and waits again for a message from the client. \n\t3. If the timestamp is legal, the process will judge whether the client id is legal or not, if not, it will send fail to inform the client that the authentication fails\n\t4. If it is legal, it will generate the TGS session key SK_{c,tgs}, encrypt the ticket between the client and the TGS with the TGS key K_TGS, encrypt SK_{c,tgs} with the client's key to get SK_TGS\n\t5. Finally, it sends SK_TGS and TGT to the client.",
                "pat_code": "var sTGT;\nvar sSK_TGS;\nvar sSK_c_tgs;\nASSrv() = CtoAS?id.lifeCAS -> clk?ts -> if(lifeCAS > ts) {\n\t\tAStoC!fail -> ASSrv()\n\t} else if(id == VALID){\n\t\t{\n\t\t\tsTGT = call(E, K_TGS, Ticket_c_tgs);\n\t\t\tsSK_TGS = call(E, K_client, sSK_c_tgs);\n\t\t} -> AStoC!sTGT.sSK_TGS -> ASSrv()\n\t} else {\n\t\tAStoC!fail -> ASSrv()\n\t};"
            },
            {
                "name": "TGSSrv",
                "description": "The Ticket Granting Server(TGS):\n\t1. TGS receives two messages Auenticator and TGT from the client\n\t2. Then, it obtains the system clock\n\t3. After that, it decrypts TGT by using the key K_TGS to get the timestamp of the AS authentication message, the client id and the TGS session key contained in TGT\n\t4. And then decrypts Auenticator to get the timestamp of the TGS authentication message and the client id by using the TGS session key. \n\t5. TGS first checks if both timestamps are legal, if at least one of them is not legal, then it discards the message and wait for the client to resend it. \n\t6.1. If both timestamps are legal, check whether the two ids are equal, if they are not equal, the authentication fails and return client fail message, \n\t6.2. If the ids are equal, the authentication succeeds, TGS generates the server session key SK_{c,s}, encrypts the ticket between the client and the server with the server key to get the CST message, and encrypts the server session key with TGS to get the CSK message.\n\t7. Finally, sends CST and CSK to client.",
                "pat_code": "var id1; var id2;\nvar slifeCAS; var slifeCTGS;\nvar sSK_c_s;\nvar sCST;\nvar sCSK;\nTGSSrv() = CtoTGS?auth.tgt -> clk?ts -> \n\tdec_ticket_c_tgs{\n\t\tid1 = call(D, K_TGS, tgt);\n\t\tslifeCAS = call(D, K_TGS, tgt);\n\t\tsSK_c_s = call(D, K_TGS, tgt);\n\t} -> dec_auth{\n\t\tid2 = call(D, sSK_c_tgs, auth);\n\t\tslifeCTGS = call(D, sSK_c_tgs, auth);\n\t} -> if(slifeCAS > ts || slifeCTGS > ts) {\n\t\tAStoC!fail -> TGSSrv()\n\t} else if(id1 != id2) {\n\t\tAStoC!fail -> TGSSrv()\n\t} else {\n\t\tenc{\n\t\t\tsCST = call(E, K_server, Ticket_c_s);\n\t\t\tsCSK = call(E, sSK_c_tgs, sSK_c_s);\n\t\t} -> TGStoC!sCST.sCSK -> TGSSrv()\n\t};"
            },
            {
                "name": "SSrv",
                "description": "The server communicates with the client:\n  1. The server receives the Auenticator and CST from the client\n\t2. Then gets the system clock\n\t3. Decrypts the CST with the server key K_server to get the session key SK_{c,s}, client id, timestamp of the ticket. \n\t4. Then decrypt Auenticator with the session key to get the timestamp of the server authentication message, client id. \n\t5. The server determines whether the two timestamps are legal or not, if not, the authentication fails and return client fail message. \n\t6. If they are legal, the server will check whether the two ids are the same, if they are not, the authentication will fail and return the fail message.\n  7. If ids are consistent, the authentication is successful, and the timestamp is sent to the client to update its timestamp.",
                "pat_code": "var slifeT; var slifeCS;\nvar sSrvRes;\nSSrv() = CtoS?auth.cts -> clk?ts -> \n\tdec_cst{\n\t\tid1 = call(D, K_TGS, cts);\n\t\tslifeT = call(D, K_TGS, cts);\n\t\tsSK_c_s = call(D, K_TGS, cts);\n\t} -> dec_auth{\n\t\tid2 = call(D, sSK_c_s, auth);\n\t\tslifeCS = call(D, sSK_c_s, auth);\n\t} -> if(slifeT > ts || slifeCS > ts) {\n\t\tStoC!fail -> SSrv()\n\t} else if(id1 != id2){\n\t\tStoC!fail -> SSrv()\n\t} else {\n\t\tenc{sSrvRes = call(E, sSK_c_s, slifeCS);} -> StoC!sSrvRes -> SSrv()\n\t};"
            },
            {
                "name": "System",
                "description": "The whole system can be modeled in three parts: the client, the server and the clock.",
                "pat_code": "System() = Client(VALID) || Server() || Clock();"
            }
        ],
        "global_definition": "enum{fail};\nenum{VALID};\nenum{Ticket_c_tgs, Ticket_c_s, K_TGS, K_client, K_server};\n\n#define E(k,b) {k*b + b};\n#define D(k,s) {s % k};\n\n// clock\nvar t;\n// client\nvar cTGT;\nvar cCST;\nvar cSK_c_tgs;\nvar cSK_c_s;\n\nvar authenticator;\n// server\n\n\nchannel clk 0;\nchannel CtoAS 0;\nchannel AStoC 0;\nchannel CtoTGS 0;\nchannel TGStoC 0;\nchannel CtoS 0;\nchannel StoC 0;",
        "path": "handwrite/Kerberos.csp"
    },
    {
        "name": "MQTT-SN Communication Model",
        "tags": [
            "Protocol",
            "Attacker"
        ],
        "use_non_container_lib": false,
        "description": "There are four main entities in MQTT-SN communication: clients(publishers and subscribers), gateways, and brokers.\n  \u2013 Clients: Clients can be divided into two types of roles, namely publishers and subscribers. Clients who publish messages with topics are called publishers, while clients who subscribe to topics are called subscribers.\n  \u2013 Gateways: The communication between clients and gateways follows the MQTT-SN protocol, while the communication between gateways and brokers adopts the MQTT protocol. The main function of the gateway is to adjust the format of data packets and forward them after protocol conversion between MQTT-SN and MQTT. The gateway may be integrated into the broker server or may exist independently. As the function of the gateway is independent of that of the broker, the gateway is assumed to be an independent module in the subsequent modeling part.\n\t- Brokers: All clients need to be connected to the broker via a gateway to achieve topic-based message exchange, rather than communicating with each other directly. The main function of brokers is to receive messages from publishers and distribute these messages to the appropriate subscribers.",
        "pat_code": "#import \"PAT.Lib.Hashtable\";\n// topic table\nvar <HashTable> TpcTable;\n\n// channel definition\nchannel ComPP 0;channel ComBP 0;channel ComSS 0;channel ComBS 0;\nchannel FakeA 0;channel FakeB 0;channel FakeC 0;channel FakeD 0;channel FakeE 0;\n\n// request and message definition\nenum{data, name, topic};\nenum{gwId, topicId, none};\nenum{search, connect, reg, pub, sub, update, disconnect};\nenum{A, B, C, D, E};\nenum{invalid_tag, valid_tag};\n\nvar tag_p = valid_tag;var tag_s = valid_tag;\nvar tag_gp = valid_tag;var tag_gs = valid_tag;var tag_b = valid_tag;\nvar tag_i = invalid_tag;\n\n// property variables\nvar data_reachability = false;\nvar publisher_fake_success = false;var subscriber_fake_success = false;\nvar gatewayp_fake_success = false; var gateways_fake_success = false;var broker_fake_success = false;\nvar data_leakage_success = false;\n\n// authentication related variables\nvar isLegalPub;var isLegalGWP;var isLegalBroker;var isLegalSub;var isLegalGWS;\n// functions to verify the identity of entities \n#define getPub(tg1,tg){\n\tisLegalPub = false;\n\tif(tg1 == tg){isLegalPub = true;}\n};\n#define getSub(tg1,tg){\n\tisLegalSub = false;\n\tif(tg1 == tg){isLegalSub = true;}\n};\n#define getGWP(tg1,tg){\n\tisLegalGWP = false;\n\tif(tg1 == tg){isLegalGWP = true;}\n};\n#define getGWS(tg1,tg){\n\tisLegalGWS = false;\n\tif(tg1 == tg){isLegalGWS = true;}\n};\n#define getBroker(tg1,tg){\n\tisLegalBroker = false;\n\tif(tg1 == tg){isLegalBroker = true;}\n};\n\n/*@Process: Publisher\n\tThe publisher executes the four steps: Searchs for a publisher gateway, attempts to connect to it, register topics and publish data\n*/\nPublisher() = FindGWP(); Connect(); TopicReg(); MsgPub(); Publisher();\n\n/*@Process: FindGWP\n  The publisher searches for a publisher gateway\n\t1. It sends a search packet to search the publisher gateway.\n\t2. It waits for reponses from the gateway.\n\t3. If a valid acknowledgment with a valid gateway ID is received, it proceeds, otherwise, it may fail and retry finding a gateway. \n*/\nFindGWP()= \n\tComPP!A.B.tag_p.search ->\n\tComPP?B.A.t.ack.gwId{call(getGWP,tag_gp,t)} ->\n\tif(isLegalGWP==true){\n\t\tif(ack == true) {Skip} else{fail->FindGWP()}\n\t}else{drop->FindGWP()}\n\t[]FakeA!A.B.tag_i.search->\n\t  FakeB?B.A.t.ack.gwId->\n\t  if(t==tag_gp){\n\t  \t{gatewayp_fake_success=true;}->FindGWP()\n\t  }else{FindGWP()};\n\t\n/*@Process: Connect\n\tAfter finding a gateway, the Publisher attempts to connect to it \n\t1. It sends a connect request to the gateway\n\t2. And waits for the response\n\t3. Similar to finding a gateway,it requires a valid acknowledgement from the Gateway to proceed, otherwise, it may fail and retry connecting to it.\n*/\nConnect() =\n\tComPP!A.B.tag_p.connect->\n\tComPP?B.A.t.ack{call(getGWP,tag_gp,t)} ->\n\tif(isLegalGWP==true){\n\t\tif(ack == true) {Skip} else{fail->Connect()}\n\t}else{drop->Connect()}\n\t[]FakeA!A.B.tag_i.connect->\n\t  FakeB?B.A.t.ack->\n\t  if(t==tag_gp){\n\t  \t{gatewayp_fake_success=true;}->Connect()\n\t  }else{Connect()};\n\n/*@Process: TopicReg\n\tRegister a topic to the gateway\n\t1. It sends a register request with topic name to the gateway and waits for the response\n\t2. The publisher receives a topic ID if registration is successful, otherwise, it fails and retries.\n*/\nTopicReg() =\n\tComPP!A.B.reg.tag_p.name->\n\tComPP?B.A.t.ack.topicId{call(getGWP,tag_gp,t)} ->\n\tif(isLegalGWP==true){\n\t\tif(ack == true) {Skip} else{fail->TopicReg()}\n\t}else{drop->TopicReg()}\n\t[]FakeA!A.B.reg.tag_i.name->\n\t  FakeB?B.A.t.ack.topicId->\n\t  if(t==tag_gp){\n\t  \t{gatewayp_fake_success=true;}->TopicReg()\n\t  }else{TopicReg()};\n\n/*@Process: MsgPub\nPublish data:\n\t1. The Publisher publishes data to a registered topic and waits for acknowledgement\n\t2. A valid acknowledgment from the Gateway is needed, otherwise, it fails and retries publishing.\n*/\nMsgPub() =\n\tComPP!A.B.pub.tag_p.data->\n\tComPP?B.A.t.ack{call(getGWP,tag_gp,t)}->\n\tif(isLegalGWP==true){\n\t\tif(ack == true) {MsgPub()} else{fail->MsgPub()}\n\t}else{drop->MsgPub()}\n  []ComPP!A.B.tag_p.disconnect ->\n\tComPP?B.A.t.ack{call(getGWP,tag_gp,t)} ->\n\tif(isLegalGWP==true){\n\t\tif(ack == true) {Skip} else{fail->MsgPub()}\n\t}else{drop->MsgPub()}\n  []FakeA!A.B.pub.tag_i.data->\n\t  FakeB?B.A.t.ack->\n\t  if(t==tag_gp){\n\t  \t{gatewayp_fake_success=true;}->MsgPub()\n\t  }else{MsgPub()}\n  []FakeA!A.B.tag_i.disconnect->\n\t  FakeB?B.A.t.ack->\n\t  if(t==tag_gp){\n\t  \t{gatewayp_fake_success=true;}->MsgPub()\n\t  }else{MsgPub()};\n\n/*@Process: Subscriber\n The subscriber behaves like the publisher and executes three steps: Find a subscriber gateway, connects to it and subscribe messages.\n*/\nSubscriber()= FindGWS();ConnectS();MsgSub();Subscriber();\n\n/*@Process: FindGWS\n  Finding a subscriber gateway\n  1. First, The Subscriber first attempts to find a valid subscriber gateway and waits for acknowledgement.\n\t2. If a valid acknowledgment with a valid gateway ID is received, it proceeds; otherwise, it may fail and retry finding a gateway. \n*/\nFindGWS()= \n\tComSS!E.D.tag_s.search ->\n\tComSS?D.E.t.ack.gwId{call(getGWS,tag_gs,t)} ->\n\tif(isLegalGWS==true){\n\t\tif(ack == true) {Skip} else{fail->FindGWS()}\n\t}else{drop->FindGWS()}\n\t[] FakeE!E.D.tag_i.search ->\n\t   FakeD?D.E.t.ack.gwId->\n\t   if(t==tag_gs){\n\t  \t{gateways_fake_success=true;}->FindGWS()\n\t  }else{FindGWS()};\n\n/*@Process: ConnectS\n1. After finding a gateway, the Subscriber attempts to connect to it.\n\t2. Similar to finding a gateway, it requires a valid acknowledgement from the Gateway to proceeds to message subscription phase. Otherwise, it fails and retries connecting.\n*/\nConnectS()=\n\tComSS!E.D.tag_s.connect ->\n\tComSS?D.E.t.ack{call(getGWS,tag_gs,t)} ->\n\tif(isLegalGWS==true){\n\t\tif(ack == true) {Skip} else{fail->ConnectS()}\n\t}else{drop->ConnectS()}\n\t[] FakeE!E.D.tag_i.connect ->\n\t   FakeD?D.E.t.ack->\n\t   if(t==tag_gs){\n\t  \t{gateways_fake_success=true;}->ConnectS()\n\t  }else{ConnectS()};\n\n/*@Process: MsgSub\n\tIn the message subscription phase, the process may do one of these things:\n\t  - The subscriber subscribes to a topic. If a subscription is successful, it continues subscribing message, otherwise, it fails and retries.\n\t\t- The subscriber process can disconnect to the gateway by sending disconnect message. The disconnect operation also requires acknowledgement from the gateway.\n\t\t- The subscriber may receive update messages from the gateway and update the data. \n*/\nMsgSub()=\n     ComSS!E.D.sub.tag_s.topic ->\n     ComSS?D.E.t.ack{call(getGWS,tag_gs,t)} ->\n\tif(isLegalGWS==true){\n\t\tif(ack == true) {MsgSub()} else{fail->MsgSub()}\n\t}else{drop->MsgSub()}\n  []ComSS!E.D.tag_s.disconnect->\n\tComSS?D.E.t.ack{call(getGWS,tag_gs,t)} ->\n\tif(isLegalGWS==true){\n\t\tif(ack == true) {Skip} else{fail->MsgSub()}\n\t}else{drop->MsgSub()}\n  []ComSS?D.E.update.t.data{call(getGWS,tag_gs,t)} ->\n\tif(isLegalGWS==true) {\n\t\tComSS!E.D.tag_s.true{data_reachability=true;}->MsgSub()\n\t}else {ComSS!E.D.tag_s.false->MsgSub()}\n  [] FakeE!E.D.sub.tag_i.topic ->\n\t FakeD?D.E.t.ack->\n\t   if(t==tag_gs){\n\t  \t{gateways_fake_success=true;}->MsgSub()\n\t  }else{MsgSub()}\n  [] FakeE!E.D.tag_i.disconnect ->\n\t FakeD?D.E.t.ack->\n\t   if(t==tag_gs){\n\t  \t{gateways_fake_success=true;}->MsgSub()\n\t  }else{MsgSub()}\n  [] FakeD?D.E.update.t.data->\n     if(tag_gs==t){\n     \t{gateways_fake_success=true;}->MsgSub()\n     }else{MsgSub()};\n\n/*@Process: GatewayP\n  The publisher gateway may receives several types of request from the publisher and responds to each of them. For each request, it authenticates the Publisher checking if the provided tag matches the expected tag_p. \n\tIf the Publisher is authenticated:\n\t- Search: it responds with the gateway ID.\n\t- Registration: it registers the topic (if it doesn't exist) and responds with a topic ID. The topic information is stored into a Hashtable.\n  - Connection, publishing and disconnection: it forwards these requests to the Broker and waits for an acknowledgement from the Broker and responds to the publisher with the ack from the broker.\n\tIf the Publisher is not authenticated, it sends an error message back to the Publisher.\n*/\nGatewayP()=\n       ComPP?A.B.t.search{call(getPub,tag_p,t)}->\n       if(isLegalPub==true) {ComPP!B.A.tag_gp.true.gwId -> GatewayP()} \n       else{ComPP!B.A.tag_gp.false.none -> GatewayP()}\n  []ComPP?A.B.reg.t.name{call(getPub,tag_p,t)} ->\n       if(isLegalPub==true){\n\t\t\tif(TpcTable.ContainsKey(name)){\n\t\t\t\tComPP!B.A.tag_gp.true.TpcTable.GetValue(name)->GatewayP()\n\t\t\t}else{\n\t\t\t\t{TpcTable.Add(name,topicId);}->ComPP!B.A.tag_gp.true.TpcTable.GetValue(name)->GatewayP()\n\t\t\t}\n       }\n       else{ComPP!B.A.tag_gp.false.none -> GatewayP()}\n  []ComPP?A.B.t.connect{call(getPub,tag_p,t)}->\n       if(isLegalPub==true) {ComBP!B.C.tag_gp.connect->ComBP?C.B.t.ack{call(getBroker,tag_b,t)}->\n       \t\tif(isLegalBroker==true){\n       \t\t\tComPP!B.A.tag_gp.ack->GatewayP()\n       \t\t}else{ComPP!B.A.tag_gp.false->GatewayP()}\n       }else{ComPP!B.A.tag_gp.false -> GatewayP()}\n  []ComPP?A.B.pub.t.data{call(getPub,tag_p,t)}->\n       if(isLegalPub==true) {ComBP!B.C.pub.tag_gp.data->ComBP?C.B.t.ack{call(getBroker,tag_b,t)}->\n       \t\tif(isLegalBroker==true){\n       \t\t\tComPP!B.A.tag_gp.ack->GatewayP()\n       \t\t}else{ComPP!B.A.tag_gp.false->GatewayP()}\n       }else{ComPP!B.A.tag_gp.false -> GatewayP()}\n  []ComPP?A.B.t.disconnect{call(getPub,tag_p,t)}->\n       if(isLegalPub==true) {ComBP!B.C.tag_gp.disconnect->ComBP?C.B.t.ack{call(getBroker,tag_b,t)}->\n       \t\tif(isLegalBroker==true){\n       \t\t\tComPP!B.A.tag_gp.ack->GatewayP()\n       \t\t}else{ComPP!B.A.tag_gp.false->GatewayP()}\n       }else{ComPP!B.A.tag_gp.false -> GatewayP()}\n  []FakeB!B.C.tag_i.connect->FakeC?C.B.t.ack->\n      if(tag_b==t){\n       \t{broker_fake_success=true;}->GatewayP()\n      }else{GatewayP()}\n  []FakeB!B.C.pub.tag_i.data->FakeC?C.B.t.ack->\n      if(tag_b==t){\n       \t{broker_fake_success=true;}->GatewayP()\n      }else{GatewayP()}\n  []FakeB!B.C.tag_i.disconnect->FakeC?C.B.t.ack->\n      if(tag_b==t){\n       \t{broker_fake_success=true;}->GatewayP()\n      }else{GatewayP()};\n  \n/*@Process: GatewayS\n\tThe subscriber gateway may receives several types of request from the subscriber and responds to each of them. For each request, it authenticates the subscriber checking if the provided tag matches the expected tag_p. \n\tIf the subscriber is authenticated:\n\t- Search: it responds with the gateway ID.\n\t- Connection, subscription and disconnection: it forwards these requests to the Broker and waits for an acknowledgement from the Broker and responds to the publisher with the ack from the broker.\n\t- Update from the Broker: the gateway checks if the subscriber is legal and sends data to subscriber.\n  If the Subscriber is not authenticated, it sends an error message back to the Subscriber.\n*/\nGatewayS()=\n       ComSS?E.D.t.search{call(getSub,tag_s,t)}->\n       if(isLegalSub==true) {ComSS!D.E.tag_gs.true.gwId -> GatewayS()} \n       else{ComSS!D.E.tag_gs.false.none -> GatewayS()}\n  []ComSS?E.D.t.connect{call(getSub,tag_s,t)}->\n       if(isLegalSub==true) {ComBS!D.C.tag_gs.connect->ComBS?C.D.t.ack{call(getBroker,tag_b,t)}->\n       \t\tif(isLegalBroker==true){\n       \t\t\tComSS!D.E.tag_gs.ack->GatewayS()\n       \t\t}else{ComSS!D.E.tag_gs.false->GatewayS()}\n       }else{ComSS!D.E.tag_gs.false -> GatewayS()}\n  []ComSS?E.D.sub.t.topic{call(getSub,tag_s,t)}->\n       if(isLegalSub==true) {ComBS!D.C.sub.tag_gs.topic->ComBS?C.D.t.ack{call(getBroker,tag_b,t)}->\n       \t\tif(isLegalBroker==true){\n       \t\t\tComSS!D.E.tag_gs.ack->GatewayS()\n       \t\t}else{ComSS!D.E.tag_gs.false->GatewayS()}\n       }else{ComSS!D.E.tag_gs.false -> GatewayS()}\n  []ComSS?E.D.t.disconnect{call(getSub,tag_s,t)}->\n       if(isLegalSub==true) {ComBS!D.C.tag_gs.disconnect->ComBS?C.D.t.ack{call(getBroker,tag_b,t)}->\n       \t\tif(isLegalBroker==true){\n       \t\t\tComSS!D.E.tag_gs.ack->GatewayS()\n       \t\t}else{ComSS!D.E.tag_gs.false->GatewayS()}\n       }else{ComSS!D.E.tag_gs.false -> GatewayS()}\n  []ComBS?C.D.update.t.data{call(getBroker,tag_b,t)} ->\n       if(isLegalBroker==true) {ComSS!D.E.update.tag_gs.data->ComSS?E.D.t.ack{call(getSub,tag_s,t)}->\n       \t\tif(isLegalSub==true){ComBS!D.C.tag_gs.ack->GatewayS()\n       \t\t}else{ComBS!D.C.tag_gs.false->GatewayS()}\n       }else {ComBS!D.C.tag_gs.false->GatewayS()}\n  []FakeC?C.D.update.t.data ->\n\t  \tif(tag_b==t){\n\t  \t\t{broker_fake_success=true;}->GatewayS()\n\t  \t}else{GatewayS()};\n\n/*@Process: Broker\n  Broker process acts as a central hub:\n  1. The Broker receives connection, disconnection, publish, and subscribe requests from publisher gateway and subscriber gateway.\n\t2. For each request, it authenticates the Gateway, checking if the provided tag matches the expected\n  3. If the gateway is authenticated, it acknowledges the request and it sends an error message back to the gateway.\n*/\nBroker()=\n       ComBP?B.C.t.connect{call(getGWP,tag_gp,t)}->\n       if(isLegalGWP==true) {ComBP!C.B.tag_b.true ->Broker()}\n       else {ComBP!C.B.tag_b.false ->Broker()}\n  []ComBP?B.C.t.disconnect{call(getGWP,tag_gp,t)}->\n       if(isLegalGWP==true) {ComBP!C.B.tag_b.true ->Broker()}\n       else {ComBP!C.B.tag_b.false->Broker()}\n  []ComBS?D.C.t.connect{call(getGWS,tag_gs,t)}->\n       if(isLegalGWS==true) {ComBS!C.D.tag_b.true->Broker()}\n       else {ComBS!C.D.tag_b.false ->Broker()}\n  []ComBS?D.C.t.disconnect{call(getGWS,tag_gs,t)}->\n       if(isLegalGWS==true) {ComBS!C.D.tag_b.true ->Broker()}\n       else {ComBS!C.D.tag_b.false ->Broker()}\n  []ComBP?B.C.pub.t.data{call(getGWP,tag_gp,t)}->\n       if(isLegalGWP==true) {ComBP!C.B.tag_b.true{data_reachability=true;}->Broker()}\n       else {ComBP!C.B.tag_b.false ->Broker()}\n  []ComBS?D.C.sub.t.topic{call(getGWS,tag_gs,t)}->\n       if(isLegalGWS==true) {ComBS!C.D.tag_b.true{data_reachability=true;}->Broker()}\n       else {ComBS!C.D.tag_b.false->Broker()}\n  []ComBS!C.D.update.tag_b.data->\n  \tComBS?D.C.t.ack{call(getGWS,tag_gp,t)}->\n       if(isLegalGWS==true){\n       \t\tif(ack == true) {Broker()} else{fail->Broker()}\n       }else{drop->Broker()}\n  []FakeC!C.D.update.tag_i.data->Broker();\n \n /*@Process: Intruder\n  In this model, we assume that intruders can intercept or fake messages via normal communication channels ComPP, ComBP, ComSS and ComBS.\n  - The intruder can get the encrypted message E(k,d) if it has the encryption key k and the data d. \n  - The intruder can get the plaintext d if it has the decryption key sk and the encrypted message E(sk,d). \n  - If the fact f can be deduced from the fact set F,andF is a subset of F\u2019, then the intruder can also deduce f from the bigger set F\u2019.\n */\nIntruder() = \n\tFakeA?A.B.t.search->\n\t\tif(tag_p==t) {\n\t\t\t{publisher_fake_success=true;data_leakage_success = true;}->FakeB!B.A.tag_i.true.gwId->Intruder()\n\t\t}else {FakeB!B.A.tag_i.true.gwId->Intruder()}\n\t[] FakeA?A.B.t.connect->\n\t\tif(tag_p==t) {\n\t\t\t{publisher_fake_success=true;data_leakage_success = true;}->FakeB!B.A.tag_i.true->Intruder()\n\t\t}else {FakeB!B.A.tag_i.true->Intruder()}\n\t[] FakeA?A.B.reg.t.name->\n\t\tif(tag_p==t) {\n\t\t\t{publisher_fake_success=true;data_leakage_success = true;}->FakeB!B.A.tag_i.true.topicId->Intruder()\n\t\t}else {FakeB!B.A.tag_i.true.topicId->Intruder()}\n\t[] FakeA?A.B.pub.t.data{call(getPub,tag_p,t)}->\n\t\tif(tag_p==t) {\n\t\t\t{publisher_fake_success=true;data_leakage_success = true;}->FakeB!B.A.tag_i.true->Intruder()\n\t\t}else {FakeB!B.A.tag_i.true->Intruder()}\n\t[] FakeA?A.B.t.disconnect{call(getPub,tag_p,t)}->\n\t\tif(tag_p==t) {\n\t\t\t{publisher_fake_success=true;data_leakage_success = true;}->FakeB!B.A.tag_i.true->Intruder()\n\t\t}else {FakeB!B.A.tag_i.true->Intruder()}\n  \t[] FakeE?E.D.t.search->\n\t\tif(tag_s==t) {\n\t\t\t{subscriber_fake_success=true;data_leakage_success = true;}->FakeD!D.E.tag_i.true.gwId->Intruder()\n\t\t}else {FakeD!D.E.tag_i.true.gwId->Intruder()}\n  \t[] FakeE?E.D.t.connect->\n\t\tif(tag_s==t) {\n\t\t\t{subscriber_fake_success=true;data_leakage_success = true;}->FakeD!D.E.tag_i.true->Intruder()\n\t\t}else {FakeD!D.E.tag_i.true->Intruder()}\n  \t[] FakeE?E.D.t.disconnect->\n\t\tif(tag_s==t) {\n\t\t\t{subscriber_fake_success=true;data_leakage_success = true;}->FakeD!D.E.tag_i.true->Intruder()\n\t\t}else {FakeD!D.E.tag_i.true->Intruder()}\n  \t[] FakeE?E.D.sub.t.topic->\n\t\tif(tag_s==t) {\n\t\t\t{subscriber_fake_success=true;data_leakage_success = true;}->FakeD!D.E.tag_i.true->Intruder()\n\t\t}else {FakeD!D.E.tag_i.true->Intruder()}\n  \t[] FakeD!D.E.update.tag_i.data->Intruder()\n  \t[] FakeB?B.C.t.connect->FakeC!C.B.tag_i.true->Intruder()\n  \t[] FakeB?B.C.pub.t.data->FakeC!C.B.tag_i.true->Intruder()\n  \t[] FakeB?B.C.t.disconnect->FakeC!C.B.tag_i.true->Intruder();\n  \n/*@Process: SYSTEM\n\t\tThere are four main entities in MQTT-SN communication: clients(publisher and subscriber), gateways, and brokers.\n   While the publisher and subscribe communicates with its own gateway and broker.\n   It also includes an INTRUDER process that attempts to compromise the system.\n*/\nSYSTEM() = (Publisher() || GatewayP() || Broker()) || (Subscriber() || GatewayS() || Broker()) || Intruder();",
        "property_desc": [
            "The system is deadlock-free.",
            "The system is divergencefree-free.",
            "All the messages published by the clients and all the requests sent by the clients can be successfully received and processed by the broker server.",
            "Intruders cannot impersonate publishers or subscribers to communicate with other entities in the system.",
            "Intruders are unable to pretend to be gateways.",
            "Intruders cannot impersonate brokers to communicate in the system.",
            "Intruders can obtain, use or share plaintext data during the communication process."
        ],
        "properties": [
            "#assert SYSTEM deadlockfree;",
            "#assert SYSTEM divergencefree;",
            "#define Data_Reachability_Success data_reachability == true;\n#assert SYSTEM reaches Data_Reachability_Success;",
            "#define client_fake_success (publisher_fake_success || subscriber_fake_success);\n#define Client_Fake_Success client_fake_success==true;\n#assert SYSTEM |=[]! Client_Fake_Success;",
            "#define gateway_fake_success (gatewayp_fake_success || gateways_fake_success);\n#define Gateway_Fake_Success gateway_fake_success==true;\n#assert SYSTEM |=[]! Gateway_Fake_Success;",
            "#define Broker_Fake_Success broker_fake_success==true;\n#assert SYSTEM |=[]! Broker_Fake_Success;",
            "#define Data_Leakage_Success data_leakage_success ==true;\n#assert SYSTEM |=[]! Data_Leakage_Success;"
        ],
        "processes": [
            {
                "name": "Publisher",
                "description": "The publisher executes the four steps: Searchs for a publisher gateway, attempts to connect to it, register topics and publish data",
                "pat_code": "Publisher() = FindGWP(); Connect(); TopicReg(); MsgPub(); Publisher();"
            },
            {
                "name": "FindGWP",
                "description": "The publisher searches for a publisher gateway\n\t1. It sends a search packet to search the publisher gateway.\n\t2. It waits for reponses from the gateway.\n\t3. If a valid acknowledgment with a valid gateway ID is received, it proceeds, otherwise, it may fail and retry finding a gateway.",
                "pat_code": "FindGWP()= \n\tComPP!A.B.tag_p.search ->\n\tComPP?B.A.t.ack.gwId{call(getGWP,tag_gp,t)} ->\n\tif(isLegalGWP==true){\n\t\tif(ack == true) {Skip} else{fail->FindGWP()}\n\t}else{drop->FindGWP()}\n\t[]FakeA!A.B.tag_i.search->\n\t  FakeB?B.A.t.ack.gwId->\n\t  if(t==tag_gp){\n\t  \t{gatewayp_fake_success=true;}->FindGWP()\n\t  }else{FindGWP()};"
            },
            {
                "name": "Connect",
                "description": "After finding a gateway, the Publisher attempts to connect to it \n\t1. It sends a connect request to the gateway\n\t2. And waits for the response\n\t3. Similar to finding a gateway,it requires a valid acknowledgement from the Gateway to proceed, otherwise, it may fail and retry connecting to it.",
                "pat_code": "Connect() =\n\tComPP!A.B.tag_p.connect->\n\tComPP?B.A.t.ack{call(getGWP,tag_gp,t)} ->\n\tif(isLegalGWP==true){\n\t\tif(ack == true) {Skip} else{fail->Connect()}\n\t}else{drop->Connect()}\n\t[]FakeA!A.B.tag_i.connect->\n\t  FakeB?B.A.t.ack->\n\t  if(t==tag_gp){\n\t  \t{gatewayp_fake_success=true;}->Connect()\n\t  }else{Connect()};"
            },
            {
                "name": "TopicReg",
                "description": "Register a topic to the gateway\n\t1. It sends a register request with topic name to the gateway and waits for the response\n\t2. The publisher receives a topic ID if registration is successful, otherwise, it fails and retries.",
                "pat_code": "TopicReg() =\n\tComPP!A.B.reg.tag_p.name->\n\tComPP?B.A.t.ack.topicId{call(getGWP,tag_gp,t)} ->\n\tif(isLegalGWP==true){\n\t\tif(ack == true) {Skip} else{fail->TopicReg()}\n\t}else{drop->TopicReg()}\n\t[]FakeA!A.B.reg.tag_i.name->\n\t  FakeB?B.A.t.ack.topicId->\n\t  if(t==tag_gp){\n\t  \t{gatewayp_fake_success=true;}->TopicReg()\n\t  }else{TopicReg()};"
            },
            {
                "name": "MsgPub",
                "description": "Publish data:\n\t1. The Publisher publishes data to a registered topic and waits for acknowledgement\n\t2. A valid acknowledgment from the Gateway is needed, otherwise, it fails and retries publishing.",
                "pat_code": "MsgPub() =\n\tComPP!A.B.pub.tag_p.data->\n\tComPP?B.A.t.ack{call(getGWP,tag_gp,t)}->\n\tif(isLegalGWP==true){\n\t\tif(ack == true) {MsgPub()} else{fail->MsgPub()}\n\t}else{drop->MsgPub()}\n  []ComPP!A.B.tag_p.disconnect ->\n\tComPP?B.A.t.ack{call(getGWP,tag_gp,t)} ->\n\tif(isLegalGWP==true){\n\t\tif(ack == true) {Skip} else{fail->MsgPub()}\n\t}else{drop->MsgPub()}\n  []FakeA!A.B.pub.tag_i.data->\n\t  FakeB?B.A.t.ack->\n\t  if(t==tag_gp){\n\t  \t{gatewayp_fake_success=true;}->MsgPub()\n\t  }else{MsgPub()}\n  []FakeA!A.B.tag_i.disconnect->\n\t  FakeB?B.A.t.ack->\n\t  if(t==tag_gp){\n\t  \t{gatewayp_fake_success=true;}->MsgPub()\n\t  }else{MsgPub()};"
            },
            {
                "name": "Subscriber",
                "description": "The subscriber behaves like the publisher and executes three steps: Find a subscriber gateway, connects to it and subscribe messages.",
                "pat_code": "Subscriber()= FindGWS();ConnectS();MsgSub();Subscriber();"
            },
            {
                "name": "FindGWS",
                "description": "Finding a subscriber gateway\n  1. First, The Subscriber first attempts to find a valid subscriber gateway and waits for acknowledgement.\n\t2. If a valid acknowledgment with a valid gateway ID is received, it proceeds; otherwise, it may fail and retry finding a gateway.",
                "pat_code": "FindGWS()= \n\tComSS!E.D.tag_s.search ->\n\tComSS?D.E.t.ack.gwId{call(getGWS,tag_gs,t)} ->\n\tif(isLegalGWS==true){\n\t\tif(ack == true) {Skip} else{fail->FindGWS()}\n\t}else{drop->FindGWS()}\n\t[] FakeE!E.D.tag_i.search ->\n\t   FakeD?D.E.t.ack.gwId->\n\t   if(t==tag_gs){\n\t  \t{gateways_fake_success=true;}->FindGWS()\n\t  }else{FindGWS()};"
            },
            {
                "name": "ConnectS",
                "description": "1. After finding a gateway, the Subscriber attempts to connect to it.\n\t2. Similar to finding a gateway, it requires a valid acknowledgement from the Gateway to proceeds to message subscription phase. Otherwise, it fails and retries connecting.",
                "pat_code": "ConnectS()=\n\tComSS!E.D.tag_s.connect ->\n\tComSS?D.E.t.ack{call(getGWS,tag_gs,t)} ->\n\tif(isLegalGWS==true){\n\t\tif(ack == true) {Skip} else{fail->ConnectS()}\n\t}else{drop->ConnectS()}\n\t[] FakeE!E.D.tag_i.connect ->\n\t   FakeD?D.E.t.ack->\n\t   if(t==tag_gs){\n\t  \t{gateways_fake_success=true;}->ConnectS()\n\t  }else{ConnectS()};"
            },
            {
                "name": "MsgSub",
                "description": "In the message subscription phase, the process may do one of these things:\n\t  - The subscriber subscribes to a topic. If a subscription is successful, it continues subscribing message, otherwise, it fails and retries.\n\t\t- The subscriber process can disconnect to the gateway by sending disconnect message. The disconnect operation also requires acknowledgement from the gateway.\n\t\t- The subscriber may receive update messages from the gateway and update the data.",
                "pat_code": "MsgSub()=\n     ComSS!E.D.sub.tag_s.topic ->\n     ComSS?D.E.t.ack{call(getGWS,tag_gs,t)} ->\n\tif(isLegalGWS==true){\n\t\tif(ack == true) {MsgSub()} else{fail->MsgSub()}\n\t}else{drop->MsgSub()}\n  []ComSS!E.D.tag_s.disconnect->\n\tComSS?D.E.t.ack{call(getGWS,tag_gs,t)} ->\n\tif(isLegalGWS==true){\n\t\tif(ack == true) {Skip} else{fail->MsgSub()}\n\t}else{drop->MsgSub()}\n  []ComSS?D.E.update.t.data{call(getGWS,tag_gs,t)} ->\n\tif(isLegalGWS==true) {\n\t\tComSS!E.D.tag_s.true{data_reachability=true;}->MsgSub()\n\t}else {ComSS!E.D.tag_s.false->MsgSub()}\n  [] FakeE!E.D.sub.tag_i.topic ->\n\t FakeD?D.E.t.ack->\n\t   if(t==tag_gs){\n\t  \t{gateways_fake_success=true;}->MsgSub()\n\t  }else{MsgSub()}\n  [] FakeE!E.D.tag_i.disconnect ->\n\t FakeD?D.E.t.ack->\n\t   if(t==tag_gs){\n\t  \t{gateways_fake_success=true;}->MsgSub()\n\t  }else{MsgSub()}\n  [] FakeD?D.E.update.t.data->\n     if(tag_gs==t){\n     \t{gateways_fake_success=true;}->MsgSub()\n     }else{MsgSub()};"
            },
            {
                "name": "GatewayP",
                "description": "The publisher gateway may receives several types of request from the publisher and responds to each of them. For each request, it authenticates the Publisher checking if the provided tag matches the expected tag_p. \n\tIf the Publisher is authenticated:\n\t- Search: it responds with the gateway ID.\n\t- Registration: it registers the topic (if it doesn't exist) and responds with a topic ID. The topic information is stored into a Hashtable.\n  - Connection, publishing and disconnection: it forwards these requests to the Broker and waits for an acknowledgement from the Broker and responds to the publisher with the ack from the broker.\n\tIf the Publisher is not authenticated, it sends an error message back to the Publisher.",
                "pat_code": "GatewayP()=\n       ComPP?A.B.t.search{call(getPub,tag_p,t)}->\n       if(isLegalPub==true) {ComPP!B.A.tag_gp.true.gwId -> GatewayP()} \n       else{ComPP!B.A.tag_gp.false.none -> GatewayP()}\n  []ComPP?A.B.reg.t.name{call(getPub,tag_p,t)} ->\n       if(isLegalPub==true){\n\t\t\tif(TpcTable.ContainsKey(name)){\n\t\t\t\tComPP!B.A.tag_gp.true.TpcTable.GetValue(name)->GatewayP()\n\t\t\t}else{\n\t\t\t\t{TpcTable.Add(name,topicId);}->ComPP!B.A.tag_gp.true.TpcTable.GetValue(name)->GatewayP()\n\t\t\t}\n       }\n       else{ComPP!B.A.tag_gp.false.none -> GatewayP()}\n  []ComPP?A.B.t.connect{call(getPub,tag_p,t)}->\n       if(isLegalPub==true) {ComBP!B.C.tag_gp.connect->ComBP?C.B.t.ack{call(getBroker,tag_b,t)}->\n       \t\tif(isLegalBroker==true){\n       \t\t\tComPP!B.A.tag_gp.ack->GatewayP()\n       \t\t}else{ComPP!B.A.tag_gp.false->GatewayP()}\n       }else{ComPP!B.A.tag_gp.false -> GatewayP()}\n  []ComPP?A.B.pub.t.data{call(getPub,tag_p,t)}->\n       if(isLegalPub==true) {ComBP!B.C.pub.tag_gp.data->ComBP?C.B.t.ack{call(getBroker,tag_b,t)}->\n       \t\tif(isLegalBroker==true){\n       \t\t\tComPP!B.A.tag_gp.ack->GatewayP()\n       \t\t}else{ComPP!B.A.tag_gp.false->GatewayP()}\n       }else{ComPP!B.A.tag_gp.false -> GatewayP()}\n  []ComPP?A.B.t.disconnect{call(getPub,tag_p,t)}->\n       if(isLegalPub==true) {ComBP!B.C.tag_gp.disconnect->ComBP?C.B.t.ack{call(getBroker,tag_b,t)}->\n       \t\tif(isLegalBroker==true){\n       \t\t\tComPP!B.A.tag_gp.ack->GatewayP()\n       \t\t}else{ComPP!B.A.tag_gp.false->GatewayP()}\n       }else{ComPP!B.A.tag_gp.false -> GatewayP()}\n  []FakeB!B.C.tag_i.connect->FakeC?C.B.t.ack->\n      if(tag_b==t){\n       \t{broker_fake_success=true;}->GatewayP()\n      }else{GatewayP()}\n  []FakeB!B.C.pub.tag_i.data->FakeC?C.B.t.ack->\n      if(tag_b==t){\n       \t{broker_fake_success=true;}->GatewayP()\n      }else{GatewayP()}\n  []FakeB!B.C.tag_i.disconnect->FakeC?C.B.t.ack->\n      if(tag_b==t){\n       \t{broker_fake_success=true;}->GatewayP()\n      }else{GatewayP()};"
            },
            {
                "name": "GatewayS",
                "description": "The subscriber gateway may receives several types of request from the subscriber and responds to each of them. For each request, it authenticates the subscriber checking if the provided tag matches the expected tag_p. \n\tIf the subscriber is authenticated:\n\t- Search: it responds with the gateway ID.\n\t- Connection, subscription and disconnection: it forwards these requests to the Broker and waits for an acknowledgement from the Broker and responds to the publisher with the ack from the broker.\n\t- Update from the Broker: the gateway checks if the subscriber is legal and sends data to subscriber.\n  If the Subscriber is not authenticated, it sends an error message back to the Subscriber.",
                "pat_code": "GatewayS()=\n       ComSS?E.D.t.search{call(getSub,tag_s,t)}->\n       if(isLegalSub==true) {ComSS!D.E.tag_gs.true.gwId -> GatewayS()} \n       else{ComSS!D.E.tag_gs.false.none -> GatewayS()}\n  []ComSS?E.D.t.connect{call(getSub,tag_s,t)}->\n       if(isLegalSub==true) {ComBS!D.C.tag_gs.connect->ComBS?C.D.t.ack{call(getBroker,tag_b,t)}->\n       \t\tif(isLegalBroker==true){\n       \t\t\tComSS!D.E.tag_gs.ack->GatewayS()\n       \t\t}else{ComSS!D.E.tag_gs.false->GatewayS()}\n       }else{ComSS!D.E.tag_gs.false -> GatewayS()}\n  []ComSS?E.D.sub.t.topic{call(getSub,tag_s,t)}->\n       if(isLegalSub==true) {ComBS!D.C.sub.tag_gs.topic->ComBS?C.D.t.ack{call(getBroker,tag_b,t)}->\n       \t\tif(isLegalBroker==true){\n       \t\t\tComSS!D.E.tag_gs.ack->GatewayS()\n       \t\t}else{ComSS!D.E.tag_gs.false->GatewayS()}\n       }else{ComSS!D.E.tag_gs.false -> GatewayS()}\n  []ComSS?E.D.t.disconnect{call(getSub,tag_s,t)}->\n       if(isLegalSub==true) {ComBS!D.C.tag_gs.disconnect->ComBS?C.D.t.ack{call(getBroker,tag_b,t)}->\n       \t\tif(isLegalBroker==true){\n       \t\t\tComSS!D.E.tag_gs.ack->GatewayS()\n       \t\t}else{ComSS!D.E.tag_gs.false->GatewayS()}\n       }else{ComSS!D.E.tag_gs.false -> GatewayS()}\n  []ComBS?C.D.update.t.data{call(getBroker,tag_b,t)} ->\n       if(isLegalBroker==true) {ComSS!D.E.update.tag_gs.data->ComSS?E.D.t.ack{call(getSub,tag_s,t)}->\n       \t\tif(isLegalSub==true){ComBS!D.C.tag_gs.ack->GatewayS()\n       \t\t}else{ComBS!D.C.tag_gs.false->GatewayS()}\n       }else {ComBS!D.C.tag_gs.false->GatewayS()}\n  []FakeC?C.D.update.t.data ->\n\t  \tif(tag_b==t){\n\t  \t\t{broker_fake_success=true;}->GatewayS()\n\t  \t}else{GatewayS()};"
            },
            {
                "name": "Broker",
                "description": "Broker process acts as a central hub:\n  1. The Broker receives connection, disconnection, publish, and subscribe requests from publisher gateway and subscriber gateway.\n\t2. For each request, it authenticates the Gateway, checking if the provided tag matches the expected\n  3. If the gateway is authenticated, it acknowledges the request and it sends an error message back to the gateway.",
                "pat_code": "Broker()=\n       ComBP?B.C.t.connect{call(getGWP,tag_gp,t)}->\n       if(isLegalGWP==true) {ComBP!C.B.tag_b.true ->Broker()}\n       else {ComBP!C.B.tag_b.false ->Broker()}\n  []ComBP?B.C.t.disconnect{call(getGWP,tag_gp,t)}->\n       if(isLegalGWP==true) {ComBP!C.B.tag_b.true ->Broker()}\n       else {ComBP!C.B.tag_b.false->Broker()}\n  []ComBS?D.C.t.connect{call(getGWS,tag_gs,t)}->\n       if(isLegalGWS==true) {ComBS!C.D.tag_b.true->Broker()}\n       else {ComBS!C.D.tag_b.false ->Broker()}\n  []ComBS?D.C.t.disconnect{call(getGWS,tag_gs,t)}->\n       if(isLegalGWS==true) {ComBS!C.D.tag_b.true ->Broker()}\n       else {ComBS!C.D.tag_b.false ->Broker()}\n  []ComBP?B.C.pub.t.data{call(getGWP,tag_gp,t)}->\n       if(isLegalGWP==true) {ComBP!C.B.tag_b.true{data_reachability=true;}->Broker()}\n       else {ComBP!C.B.tag_b.false ->Broker()}\n  []ComBS?D.C.sub.t.topic{call(getGWS,tag_gs,t)}->\n       if(isLegalGWS==true) {ComBS!C.D.tag_b.true{data_reachability=true;}->Broker()}\n       else {ComBS!C.D.tag_b.false->Broker()}\n  []ComBS!C.D.update.tag_b.data->\n  \tComBS?D.C.t.ack{call(getGWS,tag_gp,t)}->\n       if(isLegalGWS==true){\n       \t\tif(ack == true) {Broker()} else{fail->Broker()}\n       }else{drop->Broker()}\n  []FakeC!C.D.update.tag_i.data->Broker();"
            },
            {
                "name": "Intruder",
                "description": "In this model, we assume that intruders can intercept or fake messages via normal communication channels ComPP, ComBP, ComSS and ComBS.\n  - The intruder can get the encrypted message E(k,d) if it has the encryption key k and the data d. \n  - The intruder can get the plaintext d if it has the decryption key sk and the encrypted message E(sk,d). \n  - If the fact f can be deduced from the fact set F,andF is a subset of F\u2019, then the intruder can also deduce f from the bigger set F\u2019.",
                "pat_code": "Intruder() = \n\tFakeA?A.B.t.search->\n\t\tif(tag_p==t) {\n\t\t\t{publisher_fake_success=true;data_leakage_success = true;}->FakeB!B.A.tag_i.true.gwId->Intruder()\n\t\t}else {FakeB!B.A.tag_i.true.gwId->Intruder()}\n\t[] FakeA?A.B.t.connect->\n\t\tif(tag_p==t) {\n\t\t\t{publisher_fake_success=true;data_leakage_success = true;}->FakeB!B.A.tag_i.true->Intruder()\n\t\t}else {FakeB!B.A.tag_i.true->Intruder()}\n\t[] FakeA?A.B.reg.t.name->\n\t\tif(tag_p==t) {\n\t\t\t{publisher_fake_success=true;data_leakage_success = true;}->FakeB!B.A.tag_i.true.topicId->Intruder()\n\t\t}else {FakeB!B.A.tag_i.true.topicId->Intruder()}\n\t[] FakeA?A.B.pub.t.data{call(getPub,tag_p,t)}->\n\t\tif(tag_p==t) {\n\t\t\t{publisher_fake_success=true;data_leakage_success = true;}->FakeB!B.A.tag_i.true->Intruder()\n\t\t}else {FakeB!B.A.tag_i.true->Intruder()}\n\t[] FakeA?A.B.t.disconnect{call(getPub,tag_p,t)}->\n\t\tif(tag_p==t) {\n\t\t\t{publisher_fake_success=true;data_leakage_success = true;}->FakeB!B.A.tag_i.true->Intruder()\n\t\t}else {FakeB!B.A.tag_i.true->Intruder()}\n  \t[] FakeE?E.D.t.search->\n\t\tif(tag_s==t) {\n\t\t\t{subscriber_fake_success=true;data_leakage_success = true;}->FakeD!D.E.tag_i.true.gwId->Intruder()\n\t\t}else {FakeD!D.E.tag_i.true.gwId->Intruder()}\n  \t[] FakeE?E.D.t.connect->\n\t\tif(tag_s==t) {\n\t\t\t{subscriber_fake_success=true;data_leakage_success = true;}->FakeD!D.E.tag_i.true->Intruder()\n\t\t}else {FakeD!D.E.tag_i.true->Intruder()}\n  \t[] FakeE?E.D.t.disconnect->\n\t\tif(tag_s==t) {\n\t\t\t{subscriber_fake_success=true;data_leakage_success = true;}->FakeD!D.E.tag_i.true->Intruder()\n\t\t}else {FakeD!D.E.tag_i.true->Intruder()}\n  \t[] FakeE?E.D.sub.t.topic->\n\t\tif(tag_s==t) {\n\t\t\t{subscriber_fake_success=true;data_leakage_success = true;}->FakeD!D.E.tag_i.true->Intruder()\n\t\t}else {FakeD!D.E.tag_i.true->Intruder()}\n  \t[] FakeD!D.E.update.tag_i.data->Intruder()\n  \t[] FakeB?B.C.t.connect->FakeC!C.B.tag_i.true->Intruder()\n  \t[] FakeB?B.C.pub.t.data->FakeC!C.B.tag_i.true->Intruder()\n  \t[] FakeB?B.C.t.disconnect->FakeC!C.B.tag_i.true->Intruder();"
            },
            {
                "name": "SYSTEM",
                "description": "There are four main entities in MQTT-SN communication: clients(publisher and subscriber), gateways, and brokers.\n   While the publisher and subscribe communicates with its own gateway and broker.\n   It also includes an INTRUDER process that attempts to compromise the system.",
                "pat_code": "SYSTEM() = (Publisher() || GatewayP() || Broker()) || (Subscriber() || GatewayS() || Broker()) || Intruder();"
            }
        ],
        "global_definition": "#import \"PAT.Lib.Hashtable\";\n// topic table\nvar <HashTable> TpcTable;\n\n// channel definition\nchannel ComPP 0;channel ComBP 0;channel ComSS 0;channel ComBS 0;\nchannel FakeA 0;channel FakeB 0;channel FakeC 0;channel FakeD 0;channel FakeE 0;\n\n// request and message definition\nenum{data, name, topic};\nenum{gwId, topicId, none};\nenum{search, connect, reg, pub, sub, update, disconnect};\nenum{A, B, C, D, E};\nenum{invalid_tag, valid_tag};\n\nvar tag_p = valid_tag;var tag_s = valid_tag;\nvar tag_gp = valid_tag;var tag_gs = valid_tag;var tag_b = valid_tag;\nvar tag_i = invalid_tag;\n\n// property variables\nvar data_reachability = false;\nvar publisher_fake_success = false;var subscriber_fake_success = false;\nvar gatewayp_fake_success = false; var gateways_fake_success = false;var broker_fake_success = false;\nvar data_leakage_success = false;\n\n// authentication related variables\nvar isLegalPub;var isLegalGWP;var isLegalBroker;var isLegalSub;var isLegalGWS;\n// functions to verify the identity of entities \n#define getPub(tg1,tg){\n\tisLegalPub = false;\n\tif(tg1 == tg){isLegalPub = true;}\n};\n#define getSub(tg1,tg){\n\tisLegalSub = false;\n\tif(tg1 == tg){isLegalSub = true;}\n};\n#define getGWP(tg1,tg){\n\tisLegalGWP = false;\n\tif(tg1 == tg){isLegalGWP = true;}\n};\n#define getGWS(tg1,tg){\n\tisLegalGWS = false;\n\tif(tg1 == tg){isLegalGWS = true;}\n};\n#define getBroker(tg1,tg){\n\tisLegalBroker = false;\n\tif(tg1 == tg){isLegalBroker = true;}\n};",
        "path": "handwrite/MQTT-SN.csp"
    },
    {
        "name": "NDN",
        "tags": [
            "Protocol",
            "Attacker"
        ],
        "use_non_container_lib": false,
        "description": "Named Data Networking (NDN) is one of the leading architectures in Information-Centric Networking (ICN) that aims to resolve the existing problems in TCP/IP Internet.\n   The establishment of this access control solution is mainly based on the entities as below: Readers, Writers, Readers and writers, and Network Nodes (NN). \n   Readers and writers: They correspond to users with the read and write rights respectively. Readers want to read the encrypted data. Writers are responsible for producing the encrypted data.\n   Access Control Manager (ACM): It is introduced to control the management of the access control policy.\n   Network Nodes (NN): They guarantee content delivery to transit message between entities and ACM.",
        "pat_code": "//Assume that the Writer and Reader are separated and there is only one ACM\n#define Wn 3;\n#define Rn 2;\n#define N 5;\n#define DKn 2;\nenum{Msg_Int1,Msg_Dat1,W,M,NN,HL,Retransmit};\nenum{K_pub,K_pri,NK_e,NK_d,NK_e_f,NK_d_f,K_pub_M,K_pri_M,K_pub_I,K_pri_I,K_pub_A,K_pri_A};\nenum{Data,DataName,DK,DKName,Data_f,DataName_f,DK_f,DKName_f,NKName};\nenum{K_pub_1,K_pub_2,K_pub_3,k_pub_ACM,k_pri_ACM,k_pri_Intruder,k_pub_Intruder,K_pri_1,K_pri_2,K_pri_3,K_W,K_R};\n\nvar data_decryption_error = false;\nvar data_leakage_success = false;\nvar nk_decryption_error = false;\nvar nk_faking_success = false;\nvar nk_misjudgement = false;\nvar data_acquisition_success = false;\n\n\n#define getData1(dk1,data,nk_e,dk2,k1,nk_d,k2){if(!(k1==K_pub&&k2==K_pri&&\n((nk_e==NK_e&&nk_d==NK_d)||(nk_e==NK_e_f&&nk_d==NK_d_f))&&\n(dk1==DK&&dk2==DK)&&\n(data==Data)))\n{data_decryption_error=true}};\n\n#define getData2(dk1,data,nk_e,dk2,nk_d) {if(!(\n((nk_e==NK_e&&nk_d==NK_d)||(nk_e==NK_e_f&&nk_d==NK_d_f))&&\n(dk1==DK&&dk2==DK)&&\n(data==Data)))\n{data_decryption_error=true}\n};\n\n\n#define getNK1(k,nk_d){if(nk_d==NK_d_f)\n{nk_faking_success=true}\n};\n\n#define getNK2(k,nk_e,nk_d){if(nk_e==NK_e_f&&nk_d==NK_d_f)\n{nk_faking_success=true}\n};\n\n#define getNK3(k,k_m,nk_d,k_pub_m_local)\n{if(!(((k_pub_m_local==K_pub_M&&k_m==K_pri_M)||(k_pub_m_local==K_pub_I&&k_m==K_pri_I))))\n{nk_decryption_error=true}\nelse if(nk_d==NK_d_f)\n{nk_faking_success=true};\nif(nk_decryption_error==true&&k_pub_m_local==K_pub_I)\n{nk_misjudgement=true}\n};\n\n#define getNK4(k,k_m,nk_e,nk_d,k_pub_m_local) \n{if(!(((k_pub_m_local==K_pub_M&&k_m==K_pri_M)||(k_pub_m_local==K_pub_I&&k_m==K_pri_I))))\n{nk_decryption_error=true}\nelse if(nk_e==NK_e_f&&nk_d==NK_d_f)\n{nk_faking_success=true};\nif(nk_decryption_error==true&&k_pub_m_local==K_pub_I)\n{nk_misjudgement=true}\n};\n\n#define getNK5(k,k_m1,nk_d,k_a,k_m2,k_pub_m_local) \n{if(!(((k_pub_m_local==K_pub_M&&k_m1==K_pri_M&&k_m2==K_pub_M)||(k_pub_m_local==K_pub_I&&k_m1==K_pri_I&&k_m2==K_pub_I))))\n{nk_decryption_error=true}\nelse if(nk_d==NK_d_f)\n{nk_faking_success=true}\n};\n\n#define getNK6(k,k_m1,nk_e,nk_d,k_a,k_m2,k_pub_m_local) \n{if(!(((k_pub_m_local==K_pub_M&&k_m1==K_pri_M&&k_m2==K_pub_M)||(k_pub_m_local==K_pub_I&&k_m1==K_pri_I&&k_m2==K_pub_I))))\n{nk_decryption_error=true}\nelse if(nk_e==NK_e_f&&nk_d==NK_d_f)\n{nk_faking_success=true}\n};\n\nchannel ComWM 0;\nchannel ComRM 0;\nchannel FakeRM1 0;\nchannel FakeWM1 0;\nchannel FakeRM2 0;\nchannel FakeWM2 0;\n\n\n//-----------------------------------------------------------------\n/*@Process: READER\n   Read Operation Process: \n   1. Reader receives the data key and the data from ACM.\n   2. It receives an encrypted Node Key together with the data key used to encrypt the data from the ACM.\n   3. It receivre the public key and the decrypted Node Key from the ACM.\n   4. It checks for Node Key faking and decrypts the data\n   5. If data decryption is successful, it sets data_acquisition_success to true. \n*/\nREADER() =\nInitialization{nk_faking_success=false;data_acquisition_success=false} -> (\nComRM?dk1.data -> ComRM?nk_e.dk2 -> ComRM?k.nk_d{call(getNK1,k,nk_d);call(getData1,dk1,data,nk_e,dk2,k,nk_d,K_pri);if(data_decryption_error==false){data_acquisition_success=true}} -> READER()\n[]FakeRM1?dk1.data -> FakeRM1?nk_e.dk2 -> FakeRM1?k.nk_d{call(getNK1,k,nk_d);call(getData1,dk1,data,nk_e,dk2,k,nk_d,K_pri);if(data_decryption_error==false){data_acquisition_success=true}} -> READER());\n\n/*@Process: ACM_R\n   The ACM_R process is responsible for managing access control policies related to reading.\n   1. It communicates with the READER process via the ComRM channel sending the data key and the data.\n   2. It sends an encrypted Node Key together with the data key used to encrypt the data to the reader.\n   3. It sends the public key and the decrypted Node Key to the reader\n   4. It loops back to continues communicating with the reader.\n*/\nACM_R() =\nComRM!DK.Data -> ComRM!NK_e.DK -> ComRM!K_pub.NK_d -> ACM_R()\n[]FakeRM2!DK.Data -> FakeRM2!NK_e.DK -> FakeRM2!K_pub.NK_d -> ACM_R();\n\n/*@Process: WRITER\n   Write Operation Process:\n   1. It receives a Public Key, an encrypted Node Key, and a decrypted Node Key from the ACM process via ComWM.\n   2. It sends the Data Key, encrypted data to the ACM\n   3. It sends encrypted Node Key, and another Data Key used to encrypt the data to the ACM process.\n*/\nWRITER() =\nComWM?k.nk_e.nk_d{call(getNK2,k,nk_e,nk_d)} -> ComWM!DK.Data -> ComWM!nk_e.DK -> WRITER()\n[]FakeWM1?k.nk_e.nk_d{call(getNK2,k,nk_e,nk_d)} -> FakeWM1!DK.Data -> FakeWM1!nk_e.DK -> WRITER();\n\n/*@Process: ACM_W\n   The ACM_W process is responsible for managing access control policies related to writing.\n   1. It sends a Public Key, an encrypted Node Key, and a decrypted Node Key to the WRITER process via ComWM.\n   2. It receives a Data Key, encrypted data from the writer\n   3. It receives encrypted Node Key, and another Data Key used to encrypt the data from the WRITER process.\n   4. It decrypts the data using the received parameters and also checks for data decryption errors.\n   5. If data decryption is successful, it sets data_acquisition_success to true.\n*/\nACM_W() =\nComWM!K_pub.NK_e.NK_d -> ComWM?dk1.data -> ComWM?nk_e.dk2{call(getData2,dk1,data,nk_e,dk2,NK_d);if(data_decryption_error==false){data_acquisition_success=true}} -> ACM_W()\n[]FakeWM2!K_pub.NK_e.NK_d -> FakeWM2?dk1.data -> FakeWM2?nk_e.dk2{call(getData2,dk1,data,nk_e,dk2,NK_d);if(data_decryption_error==false){data_acquisition_success=true}} -> ACM_W();\n\n/*@Process: INTRUDER\n   The model also introduces a intruder\n   - It intercepts messages between ACM_R and READER via FakeRM2 and forwards potentially modified messages to READER via FakeRM1, attempting to inject a faked Node Key.\n   - It intercepts messages between ACM_W and WRITER via FakeWM2, injects a faked Node Key via FakeWM1, captures encrypted data, and attempts to decrypt it. If successful in decrypting the data using the faked key, it sets data_leakage_success to true.\n*/\nINTUDER() =\nFakeRM2?dk.data -> FakeRM1!dk.data -> FakeRM2?nk_e.dk -> FakeRM1!nk_e.dk -> FakeRM2?k.nk_d -> FakeRM1!K_pub.NK_d_f -> INTUDER()\n[]FakeWM2?k.nk_e1.nk_d1 -> FakeWM1!k.NK_e_f.NK_d_f -> FakeWM1?dk1.data -> FakeWM2!dk1.data -> FakeWM1?nk_e2.dk2{call(getData2,dk1,data,nk_e2,dk2,NK_d_f);if(data_decryption_error==false){data_leakage_success=true}} -> FakeWM2!nk_e2.dk2 -> INTUDER();\n\n/*@Process: SystemR\n  SystemR is the parallel composition of the reader the access control manager of the reader\n*/\nSystemR() = READER()||ACM_R();\n/*@Process: SystemW\n  SystemW is the parallel composition of the writer the access control manager of the writer\n*/\nSystemW() = WRITER()||ACM_W();\n/*@Process: SystemR_I\n  SystemR_I is the SystemR with the intruder\n*/\nSystemR_I() = SystemR()||INTUDER();\n/*@Process: SystemW_I\n  SystemW_I is the SystemW with the intruder\n*/\nSystemW_I() = SystemW()||INTUDER();",
        "property_desc": [
            "For reachers, the system is deadlock-free.",
            "For reachers with intruder, eventually the data can be transmitted to the entity requiring for it.",
            "For writers, whether the NK key pair can be faked successfully.",
            "For writers with intruder, whether the data can be obtained by intruders."
        ],
        "properties": [
            "#define Data_Acquisition_Success data_acquisition_success==true;\n#define Data_Leakage_Success data_leakage_success==true;\n#define NK_Faking_Success nk_faking_success==true;\n\n#assert SystemR() deadlockfree;",
            "#assert SystemR_I() |= <>Data_Acquisition_Success;",
            "#assert SystemW() |= []!NK_Faking_Success;",
            "#assert SystemW_I() |= []!Data_Leakage_Success;"
        ],
        "processes": [
            {
                "name": "READER",
                "description": "Read Operation Process: \n   1. Reader receives the data key and the data from ACM.\n   2. It receives an encrypted Node Key together with the data key used to encrypt the data from the ACM.\n   3. It receivre the public key and the decrypted Node Key from the ACM.\n   4. It checks for Node Key faking and decrypts the data\n   5. If data decryption is successful, it sets data_acquisition_success to true.",
                "pat_code": "READER() =\nInitialization{nk_faking_success=false;data_acquisition_success=false} -> (\nComRM?dk1.data -> ComRM?nk_e.dk2 -> ComRM?k.nk_d{call(getNK1,k,nk_d);call(getData1,dk1,data,nk_e,dk2,k,nk_d,K_pri);if(data_decryption_error==false){data_acquisition_success=true}} -> READER()\n[]FakeRM1?dk1.data -> FakeRM1?nk_e.dk2 -> FakeRM1?k.nk_d{call(getNK1,k,nk_d);call(getData1,dk1,data,nk_e,dk2,k,nk_d,K_pri);if(data_decryption_error==false){data_acquisition_success=true}} -> READER());"
            },
            {
                "name": "ACM_R",
                "description": "The ACM_R process is responsible for managing access control policies related to reading.\n   1. It communicates with the READER process via the ComRM channel sending the data key and the data.\n   2. It sends an encrypted Node Key together with the data key used to encrypt the data to the reader.\n   3. It sends the public key and the decrypted Node Key to the reader\n   4. It loops back to continues communicating with the reader.",
                "pat_code": "ACM_R() =\nComRM!DK.Data -> ComRM!NK_e.DK -> ComRM!K_pub.NK_d -> ACM_R()\n[]FakeRM2!DK.Data -> FakeRM2!NK_e.DK -> FakeRM2!K_pub.NK_d -> ACM_R();"
            },
            {
                "name": "WRITER",
                "description": "Write Operation Process:\n   1. It receives a Public Key, an encrypted Node Key, and a decrypted Node Key from the ACM process via ComWM.\n   2. It sends the Data Key, encrypted data to the ACM\n   3. It sends encrypted Node Key, and another Data Key used to encrypt the data to the ACM process.",
                "pat_code": "WRITER() =\nComWM?k.nk_e.nk_d{call(getNK2,k,nk_e,nk_d)} -> ComWM!DK.Data -> ComWM!nk_e.DK -> WRITER()\n[]FakeWM1?k.nk_e.nk_d{call(getNK2,k,nk_e,nk_d)} -> FakeWM1!DK.Data -> FakeWM1!nk_e.DK -> WRITER();"
            },
            {
                "name": "ACM_W",
                "description": "The ACM_W process is responsible for managing access control policies related to writing.\n   1. It sends a Public Key, an encrypted Node Key, and a decrypted Node Key to the WRITER process via ComWM.\n   2. It receives a Data Key, encrypted data from the writer\n   3. It receives encrypted Node Key, and another Data Key used to encrypt the data from the WRITER process.\n   4. It decrypts the data using the received parameters and also checks for data decryption errors.\n   5. If data decryption is successful, it sets data_acquisition_success to true.",
                "pat_code": "ACM_W() =\nComWM!K_pub.NK_e.NK_d -> ComWM?dk1.data -> ComWM?nk_e.dk2{call(getData2,dk1,data,nk_e,dk2,NK_d);if(data_decryption_error==false){data_acquisition_success=true}} -> ACM_W()\n[]FakeWM2!K_pub.NK_e.NK_d -> FakeWM2?dk1.data -> FakeWM2?nk_e.dk2{call(getData2,dk1,data,nk_e,dk2,NK_d);if(data_decryption_error==false){data_acquisition_success=true}} -> ACM_W();"
            },
            {
                "name": "INTRUDER",
                "description": "The model also introduces a intruder\n   - It intercepts messages between ACM_R and READER via FakeRM2 and forwards potentially modified messages to READER via FakeRM1, attempting to inject a faked Node Key.\n   - It intercepts messages between ACM_W and WRITER via FakeWM2, injects a faked Node Key via FakeWM1, captures encrypted data, and attempts to decrypt it. If successful in decrypting the data using the faked key, it sets data_leakage_success to true.",
                "pat_code": "INTUDER() =\nFakeRM2?dk.data -> FakeRM1!dk.data -> FakeRM2?nk_e.dk -> FakeRM1!nk_e.dk -> FakeRM2?k.nk_d -> FakeRM1!K_pub.NK_d_f -> INTUDER()\n[]FakeWM2?k.nk_e1.nk_d1 -> FakeWM1!k.NK_e_f.NK_d_f -> FakeWM1?dk1.data -> FakeWM2!dk1.data -> FakeWM1?nk_e2.dk2{call(getData2,dk1,data,nk_e2,dk2,NK_d_f);if(data_decryption_error==false){data_leakage_success=true}} -> FakeWM2!nk_e2.dk2 -> INTUDER();"
            },
            {
                "name": "SystemR",
                "description": "SystemR is the parallel composition of the reader the access control manager of the reader",
                "pat_code": "SystemR() = READER()||ACM_R();"
            },
            {
                "name": "SystemW",
                "description": "SystemW is the parallel composition of the writer the access control manager of the writer",
                "pat_code": "SystemW() = WRITER()||ACM_W();"
            },
            {
                "name": "SystemR_I",
                "description": "SystemR_I is the SystemR with the intruder",
                "pat_code": "SystemR_I() = SystemR()||INTUDER();"
            },
            {
                "name": "SystemW_I",
                "description": "SystemW_I is the SystemW with the intruder",
                "pat_code": "SystemW_I() = SystemW()||INTUDER();"
            }
        ],
        "global_definition": "//Assume that the Writer and Reader are separated and there is only one ACM\n#define Wn 3;\n#define Rn 2;\n#define N 5;\n#define DKn 2;\nenum{Msg_Int1,Msg_Dat1,W,M,NN,HL,Retransmit};\nenum{K_pub,K_pri,NK_e,NK_d,NK_e_f,NK_d_f,K_pub_M,K_pri_M,K_pub_I,K_pri_I,K_pub_A,K_pri_A};\nenum{Data,DataName,DK,DKName,Data_f,DataName_f,DK_f,DKName_f,NKName};\nenum{K_pub_1,K_pub_2,K_pub_3,k_pub_ACM,k_pri_ACM,k_pri_Intruder,k_pub_Intruder,K_pri_1,K_pri_2,K_pri_3,K_W,K_R};\n\nvar data_decryption_error = false;\nvar data_leakage_success = false;\nvar nk_decryption_error = false;\nvar nk_faking_success = false;\nvar nk_misjudgement = false;\nvar data_acquisition_success = false;\n\n\n#define getData1(dk1,data,nk_e,dk2,k1,nk_d,k2){if(!(k1==K_pub&&k2==K_pri&&\n((nk_e==NK_e&&nk_d==NK_d)||(nk_e==NK_e_f&&nk_d==NK_d_f))&&\n(dk1==DK&&dk2==DK)&&\n(data==Data)))\n{data_decryption_error=true}};\n\n#define getData2(dk1,data,nk_e,dk2,nk_d) {if(!(\n((nk_e==NK_e&&nk_d==NK_d)||(nk_e==NK_e_f&&nk_d==NK_d_f))&&\n(dk1==DK&&dk2==DK)&&\n(data==Data)))\n{data_decryption_error=true}\n};\n\n\n#define getNK1(k,nk_d){if(nk_d==NK_d_f)\n{nk_faking_success=true}\n};\n\n#define getNK2(k,nk_e,nk_d){if(nk_e==NK_e_f&&nk_d==NK_d_f)\n{nk_faking_success=true}\n};\n\n#define getNK3(k,k_m,nk_d,k_pub_m_local)\n{if(!(((k_pub_m_local==K_pub_M&&k_m==K_pri_M)||(k_pub_m_local==K_pub_I&&k_m==K_pri_I))))\n{nk_decryption_error=true}\nelse if(nk_d==NK_d_f)\n{nk_faking_success=true};\nif(nk_decryption_error==true&&k_pub_m_local==K_pub_I)\n{nk_misjudgement=true}\n};\n\n#define getNK4(k,k_m,nk_e,nk_d,k_pub_m_local) \n{if(!(((k_pub_m_local==K_pub_M&&k_m==K_pri_M)||(k_pub_m_local==K_pub_I&&k_m==K_pri_I))))\n{nk_decryption_error=true}\nelse if(nk_e==NK_e_f&&nk_d==NK_d_f)\n{nk_faking_success=true};\nif(nk_decryption_error==true&&k_pub_m_local==K_pub_I)\n{nk_misjudgement=true}\n};\n\n#define getNK5(k,k_m1,nk_d,k_a,k_m2,k_pub_m_local) \n{if(!(((k_pub_m_local==K_pub_M&&k_m1==K_pri_M&&k_m2==K_pub_M)||(k_pub_m_local==K_pub_I&&k_m1==K_pri_I&&k_m2==K_pub_I))))\n{nk_decryption_error=true}\nelse if(nk_d==NK_d_f)\n{nk_faking_success=true}\n};\n\n#define getNK6(k,k_m1,nk_e,nk_d,k_a,k_m2,k_pub_m_local) \n{if(!(((k_pub_m_local==K_pub_M&&k_m1==K_pri_M&&k_m2==K_pub_M)||(k_pub_m_local==K_pub_I&&k_m1==K_pri_I&&k_m2==K_pub_I))))\n{nk_decryption_error=true}\nelse if(nk_e==NK_e_f&&nk_d==NK_d_f)\n{nk_faking_success=true}\n};\n\nchannel ComWM 0;\nchannel ComRM 0;\nchannel FakeRM1 0;\nchannel FakeWM1 0;\nchannel FakeRM2 0;\nchannel FakeWM2 0;\n\n\n//-----------------------------------------------------------------",
        "path": "handwrite/NDN.csp"
    },
    {
        "name": "New Simple Queue",
        "tags": [
            "Protocol",
            "Distributed System"
        ],
        "use_non_container_lib": false,
        "description": "NSQ is a distributed messaging platform based on Go language with outstanding performance, robustness, and usability.\n\tThe overall system is composed of interleaving execution of instances of Producers, NSQ daemons (nsqd), NSQ lookup daemons (nsqlookupd), and Consumers. \n\tThe number of each component is defined by constants P, D, LD, and C, respectively.",
        "pat_code": "#define P 2; //prod\n#define C 2; // consmer\n#define D 2; // nsqD\n#define T 1; // topic\n#define LD 2; //nsqD lookup\n#define CHA 2; // two NSQ channel for each topic\n#define MsgNum 3;\n\n// nsqd\nvar DTStates[D][T]=[0,0];\nvar DChStates[D][T][CHA]=[0,0,0,0];\nvar startMsgPump[D][T]=[0,0];\nvar TCh2C[D][T][CHA][C]=[0,0,0,0,0,0,0,0];\nvar TC2D[D][T][CHA][C]=[0,0,0,0,0,0,0,0];\n\n// nsqlookupd\nvar addrLookupd[LD]=[1,1];\nvar LDStates[LD][D]=[0,0,0,0];\nvar T2D[LD][T][D]=[0,0,0,0];\n\n// consumer\nvar RDY[C][D]=[0,0,0,0];\nvar pushStates[D][C]=[0,0,0,0];\nvar Attempts[C][MsgNum]=[0,0,0,0,0,0];\nvar msgOrder[C][MsgNum]=[0,0,0,0,0,0];\n\n// buffer\nchannel MsgCON[C] MsgNum;\nchannel MsgTPC[D * T] MsgNum;\nchannel MsgCHA[D * T * CHA] MsgNum;\n// comm\nchannel ComPD[P * D] 0; // producer <-> nsqd\nchannel ComDL[D * LD] 0; // nsqd <-> nsqlookupd\nchannel ComCD[C * D] 0; // consumer <-> nsqd\nchannel ComCL[C * LD] 0; // consumer <-> nsqlookupd\n\nenum{msg_req, msg_data, msg_rep};\nenum{PUB, REP, OK, SUB, ERROR, TIMEOUT, LOOKUPD, FIN, REQ};\n#define unRegisternsqd(lid,did){\n\tLDStates[lid][_did]=0;\n\tvar i=0;\n\twhile(i<T){\n\t\tvar j=did;\n\t\tT2D[lid][i][did]=0;\n\t\twhile(j<CHA){\n\t\t\tTC2D[lid][i][j][did]=0; j=j+1;\n\t\t};\n\t\ti=i+1;\n\t};\n};\n#define ComDL_index (i, j) { i * LD + j } ;\n#define ComCD_index (i, j) { i * D + j } ;\n#define ComCL_index (i, j) { i * LD + j } ;\n#define TMsgChan_index(i,j) {i*T+j};\n#define CMsgChan_index(i,j,k) {i*D*T + j*T + k};\n\n// producer\nvar MSGID;\nvar _tid; \nvar _did;\nvar PmsgStates[MsgNum];\n/*@Process: Producer\n  Producer with pid:\n  1. A producer pid is initialized, where it sets its did and tid to pid and 0.\n\t2. The producer sends a message request to a specific NSQ daemon. This request includes the producer's ID, the NSQ daemon's I, a PUB command, a topic ID, and a message ID .\n  3. It then waits for a message reply from the nsqd including the message id.\n\t4. Upon receiving the confirmation, the producer updates the message state.\n  5. The producer increments the message ID for the next message, and restarts publishing.\n*/\nProducer(pid)=\n\t{_did=pid;_tid=0;}->\n\tComPD[pid]!msg_req.pid._did.PUB._tid.MSGID->\n\tComPD[pid]?msg_rep.did2.pid.REP.msgid.OK->\n\tupdateMsgStates{PmsgStates[msgid]=1;}->\n\tif(msgid==1){\n\t\tSkip\n\t} else{\n\t\tnextMsg{MSGID++;}-> Producer(pid)\n\t};\n\t\n// nsqd\n/*@Process: nsqd\n  NSQ Daemon: The nsqd process with its id consists of three interleaving components, ExecLoop, msgPump and msgPush.\n*/\nnsqd(did) = ExecLoop(did) ||| msgPump(did, 0) ||| msgPush(did);\n\n/*@Process: ExecLoop\n\tExecLoop with deamon's id: Handles the four main operations: publishing, subscribing, message request, and message acknowledgment.\n*/\nExecLoop(did)=|||cid:{0..C-1}@(\n\tExecPUB(did)\n\t[]ExecSUB(did,cid)\n\t[]ExecFIN(did,cid)\n\t[]ExecREQ(did,cid)\n);\n\n/*@Process: ExecFIN\n  ExecFIN: After receiveing the finalization requests from consumers, it updates the message state.\n\t\n*/\nvar DMStates[D][T][CHA][C]=[0,0,0,0,0,0,0,0];\nExecFIN(did,cid)=\n\tComCD[call(ComCD_index,cid,did)]?msg_req.cid.did.FIN.tid.chid.msgid->\n\tupdateMsg{DMStates[did][tid][chid][msgid]=-1;}->\n\tExecFIN(did,cid);\n\n/*@Process: ExecREQ\n\tExecREQ: After receiving the message request, it updates the message status and puts the message into the channel.\n*/\nExecREQ(did,cid)=\n\tComCD[call(ComCD_index,cid,did)]?msg_req.cid.did.REQ.tid.chid.msgid->\n\tupdateMsg{DMStates[did][tid][chid][msgid]++;}->\n\tMsgCHA[did*D + tid*T + chid]!msg_data.tid.chid.msgid->\n\tExecREQ(did,cid);\n\n/*@Process: ExecPUB\nExecPUB: \n\t1. Receives message publish requests from producers including topic id, message id.\n  2. If the topic doesn't exist, it creates the topic.\n  3. It then puts the message data into the topic channel.\n  4. Finally, it sends a response back to the producer confirming successful publication.\n*/\nvar tid_tmp;\nvar msg_tmp;\nvar chid_tmp;\nExecPUB(did)=\n\tComPD[did]?msg_req.did.did.PUB.tid.msgid{tid_tmp=tid;msg_tmp=msgid;}->//pid==did\n\tif(DTStates[did][tid]==0){createTopi.did.tid -> Skip}\n\telse{Skip};\n\tMsgTPC[call(TMsgChan_index,did,tid_tmp)]!msg_data.tid_tmp.msg_tmp->\n\tComPD[did]!msg_rep.did.did.REP.msg_tmp.OK-> ExecPUB(did);\n\n/*@Process: ExecSUB\nExecSUB: \n\t1. Handles subscription requests from consumers including topic id and message id.\n  2. If the topic doesn't exist, it creates the topic.\n  3. It updates the channel state\n\t4. It adds the consumer to the list of clients for that channel.\n  5. Finally, it sends a response back to the consumer confirming the subscription.\n*/\nExecSUB(did,cid)=\n\tComCD[call(ComCD_index,cid,did)]?msg_req.cid.did.SUB.tid.chid{chid_tmp=chid;tid_tmp=_tid}->\n\tif(DTStates[did][tid]==0){\n\t\tcreateTopic.did.tid -> \n\t\tupdateChannel{DChStates[did][tid][chid]=1;}->\n\t\tNotify(did,tid,chid)\n\t} else{\n\t\tif(DChStates[did][tid][chid]==0){\n\t\t\tupdateChannel{DChStates[did][tid][chid]=1;}->\n\t\t\tNotify(did,tid,chid)\n\t\t}else{Skip}\n\t};\n\taddClient{TCh2C[did][tid_tmp][chid_tmp][cid]=1;}->\n\tpumpMsg{startMsgPump[did][tid_tmp]=1;}->\n\tComCD[call(ComCD_index,cid,did)]!msg_rep.did.cid.SUB.OK->ExecSUB(did,cid);\n\tNotify(a,b,c) = Skip;\n\n/*@Process: msgPump\n  msgPump: When a new message arrives, the process starts the loop of process pump_loop,.\n*/\nmsgPump(did,tid)=\n\t[startMsgPump[did][tid]==1]MsgTPC[call(TMsgChan_index,did,tid)]?msg_data.tid.msgid->\n\tpump_loop(did,tid,msgid);\n\tmsgPump(did,tid);\n\n/*@PRocess: pump_loop\n   which pump the messages with lookup's id channel's id and message id through all channels\n*/\npump_loop(did,tid,msgid)=|||chid:{0..CHA-1}@(\n\tif(DChStates[did][tid][chid]==0){Skip}\n\telse{MsgCHA[call(CMsgChan_index,did,tid,chid)]!msg_data.tid.chid.msgid->Skip}\n);\n\n/*@Process: msgPush\n It may push the message with the daemon'is, the lookup's id, the channel's id and client's id of 1 or 2.\n*/\nmsgPush(did)=_msgPush(did,0,0,0)<>_msgPush(did,0,0,1); msgPush(did);\n/*@Process: _msgPush\n\tmsgPush: It checks if a consumer is ready to receive a message, and then receives a message from the channel and pushes it to the consumer.\n*/\n_msgPush(did,tid,chid,cid)= if(TCh2C[did][tid][chid][cid]==1&&RDY[cid][did]>0){\n\t\tMsgCHA[call(CMsgChan_index,did,tid,chid)]?msg_data.tid.chid.msgid{pushStates[did][cid]=1;}->\n\t\tComCD[call(ComCD_index,cid,did)]!msg_rep.did.cid.tid.chid.msgid{pushStates[did][cid]=0;}->Skip\n\t} else{Skip};\n\t\n// nsq lookup\n/*@Process: nsqlookupd\n\tThe NSQ Lookup Daemon with id maintains a registry of NSQ daemons and topics. It consists of three interleaving components: Lookup, Register and ErrorHandler \n*/\nnsqlookupd(lid) = Lookup(lid) ||| Register(lid) ||| ErrorHandler(lid);\n\n/*@Process: Register\n  It has D processes equal to the number of deamons to handle message from them. \n*/\nRegister(lid)=[]did:{0..D-1}@(_Register(lid,did));\n/*@Process: _Register\n One register may receive messages from different NSQ daemons:\n  1. It waits for registration requests from NSQ daemons including the channel id.\n\t2. If the channel id is invalid, it only registers the topic and updates its internal state.\n\t3. Otherwise, it registers the toppic and the channel ,updates its internal tables to reflect the presence of the NSQ daemon and the topics it serves.\n*/\nvar LTStates[LD][T];\nvar LCStates[LD][T][CHA];\n_Register(lid,did)= \n\tComDL[call(ComDL_index,did,lid)]?msg_req.did.lid.REGISTER.tid.chid->\n\taddnsqd{LDStates[lid][did]=1}->\n\tif(chid==-1){\n\t\tregisterTopic{\n\t\t\tLTStates[lid][tid]=1;\n\t\t\tT2D[lid][tid][did]=1;\n\t\t}->Skip\n\t}else{\n\t\tregisterTopicandChan{\n\t\t\tLTStates[lid][tid]=1;\n\t\t\tLCStates[lid][tid][chid]=1;\n\t\t\tT2D[lid][tid][did]=1;\n\t\t\tTC2D[lid][tid][chid][did]=1;\n\t\t}->Skip\n\t}; _Register(lid,did);\n\n/*@Process: Lookup\n  It may receives request from a consumer or from a nsqd.\n*/\nLookup(lid)=_LookupNsqd(lid)[]_LookupChannel(lid);Lookup(lid);\n/*@Process: _LookupNsqd\n\tLookupNsqd:\n  1. It receives a lookup NSQd request from a consumer.\n\t2. It checks its internal tables to find the NSQ daemons that serve the requested topic.\n  3. It sends a response back to the consumer containing a list of available NSQ daemons.\n*/\nvar dList[D];\n_LookupNsqd(lid)=[]cid:{0..C-1}@(\n\tComCL[call(ComCL_index,cid,lid)]?msg_req.cid.lid.LOOKUPD.tid->\n\tlookupnsqd{\n\t\tvar i=0;\n\t\twhile(i<D){\n\t\tif(T2D[lid][tid][i]==1){dList[i]=1;}\n\t\telse{dList[i]=0};i=i+1;};\n\t}-> \n\tComCL[call(ComCL_index,cid,lid)]!msg_rep.lid.cid.REP.tid.dList->Skip\n);\n\n/*@Process: _LookupChannel\n LookupChannel\n\t1. Or, it receives a lookup channel request from a nsqd.\n  2. It checks its internal tables to find the Channels.\n  3. It sends a response back to the nsqd containing a list of available Channels.\n*/\nvar chList[D];\n_LookupChannel(lid)=[]did:{0..D-1}@(\n\tComDL[call(ComDL_index,did,lid)]?msg_req.did.lid.LOOKUPCHA.tid->\n\tlookupChannel{\n\t\tvar i=0;\n\t\twhile(i<CHA){\n\t\tif(LCStates[lid][tid][i]==1){chList[i]=1;}\n\t\telse{chList[i]=0};i=i+1;};\n\t}->\n\tComDL[call(ComDL_index,did,lid)]!msg_rep.lid.did.REP.tid.chList->Skip\n);\n\n/*@Process: ErrorHandler\n\tErrorHandler: It receives the timeout message from the nsqd and unregister it.\n*/\nErrorHandler(lid)= ComDL[call(ComDL_index,0,lid)]?msg_req.0.lid.ERROR.TIMEOUT -> unreg{call(unRegisternsqd,lid,0)}->Skip;\n\n/*@Process: Consumer\n\tConsumer first executes the ConnToLookupd process.\n\tAfter that, the consumer starts up readLoop together with the Handler to process messages from channel.\n*/\nConsumer(cid)=ConnToLookupd(cid,0,0);readLoop(cid)|||Handler(cid);\n\n/*@Process: ConnToLookupd\n\tConsumer first executes the ConnToLookupd process:\n  1. Tries to connect to all available nsqlookupd servers.\n  2. If only one nsqlookupd is available, it records the server address.\n\t3. It count the available server count, if the count is less or equal to 1, it sends request with LOOKUPD command and receives acknowledgement.\n  4. Then proceeds to connect to the appropriate nsqd nodes with process connsqd_loop.\n*/\nvar totalLD;\nvar CLStates[C][LD];\nvar CDStates[C][D];\nConnToLookupd(cid,lid,tid)= \n  if(addrLookupd[lid]==0){\n\t\tSkip\n\t} else{\n\t\taddLD{CLStates[cid][lid]=1;}->\n\t\tcount{\n\t\t\tvar i=0;var sum=0;\n\t\t\twhile(i<LD){\n\t\t\t\tsum=sum+CLStates[cid][i];i=i+1;\n\t\t\t};\n\t\t\ttotalLD=sum;\n\t\t}->\n\t\tif(totalLD<=1){\n\t\t\tComCL[call(ComCL_index,cid,lid)]!msg_req.cid.lid.LOOKUPD.tid->\n\t\t\tComCL[call(ComCL_index,cid,lid)]?msg_rep.lid.cid.REP.tid.dlist->\n\t\t\tconnsqd_loop(cid,tid,dlist)\n\t\t}else{Skip}\n\t};\n\n/*@Process: connsqd_loop\n  connsqd_loop: It keeps finding available nsqd service by sending message to all nsqds, if the nsqd responds with success, it records the nsqd and update ready state.\n*/\nvar c2ch[C];\nconnsqd_loop(cid,tid,dlist)=|||did:{0..D-1}@(if(dlist[did]==1){ConnToNsqd(cid,did,tid)}else{Skip});\nConnToNsqd(cid,did,tid)=if(CDStates[cid][did]==1){\n\t\tSkip\n\t}else{\n\t\tComCD[call(ComCD_index,cid,did)]!msg_req.cid.did.SUB.tid.c2ch[cid]->\n\t\tComCD[call(ComCD_index,cid,did)]?msg_rep.did.cid.SUB.OK->\n\t\taddnsqd{CDStates[cid][did]=1;}->\n\t\tupdateRDY{RDY[cid][did]=1;}->Skip\n\t};\n\n/*@Process: readLoop\n  It contains D subprocesses equal to the number of deamons that listening for messages from NSQ daemons\n*/\nreadLoop(cid)=|||did:{0..D-1}@(_readLoop(cid,did));\n/*@Process: _readLoop\nreadLoop: It continuously listens for messages from NSQ daemons. After the consumer receives a message from the channel, updates the ready states.\n*/\n_readLoop(cid,did)=\n\tComCD[call(ComCD_index,cid,did)]?msg_rep.did.cid.MSG.tid.chid.msgid{RDY[cid][did]--;}->\n\tif(Attempts[cid][msgid]==-1){\n\t\tupdateRDY{RDY[cid][did]++;}->Skip\n\t}else{\n\t\tMsgCON[cid]!msg_data.did.tid.chid.msgid->Skip\n\t};\n\t_readLoop(cid,did);\n\n/*@Process: Handler\n  Handler:\n  1. If the message has exceeded the maximum number of delivery attempts, it sends a FIN message back to the NSQ daemon and stops attempting delivery.\n  2. Otherwise, it sends either a FIN or a REQ message to the NSQ daemon and update the RDY state.\n*/\n#define MaxAttempts 3;\nHandler(cid)=MsgCON[cid]?msg_data.did.tid.chid.msgid->\n\tif(Attempts[cid][msgid]>MaxAttempts){\n\t\tComCD[call(ComCD_index,cid,did)]!msg_req.cid.did.FIN.tid.chid.msgid{Attempts[cid][msgid]=-1;}->\n\t\tupdateRDY{RDY[cid][did]++;}->Skip\n\t}else{\n\t\tComCD[call(ComCD_index,cid,did)]!msg_req.cid.did.FIN.tid.chid.msgid{Attempts[cid][msgid]=-1;}->\n\t\tupdateRDY{RDY[cid][did]++;}->Skip\n\t\t<>\n\t\tComCD[call(ComCD_index,cid,did)]!msg_req.cid.did.REQ.tid.chid.msgid{Attempts[cid][msgid]++;}->\n\t\tupdateRDY{RDY[cid][did]++;}->Skip\n\t};\n\tHandler(cid);\n\n/*@Process: System\n  The overall system is composed of interleaving execution of instances of Producers, NSQ daemons (nsqd), NSQ lookup daemons (nsqlookupd), and Consumers. \n\tThe number of each component is defined by constants P, D, LD, and C, respectively.\n*/\nSystem()=|||i:{0..1}@(Producer(i)|||nsqd(i)|||nsqlookupd(i)|||Consumer(i));",
        "property_desc": [
            "The system is deadlock-free.",
            "All messages will be processed."
        ],
        "properties": [
            "#assert System() deadlockfree;",
            "#define Reachability {\n\tAttempts[0][0] == -1 && Attempts[1][0] == -1 &&\n\tAttempts[0][1] == -1 && Attempts[1][1] == -1 &&\n\tAttempts[0][2] == -1 && Attempts[1][2] == -1 \n};\n#assert System() |=<> Reachability;"
        ],
        "processes": [
            {
                "name": "Producer",
                "description": "Producer with pid:\n  1. A producer pid is initialized, where it sets its did and tid to pid and 0.\n\t2. The producer sends a message request to a specific NSQ daemon. This request includes the producer's ID, the NSQ daemon's I, a PUB command, a topic ID, and a message ID .\n  3. It then waits for a message reply from the nsqd including the message id.\n\t4. Upon receiving the confirmation, the producer updates the message state.\n  5. The producer increments the message ID for the next message, and restarts publishing.",
                "pat_code": "Producer(pid)=\n\t{_did=pid;_tid=0;}->\n\tComPD[pid]!msg_req.pid._did.PUB._tid.MSGID->\n\tComPD[pid]?msg_rep.did2.pid.REP.msgid.OK->\n\tupdateMsgStates{PmsgStates[msgid]=1;}->\n\tif(msgid==1){\n\t\tSkip\n\t} else{\n\t\tnextMsg{MSGID++;}-> Producer(pid)\n\t};\n\t\n// nsqd"
            },
            {
                "name": "nsqd",
                "description": "NSQ Daemon: The nsqd process with its id consists of three interleaving components, ExecLoop, msgPump and msgPush.",
                "pat_code": "nsqd(did) = ExecLoop(did) ||| msgPump(did, 0) ||| msgPush(did);"
            },
            {
                "name": "ExecLoop",
                "description": "ExecLoop with deamon's id: Handles the four main operations: publishing, subscribing, message request, and message acknowledgment.",
                "pat_code": "ExecLoop(did)=|||cid:{0..C-1}@(\n\tExecPUB(did)\n\t[]ExecSUB(did,cid)\n\t[]ExecFIN(did,cid)\n\t[]ExecREQ(did,cid)\n);"
            },
            {
                "name": "ExecFIN",
                "description": "ExecFIN: After receiveing the finalization requests from consumers, it updates the message state.",
                "pat_code": "var DMStates[D][T][CHA][C]=[0,0,0,0,0,0,0,0];\nExecFIN(did,cid)=\n\tComCD[call(ComCD_index,cid,did)]?msg_req.cid.did.FIN.tid.chid.msgid->\n\tupdateMsg{DMStates[did][tid][chid][msgid]=-1;}->\n\tExecFIN(did,cid);"
            },
            {
                "name": "ExecREQ",
                "description": "ExecREQ: After receiving the message request, it updates the message status and puts the message into the channel.",
                "pat_code": "ExecREQ(did,cid)=\n\tComCD[call(ComCD_index,cid,did)]?msg_req.cid.did.REQ.tid.chid.msgid->\n\tupdateMsg{DMStates[did][tid][chid][msgid]++;}->\n\tMsgCHA[did*D + tid*T + chid]!msg_data.tid.chid.msgid->\n\tExecREQ(did,cid);"
            },
            {
                "name": "ExecPUB",
                "description": "ExecPUB: \n\t1. Receives message publish requests from producers including topic id, message id.\n  2. If the topic doesn't exist, it creates the topic.\n  3. It then puts the message data into the topic channel.\n  4. Finally, it sends a response back to the producer confirming successful publication.",
                "pat_code": "var tid_tmp;\nvar msg_tmp;\nvar chid_tmp;\nExecPUB(did)=\n\tComPD[did]?msg_req.did.did.PUB.tid.msgid{tid_tmp=tid;msg_tmp=msgid;}->//pid==did\n\tif(DTStates[did][tid]==0){createTopi.did.tid -> Skip}\n\telse{Skip};\n\tMsgTPC[call(TMsgChan_index,did,tid_tmp)]!msg_data.tid_tmp.msg_tmp->\n\tComPD[did]!msg_rep.did.did.REP.msg_tmp.OK-> ExecPUB(did);"
            },
            {
                "name": "ExecSUB",
                "description": "ExecSUB: \n\t1. Handles subscription requests from consumers including topic id and message id.\n  2. If the topic doesn't exist, it creates the topic.\n  3. It updates the channel state\n\t4. It adds the consumer to the list of clients for that channel.\n  5. Finally, it sends a response back to the consumer confirming the subscription.",
                "pat_code": "ExecSUB(did,cid)=\n\tComCD[call(ComCD_index,cid,did)]?msg_req.cid.did.SUB.tid.chid{chid_tmp=chid;tid_tmp=_tid}->\n\tif(DTStates[did][tid]==0){\n\t\tcreateTopic.did.tid -> \n\t\tupdateChannel{DChStates[did][tid][chid]=1;}->\n\t\tNotify(did,tid,chid)\n\t} else{\n\t\tif(DChStates[did][tid][chid]==0){\n\t\t\tupdateChannel{DChStates[did][tid][chid]=1;}->\n\t\t\tNotify(did,tid,chid)\n\t\t}else{Skip}\n\t};\n\taddClient{TCh2C[did][tid_tmp][chid_tmp][cid]=1;}->\n\tpumpMsg{startMsgPump[did][tid_tmp]=1;}->\n\tComCD[call(ComCD_index,cid,did)]!msg_rep.did.cid.SUB.OK->ExecSUB(did,cid);\n\tNotify(a,b,c) = Skip;"
            },
            {
                "name": "msgPump",
                "description": "msgPump: When a new message arrives, the process starts the loop of process pump_loop,.",
                "pat_code": "msgPump(did,tid)=\n\t[startMsgPump[did][tid]==1]MsgTPC[call(TMsgChan_index,did,tid)]?msg_data.tid.msgid->\n\tpump_loop(did,tid,msgid);\n\tmsgPump(did,tid);\n\n/*@PRocess: pump_loop\n   which pump the messages with lookup's id channel's id and message id through all channels\n*/\npump_loop(did,tid,msgid)=|||chid:{0..CHA-1}@(\n\tif(DChStates[did][tid][chid]==0){Skip}\n\telse{MsgCHA[call(CMsgChan_index,did,tid,chid)]!msg_data.tid.chid.msgid->Skip}\n);"
            },
            {
                "name": "msgPush",
                "description": "It may push the message with the daemon'is, the lookup's id, the channel's id and client's id of 1 or 2.",
                "pat_code": "msgPush(did)=_msgPush(did,0,0,0)<>_msgPush(did,0,0,1); msgPush(did);"
            },
            {
                "name": "_msgPush",
                "description": "msgPush: It checks if a consumer is ready to receive a message, and then receives a message from the channel and pushes it to the consumer.",
                "pat_code": "_msgPush(did,tid,chid,cid)= if(TCh2C[did][tid][chid][cid]==1&&RDY[cid][did]>0){\n\t\tMsgCHA[call(CMsgChan_index,did,tid,chid)]?msg_data.tid.chid.msgid{pushStates[did][cid]=1;}->\n\t\tComCD[call(ComCD_index,cid,did)]!msg_rep.did.cid.tid.chid.msgid{pushStates[did][cid]=0;}->Skip\n\t} else{Skip};\n\t\n// nsq lookup"
            },
            {
                "name": "nsqlookupd",
                "description": "The NSQ Lookup Daemon with id maintains a registry of NSQ daemons and topics. It consists of three interleaving components: Lookup, Register and ErrorHandler",
                "pat_code": "nsqlookupd(lid) = Lookup(lid) ||| Register(lid) ||| ErrorHandler(lid);"
            },
            {
                "name": "Register",
                "description": "It has D processes equal to the number of deamons to handle message from them.",
                "pat_code": "Register(lid)=[]did:{0..D-1}@(_Register(lid,did));"
            },
            {
                "name": "_Register",
                "description": "One register may receive messages from different NSQ daemons:\n  1. It waits for registration requests from NSQ daemons including the channel id.\n\t2. If the channel id is invalid, it only registers the topic and updates its internal state.\n\t3. Otherwise, it registers the toppic and the channel ,updates its internal tables to reflect the presence of the NSQ daemon and the topics it serves.",
                "pat_code": "var LTStates[LD][T];\nvar LCStates[LD][T][CHA];\n_Register(lid,did)= \n\tComDL[call(ComDL_index,did,lid)]?msg_req.did.lid.REGISTER.tid.chid->\n\taddnsqd{LDStates[lid][did]=1}->\n\tif(chid==-1){\n\t\tregisterTopic{\n\t\t\tLTStates[lid][tid]=1;\n\t\t\tT2D[lid][tid][did]=1;\n\t\t}->Skip\n\t}else{\n\t\tregisterTopicandChan{\n\t\t\tLTStates[lid][tid]=1;\n\t\t\tLCStates[lid][tid][chid]=1;\n\t\t\tT2D[lid][tid][did]=1;\n\t\t\tTC2D[lid][tid][chid][did]=1;\n\t\t}->Skip\n\t}; _Register(lid,did);"
            },
            {
                "name": "Lookup",
                "description": "It may receives request from a consumer or from a nsqd.",
                "pat_code": "Lookup(lid)=_LookupNsqd(lid)[]_LookupChannel(lid);Lookup(lid);"
            },
            {
                "name": "_LookupNsqd",
                "description": "LookupNsqd:\n  1. It receives a lookup NSQd request from a consumer.\n\t2. It checks its internal tables to find the NSQ daemons that serve the requested topic.\n  3. It sends a response back to the consumer containing a list of available NSQ daemons.",
                "pat_code": "var dList[D];\n_LookupNsqd(lid)=[]cid:{0..C-1}@(\n\tComCL[call(ComCL_index,cid,lid)]?msg_req.cid.lid.LOOKUPD.tid->\n\tlookupnsqd{\n\t\tvar i=0;\n\t\twhile(i<D){\n\t\tif(T2D[lid][tid][i]==1){dList[i]=1;}\n\t\telse{dList[i]=0};i=i+1;};\n\t}-> \n\tComCL[call(ComCL_index,cid,lid)]!msg_rep.lid.cid.REP.tid.dList->Skip\n);"
            },
            {
                "name": "_LookupChannel",
                "description": "LookupChannel\n\t1. Or, it receives a lookup channel request from a nsqd.\n  2. It checks its internal tables to find the Channels.\n  3. It sends a response back to the nsqd containing a list of available Channels.",
                "pat_code": "var chList[D];\n_LookupChannel(lid)=[]did:{0..D-1}@(\n\tComDL[call(ComDL_index,did,lid)]?msg_req.did.lid.LOOKUPCHA.tid->\n\tlookupChannel{\n\t\tvar i=0;\n\t\twhile(i<CHA){\n\t\tif(LCStates[lid][tid][i]==1){chList[i]=1;}\n\t\telse{chList[i]=0};i=i+1;};\n\t}->\n\tComDL[call(ComDL_index,did,lid)]!msg_rep.lid.did.REP.tid.chList->Skip\n);"
            },
            {
                "name": "ErrorHandler",
                "description": "ErrorHandler: It receives the timeout message from the nsqd and unregister it.",
                "pat_code": "ErrorHandler(lid)= ComDL[call(ComDL_index,0,lid)]?msg_req.0.lid.ERROR.TIMEOUT -> unreg{call(unRegisternsqd,lid,0)}->Skip;"
            },
            {
                "name": "Consumer",
                "description": "Consumer first executes the ConnToLookupd process.\n\tAfter that, the consumer starts up readLoop together with the Handler to process messages from channel.",
                "pat_code": "Consumer(cid)=ConnToLookupd(cid,0,0);readLoop(cid)|||Handler(cid);"
            },
            {
                "name": "ConnToLookupd",
                "description": "Consumer first executes the ConnToLookupd process:\n  1. Tries to connect to all available nsqlookupd servers.\n  2. If only one nsqlookupd is available, it records the server address.\n\t3. It count the available server count, if the count is less or equal to 1, it sends request with LOOKUPD command and receives acknowledgement.\n  4. Then proceeds to connect to the appropriate nsqd nodes with process connsqd_loop.",
                "pat_code": "var totalLD;\nvar CLStates[C][LD];\nvar CDStates[C][D];\nConnToLookupd(cid,lid,tid)= \n  if(addrLookupd[lid]==0){\n\t\tSkip\n\t} else{\n\t\taddLD{CLStates[cid][lid]=1;}->\n\t\tcount{\n\t\t\tvar i=0;var sum=0;\n\t\t\twhile(i<LD){\n\t\t\t\tsum=sum+CLStates[cid][i];i=i+1;\n\t\t\t};\n\t\t\ttotalLD=sum;\n\t\t}->\n\t\tif(totalLD<=1){\n\t\t\tComCL[call(ComCL_index,cid,lid)]!msg_req.cid.lid.LOOKUPD.tid->\n\t\t\tComCL[call(ComCL_index,cid,lid)]?msg_rep.lid.cid.REP.tid.dlist->\n\t\t\tconnsqd_loop(cid,tid,dlist)\n\t\t}else{Skip}\n\t};"
            },
            {
                "name": "connsqd_loop",
                "description": "connsqd_loop: It keeps finding available nsqd service by sending message to all nsqds, if the nsqd responds with success, it records the nsqd and update ready state.",
                "pat_code": "var c2ch[C];\nconnsqd_loop(cid,tid,dlist)=|||did:{0..D-1}@(if(dlist[did]==1){ConnToNsqd(cid,did,tid)}else{Skip});\nConnToNsqd(cid,did,tid)=if(CDStates[cid][did]==1){\n\t\tSkip\n\t}else{\n\t\tComCD[call(ComCD_index,cid,did)]!msg_req.cid.did.SUB.tid.c2ch[cid]->\n\t\tComCD[call(ComCD_index,cid,did)]?msg_rep.did.cid.SUB.OK->\n\t\taddnsqd{CDStates[cid][did]=1;}->\n\t\tupdateRDY{RDY[cid][did]=1;}->Skip\n\t};"
            },
            {
                "name": "readLoop",
                "description": "It contains D subprocesses equal to the number of deamons that listening for messages from NSQ daemons",
                "pat_code": "readLoop(cid)=|||did:{0..D-1}@(_readLoop(cid,did));"
            },
            {
                "name": "_readLoop",
                "description": "readLoop: It continuously listens for messages from NSQ daemons. After the consumer receives a message from the channel, updates the ready states.",
                "pat_code": "_readLoop(cid,did)=\n\tComCD[call(ComCD_index,cid,did)]?msg_rep.did.cid.MSG.tid.chid.msgid{RDY[cid][did]--;}->\n\tif(Attempts[cid][msgid]==-1){\n\t\tupdateRDY{RDY[cid][did]++;}->Skip\n\t}else{\n\t\tMsgCON[cid]!msg_data.did.tid.chid.msgid->Skip\n\t};\n\t_readLoop(cid,did);"
            },
            {
                "name": "Handler",
                "description": "Handler:\n  1. If the message has exceeded the maximum number of delivery attempts, it sends a FIN message back to the NSQ daemon and stops attempting delivery.\n  2. Otherwise, it sends either a FIN or a REQ message to the NSQ daemon and update the RDY state.",
                "pat_code": "#define MaxAttempts 3;\nHandler(cid)=MsgCON[cid]?msg_data.did.tid.chid.msgid->\n\tif(Attempts[cid][msgid]>MaxAttempts){\n\t\tComCD[call(ComCD_index,cid,did)]!msg_req.cid.did.FIN.tid.chid.msgid{Attempts[cid][msgid]=-1;}->\n\t\tupdateRDY{RDY[cid][did]++;}->Skip\n\t}else{\n\t\tComCD[call(ComCD_index,cid,did)]!msg_req.cid.did.FIN.tid.chid.msgid{Attempts[cid][msgid]=-1;}->\n\t\tupdateRDY{RDY[cid][did]++;}->Skip\n\t\t<>\n\t\tComCD[call(ComCD_index,cid,did)]!msg_req.cid.did.REQ.tid.chid.msgid{Attempts[cid][msgid]++;}->\n\t\tupdateRDY{RDY[cid][did]++;}->Skip\n\t};\n\tHandler(cid);"
            },
            {
                "name": "System",
                "description": "The overall system is composed of interleaving execution of instances of Producers, NSQ daemons (nsqd), NSQ lookup daemons (nsqlookupd), and Consumers. \n\tThe number of each component is defined by constants P, D, LD, and C, respectively.",
                "pat_code": "System()=|||i:{0..1}@(Producer(i)|||nsqd(i)|||nsqlookupd(i)|||Consumer(i));"
            }
        ],
        "global_definition": "#define P 2; //prod\n#define C 2; // consmer\n#define D 2; // nsqD\n#define T 1; // topic\n#define LD 2; //nsqD lookup\n#define CHA 2; // two NSQ channel for each topic\n#define MsgNum 3;\n\n// nsqd\nvar DTStates[D][T]=[0,0];\nvar DChStates[D][T][CHA]=[0,0,0,0];\nvar startMsgPump[D][T]=[0,0];\nvar TCh2C[D][T][CHA][C]=[0,0,0,0,0,0,0,0];\nvar TC2D[D][T][CHA][C]=[0,0,0,0,0,0,0,0];\n\n// nsqlookupd\nvar addrLookupd[LD]=[1,1];\nvar LDStates[LD][D]=[0,0,0,0];\nvar T2D[LD][T][D]=[0,0,0,0];\n\n// consumer\nvar RDY[C][D]=[0,0,0,0];\nvar pushStates[D][C]=[0,0,0,0];\nvar Attempts[C][MsgNum]=[0,0,0,0,0,0];\nvar msgOrder[C][MsgNum]=[0,0,0,0,0,0];\n\n// buffer\nchannel MsgCON[C] MsgNum;\nchannel MsgTPC[D * T] MsgNum;\nchannel MsgCHA[D * T * CHA] MsgNum;\n// comm\nchannel ComPD[P * D] 0; // producer <-> nsqd\nchannel ComDL[D * LD] 0; // nsqd <-> nsqlookupd\nchannel ComCD[C * D] 0; // consumer <-> nsqd\nchannel ComCL[C * LD] 0; // consumer <-> nsqlookupd\n\nenum{msg_req, msg_data, msg_rep};\nenum{PUB, REP, OK, SUB, ERROR, TIMEOUT, LOOKUPD, FIN, REQ};\n#define unRegisternsqd(lid,did){\n\tLDStates[lid][_did]=0;\n\tvar i=0;\n\twhile(i<T){\n\t\tvar j=did;\n\t\tT2D[lid][i][did]=0;\n\t\twhile(j<CHA){\n\t\t\tTC2D[lid][i][j][did]=0; j=j+1;\n\t\t};\n\t\ti=i+1;\n\t};\n};\n#define ComDL_index (i, j) { i * LD + j } ;\n#define ComCD_index (i, j) { i * D + j } ;\n#define ComCL_index (i, j) { i * LD + j } ;\n#define TMsgChan_index(i,j) {i*T+j};\n#define CMsgChan_index(i,j,k) {i*D*T + j*T + k};\n\n// producer\nvar MSGID;\nvar _tid; \nvar _did;\nvar PmsgStates[MsgNum];",
        "path": "handwrite/NSQ.csp"
    },
    {
        "name": "OAuth2",
        "tags": [
            "Protocol"
        ],
        "use_non_container_lib": false,
        "description": "OAuth 2.0 is a widely-used authorization framework. It is extensively applied in scenarios such as social logins, API access control, and cross-platform data sharing, and has become an indispensable part of modern Internet services. Through OAuth 2.0, users can securely authorize third - party applications to access their resources without revealing their credentials. By introducing the token mechanism, OAuth 2.0 separates authentication and authorization, enhancing security and flexibility. The core roles of OAuth 2.0 include the resource owner (user), the client (third - party application), the authorization server (responsible for issuing tokens), and the resource server (storing resources). After the user approves the client's access request through the authorization server, the client will obtain an access token, which is used to access the protected resources on the resource server. \n  Oauth 2.0 has four roles: \n\t- Resource Owner: The owner of resources, usually an end - user. \n\t- Client: A third - party application that requests access to protected resources. \n\t- Authorization Server: A server responsible for verifying the identity of the resource owner and issuing an Access Token to the client.\n\t- Resource Server: A server that stores protected resources and can receive and respond to requests for access using an Access Token.",
        "pat_code": "#define N 4;\n#define VALIDTIME 10;\n#define MAXENDTIME 50;\n#define CANREFRESH true;\n\nchannel channelCliRO[N+1] 0; // client -> RO\nchannel channelROCli[N+1] 0; // RO -> client\nchannel channelCliAS[N+1] 0; // client -> AS\nchannel channelASCli[N+1] 0; // AS -> client\nchannel channelCliRS[N+1] 0; // client -> RS\nchannel channelRSCli[N+1] 0; // RS -> client\n\nvar startTime[N+1]; //the start time of Access Token\nvar grant[N+1]; // whether the resource owner make the grant that you can access ResourceServer[i]\nvar ACCESS[N+1]=[0,7611, 8922, 6777, 2233]; //Access Token\nvar REFRESH[N+1]=[0,1167, 2298, 7776, 3322]; //Refresh Token\nvar success[N+1]; //record whether succeed in accessing the Resource\nvar timestamp = 1; //record the global timestamp\n\nvar nowAuthor[N+1]; // current state of grant\nvar nowAccess[N+1]; // current state of access token\nvar nowRefresh[N+1]; // current state of refresh token\nvar nowInfo[N+1]; // the state of the query to the resource\nvar refreshcount[N+1]; // current count of refresh time\n\n/*@Process: getAccess\n  Oauth 2.0's action of getting access, client sends owner's grant to the Authorization Server, \nand receives the access token and refresh token from AS.\n*/\ngetAccess(i)=startCount.i -> channelCliAS[i]!nowAuthor[i] \n\t\t\t-> channelASCli[i]?access.refresh.nowtime->Skip;\n\n/*@Process: tryUpdateAccess\n  Oauth 2.0's action of updating the access, client trys to update the access token. It sends the request to the Authorization Server.\n*/\ntryUpdateAccess(i)=startCount.i -> updateAccess.i -> endUpdate.i->Skip;\n\n/*@Process: getResource\n  Oauth 2.0's action of getting the resource from Resource Server:\n\t1. Client sends the access token to the Resource Server and get the resource from the Resource Server.\n\t2. Check the Resource, if it is valid, which means the info is 200, the client succeeds getting the resource.\n\t3. If it is no valid, which means the info is 404 and the access token is out of date, the client fails to get resource, so it trys to update the Access token, then do the action of geting resource again.\n*/\ngetResource(i)=startCount.i -> channelCliRS[i]!nowAccess[i] -> channelRSCli[i]?info->           \n\t([info==200]succeed.i{\n\t\t\tsuccess[i]=success[i]+1;\n\t\t}->Skip\n      [][info==404 && nowAccess[i]==ACCESS[i]] \n\t      tryUpdateAccess(i);\n\t      getResource(i);\n\t      Skip\n      );\n\n/*@Process: Client\n  The Client:\n  1. It checks the resource owner's grant first.\n  2. If the owner gives no grant(ad==0) or timestamp has achieved the MAXENDTIME or it succeeds getting the resource, the client terminates.\n  3.  If the owner gives the grant(ad==1) and timestamp has not achieved the MAXENDTIME and it has not getting any resource, the client will do getAccess and getResource.\n  4. If the owner gives the grant(ad==1) and timestamp has not achieved the MAXENDTIME and it has getting parts of the resource, the client will getResource.\n*/\nClient() = |||i:{1..N}@client(i);\nclient(i) = startCount.i-> channelCliRO[i]!grant[i] -> channelROCli[i]?ad->\n\t([ad==1&&timestamp <= MAXENDTIME&&success[i]==0](getAccess(i);getResource(i);client(i))\n\t\t[][ad==1&&timestamp <= MAXENDTIME&&success[i]>=1&&success[i]<5](getResource(i);client(i))\n\t\t[][ad==0 || timestamp > MAXENDTIME || success[i]==5]end.i->Skip);\n\n/*@Process: ResourceOwner\n  The ResourceOwner:\n  1. It checks the resource owner's grant from the pre-setting.\n  2. If the grant is available(granted==1), it sends the client 'Yes'(nowAuthor[i]=1), or it sends the client 'No'(nowAuthor[i]=0).\n*/\nResourceOwner() = |||i:{1..N}@owner(i);\nowner(i) = channelCliRO[i]?granted->getGrant.i{\n\tif (granted==1){\n\t\tnowAuthor[i]=1;\n\t}\n\telse{\n\t\tnowAuthor[i]=0;\n\t}\n}->channelROCli[i]!nowAuthor[i]->owner(i)\n[]end.i->Skip;\n\n/*@Process: AuthorizationServer\n  The AuthorizationServer:\n  1. If the client trys to get the access with owner's grant, the AuthorizationServer will provide the access token, refresh token and record the timestamp.\n  2. If the client trys to update the token, reset the startTime of the access token\n*/\nAuthorizationServer() = |||i:{1..N}@aserver(i);\naserver(i) = (channelCliAS[i]?authored->\n\t\tcheckAuthorization{\n\t\t\tnowAccess[i]=ACCESS[i];\n\t\t\tnowRefresh[i]=REFRESH[i];\n\t\t\tstartTime[i]=timestamp;\n\t\t}->channelASCli[i]!nowAccess[i].nowRefresh[i].startTime[i]->aserver(i))\n\t\t[](updateAccess.i->\n\t\tupdateTokenTsp.i{\n\t\t\tif(CANREFRESH){\n\t\t\t\tstartTime[i]=timestamp;\n\t\t\t\trefreshcount[i]=refreshcount[i]+1;\n\t\t\t}\n\t\t}->endUpdate.i->aserver(i))\n\t\t[]end.i->Skip;\n\n/*@Process: ResourceServer\n  The ResourceServer:\n  1. If the client trys to get the resource with the access token, the ResourceServer will check the access token first.\n  2. If the access token is valid and it has not been out of date, then the RS will send the resource to the client\n  3. ELSE the RS will send the client the information that it fails to provide the resource.\n*/\nResourceServer(i) = (channelCliRS[i]?access -> checkAccess{\n\tif (access==ACCESS[i] && (timestamp<=(startTime[i]+VALIDTIME))){\n\t\tnowInfo[i]=200;\n\t}\n\telse{\n\t\tnowInfo[i]=404;\n\t}\n}->channelRSCli[i]!nowInfo[i]->ResourceServer(i))\n[]end.i->Skip;\n\n/*@Process: TimeCount\n  The TimeCount provides a strictly monotone increasing timestamp. It consists of N subprocesses handling request from each client.\n*/\nTimeCount() = |||i:{1..N}@TSOProxy(i);\nTSOProxy(i)=\n[timestamp <= MAXENDTIME]startCount.i-> \n\ttimeGoing.i{\n\t\ttimestamp++;\n\t}->TSOProxy(i)\n[][timestamp > MAXENDTIME]end.i->Skip\n[]end.i->Skip;\n\n/*@Process: System\n\tAfter initializing the system by setting the timestamp to 1 and grant access to the second resourceServer,\n  This system models contains N ResourceServers and the communication between each client and TimeCount and ResourceOwner and AuthorizationServer is independent.\n*/\nSystem() = initization{timestamp = 1;grant[1]=1;} -> Skip; ResourceOwner() ||Client()|| AuthorizationServer() ||(|||i:{1..N}@ResourceServer(i)) || TimeCount();",
        "property_desc": [
            "The system is deadlock-free.",
            "The system is divergence-free.",
            "The system will not get any resource when no RS's grant is 'Yes' in pre-setting.",
            "The system can succeed getting resource when RS's grant is 'Yes'.",
            "The system can succeed update the access token when it is out of date."
        ],
        "properties": [
            "#assert System() deadlockfree;",
            "#assert System() divergencefree;",
            "#define NoAccess (success[1]==0&&success[2]==0&&success[3]==0&&success[4]==0);\n#assert System() reaches NoAccess;",
            "#define succeedGetData (success[1]>0);\n#assert System() reaches succeedGetData;",
            "#define succeedUpdateToken (refreshcount[1]>0);\n#assert System() reaches succeedUpdateToken;"
        ],
        "processes": [
            {
                "name": "getAccess",
                "description": "Oauth 2.0's action of getting access, client sends owner's grant to the Authorization Server, \nand receives the access token and refresh token from AS.",
                "pat_code": "getAccess(i)=startCount.i -> channelCliAS[i]!nowAuthor[i] \n\t\t\t-> channelASCli[i]?access.refresh.nowtime->Skip;"
            },
            {
                "name": "tryUpdateAccess",
                "description": "Oauth 2.0's action of updating the access, client trys to update the access token. It sends the request to the Authorization Server.",
                "pat_code": "tryUpdateAccess(i)=startCount.i -> updateAccess.i -> endUpdate.i->Skip;"
            },
            {
                "name": "getResource",
                "description": "Oauth 2.0's action of getting the resource from Resource Server:\n\t1. Client sends the access token to the Resource Server and get the resource from the Resource Server.\n\t2. Check the Resource, if it is valid, which means the info is 200, the client succeeds getting the resource.\n\t3. If it is no valid, which means the info is 404 and the access token is out of date, the client fails to get resource, so it trys to update the Access token, then do the action of geting resource again.",
                "pat_code": "getResource(i)=startCount.i -> channelCliRS[i]!nowAccess[i] -> channelRSCli[i]?info->           \n\t([info==200]succeed.i{\n\t\t\tsuccess[i]=success[i]+1;\n\t\t}->Skip\n      [][info==404 && nowAccess[i]==ACCESS[i]] \n\t      tryUpdateAccess(i);\n\t      getResource(i);\n\t      Skip\n      );"
            },
            {
                "name": "Client",
                "description": "The Client:\n  1. It checks the resource owner's grant first.\n  2. If the owner gives no grant(ad==0) or timestamp has achieved the MAXENDTIME or it succeeds getting the resource, the client terminates.\n  3.  If the owner gives the grant(ad==1) and timestamp has not achieved the MAXENDTIME and it has not getting any resource, the client will do getAccess and getResource.\n  4. If the owner gives the grant(ad==1) and timestamp has not achieved the MAXENDTIME and it has getting parts of the resource, the client will getResource.",
                "pat_code": "Client() = |||i:{1..N}@client(i);\nclient(i) = startCount.i-> channelCliRO[i]!grant[i] -> channelROCli[i]?ad->\n\t([ad==1&&timestamp <= MAXENDTIME&&success[i]==0](getAccess(i);getResource(i);client(i))\n\t\t[][ad==1&&timestamp <= MAXENDTIME&&success[i]>=1&&success[i]<5](getResource(i);client(i))\n\t\t[][ad==0 || timestamp > MAXENDTIME || success[i]==5]end.i->Skip);"
            },
            {
                "name": "ResourceOwner",
                "description": "The ResourceOwner:\n  1. It checks the resource owner's grant from the pre-setting.\n  2. If the grant is available(granted==1), it sends the client 'Yes'(nowAuthor[i]=1), or it sends the client 'No'(nowAuthor[i]=0).",
                "pat_code": "ResourceOwner() = |||i:{1..N}@owner(i);\nowner(i) = channelCliRO[i]?granted->getGrant.i{\n\tif (granted==1){\n\t\tnowAuthor[i]=1;\n\t}\n\telse{\n\t\tnowAuthor[i]=0;\n\t}\n}->channelROCli[i]!nowAuthor[i]->owner(i)\n[]end.i->Skip;"
            },
            {
                "name": "AuthorizationServer",
                "description": "The AuthorizationServer:\n  1. If the client trys to get the access with owner's grant, the AuthorizationServer will provide the access token, refresh token and record the timestamp.\n  2. If the client trys to update the token, reset the startTime of the access token",
                "pat_code": "AuthorizationServer() = |||i:{1..N}@aserver(i);\naserver(i) = (channelCliAS[i]?authored->\n\t\tcheckAuthorization{\n\t\t\tnowAccess[i]=ACCESS[i];\n\t\t\tnowRefresh[i]=REFRESH[i];\n\t\t\tstartTime[i]=timestamp;\n\t\t}->channelASCli[i]!nowAccess[i].nowRefresh[i].startTime[i]->aserver(i))\n\t\t[](updateAccess.i->\n\t\tupdateTokenTsp.i{\n\t\t\tif(CANREFRESH){\n\t\t\t\tstartTime[i]=timestamp;\n\t\t\t\trefreshcount[i]=refreshcount[i]+1;\n\t\t\t}\n\t\t}->endUpdate.i->aserver(i))\n\t\t[]end.i->Skip;"
            },
            {
                "name": "ResourceServer",
                "description": "The ResourceServer:\n  1. If the client trys to get the resource with the access token, the ResourceServer will check the access token first.\n  2. If the access token is valid and it has not been out of date, then the RS will send the resource to the client\n  3. ELSE the RS will send the client the information that it fails to provide the resource.",
                "pat_code": "ResourceServer(i) = (channelCliRS[i]?access -> checkAccess{\n\tif (access==ACCESS[i] && (timestamp<=(startTime[i]+VALIDTIME))){\n\t\tnowInfo[i]=200;\n\t}\n\telse{\n\t\tnowInfo[i]=404;\n\t}\n}->channelRSCli[i]!nowInfo[i]->ResourceServer(i))\n[]end.i->Skip;"
            },
            {
                "name": "TimeCount",
                "description": "The TimeCount provides a strictly monotone increasing timestamp. It consists of N subprocesses handling request from each client.",
                "pat_code": "TimeCount() = |||i:{1..N}@TSOProxy(i);\nTSOProxy(i)=\n[timestamp <= MAXENDTIME]startCount.i-> \n\ttimeGoing.i{\n\t\ttimestamp++;\n\t}->TSOProxy(i)\n[][timestamp > MAXENDTIME]end.i->Skip\n[]end.i->Skip;"
            },
            {
                "name": "System",
                "description": "After initializing the system by setting the timestamp to 1 and grant access to the second resourceServer,\n  This system models contains N ResourceServers and the communication between each client and TimeCount and ResourceOwner and AuthorizationServer is independent.",
                "pat_code": "System() = initization{timestamp = 1;grant[1]=1;} -> Skip; ResourceOwner() ||Client()|| AuthorizationServer() ||(|||i:{1..N}@ResourceServer(i)) || TimeCount();"
            }
        ],
        "global_definition": "#define N 4;\n#define VALIDTIME 10;\n#define MAXENDTIME 50;\n#define CANREFRESH true;\n\nchannel channelCliRO[N+1] 0; // client -> RO\nchannel channelROCli[N+1] 0; // RO -> client\nchannel channelCliAS[N+1] 0; // client -> AS\nchannel channelASCli[N+1] 0; // AS -> client\nchannel channelCliRS[N+1] 0; // client -> RS\nchannel channelRSCli[N+1] 0; // RS -> client\n\nvar startTime[N+1]; //the start time of Access Token\nvar grant[N+1]; // whether the resource owner make the grant that you can access ResourceServer[i]\nvar ACCESS[N+1]=[0,7611, 8922, 6777, 2233]; //Access Token\nvar REFRESH[N+1]=[0,1167, 2298, 7776, 3322]; //Refresh Token\nvar success[N+1]; //record whether succeed in accessing the Resource\nvar timestamp = 1; //record the global timestamp\n\nvar nowAuthor[N+1]; // current state of grant\nvar nowAccess[N+1]; // current state of access token\nvar nowRefresh[N+1]; // current state of refresh token\nvar nowInfo[N+1]; // the state of the query to the resource\nvar refreshcount[N+1]; // current count of refresh time",
        "path": "handwrite/OAuth2.csp"
    },
    {
        "name": "OPCUA",
        "tags": [
            "Protocol"
        ],
        "use_non_container_lib": false,
        "description": "OPC Unified Architecture (OPC UA) is a protocol that can be used to accomplish information interoperability in manufacturing and its usage is expanding\n  This model consists of the communication between the Manufacturing Execution System(MES) and the Workshop.",
        "pat_code": "channel SecureChannel 0;\nchannel CreateSession 0;\nchannel ActivateSession 0;\n\n// Asymmetric Keys & Certificates: MES = MES, WS = WorkShop\nenum {Certmes, Certws, Certf}; \t// Certificates: Cert = Certificate\nenum {PKmes, PKws, PKf };    \t// MES's public key & private key\nenum {SKmes, SKws, SKf};      \t// WorkShop's public key & private key\n\n// Nonces\nenum {Nc, Ns, Nfc, Nfs};          \t\t\t\t\t//  Nc = clientNonce, Ns = serverNonce: generate symmetric keys for session\nenum {Nmes, Nws, Nfmes, Nfws}; \t\t// Nmes = mesNonce, Nws = workshopNonce, Nws2 = workshopNonce2: authenticate identity for user signatures\nenum {Nws2, Nfws2}; \t\t\t\t\t\t\t\t\n\n// Symmetric Keys: SG = SigningKey, EK = EncryptionKey\nenum {SGc, SGs, SGfc, SGsf};     // clientSigningKey = PRF(serverNonce, clientNonce, SigningKeyLength)\nenum {EKc, EKs, EKfc, EKsf};     \n\n// IDs\nenum {IDsc, IDsf}; \t\t\t// SecureChannel ID\n\n// Status\nenum {RES_Suc, RES_Fail}; // response status\n\n\n// System property judge variables\nvar channel_open_success = false;\nvar create_session_success = false;\nvar active_session_success = false;\n\n// Encrypted Messages: \treq = request, res = response\n//\t\t\t\t\t\tEnc = Encryption, Sig = Signing\n// OSC = OpenSecureChannel\nvar reqOSCEnc[3]; // [0] = key, [n] = messages\nvar reqOSCSig[3]; // [0] = key, [n] represents hashed messages\nvar resOSCEnc[3];\nvar resOSCSig[3];\n\n// CS = CreateSession\nvar reqCSEnc[3];\nvar reqCSSig[3];\nvar resCSEnc[2][3]; \t\t// [0][0] = key, [0][n] = messages; [1][...] serverSignature: [1][0] = key, [1][n] = messages\nvar resCSSig[2][3]; \t\t// [0][0] = key, [0][n] = messages; [1][...] serverSignature: [1][0] = key, [1][n] = messages\n\n// AS = ActivateSession \nvar reqASEnc[2][3];\t// [0][0] = key; [1][...] serverSignature: [1][0] = key, [1][n] = messages\nvar reqASSig[2][3];\t// [0][0] = key; [1][...] serverSignature: [1][0] = key, [1][n] = messages\nvar resASEnc[3];\nvar resASSig[3];\n\n\n/*-------------------------------------------// decrypt encrypted messages */\nvar CouldGetEncMsg = false;\n#define getEncMsg(mes, key){\n\tCouldGetEncMsg= false;\n\tif((mes[0]==PKmes && key== SKmes)||(mes[0]==PKws && key == SKws)||(mes[0]==PKf && key == SKf)\n\t\t||(mes[0]==EKc && key == EKc)||(mes[0]==EKs && key == EKs)||(mes[0]==EKfc && key ==EKfc)||(mes[0]==EKsf &&key == EKsf))\n\t{\n\t\tCouldGetEncMsg = true;\n\t}\n};\n\n/*-------------------------------------------// verify signatured messages */\nvar CouldVerifySigMsg = false;\n#define verifySigMsg(sigMes, key, encMes){\n\tCouldVerifySigMsg = false;\n\tif(((sigMes[0]==SKmes&&key==PKmes)||(sigMes[0]==SKws&&key==PKws)||(sigMes[0]==SKf&&key==PKf)\n\t\t||(sigMes[0]==SGc&&key==SGc)||(sigMes[0]==SGs&&key==SGs)||(sigMes[0]==SGfc&&key==SGfc)||(sigMes[0]==SGsf&&key==SGsf))\n\t\t&&sigMes[1]==encMes[1]&&sigMes[2]==encMes[2]){\n\t\tCouldVerifySigMsg = true;\n\t}\n};\n\n/*-------------------------------------------// authenticate signature */\nvar CouldAuthMsg = false;\n#define authMsg(sig1, sig2, key, nonce, cert){\n\tCouldAuthMsg = false;\n\tif(((sig1[0]==SKmes&&key==PKmes)||(sig1[0]==SKws&&key==PKws))&&sig1[1]==nonce&&sig1[2]==cert\n\t\t&&sig2[0]==sig1[0]&&sig2[1]==nonce&&sig2[2]==cert){\n\t\tCouldAuthMsg = true;\n\t}\n};\n\n\n/*@Process: MES0\n  The MES mainly acts as an OPC UA client\n  The MES process initiates by trying one of the three options: opening a secure channel, creating a session, or activating a session.\n  - Open Secure Channel:\n\t1. It first generates a request to open a secure channel, containing a client nonce with the private key and the MES certificate and corresponding hashed message. \n\t2. Then sends the request to the Workshop.\n\t3. Receives a status and encrypted/signed response from the Workshop.\n\t4. If the status is success, it attempts to decrypt the response using its private key and verify the signature using the Workshop's public key. Otherwise, it fails to open the channel.\n\t5. If decryption and verification are successful, it the channel is opened successfully and loops back to the beginning. Otherwise, it fails.\n  - Create Session:\n\t1. It first generates a request to create a session, the request contains a nonce, encryption key and the MES certificate, and corresponding signature.\n\t2. Sends request and signature to the Workshop.\n\t3. Receives a status and encrypted/signed response and records it.\n\t4. If the status is success, it decrypts the response, authenticates with the Workshop's public key, and verifies the signature.\n\t5. If decryption, authentication and verification are successful, the session is marked open and loops back. Otherwise, it fails to create a session.\n  - Activate Session:\n\t1. It first generates a request containing encryption key, private key of MES, and a nonce and certificate of the Workshop. Together with the singed messages. \n\t2. Sends this request to the Workshop and waits for a status and encrypted/signed response.\n\t3. If the status is success, it decrypts the response and verifies the signature using the server's signing key.\n\t4. If successful, the session is marked active. Otherwise, it fails.\n\n*/\n/*=============================================================// MES Processes */\n\n// Knowlege: Certmes, PKmes, SKmes, PKws(from previous GetEndPointDescription)\nvar resCSEnc_Per[3];\nvar resCSEncSig_Per[3];\nvar resCSSig_Per[3];\nvar resCSSigSig_Per[3];\n\nMES0() =\n\t\tGenerateOSCReqMessage0\n\t\t{\n\t\t\treqOSCEnc[0] = PKws; reqOSCEnc[1] = Nc; reqOSCEnc[2] = Certmes;\n\t\t\treqOSCSig[0] = SKmes; reqOSCSig[1] = Nc; reqOSCSig[2] = Certmes;\n\t\t}\n\t\t-> \tSecureChannel!reqOSCEnc.reqOSCSig\n\t\t-> \tSecureChannel?status.Xe.Xs\n\t\t->\tif(status == RES_Suc){\n\t\t\t \tatomic{\n\t\t\t\t\tParseResOSCMessage0{call(getEncMsg, Xe, SKmes);call(verifySigMsg, Xs, PKws, Xe);}\n\t\t\t\t\t-> \tif(CouldGetEncMsg==true&&CouldVerifySigMsg==true)\t// 1. Decrypt to get Workshop Certificate & serverNonce\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsuccessOSC{channel_open_success=true}\n\t\t\t\t\t\t\t-> \tMES0\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{fail2{channel_open_success=false}-> MES0()}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfail1{channel_open_success=false} -> MES0()\n\t\t\t}\n[]\n\t\tGenerateCSReqMessage0\n\t\t{\n\t\t\treqCSEnc[0] = EKc; reqCSEnc[1] = Nmes; reqCSEnc[2] = Certmes;\n\t\t\treqCSSig[0] = SGc; reqCSSig[1] = Nmes; reqCSSig[2] = Certmes;\n\t\t}\n\t\t-> \tCreateSession!reqCSEnc.reqCSSig\n\t\t-> \tCreateSession?status.Xe.Xs\n\t\t{\n\t\t\tresCSEnc_Per[0] = Xe[0]; resCSEnc_Per[1] = Xe[1]; resCSEnc_Per[2] = Xe[2];\n\t\t\tresCSEncSig_Per[0] = Xe[3]; resCSEncSig_Per[1] = Xe[4]; resCSEncSig_Per[2] = Xe[5];\n\t\t\tresCSSig_Per[0] = Xs[0]; resCSSig_Per[1] = Xs[1]; resCSSig_Per[2] = Xs[2];\n\t\t\tresCSSigSig_Per[0] = Xs[3]; resCSSigSig_Per[1] = Xs[4]; resCSSigSig_Per[2] = Xs[5];\n\t\t}\n\t\t->\tif(status == RES_Suc){\n\t\t\t\tatomic{\n\t\t\t\t\tParseResCSMessage0{call(getEncMsg, resCSEnc_Per, EKs);call(authMsg, resCSEncSig_Per, resCSSigSig_Per, PKws, Nmes, Certmes);call(verifySigMsg, resCSSig_Per, SGs, resCSEnc_Per);}\t// NOTE: need to verify serverSignature\n\t\t\t\t\t-> if(CouldGetEncMsg==true&&CouldAuthMsg==true&&CouldVerifySigMsg==true)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsuccessCS{create_session_success=true}\n\t\t\t\t\t\t\t->  MES0\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{fail4{create_session_success=false}-> MES0()}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{fail3{create_session_success=false}->MES0() }\n[]\n\t\tGenerateASReqMessage0\n\t\t{\n\t\t\treqASEnc[0][0] = EKc; \n\t\t\treqASEnc[1][0] = SKmes; reqASEnc[1][1] = Nws; reqASEnc[1][2] = Certws;\n\t\t\treqASSig[0][0] = SGc; \n\t\t\treqASSig[1][0] = SKmes; reqASSig[1][1] = Nws; reqASSig[1][2] = Certws;\n\t\t}\n\t\t->\tActivateSession!reqASEnc.reqASSig\n\t\t->\tActivateSession?status.Xe.Xs\n\t\t->\tif(status == RES_Suc){\n\t\t\t\tatomic{\n\t\t\t\t\tParseResASMessage0{call(getEncMsg, Xe, EKs);call(verifySigMsg, Xs, SGs, Xe);}\n\t\t\t\t\t->\tif(CouldGetEncMsg==true&&CouldVerifySigMsg==true)\t// 1. Decrypt to get Workshop Certificate & serverNonce\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsuccessAS{active_session_success=true}\n\t\t\t\t\t\t\t->  MES0()\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{fail6{active_session_success=false}-> MES0()}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{fail5{active_session_success=false}-> MES0()};\n\t\t\t\n\n/*@Process: WORKSHOP0\nThe Workshop process would provide Services to reply to MES client\u2019s requests: open secure channel, create session, or activate session.\n- Secure Channel Request:\n  1. Receives an encrypted and signed request from the MES.\n  2. Attempts to decrypt the request using its private key and verify the signature using the MES's public key.\n  3. If both are successful, generates an encrypted and signed response containing a server nonce and a secure channel ID. \n  4. Sends a success status and the response back to the MES. Otherwise, sends a failure status.\n\n- Create Session Request:\n  1. Receives an encrypted and signed request from the MES.\n  2. Decrypts the request and verifies the signature.\n  3. If successful, generates an encrypted and signed response containing a Workshop nonce and certificate. \n  4. Sends a success status and the response. Otherwise, sends a failure status.\n\n- Activate Session Request:\n  1. Receives an encrypted and signed request from the MES.\n  2. Decrypts the request, verifies the signature, and authenticates.\n  3. If successful, generates an encrypted and signed response containing a nonce and encryption key. Sends the response back to MES. Otherwise, sends a failure status.\n*/\n/*=============================================================// Workshop Processes */\n\nvar reqASEnc_Per[3];\nvar reqASEncSig_Per[3];\nvar reqASSig_Per[3];\nvar reqASSigSig_Per[3];\n\nWORKSHOP0() = \n\t\tSecureChannel?Xe.Xs // Xe is process level var\n\t\t->  atomic{\n\t\t\t\tParseReqOSCMessage0{call(getEncMsg, Xe, SKws);call(verifySigMsg, Xs, PKmes, Xe);}\n\t\t\t\t-> \tif(CouldGetEncMsg==true&&CouldVerifySigMsg==true)\t// 1. Decrypt to get MES Certificate & clientNonce; 2. Verify Signature\n\t\t\t\t\t{\n\t\t\t\t\t\tGenerateOSCResMessage0\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tresOSCEnc[0] = PKmes; resOSCEnc[1] = Ns; resOSCEnc[2] = IDsc;\n\t\t\t\t\t\t\tresOSCSig[0] = SKws; resOSCSig[1] = Ns; resOSCSig[2] = IDsc;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t->\tSecureChannel!RES_Suc.resOSCEnc.resOSCSig\n\t\t\t\t\t\t-> \tWORKSHOP0\n\t\t\t\t\t}\n\t\t\t\t\telse{SecureChannel!RES_Fail.resOSCEnc.resOSCSig -> WORKSHOP0()}\n\t\t\t}\n[]\n\t\tCreateSession?Xe.Xs\n\t\t-> \tatomic{\n\t\t\t\tParseReqCSMessage0{call(getEncMsg, Xe, EKc);call(verifySigMsg, Xs, SGc, Xe);}\n\t\t\t\t->\tif(CouldGetEncMsg==true&&CouldVerifySigMsg==true)\t// 1. Decrypt to get MES Certificate & clientNonce 2. signed message\n\t\t\t\t\t{\n\t\t\t\t\t\tGenerateCSResMessage0\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tresCSEnc[0][0] = EKs; resCSEnc[0][1] = Nws; resCSEnc[0][2] = Certws;\n\t\t\t\t\t\t\tresCSEnc[1][0] = SKws; resCSEnc[1][1] = Nmes; resCSEnc[1][2] = Certmes;\n\t\t\t\t\t\t\tresCSSig[0][0] = SGs; resCSSig[0][1] = Nws; resCSSig[0][2] = Certws;\n\t\t\t\t\t\t\tresCSSig[1][0] = SKws; resCSSig[1][1] = Nmes; resCSSig[1][2] = Certmes;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t->\tCreateSession!RES_Suc.resCSEnc.resCSSig\n\t\t\t\t\t\t-> \tWORKSHOP0\n\t\t\t\t\t}\n\t\t\t\t\telse{CreateSession!RES_Fail.resCSEnc.resCSSig-> WORKSHOP0()}\n\t\t\t}\n[] \n\t\tActivateSession?Xe.Xs\n\t\t{\n\t\t\treqASEnc_Per[0] = Xe[0];\n\t\t\treqASEncSig_Per[0] = Xe[3]; reqASEncSig_Per[1] = Xe[4]; reqASEncSig_Per[2] = Xe[5];\n\t\t\treqASSig_Per[0] = Xs[0];\n\t\t\treqASSigSig_Per[0] = Xs[3]; reqASSigSig_Per[1] = Xs[4]; reqASSigSig_Per[2] = Xs[5];\n\t\t}\n\t\t->\tatomic{\n\t\t\t\tParseReqASMessage0{call(getEncMsg, reqASEnc_Per, EKc);call(verifySigMsg, reqASSig_Per, SGc, reqASEnc_Per);call(authMsg, reqASEncSig_Per, reqASSigSig_Per, PKmes, Nws, Certws);}\n\t\t\t\t->\tif(CouldGetEncMsg==true&&CouldVerifySigMsg==true&&CouldAuthMsg==true)\t// 1. Decrypt to get MES Certificate & clientNonce \n\t\t\t\t\t{\n\t\t\t\t\t\tGenerateASResMessage0\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tresASEnc[0] = EKs; resASEnc[1] = Nws2;\n\t\t\t\t\t\t\tresASSig[0] = SGs; resASSig[1] = Nws2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t->\tActivateSession!RES_Suc.resASEnc.resASSig\n\t\t\t\t\t\t-> \tWORKSHOP0()\n\t\t\t\t\t}\n\t\t\t\t\telse{ActivateSession!RES_Fail.resASEnc.resASSig-> WORKSHOP0()}\n\t\t\t};\n\n/*@Process: OPCUA_Connection\nThe overall system is the parallel composition of the MES0 and WORKSHOP0 processes\n*/\n// OPC UA communication process\nOPCUA_Connection() = MES0 || WORKSHOP0;",
        "property_desc": [
            "The system is deadlock-free.",
            "The system is divergence-free.",
            "The MES can open a secure channel to the Workshop",
            "The MES can create a session.",
            "The MES can activate a session."
        ],
        "properties": [
            "#define Channel_Open_Success channel_open_success == true;\n#define Create_Session_Success create_session_success == true;\n#define Active_Session_Success active_session_success == true;\n\n#assert OPCUA_Connection deadlockfree;",
            "#assert OPCUA_Connection divergencefree;",
            "#assert OPCUA_Connection reaches Channel_Open_Success;",
            "#assert OPCUA_Connection reaches Create_Session_Success;",
            "#assert OPCUA_Connection reaches Active_Session_Success;"
        ],
        "processes": [
            {
                "name": "MES0",
                "description": "The MES mainly acts as an OPC UA client\n  The MES process initiates by trying one of the three options: opening a secure channel, creating a session, or activating a session.\n  - Open Secure Channel:\n\t1. It first generates a request to open a secure channel, containing a client nonce with the private key and the MES certificate and corresponding hashed message. \n\t2. Then sends the request to the Workshop.\n\t3. Receives a status and encrypted/signed response from the Workshop.\n\t4. If the status is success, it attempts to decrypt the response using its private key and verify the signature using the Workshop's public key. Otherwise, it fails to open the channel.\n\t5. If decryption and verification are successful, it the channel is opened successfully and loops back to the beginning. Otherwise, it fails.\n  - Create Session:\n\t1. It first generates a request to create a session, the request contains a nonce, encryption key and the MES certificate, and corresponding signature.\n\t2. Sends request and signature to the Workshop.\n\t3. Receives a status and encrypted/signed response and records it.\n\t4. If the status is success, it decrypts the response, authenticates with the Workshop's public key, and verifies the signature.\n\t5. If decryption, authentication and verification are successful, the session is marked open and loops back. Otherwise, it fails to create a session.\n  - Activate Session:\n\t1. It first generates a request containing encryption key, private key of MES, and a nonce and certificate of the Workshop. Together with the singed messages. \n\t2. Sends this request to the Workshop and waits for a status and encrypted/signed response.\n\t3. If the status is success, it decrypts the response and verifies the signature using the server's signing key.\n\t4. If successful, the session is marked active. Otherwise, it fails.",
                "pat_code": "/*=============================================================// MES Processes */\n\n// Knowlege: Certmes, PKmes, SKmes, PKws(from previous GetEndPointDescription)\nvar resCSEnc_Per[3];\nvar resCSEncSig_Per[3];\nvar resCSSig_Per[3];\nvar resCSSigSig_Per[3];\n\nMES0() =\n\t\tGenerateOSCReqMessage0\n\t\t{\n\t\t\treqOSCEnc[0] = PKws; reqOSCEnc[1] = Nc; reqOSCEnc[2] = Certmes;\n\t\t\treqOSCSig[0] = SKmes; reqOSCSig[1] = Nc; reqOSCSig[2] = Certmes;\n\t\t}\n\t\t-> \tSecureChannel!reqOSCEnc.reqOSCSig\n\t\t-> \tSecureChannel?status.Xe.Xs\n\t\t->\tif(status == RES_Suc){\n\t\t\t \tatomic{\n\t\t\t\t\tParseResOSCMessage0{call(getEncMsg, Xe, SKmes);call(verifySigMsg, Xs, PKws, Xe);}\n\t\t\t\t\t-> \tif(CouldGetEncMsg==true&&CouldVerifySigMsg==true)\t// 1. Decrypt to get Workshop Certificate & serverNonce\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsuccessOSC{channel_open_success=true}\n\t\t\t\t\t\t\t-> \tMES0\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{fail2{channel_open_success=false}-> MES0()}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfail1{channel_open_success=false} -> MES0()\n\t\t\t}\n[]\n\t\tGenerateCSReqMessage0\n\t\t{\n\t\t\treqCSEnc[0] = EKc; reqCSEnc[1] = Nmes; reqCSEnc[2] = Certmes;\n\t\t\treqCSSig[0] = SGc; reqCSSig[1] = Nmes; reqCSSig[2] = Certmes;\n\t\t}\n\t\t-> \tCreateSession!reqCSEnc.reqCSSig\n\t\t-> \tCreateSession?status.Xe.Xs\n\t\t{\n\t\t\tresCSEnc_Per[0] = Xe[0]; resCSEnc_Per[1] = Xe[1]; resCSEnc_Per[2] = Xe[2];\n\t\t\tresCSEncSig_Per[0] = Xe[3]; resCSEncSig_Per[1] = Xe[4]; resCSEncSig_Per[2] = Xe[5];\n\t\t\tresCSSig_Per[0] = Xs[0]; resCSSig_Per[1] = Xs[1]; resCSSig_Per[2] = Xs[2];\n\t\t\tresCSSigSig_Per[0] = Xs[3]; resCSSigSig_Per[1] = Xs[4]; resCSSigSig_Per[2] = Xs[5];\n\t\t}\n\t\t->\tif(status == RES_Suc){\n\t\t\t\tatomic{\n\t\t\t\t\tParseResCSMessage0{call(getEncMsg, resCSEnc_Per, EKs);call(authMsg, resCSEncSig_Per, resCSSigSig_Per, PKws, Nmes, Certmes);call(verifySigMsg, resCSSig_Per, SGs, resCSEnc_Per);}\t// NOTE: need to verify serverSignature\n\t\t\t\t\t-> if(CouldGetEncMsg==true&&CouldAuthMsg==true&&CouldVerifySigMsg==true)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsuccessCS{create_session_success=true}\n\t\t\t\t\t\t\t->  MES0\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{fail4{create_session_success=false}-> MES0()}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{fail3{create_session_success=false}->MES0() }\n[]\n\t\tGenerateASReqMessage0\n\t\t{\n\t\t\treqASEnc[0][0] = EKc; \n\t\t\treqASEnc[1][0] = SKmes; reqASEnc[1][1] = Nws; reqASEnc[1][2] = Certws;\n\t\t\treqASSig[0][0] = SGc; \n\t\t\treqASSig[1][0] = SKmes; reqASSig[1][1] = Nws; reqASSig[1][2] = Certws;\n\t\t}\n\t\t->\tActivateSession!reqASEnc.reqASSig\n\t\t->\tActivateSession?status.Xe.Xs\n\t\t->\tif(status == RES_Suc){\n\t\t\t\tatomic{\n\t\t\t\t\tParseResASMessage0{call(getEncMsg, Xe, EKs);call(verifySigMsg, Xs, SGs, Xe);}\n\t\t\t\t\t->\tif(CouldGetEncMsg==true&&CouldVerifySigMsg==true)\t// 1. Decrypt to get Workshop Certificate & serverNonce\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsuccessAS{active_session_success=true}\n\t\t\t\t\t\t\t->  MES0()\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{fail6{active_session_success=false}-> MES0()}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{fail5{active_session_success=false}-> MES0()};"
            },
            {
                "name": "WORKSHOP0",
                "description": "The Workshop process would provide Services to reply to MES client\u2019s requests: open secure channel, create session, or activate session.\n- Secure Channel Request:\n  1. Receives an encrypted and signed request from the MES.\n  2. Attempts to decrypt the request using its private key and verify the signature using the MES's public key.\n  3. If both are successful, generates an encrypted and signed response containing a server nonce and a secure channel ID. \n  4. Sends a success status and the response back to the MES. Otherwise, sends a failure status.\n\n- Create Session Request:\n  1. Receives an encrypted and signed request from the MES.\n  2. Decrypts the request and verifies the signature.\n  3. If successful, generates an encrypted and signed response containing a Workshop nonce and certificate. \n  4. Sends a success status and the response. Otherwise, sends a failure status.\n\n- Activate Session Request:\n  1. Receives an encrypted and signed request from the MES.\n  2. Decrypts the request, verifies the signature, and authenticates.\n  3. If successful, generates an encrypted and signed response containing a nonce and encryption key. Sends the response back to MES. Otherwise, sends a failure status.",
                "pat_code": "/*=============================================================// Workshop Processes */\n\nvar reqASEnc_Per[3];\nvar reqASEncSig_Per[3];\nvar reqASSig_Per[3];\nvar reqASSigSig_Per[3];\n\nWORKSHOP0() = \n\t\tSecureChannel?Xe.Xs // Xe is process level var\n\t\t->  atomic{\n\t\t\t\tParseReqOSCMessage0{call(getEncMsg, Xe, SKws);call(verifySigMsg, Xs, PKmes, Xe);}\n\t\t\t\t-> \tif(CouldGetEncMsg==true&&CouldVerifySigMsg==true)\t// 1. Decrypt to get MES Certificate & clientNonce; 2. Verify Signature\n\t\t\t\t\t{\n\t\t\t\t\t\tGenerateOSCResMessage0\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tresOSCEnc[0] = PKmes; resOSCEnc[1] = Ns; resOSCEnc[2] = IDsc;\n\t\t\t\t\t\t\tresOSCSig[0] = SKws; resOSCSig[1] = Ns; resOSCSig[2] = IDsc;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t->\tSecureChannel!RES_Suc.resOSCEnc.resOSCSig\n\t\t\t\t\t\t-> \tWORKSHOP0\n\t\t\t\t\t}\n\t\t\t\t\telse{SecureChannel!RES_Fail.resOSCEnc.resOSCSig -> WORKSHOP0()}\n\t\t\t}\n[]\n\t\tCreateSession?Xe.Xs\n\t\t-> \tatomic{\n\t\t\t\tParseReqCSMessage0{call(getEncMsg, Xe, EKc);call(verifySigMsg, Xs, SGc, Xe);}\n\t\t\t\t->\tif(CouldGetEncMsg==true&&CouldVerifySigMsg==true)\t// 1. Decrypt to get MES Certificate & clientNonce 2. signed message\n\t\t\t\t\t{\n\t\t\t\t\t\tGenerateCSResMessage0\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tresCSEnc[0][0] = EKs; resCSEnc[0][1] = Nws; resCSEnc[0][2] = Certws;\n\t\t\t\t\t\t\tresCSEnc[1][0] = SKws; resCSEnc[1][1] = Nmes; resCSEnc[1][2] = Certmes;\n\t\t\t\t\t\t\tresCSSig[0][0] = SGs; resCSSig[0][1] = Nws; resCSSig[0][2] = Certws;\n\t\t\t\t\t\t\tresCSSig[1][0] = SKws; resCSSig[1][1] = Nmes; resCSSig[1][2] = Certmes;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t->\tCreateSession!RES_Suc.resCSEnc.resCSSig\n\t\t\t\t\t\t-> \tWORKSHOP0\n\t\t\t\t\t}\n\t\t\t\t\telse{CreateSession!RES_Fail.resCSEnc.resCSSig-> WORKSHOP0()}\n\t\t\t}\n[] \n\t\tActivateSession?Xe.Xs\n\t\t{\n\t\t\treqASEnc_Per[0] = Xe[0];\n\t\t\treqASEncSig_Per[0] = Xe[3]; reqASEncSig_Per[1] = Xe[4]; reqASEncSig_Per[2] = Xe[5];\n\t\t\treqASSig_Per[0] = Xs[0];\n\t\t\treqASSigSig_Per[0] = Xs[3]; reqASSigSig_Per[1] = Xs[4]; reqASSigSig_Per[2] = Xs[5];\n\t\t}\n\t\t->\tatomic{\n\t\t\t\tParseReqASMessage0{call(getEncMsg, reqASEnc_Per, EKc);call(verifySigMsg, reqASSig_Per, SGc, reqASEnc_Per);call(authMsg, reqASEncSig_Per, reqASSigSig_Per, PKmes, Nws, Certws);}\n\t\t\t\t->\tif(CouldGetEncMsg==true&&CouldVerifySigMsg==true&&CouldAuthMsg==true)\t// 1. Decrypt to get MES Certificate & clientNonce \n\t\t\t\t\t{\n\t\t\t\t\t\tGenerateASResMessage0\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tresASEnc[0] = EKs; resASEnc[1] = Nws2;\n\t\t\t\t\t\t\tresASSig[0] = SGs; resASSig[1] = Nws2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t->\tActivateSession!RES_Suc.resASEnc.resASSig\n\t\t\t\t\t\t-> \tWORKSHOP0()\n\t\t\t\t\t}\n\t\t\t\t\telse{ActivateSession!RES_Fail.resASEnc.resASSig-> WORKSHOP0()}\n\t\t\t};"
            },
            {
                "name": "OPCUA_Connection",
                "description": "The overall system is the parallel composition of the MES0 and WORKSHOP0 processes",
                "pat_code": "// OPC UA communication process\nOPCUA_Connection() = MES0 || WORKSHOP0;"
            }
        ],
        "global_definition": "channel SecureChannel 0;\nchannel CreateSession 0;\nchannel ActivateSession 0;\n\n// Asymmetric Keys & Certificates: MES = MES, WS = WorkShop\nenum {Certmes, Certws, Certf}; \t// Certificates: Cert = Certificate\nenum {PKmes, PKws, PKf };    \t// MES's public key & private key\nenum {SKmes, SKws, SKf};      \t// WorkShop's public key & private key\n\n// Nonces\nenum {Nc, Ns, Nfc, Nfs};          \t\t\t\t\t//  Nc = clientNonce, Ns = serverNonce: generate symmetric keys for session\nenum {Nmes, Nws, Nfmes, Nfws}; \t\t// Nmes = mesNonce, Nws = workshopNonce, Nws2 = workshopNonce2: authenticate identity for user signatures\nenum {Nws2, Nfws2}; \t\t\t\t\t\t\t\t\n\n// Symmetric Keys: SG = SigningKey, EK = EncryptionKey\nenum {SGc, SGs, SGfc, SGsf};     // clientSigningKey = PRF(serverNonce, clientNonce, SigningKeyLength)\nenum {EKc, EKs, EKfc, EKsf};     \n\n// IDs\nenum {IDsc, IDsf}; \t\t\t// SecureChannel ID\n\n// Status\nenum {RES_Suc, RES_Fail}; // response status\n\n\n// System property judge variables\nvar channel_open_success = false;\nvar create_session_success = false;\nvar active_session_success = false;\n\n// Encrypted Messages: \treq = request, res = response\n//\t\t\t\t\t\tEnc = Encryption, Sig = Signing\n// OSC = OpenSecureChannel\nvar reqOSCEnc[3]; // [0] = key, [n] = messages\nvar reqOSCSig[3]; // [0] = key, [n] represents hashed messages\nvar resOSCEnc[3];\nvar resOSCSig[3];\n\n// CS = CreateSession\nvar reqCSEnc[3];\nvar reqCSSig[3];\nvar resCSEnc[2][3]; \t\t// [0][0] = key, [0][n] = messages; [1][...] serverSignature: [1][0] = key, [1][n] = messages\nvar resCSSig[2][3]; \t\t// [0][0] = key, [0][n] = messages; [1][...] serverSignature: [1][0] = key, [1][n] = messages\n\n// AS = ActivateSession \nvar reqASEnc[2][3];\t// [0][0] = key; [1][...] serverSignature: [1][0] = key, [1][n] = messages\nvar reqASSig[2][3];\t// [0][0] = key; [1][...] serverSignature: [1][0] = key, [1][n] = messages\nvar resASEnc[3];\nvar resASSig[3];\n\n\n/*-------------------------------------------// decrypt encrypted messages */\nvar CouldGetEncMsg = false;\n#define getEncMsg(mes, key){\n\tCouldGetEncMsg= false;\n\tif((mes[0]==PKmes && key== SKmes)||(mes[0]==PKws && key == SKws)||(mes[0]==PKf && key == SKf)\n\t\t||(mes[0]==EKc && key == EKc)||(mes[0]==EKs && key == EKs)||(mes[0]==EKfc && key ==EKfc)||(mes[0]==EKsf &&key == EKsf))\n\t{\n\t\tCouldGetEncMsg = true;\n\t}\n};\n\n/*-------------------------------------------// verify signatured messages */\nvar CouldVerifySigMsg = false;\n#define verifySigMsg(sigMes, key, encMes){\n\tCouldVerifySigMsg = false;\n\tif(((sigMes[0]==SKmes&&key==PKmes)||(sigMes[0]==SKws&&key==PKws)||(sigMes[0]==SKf&&key==PKf)\n\t\t||(sigMes[0]==SGc&&key==SGc)||(sigMes[0]==SGs&&key==SGs)||(sigMes[0]==SGfc&&key==SGfc)||(sigMes[0]==SGsf&&key==SGsf))\n\t\t&&sigMes[1]==encMes[1]&&sigMes[2]==encMes[2]){\n\t\tCouldVerifySigMsg = true;\n\t}\n};\n\n/*-------------------------------------------// authenticate signature */\nvar CouldAuthMsg = false;\n#define authMsg(sig1, sig2, key, nonce, cert){\n\tCouldAuthMsg = false;\n\tif(((sig1[0]==SKmes&&key==PKmes)||(sig1[0]==SKws&&key==PKws))&&sig1[1]==nonce&&sig1[2]==cert\n\t\t&&sig2[0]==sig1[0]&&sig2[1]==nonce&&sig2[2]==cert){\n\t\tCouldAuthMsg = true;\n\t}\n};",
        "path": "handwrite/OPCUA.csp"
    },
    {
        "name": "OpenFlow",
        "tags": [
            "Protocol"
        ],
        "use_non_container_lib": false,
        "description": "Software Defined Networking (SDN) differs from traditional network architectures by separating the control layer from the data forwarding layer, thus realizing centralized and programmable management of the network.\n  The OpenFlow protocol, as the first proposed and most widely used standard southbound interface protocol for SDN, is one of the ideal underlying implementations of SDN.\n\n  There are several components in the model:",
        "pat_code": "#define S 3;\n#define B 2;\n#define M 3;\n\nvar isEcho[S];\n\nvar MsgNum[S];\nvar cmtNum[S];\nvar state[S][B]=[null,null,null,null,null,null];\n\nchannel ComEcho[S] 0;\nchannel ComCS[S*B] 0;\nchannel ComSB[S*B] 0;\nchannel time 0;\nchannel fake 0;\nchannel intercept 0;\nchannel tamper 0;\nchannel delay 0;\n\nvar echoReq;\nvar echoResp;\nvar timeReq;\n\nenum {open,add,close,commit,discard};\nenum {null,opened,closed};\nenum {bundle_exist,bad_id,bundle_closed,bundle_failed,scheduling_error,bad_prop,bad_fla};\nenum {success,fail};\n\n/*@Process: Controller\n  Controller represents the OpenFlow controller, managing bundles on switches:\n  The controller interacts with the switch using CBundle, which has two different behaviors CBundle1 and CBundle2\n*/\nController(cid,bid,type)=CBundle1(cid,bid,type)[]CBundle2(cid,bid,type); \n/*@Process: CBundle1\n  + CBundle1 sends a bundle operation request (bid.type) to the switch via ComCS[bid+cid*B], then waits for a response msg from the switch, and calls the Handle process.\n*/\nCBundle1(cid,bid,type)=ComCS[bid+cid*B]!bid.type->ComCS[bid+cid*B]?msg.error_code->Handle(cid,bid,msg,error_code);Skip;\n\n/*@Process: CBundle2\n  + CBundle2 sends a bundle operation request (bid.type) to the switch via ComCS[bid+cid*B] and then proceeds without waiting for a response.\n*/\nCBundle2(cid,bid,type)=ComCS[bid+cid*B]!bid.type->Skip;\n\n/*@Process: CEcho\n CEcho(cid) process sends an echo request to the switch and increments the echo count isEcho[cid] upon receiving a response.\n*/\nCEcho(cid)=ComEcho[cid]!echoReq->ComEcho[cid]?msg->{isEcho[cid]=isEcho[cid]+1;}->Skip;\n\n/*@Process: Handle\n  The Handle process deals with the switch's response to a bundle operation request. \n    - If the message is success, it does nothing. \n    - If the error code is scheduling_error, it discards all bundles for the given controller and resets the commit number. \n    - If the error code is bad_id, it does nothing. \n    - Otherwise, it discards the specific bundle.\n*/\nHandle(cid,bid,msg,error_code)=\nif(msg==success){Skip}\nelse{\nif(error_code==scheduling_error){|||i:{0..1}@CBundle1(cid,i,discard);{cmtNum[cid]=0}->Skip}\nelse{\nif(error_code==bad_id){Skip}\nelse{CBundle1(cid,bid,discard)}\n}\n};\n\n/*@Process: Switch\n  Switch represents an OpenFlow switch:\n  1. The switch receives bundle operation requests from the controller via ComCS[bid+cid*B] and then forwards the request to the Bundle process via ComSB[bid+cid*B]. \n  2. It then receives a response from the Bundle process via ComSB[bid+cid*B] and sends an acknowledgement of the operation to the Controller on channel ComCS[bid+cid*B].\n*/\nSwitch(cid,bid)=ComCS[bid+cid*B]?bid.type->ComSB[bid+cid*B]!bid.type->ComSB[bid+cid*B]?msg.type.error_code->\n  if(type==add&&msg==success) {Skip} else {ComCS[bid+cid*B]!msg.error_code->Skip};\n\n/*@Process: SEcho\n SEcho(cid) receives an echo request from the controller and sends back an echo response.\n*/\nSEcho(cid)=ComEcho[cid]?msg->ComEcho[cid]!echoResp->Skip;\n\n\n/*@Process: Bundle\n  Bundle models the bundle management logic on the switch.\n  1. It receives bundle id and operation types from the Switch via ComSB[bid+cid*B] and calls Assort process to execute specific logic.\n  2. After Assort process handles the operation, it sends the result of the operation, along with operator information and error codes, back to the switch via ComSB[bid+cid*B].\n  \n*/\nvar resp[S][B];\nvar errorCode[S][B];\nvar operator[S][B];\n\nBundle(cid,bid)=ComSB[bid+cid*B]?bid.type->Assort(cid,bid,type);ComSB[bid+cid*B]!resp[cid][bid].operator[cid][bid].errorCode[cid][bid]->Skip;\n\n/*@Process: Assort\n  Assort(cid, bid, type) is a case statement that handles different bundle operation type. There are 5 operation types:\n  - open bundle\n  - add bundle\n  - close bundle\n  - commit bundle\n  - discard bundle\n*/\nAssort(cid,bid,type)=\ncase{\n  type == open : opnBundle(cid,bid)\n  type == add : addBundle(cid,bid)\n  type == close : clsBundle(cid,bid)\n  type == commit : cmtBundle(cid,bid)\n  type == discard : delete(cid,bid)\n  default:Assort(cid,bid,type)\n};\n\n/*@Process: opnBundle\n  - opnBundle(cid, bid): Opens a bundle:\n    + If the channel identifier cid and bid are legal and does not belong to the current set of packet identifiers, the creation is considered successful.\n       The bundle is marked as opened and a success message is returned. \n    + If the bundle already exists, it returns a fail message with bundle_exist error. \n    + If the ID is invalid, it returns a fail message with a bad_id error.\n*/\nopnBundle(cid,bid)=\nif(cid<S&&bid<B){\n  if(state[cid][bid]==null){{state[cid][bid]=opened;resp[cid][bid]=success;operator[cid][bid]=open}->Skip}\n  else{{resp[cid][bid]=fail;operator[cid][bid]=open;errorCode[cid][bid]=bundle_exist}->Skip}\n}\nelse{{resp[cid][bid]=fail;operator[cid][bid]=open;errorCode[cid][bid]=bad_id}->Skip};\n\n/*@Process: addBundle\n  - addBundle(cid, bid): Adds to a bundle:\n    + If the channel identifier cid and bid are legal and if the bundle is opened, it increments MsgNum and returns a success message. \n    + If the bundle is not open, it returns a fail message with bundle_closed error. \n    + If the ID is invalid, it returns a fail message with bad_id error.\n*/\naddBundle(cid,bid)={\nif(cid<S&&bid<B){\n  if(state[cid][bid]==opened){MsgNum[cid]=MsgNum[cid]+1;resp[cid][bid]=success;operator[cid][bid]=add;}\n  else{resp[cid][bid]=fail;operator[cid][bid]=add;errorCode[cid][bid]=bundle_closed;}\n}\nelse{resp[cid][bid]=fail;operator[cid][bid]=add;errorCode[cid][bid]=bad_id;}\n}->Skip;\n\n/*@Process: clsBundle\n  - clsBundle(cid, bid): Closes a bundle:\n    + If the channel identifier cid and bid are legal and if the bundle is opened, it's marked as closed and a success message is returned. \n    + If the bundle is not open, it returns a fail message with bundle_closed error. \n    + If the ID is invalid, it returns a fail message with bad_id error.\n*/\nclsBundle(cid,bid)=\nif(cid<S&&bid<B){\n  if(state[cid][bid]==opened){{state[cid][bid]=closed;resp[cid][bid]=success;operator[cid][bid]=close}->Skip}\n  else{{resp[cid][bid]=fail;operator[cid][bid]=close;errorCode[cid][bid]=bundle_closed}->Skip}\n}\nelse{{resp[cid][bid]=fail;operator[cid][bid]=close;errorCode[cid][bid]=bad_id}->Skip};\n\n/*@Process: delete\n  - delete(cid, bid): Discards a bundle:\n    + If the channel identifier cid and bid are legal and if the bundle is not null, it's marked as null and a success message is returned. \n    + If the bundle is already null, it returns a fail message with bad_id error. \n    + If the ID is invalid, it returns a fail message with bad_id error.\n*/\ndelete(cid,bid)=\nif(cid<S&&bid<B){\n  if(state[cid][bid]!=null){{state[cid][bid]=null;resp[cid][bid]=success;operator[cid][bid]=discard}->Skip}\n  else{{resp[cid][bid]=fail;operator[cid][bid]=discard;errorCode[cid][bid]=bad_id}->Skip}\n}\nelse{{resp[cid][bid]=fail;operator[cid][bid]=discard;errorCode[cid][bid]=bad_id}->Skip};\n\n\n/*@Process: cmtBundle\n  - cmtBundle(cid, bid): Commits a bundle:\n    + If the channel identifier cid and bid are legal and if the bundle is closed and the current time is within the time threshold:\n      1. it waits for the appropriate amount of time and calls the aplMsg to apply the message. \n      2. It then updates the commit number (cmtNum) and commit time (Tc) if successful. \n      3. If the scheduling fails, it sets the error code to scheduling_error.\n    + If the bundle is not open, it returns a fail message with bundle_closed error. \n    + If the ID is invalid, it returns a fail message with bad_id error.\n*/\nvar Tc[S];\nvar Ts[S]=[3,3,3];\nvar Tt=4;\nvar now=1;\n\ncmtBundle(cid,bid)=\nif(cid<S&&bid<B){\n  if(state[cid][bid]==closed) {\n      if(now-Ts[cid]<Tt || Ts[cid]-now<Tt){\n         if(now<Ts[cid] || now==Ts[cid]) {\n             wait.(Ts[cid]-now) -> aplMsg(cid,bid);\n             if(resp[cid][bid]==success){{cmtNum[cid]=cmtNum[cid]+1;Tc[cid]=Ts[cid]}->Skip}}\n         else {\n             wait.0->aplMsg(cid,bid);\n             if(resp[cid][bid]==success){{cmtNum[cid]=cmtNum[cid]+1;Tc[cid]=now}->Skip}}\n         }\n      else {\n         {resp[cid][bid]=fail;operator[cid][bid]=commit;errorCode[cid][bid]=scheduling_error}->Skip\n      }\n   }\n   else{\n    {state[cid][bid]=closed}->cmtBundle(cid,bid)\n   }\n } else{\n  {resp[cid][bid]=fail;operator[cid][bid]=commit;errorCode[cid][bid]=bad_id}->Skip\n };\n      \n/*@Process: aplMsg\n  aplMsg(cid,bid) process: Applies messages to a bundle:\n  1. It checks isPreValid to determine if a message needs to be applied. \n  2. If the required number of messages are applied, the bundle is marked committed successfully. Otherwise, the commit fails.\n*/\nvar isPreValid[S][B*M];\nvar isApplied[S][B*M];    \nvar aplNum[S][B]; \nvar nowTime; \n      \naplMsg(cid,bid)=\n{var msg_id=0;\n   if(isPreValid[cid][bid*M+0]==0)\n     {isApplied[cid][bid*M+0]=1;aplNum[cid][bid]=aplNum[cid][bid]+1;}\n   if(isPreValid[cid][bid*M+1]==0)\n     {isApplied[cid][bid*M+1]=1;aplNum[cid][bid]=aplNum[cid][bid]+1;}\n   if(isPreValid[cid][bid*M+2]==0)\n     {isApplied[cid][bid*M+2]=1;aplNum[cid][bid]=aplNum[cid][bid]+1;}\n     \nif(aplNum[cid][bid]==M){resp[cid][bid]=success;operator[cid][bid]=commit;}\nelse{aplNum[cid][bid]=0;resp[cid][bid]=fail;operator[cid][bid]=commit;errorCode[cid][bid]=bundle_failed;}\n}->Skip;\n\n/*@Process: Timer\n  Timer(): A simple timer process that increments nowTime on each tick and allows external processes to query the current time via the time channel.\n*/\nTimer()=tick->{nowTime=nowTime+1}->Timer [] time?msg->time!nowTime->Timer();\n\n/*@Process: OpenBundle\n  OpenBundle(cid, bid) combine the interactions of the controller, switch, and bundle for each operation.\n*/\nOpenBundle(cid,bid)=CBundle1(cid,bid,open)||Switch(cid,bid)||Bundle(cid,bid);\n/*@Process: AddBundle\n  AddBundle(cid, bid) combine the interactions of the controller, switch, and bundle for each operation.\n*/\nAddBundle(cid,bid)=CBundle2(cid,bid,add)||Switch(cid,bid)||Bundle(cid,bid);\n/*@Process: CloseBundle\n  CloseBundle(cid, bid) combine the interactions of the controller, switch, and bundle for each operation.\n*/\nCloseBundle(cid,bid)=CBundle1(cid,bid,close)||Switch(cid,bid)||Bundle(cid,bid);\n/*@Process: CommitBundle\n  CommitBundle(cid, bid) combine the interactions of the controller, switch, and bundle for each operation.\n*/\nCommitBundle(cid,bid)=CBundle1(cid,bid,commit)||Switch(cid,bid)||Bundle(cid,bid);\n\n/*@Process: Open\n Open() create some specific processes by calling the bundle operations of open, add, add, add, close and commit sequentially.\n*/\nOpen()=OpenBundle(0,1);AddBundle(0,1);AddBundle(0,1);AddBundle(0,1);CloseBundle(0,1);CommitBundle(0,1);\n/*@Process: Add\n Add() create some specific processes by calling the bundle operations of open, add, add, add, close and commit sequentially.\n*/\nAdd()=OpenBundle(0,0);AddBundle(0,0);AddBundle(0,0);AddBundle(0,0);CloseBundle(0,0);CommitBundle(0,0);\n\n/*@Process: System\n  System composes the controller and switch echo processes, and then runs Open and Add interleavingly.\n*/\nSystem() = CEcho(0)||SEcho(0); Open()|||Add();",
        "property_desc": [
            "The system is deadlock-free."
        ],
        "properties": [
            "#assert System() deadlockfree;"
        ],
        "processes": [
            {
                "name": "Controller",
                "description": "Controller represents the OpenFlow controller, managing bundles on switches:\n  The controller interacts with the switch using CBundle, which has two different behaviors CBundle1 and CBundle2",
                "pat_code": "Controller(cid,bid,type)=CBundle1(cid,bid,type)[]CBundle2(cid,bid,type);"
            },
            {
                "name": "CBundle1",
                "description": "+ CBundle1 sends a bundle operation request (bid.type) to the switch via ComCS[bid+cid*B], then waits for a response msg from the switch, and calls the Handle process.",
                "pat_code": "CBundle1(cid,bid,type)=ComCS[bid+cid*B]!bid.type->ComCS[bid+cid*B]?msg.error_code->Handle(cid,bid,msg,error_code);Skip;"
            },
            {
                "name": "CBundle2",
                "description": "+ CBundle2 sends a bundle operation request (bid.type) to the switch via ComCS[bid+cid*B] and then proceeds without waiting for a response.",
                "pat_code": "CBundle2(cid,bid,type)=ComCS[bid+cid*B]!bid.type->Skip;"
            },
            {
                "name": "CEcho",
                "description": "CEcho(cid) process sends an echo request to the switch and increments the echo count isEcho[cid] upon receiving a response.",
                "pat_code": "CEcho(cid)=ComEcho[cid]!echoReq->ComEcho[cid]?msg->{isEcho[cid]=isEcho[cid]+1;}->Skip;"
            },
            {
                "name": "Handle",
                "description": "The Handle process deals with the switch's response to a bundle operation request. \n    - If the message is success, it does nothing. \n    - If the error code is scheduling_error, it discards all bundles for the given controller and resets the commit number. \n    - If the error code is bad_id, it does nothing. \n    - Otherwise, it discards the specific bundle.",
                "pat_code": "Handle(cid,bid,msg,error_code)=\nif(msg==success){Skip}\nelse{\nif(error_code==scheduling_error){|||i:{0..1}@CBundle1(cid,i,discard);{cmtNum[cid]=0}->Skip}\nelse{\nif(error_code==bad_id){Skip}\nelse{CBundle1(cid,bid,discard)}\n}\n};"
            },
            {
                "name": "Switch",
                "description": "Switch represents an OpenFlow switch:\n  1. The switch receives bundle operation requests from the controller via ComCS[bid+cid*B] and then forwards the request to the Bundle process via ComSB[bid+cid*B]. \n  2. It then receives a response from the Bundle process via ComSB[bid+cid*B] and sends an acknowledgement of the operation to the Controller on channel ComCS[bid+cid*B].",
                "pat_code": "Switch(cid,bid)=ComCS[bid+cid*B]?bid.type->ComSB[bid+cid*B]!bid.type->ComSB[bid+cid*B]?msg.type.error_code->\n  if(type==add&&msg==success) {Skip} else {ComCS[bid+cid*B]!msg.error_code->Skip};"
            },
            {
                "name": "SEcho",
                "description": "SEcho(cid) receives an echo request from the controller and sends back an echo response.",
                "pat_code": "SEcho(cid)=ComEcho[cid]?msg->ComEcho[cid]!echoResp->Skip;"
            },
            {
                "name": "Bundle",
                "description": "Bundle models the bundle management logic on the switch.\n  1. It receives bundle id and operation types from the Switch via ComSB[bid+cid*B] and calls Assort process to execute specific logic.\n  2. After Assort process handles the operation, it sends the result of the operation, along with operator information and error codes, back to the switch via ComSB[bid+cid*B].",
                "pat_code": "var resp[S][B];\nvar errorCode[S][B];\nvar operator[S][B];\n\nBundle(cid,bid)=ComSB[bid+cid*B]?bid.type->Assort(cid,bid,type);ComSB[bid+cid*B]!resp[cid][bid].operator[cid][bid].errorCode[cid][bid]->Skip;"
            },
            {
                "name": "Assort",
                "description": "Assort(cid, bid, type) is a case statement that handles different bundle operation type. There are 5 operation types:\n  - open bundle\n  - add bundle\n  - close bundle\n  - commit bundle\n  - discard bundle",
                "pat_code": "Assort(cid,bid,type)=\ncase{\n  type == open : opnBundle(cid,bid)\n  type == add : addBundle(cid,bid)\n  type == close : clsBundle(cid,bid)\n  type == commit : cmtBundle(cid,bid)\n  type == discard : delete(cid,bid)\n  default:Assort(cid,bid,type)\n};"
            },
            {
                "name": "opnBundle",
                "description": "- opnBundle(cid, bid): Opens a bundle:\n    + If the channel identifier cid and bid are legal and does not belong to the current set of packet identifiers, the creation is considered successful.\n       The bundle is marked as opened and a success message is returned. \n    + If the bundle already exists, it returns a fail message with bundle_exist error. \n    + If the ID is invalid, it returns a fail message with a bad_id error.",
                "pat_code": "opnBundle(cid,bid)=\nif(cid<S&&bid<B){\n  if(state[cid][bid]==null){{state[cid][bid]=opened;resp[cid][bid]=success;operator[cid][bid]=open}->Skip}\n  else{{resp[cid][bid]=fail;operator[cid][bid]=open;errorCode[cid][bid]=bundle_exist}->Skip}\n}\nelse{{resp[cid][bid]=fail;operator[cid][bid]=open;errorCode[cid][bid]=bad_id}->Skip};"
            },
            {
                "name": "addBundle",
                "description": "- addBundle(cid, bid): Adds to a bundle:\n    + If the channel identifier cid and bid are legal and if the bundle is opened, it increments MsgNum and returns a success message. \n    + If the bundle is not open, it returns a fail message with bundle_closed error. \n    + If the ID is invalid, it returns a fail message with bad_id error.",
                "pat_code": "addBundle(cid,bid)={\nif(cid<S&&bid<B){\n  if(state[cid][bid]==opened){MsgNum[cid]=MsgNum[cid]+1;resp[cid][bid]=success;operator[cid][bid]=add;}\n  else{resp[cid][bid]=fail;operator[cid][bid]=add;errorCode[cid][bid]=bundle_closed;}\n}\nelse{resp[cid][bid]=fail;operator[cid][bid]=add;errorCode[cid][bid]=bad_id;}\n}->Skip;"
            },
            {
                "name": "clsBundle",
                "description": "- clsBundle(cid, bid): Closes a bundle:\n    + If the channel identifier cid and bid are legal and if the bundle is opened, it's marked as closed and a success message is returned. \n    + If the bundle is not open, it returns a fail message with bundle_closed error. \n    + If the ID is invalid, it returns a fail message with bad_id error.",
                "pat_code": "clsBundle(cid,bid)=\nif(cid<S&&bid<B){\n  if(state[cid][bid]==opened){{state[cid][bid]=closed;resp[cid][bid]=success;operator[cid][bid]=close}->Skip}\n  else{{resp[cid][bid]=fail;operator[cid][bid]=close;errorCode[cid][bid]=bundle_closed}->Skip}\n}\nelse{{resp[cid][bid]=fail;operator[cid][bid]=close;errorCode[cid][bid]=bad_id}->Skip};"
            },
            {
                "name": "delete",
                "description": "- delete(cid, bid): Discards a bundle:\n    + If the channel identifier cid and bid are legal and if the bundle is not null, it's marked as null and a success message is returned. \n    + If the bundle is already null, it returns a fail message with bad_id error. \n    + If the ID is invalid, it returns a fail message with bad_id error.",
                "pat_code": "delete(cid,bid)=\nif(cid<S&&bid<B){\n  if(state[cid][bid]!=null){{state[cid][bid]=null;resp[cid][bid]=success;operator[cid][bid]=discard}->Skip}\n  else{{resp[cid][bid]=fail;operator[cid][bid]=discard;errorCode[cid][bid]=bad_id}->Skip}\n}\nelse{{resp[cid][bid]=fail;operator[cid][bid]=discard;errorCode[cid][bid]=bad_id}->Skip};"
            },
            {
                "name": "cmtBundle",
                "description": "- cmtBundle(cid, bid): Commits a bundle:\n    + If the channel identifier cid and bid are legal and if the bundle is closed and the current time is within the time threshold:\n      1. it waits for the appropriate amount of time and calls the aplMsg to apply the message. \n      2. It then updates the commit number (cmtNum) and commit time (Tc) if successful. \n      3. If the scheduling fails, it sets the error code to scheduling_error.\n    + If the bundle is not open, it returns a fail message with bundle_closed error. \n    + If the ID is invalid, it returns a fail message with bad_id error.",
                "pat_code": "var Tc[S];\nvar Ts[S]=[3,3,3];\nvar Tt=4;\nvar now=1;\n\ncmtBundle(cid,bid)=\nif(cid<S&&bid<B){\n  if(state[cid][bid]==closed) {\n      if(now-Ts[cid]<Tt || Ts[cid]-now<Tt){\n         if(now<Ts[cid] || now==Ts[cid]) {\n             wait.(Ts[cid]-now) -> aplMsg(cid,bid);\n             if(resp[cid][bid]==success){{cmtNum[cid]=cmtNum[cid]+1;Tc[cid]=Ts[cid]}->Skip}}\n         else {\n             wait.0->aplMsg(cid,bid);\n             if(resp[cid][bid]==success){{cmtNum[cid]=cmtNum[cid]+1;Tc[cid]=now}->Skip}}\n         }\n      else {\n         {resp[cid][bid]=fail;operator[cid][bid]=commit;errorCode[cid][bid]=scheduling_error}->Skip\n      }\n   }\n   else{\n    {state[cid][bid]=closed}->cmtBundle(cid,bid)\n   }\n } else{\n  {resp[cid][bid]=fail;operator[cid][bid]=commit;errorCode[cid][bid]=bad_id}->Skip\n };"
            },
            {
                "name": "aplMsg",
                "description": "aplMsg(cid,bid) process: Applies messages to a bundle:\n  1. It checks isPreValid to determine if a message needs to be applied. \n  2. If the required number of messages are applied, the bundle is marked committed successfully. Otherwise, the commit fails.",
                "pat_code": "var isPreValid[S][B*M];\nvar isApplied[S][B*M];    \nvar aplNum[S][B]; \nvar nowTime; \n      \naplMsg(cid,bid)=\n{var msg_id=0;\n   if(isPreValid[cid][bid*M+0]==0)\n     {isApplied[cid][bid*M+0]=1;aplNum[cid][bid]=aplNum[cid][bid]+1;}\n   if(isPreValid[cid][bid*M+1]==0)\n     {isApplied[cid][bid*M+1]=1;aplNum[cid][bid]=aplNum[cid][bid]+1;}\n   if(isPreValid[cid][bid*M+2]==0)\n     {isApplied[cid][bid*M+2]=1;aplNum[cid][bid]=aplNum[cid][bid]+1;}\n     \nif(aplNum[cid][bid]==M){resp[cid][bid]=success;operator[cid][bid]=commit;}\nelse{aplNum[cid][bid]=0;resp[cid][bid]=fail;operator[cid][bid]=commit;errorCode[cid][bid]=bundle_failed;}\n}->Skip;"
            },
            {
                "name": "Timer",
                "description": "Timer(): A simple timer process that increments nowTime on each tick and allows external processes to query the current time via the time channel.",
                "pat_code": "Timer()=tick->{nowTime=nowTime+1}->Timer [] time?msg->time!nowTime->Timer();"
            },
            {
                "name": "OpenBundle",
                "description": "OpenBundle(cid, bid) combine the interactions of the controller, switch, and bundle for each operation.",
                "pat_code": "OpenBundle(cid,bid)=CBundle1(cid,bid,open)||Switch(cid,bid)||Bundle(cid,bid);"
            },
            {
                "name": "AddBundle",
                "description": "AddBundle(cid, bid) combine the interactions of the controller, switch, and bundle for each operation.",
                "pat_code": "AddBundle(cid,bid)=CBundle2(cid,bid,add)||Switch(cid,bid)||Bundle(cid,bid);"
            },
            {
                "name": "CloseBundle",
                "description": "CloseBundle(cid, bid) combine the interactions of the controller, switch, and bundle for each operation.",
                "pat_code": "CloseBundle(cid,bid)=CBundle1(cid,bid,close)||Switch(cid,bid)||Bundle(cid,bid);"
            },
            {
                "name": "CommitBundle",
                "description": "CommitBundle(cid, bid) combine the interactions of the controller, switch, and bundle for each operation.",
                "pat_code": "CommitBundle(cid,bid)=CBundle1(cid,bid,commit)||Switch(cid,bid)||Bundle(cid,bid);"
            },
            {
                "name": "Open",
                "description": "Open() create some specific processes by calling the bundle operations of open, add, add, add, close and commit sequentially.",
                "pat_code": "Open()=OpenBundle(0,1);AddBundle(0,1);AddBundle(0,1);AddBundle(0,1);CloseBundle(0,1);CommitBundle(0,1);"
            },
            {
                "name": "Add",
                "description": "Add() create some specific processes by calling the bundle operations of open, add, add, add, close and commit sequentially.",
                "pat_code": "Add()=OpenBundle(0,0);AddBundle(0,0);AddBundle(0,0);AddBundle(0,0);CloseBundle(0,0);CommitBundle(0,0);"
            },
            {
                "name": "System",
                "description": "System composes the controller and switch echo processes, and then runs Open and Add interleavingly.",
                "pat_code": "System() = CEcho(0)||SEcho(0); Open()|||Add();"
            }
        ],
        "global_definition": "#define S 3;\n#define B 2;\n#define M 3;\n\nvar isEcho[S];\n\nvar MsgNum[S];\nvar cmtNum[S];\nvar state[S][B]=[null,null,null,null,null,null];\n\nchannel ComEcho[S] 0;\nchannel ComCS[S*B] 0;\nchannel ComSB[S*B] 0;\nchannel time 0;\nchannel fake 0;\nchannel intercept 0;\nchannel tamper 0;\nchannel delay 0;\n\nvar echoReq;\nvar echoResp;\nvar timeReq;\n\nenum {open,add,close,commit,discard};\nenum {null,opened,closed};\nenum {bundle_exist,bad_id,bundle_closed,bundle_failed,scheduling_error,bad_prop,bad_fla};\nenum {success,fail};",
        "path": "handwrite/Openflow.csp"
    },
    {
        "name": "Paxos",
        "tags": [
            "Protocol",
            "Distrubued System"
        ],
        "use_non_container_lib": false,
        "description": "The Paxos protocol is a distributed consensus algorithm.\n  Paxos categorises the roles in the system as Proposer, Acceptor, and Learner:\n\t\tProposers: Propose values to be accepted.\n\t\tAcceptors: Receive proposals and decide which values to accept.\n\t\tLearners: Receive information about the accepted values.",
        "pat_code": "//Messages through the Acceptor channels are of format: proposer id(1 or 2), n, proposed value(-1 if none, 10/20 if there is a value)\nchannel A1 2;\nchannel A2 2;\nchannel A3 2;\n\n//Messages through the Proposer channels are of format: n (-1 to denote NACK), m (last accepted promise, -1 to denote none), val (last accepted value). proposers dont need to know which acceptor this response came from.\nchannel P1Ack 3;\nchannel P2Ack 3;\nvar P1Nack = 0;\nvar P2Nack = 0;\n\n// Learner channels\nchannel L1 3;\nchannel L2 3;\n\n// values that the proposers want to propose\n#define P1Val 10;\n#define P2Val 20;\n\n//Proposer 1 counter variables\nvar P1_numPromises = 0;\nvar P1_max_m = -1;\nvar P1_max_val = -1;\n\n//Proposer 2 counter variables\nvar P2_numPromises = 0;\nvar P2_max_m = -1;\nvar P2_max_val = -1;\n\nvar A1_last_n = -1; //last promise\nvar A1_last_m = -1; //last accepted\nvar A1_last_val =-1;\n\nvar A2_last_n = -1; //last promise\nvar A2_last_m = -1; //last accepted\nvar A2_last_val =-1;\n\nvar A3_last_n = -1; //last promise\nvar A3_last_m = -1; //last accepted\nvar A3_last_val =-1;\n\n// Learner variables\nvar L1_val = -1;\nvar L2_val = -1;\n\n//The consensus case, where at least 2 of the 3 acceptors must agree on the same value. The value cannot be -1 since that is the flag to denote the absence of a value.\n#define consensus (A1_last_val == A2_last_val && A1_last_val != -1) || (A1_last_val == A3_last_val && A1_last_val != -1) || (A2_last_val == A3_last_val && A2_last_val != -1);\n\n//BASIC PAXOS IN ERROR FREE SCENARIO\n\n//For the basic scenario, there is one proposer who tries to propose a value to 3 acceptors. Eventually, we just have to check if the consensus is reached where at least 2 of the 3 acceptors share a common value.\n//The proposer and 3 acceptors are running in an interleaving pattern.\n//The proposer can choose to either send a PREPARE or a ACCEPT request, in the event that the proposer has received a majority promise.\n//The acceptor must decide if the request it receives is a PREPARE or ACCEPT request, and then send either a NACK(in the event the promise is smaller than its previous promsie), or a PROMISE.\n\n/*@Process: Proposer1\n     1.Prepare stage:Send a Prepare request (value -1) to all Acceptors and wait for responses from the three Acceptors through the Proposer's confirmation channel P1Ack.\n\t 2.Process the response: Count the number of Promises that match the current proposal number n. If the number of Promises is less than 2 (not a majority), reset and try again (increment n).\n\t 3.Accept stage:If there is an accepted value, select the val corresponding to the maximum m(the last commitment accepted) and send Accept. Otherwise, send its own value P1Val=10.\n\t\n*/\n//First proposer\nProposer1(n) = \n\tA1!1.n.-1 -> A2!1.n.-1 -> A3!1.n.-1 -> P1Ack?n1.m1.v1 -> P1Ack?n2.m2.v2 ->  P1Ack?n3.m3.v3 -> // Send PREPARE, receive PROMISE\n\ttest1{if(n1 == n) {P1_numPromises = P1_numPromises + 1;}} -> test2{if(n2==n) {P1_numPromises = P1_numPromises + 1;}} -> test3{if(n3==n) {P1_numPromises = P1_numPromises + 1;}} ->\n\tif (P1_numPromises < 2) {reset_promises{P1_numPromises = 0;} -> Proposer1(n+2)} // Did not receive majority promise, retry\n\telse {\n\t    // Respond to majority promise\n\t    // Find the latest accepted value, if any\n\t\tfindmax {\n\t\t\tvar counter = 0;\n\t\t\tvar array_m = [m1, m2, m3];\n\t\t\tvar array_val = [v1, v2, v3];\n\t\t\twhile (counter < 3) {\n\t\t\t\tif (P1_max_m < array_m[counter]) {P1_max_m = array_m[counter]; P1_max_val = array_val[counter];}\n\t\t\t\tcounter = counter + 1;\n\t\t\t}} -> if (P1_max_m > -1) {\n\t\t\t\t// Something was accepted, send ACCEPT with the accepted value\n\t\t\t\tA1!1.n.P1_max_val -> A2!1.n.P1_max_val -> A3!1.n.P1_max_val -> reset_P1_fields{P1_numPromises = 0; P1_max_m = -1; P1_max_val = -1;} -> Stop\n\t\t\t} else {\n\t\t        // Nothing accepted yet, send ACCEPT with our value\n\t\t\t\tA1!1.n.P1Val -> A2!1.n.P1Val -> A3!1.n.P1Val -> reset_P1_fields{P1_numPromises = 0; P1_max_m = -1; P1_max_val = -1;} -> Stop\n\t\t\t}\n\t};\n\n/*@Process: __IGNORE__\n    Proposer2 is similar to Proposer1, but uses proposer ID = 2 and value P2Val = 20.\n*/ \n// Second Proposer\nProposer2(n) = \n\tA1!2.n.-1 -> A2!2.n.-1 -> A3!2.n.-1 -> P2Ack?n1.m1.v1 -> P2Ack?n2.m2.v2 ->  P2Ack?n3.m3.v3 -> // Send PREPARE, receive PROMISE\n\ttest1{if(n1 == n) {P2_numPromises = P2_numPromises + 1;}} -> test2{if(n2==n) {P2_numPromises = P2_numPromises + 1;}} -> test3{if(n3==n) {P2_numPromises = P2_numPromises + 1;}} ->\n\tif (P2_numPromises < 2) {reset_promises{P2_numPromises = 0;} -> Proposer2(n+2)} // Did not receive majority promise, retry \n\telse {\n\t    // Respond to majority PROMISE/ACCEPTED\n\t    // Find the latest accepted value, if any\n\t\tfindmax {\n\t\t\tvar counter = 0;\n\t\t\tvar array_m = [m1, m2, m3];\n\t\t\tvar array_val = [v1, v2, v3];\n\t\t\twhile (counter < 3) {\n\t\t\t\tif (P2_max_m < array_m[counter]) {P2_max_m = array_m[counter]; P2_max_val = array_val[counter];}\n\t\t\t\tcounter = counter + 1;\n\t\t\t}} -> if (P2_max_m > -1) {\n\t\t\t\t//something was accepted, send ACCEPT with the accepted value\n\t\t\t\tA1!2.n.P2_max_val -> A2!2.n.P2_max_val -> A3!2.n.P2_max_val -> reset_P2_fields{P2_numPromises = 0; P2_max_m = -1; P2_max_val = -1;} -> Stop\n\t\t\t} else {\n\t\t\t    // Nothing accepted yet, send ACCEPT with our value\n\t\t\t\tA1!2.n.P2Val -> A2!2.n.P2Val -> A3!2.n.P2Val -> reset_P2_fields{P2_numPromises = 0; P2_max_m = -1; P2_max_val = -1;} -> Stop\n\t\t\t}\n\t};\n\n/*@Process: Acceptor1\n    1.Receive message: Receive proposal request through A1 channel.\n\t2.Determine whether the request type is a Prepare request or an Accept request.\n\t    Prepare request:If the current proposal number < the last accepted proposal number: send NACK. Otherwise send Promise and update the last accepted proposal number.\n\t\tAccept request:If the current proposal number \u2265 the last accepted proposal number: accept the value, send confirmation, and notify the Learner at the same time, otherwise send NACK\n*/ \nAcceptor1(last_n, last_m, last_val) = updateAllVars{A1_last_n = last_n; A1_last_m = last_m; A1_last_val = last_val;} -> A1?prop.n.val \n//The acceptor needs to decide if the request it is hearing is a PREPARE or a ACCEPT request.\n\t-> if (val == -1 ) {Acceptor1PromisePath(n, prop, last_n, last_m, last_val)} else {Acceptor1AcceptPath(n, prop, val, last_n, last_m, last_val)};\n\n/*@Process: Acceptor1PromisePath\n\tPrepare request:If the current proposal number < the last accepted proposal number: send NACK. Otherwise send Promise and update the last accepted proposal number.\n*/ \nAcceptor1PromisePath(n, prop, last_n, last_m, last_val) = if (n < last_n) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//NACK\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (prop == 1) {P1Ack!-1.-1.-1 -> nack{P1Nack = last_n} -> Acceptor1(last_n, last_m, last_val)} else {P2Ack!-1.-1.-1 -> nack{P2Nack = last_n} -> Acceptor1(last_n, last_m, last_val)}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  } else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \t\tif (prop == 1) {P1Ack!n.last_m.last_val -> Acceptor1(n, last_m, last_val)} else {P2Ack!n.last_m.last_val -> Acceptor1(n, last_m, last_val)}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  };\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \t\t\n/*@Process: Acceptor1AcceptPath\n\tAccept request:If the current proposal number \u2265 the last accepted proposal number: accept the value, send confirmation, and notify the Learner at the same time, otherwise send NACK\n*/ \nAcceptor1AcceptPath(n, prop, val, last_n, last_m, last_val) = if (n < last_n) {\n\t\t\t\t\t\t\t\t\t\t\t\t    \tif (prop == 1) {P1Ack!-1.-1.-1 -> Acceptor1(last_n, last_m, last_val)} else {P2Ack!-1.-1.-1 -> Acceptor1(last_n, last_m, last_val)}\n\t\t\t\t\t\t\t\t\t\t\t\t   } else {\n\t\t\t\t\t\t\t\t\t\t\t\t   \t\tL1!P1_max_val -> L2!P1_max_val ->\n\t\t\t\t\t\t\t\t\t\t\t\t   \t\tif (prop == 1) {P1Ack!n.n.val -> Acceptor1(n, n, val)} else {P2Ack!n.n.val -> Acceptor1(n, n, val)}\n\t\t\t\t\t\t\t\t\t\t\t\t   };\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n/*@Process: __IGNORE__\n    Behaves the same as Acceptor1, but communicates through its own channel A2.\n*/ \nAcceptor2(last_n, last_m, last_val) = updateAllVars{A2_last_n = last_n; A2_last_m = last_m; A2_last_val = last_val;} -> A2?prop.n.val \n//The acceptor needs to decide if the request it is hearing is a PREPARE or a ACCEPT request.\n\t-> if (val == -1 ) {Acceptor2PromisePath(n, prop, last_n, last_m, last_val)} else {Acceptor2AcceptPath(n, prop, val, last_n, last_m, last_val)};\n\n/*@Process: __IGNORE__\n\tPrepare request:If the current proposal number < the last accepted proposal number: send NACK. Otherwise send Promise and update the last accepted proposal number.\n*/ \nAcceptor2PromisePath(n, prop, last_n, last_m, last_val) = if (n < last_n) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//NACK\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (prop == 1) {P1Ack!-1.-1.-1 -> nack{P1Nack = last_n} -> Acceptor2(last_n, last_m, last_val)} else {P2Ack!-1.-1.-1 -> nack{P2Nack = last_n} -> Acceptor2(last_n, last_m, last_val)}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  } else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t        L1!P1_max_val -> L2!P1_max_val ->\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \t\tif (prop == 1) {P1Ack!n.last_m.last_val -> Acceptor2(n, last_m, last_val)} else {P2Ack!n.last_m.last_val -> Acceptor2(n, last_m, last_val)}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  };\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \t\t\n/*@Process: __IGNORE__\n\tAccept request:If the current proposal number \u2265 the last accepted proposal number: accept the value, send confirmation, and notify the Learner at the same time, otherwise send NACK\n*/ \nAcceptor2AcceptPath(n, prop, val, last_n, last_m, last_val) = if (n < last_n) {\n\t\t\t\t\t\t\t\t\t\t\t\t    \tif (prop == 1) {P1Ack!-1.-1.-1 -> Acceptor2(last_n, last_m, last_val)} else {P2Ack!-1.-1.-1 -> Acceptor2(last_n, last_m, last_val)}\n\t\t\t\t\t\t\t\t\t\t\t\t   } else {\n\t\t\t\t\t\t\t\t\t\t\t\t   \t\tif (prop == 1) {P1Ack!n.n.val -> Acceptor2(n, n, val)} else {P2Ack!n.n.val -> Acceptor2(n, n, val)}\n\t\t\t\t\t\t\t\t\t\t\t\t   };\n/*@Process: __IGNORE__\n    Behaves the same as Acceptor1, but communicates through its own channel A3.\n*/ \nAcceptor3(last_n, last_m, last_val) = updateAllVars{A3_last_n = last_n; A3_last_m = last_m; A3_last_val = last_val;} -> A3?prop.n.val \n//The acceptor needs to decide if the request it is hearing is a PREPARE or a ACCEPT request.\n\t-> if (val == -1 ) {Acceptor3PromisePath(n, prop, last_n, last_m, last_val)} else {Acceptor3AcceptPath(n, prop, val, last_n, last_m, last_val)};\n\n/*@Process: __IGNORE__\n\tPrepare request:If the current proposal number < the last accepted proposal number: send NACK. Otherwise send Promise and update the last accepted proposal number.\n*/ \nAcceptor3PromisePath(n, prop, last_n, last_m, last_val) = if (n < last_n) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//NACK\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (prop == 1) {P1Ack!-1.-1.-1 -> nack{P1Nack = last_n} -> Acceptor3(last_n, last_m, last_val)} else {P2Ack!-1.-1.-1 -> nack{P2Nack = last_n} -> Acceptor3(last_n, last_m, last_val)}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  } else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \t\tif (prop == 1) {P1Ack!n.last_m.last_val -> Acceptor3(n, last_m, last_val)} else {P2Ack!n.last_m.last_val -> Acceptor3(n, last_m, last_val)}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  };\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \t\t\n/*@Process: __IGNORE__\n\tAccept request:If the current proposal number \u2265 the last accepted proposal number: accept the value, send confirmation, and notify the Learner at the same time, otherwise send NACK\n*/ \nAcceptor3AcceptPath(n, prop, val, last_n, last_m, last_val) = if (n < last_n) {\n\t\t\t\t\t\t\t\t\t\t\t\t    \tif (prop == 1) {P1Ack!-1.-1.-1 -> Acceptor3(last_n, last_m, last_val)} else {P2Ack!-1.-1.-1 -> Acceptor3(last_n, last_m, last_val)}\n\t\t\t\t\t\t\t\t\t\t\t\t   } else {\n\t\t\t\t\t\t\t\t\t\t\t\t   \t\tL1!P1_max_val -> L2!P1_max_val ->\n\t\t\t\t\t\t\t\t\t\t\t\t   \t\tif (prop == 1) {P1Ack!n.n.val -> Acceptor3(n, n, val)} else {P2Ack!n.n.val -> Acceptor3(n, n, val)}\n\t\t\t\t\t\t\t\t\t\t\t\t   };\n\n/*@Process: Learner1\n\tThe Learner1 process continuously reads values \u200b\u200bfrom channel L1 and updates the learned values.\n*/ \t\t\t\t\t\t\t\t\t\t\t   \nLearner1() = L1?val -> update_val{L1_val = val} -> Learner1();\t\n\n/*@Process: __IGNORE__\n\tThe Learner2 process continuously reads values \u200b\u200bfrom channel L2 and updates the learned values.\n*/ \t\nLearner2()= L2?val -> update_val{L2_val = val} -> Learner2();\t\t\t\t\t\t\t\t\t\t\t   \n\n/*@Process: System\n\tThe System involves interleaving execution among the proposer, acceptor, and learner.\n*/ \nSystem() = Proposer1(1) ||| Acceptor1(-1, -1, -1) ||| Acceptor2(-1, -1, -1) ||| Acceptor3(-1, -1, -1) ||| Learner1() ||| Learner2();",
        "property_desc": [
            "The system is deadlock-free.",
            "The system satisfies the condition that most Acceptors agree on the same value."
        ],
        "properties": [
            "#assert System() deadlockfree;",
            "// Basic Paxos, error-free scenario\n#assert System() |= <> consensus; // expect VALID"
        ],
        "processes": [
            {
                "name": "Proposer1",
                "description": "1.Prepare stage:Send a Prepare request (value -1) to all Acceptors and wait for responses from the three Acceptors through the Proposer's confirmation channel P1Ack.\n\t 2.Process the response: Count the number of Promises that match the current proposal number n. If the number of Promises is less than 2 (not a majority), reset and try again (increment n).\n\t 3.Accept stage:If there is an accepted value, select the val corresponding to the maximum m(the last commitment accepted) and send Accept. Otherwise, send its own value P1Val=10.",
                "pat_code": "//First proposer\nProposer1(n) = \n\tA1!1.n.-1 -> A2!1.n.-1 -> A3!1.n.-1 -> P1Ack?n1.m1.v1 -> P1Ack?n2.m2.v2 ->  P1Ack?n3.m3.v3 -> // Send PREPARE, receive PROMISE\n\ttest1{if(n1 == n) {P1_numPromises = P1_numPromises + 1;}} -> test2{if(n2==n) {P1_numPromises = P1_numPromises + 1;}} -> test3{if(n3==n) {P1_numPromises = P1_numPromises + 1;}} ->\n\tif (P1_numPromises < 2) {reset_promises{P1_numPromises = 0;} -> Proposer1(n+2)} // Did not receive majority promise, retry\n\telse {\n\t    // Respond to majority promise\n\t    // Find the latest accepted value, if any\n\t\tfindmax {\n\t\t\tvar counter = 0;\n\t\t\tvar array_m = [m1, m2, m3];\n\t\t\tvar array_val = [v1, v2, v3];\n\t\t\twhile (counter < 3) {\n\t\t\t\tif (P1_max_m < array_m[counter]) {P1_max_m = array_m[counter]; P1_max_val = array_val[counter];}\n\t\t\t\tcounter = counter + 1;\n\t\t\t}} -> if (P1_max_m > -1) {\n\t\t\t\t// Something was accepted, send ACCEPT with the accepted value\n\t\t\t\tA1!1.n.P1_max_val -> A2!1.n.P1_max_val -> A3!1.n.P1_max_val -> reset_P1_fields{P1_numPromises = 0; P1_max_m = -1; P1_max_val = -1;} -> Stop\n\t\t\t} else {\n\t\t        // Nothing accepted yet, send ACCEPT with our value\n\t\t\t\tA1!1.n.P1Val -> A2!1.n.P1Val -> A3!1.n.P1Val -> reset_P1_fields{P1_numPromises = 0; P1_max_m = -1; P1_max_val = -1;} -> Stop\n\t\t\t}\n\t};"
            },
            {
                "name": "Acceptor1",
                "description": "1.Receive message: Receive proposal request through A1 channel.\n\t2.Determine whether the request type is a Prepare request or an Accept request.\n\t    Prepare request:If the current proposal number < the last accepted proposal number: send NACK. Otherwise send Promise and update the last accepted proposal number.\n\t\tAccept request:If the current proposal number \u2265 the last accepted proposal number: accept the value, send confirmation, and notify the Learner at the same time, otherwise send NACK",
                "pat_code": "Acceptor1(last_n, last_m, last_val) = updateAllVars{A1_last_n = last_n; A1_last_m = last_m; A1_last_val = last_val;} -> A1?prop.n.val \n//The acceptor needs to decide if the request it is hearing is a PREPARE or a ACCEPT request.\n\t-> if (val == -1 ) {Acceptor1PromisePath(n, prop, last_n, last_m, last_val)} else {Acceptor1AcceptPath(n, prop, val, last_n, last_m, last_val)};"
            },
            {
                "name": "Acceptor1PromisePath",
                "description": "Prepare request:If the current proposal number < the last accepted proposal number: send NACK. Otherwise send Promise and update the last accepted proposal number.",
                "pat_code": "Acceptor1PromisePath(n, prop, last_n, last_m, last_val) = if (n < last_n) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//NACK\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (prop == 1) {P1Ack!-1.-1.-1 -> nack{P1Nack = last_n} -> Acceptor1(last_n, last_m, last_val)} else {P2Ack!-1.-1.-1 -> nack{P2Nack = last_n} -> Acceptor1(last_n, last_m, last_val)}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  } else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \t\tif (prop == 1) {P1Ack!n.last_m.last_val -> Acceptor1(n, last_m, last_val)} else {P2Ack!n.last_m.last_val -> Acceptor1(n, last_m, last_val)}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  };"
            },
            {
                "name": "Acceptor1AcceptPath",
                "description": "Accept request:If the current proposal number \u2265 the last accepted proposal number: accept the value, send confirmation, and notify the Learner at the same time, otherwise send NACK",
                "pat_code": "Acceptor1AcceptPath(n, prop, val, last_n, last_m, last_val) = if (n < last_n) {\n\t\t\t\t\t\t\t\t\t\t\t\t    \tif (prop == 1) {P1Ack!-1.-1.-1 -> Acceptor1(last_n, last_m, last_val)} else {P2Ack!-1.-1.-1 -> Acceptor1(last_n, last_m, last_val)}\n\t\t\t\t\t\t\t\t\t\t\t\t   } else {\n\t\t\t\t\t\t\t\t\t\t\t\t   \t\tL1!P1_max_val -> L2!P1_max_val ->\n\t\t\t\t\t\t\t\t\t\t\t\t   \t\tif (prop == 1) {P1Ack!n.n.val -> Acceptor1(n, n, val)} else {P2Ack!n.n.val -> Acceptor1(n, n, val)}\n\t\t\t\t\t\t\t\t\t\t\t\t   };"
            },
            {
                "name": "Learner1",
                "description": "The Learner1 process continuously reads values \u200b\u200bfrom channel L1 and updates the learned values.",
                "pat_code": "Learner1() = L1?val -> update_val{L1_val = val} -> Learner1();"
            },
            {
                "name": "System",
                "description": "The System involves interleaving execution among the proposer, acceptor, and learner.",
                "pat_code": "System() = Proposer1(1) ||| Acceptor1(-1, -1, -1) ||| Acceptor2(-1, -1, -1) ||| Acceptor3(-1, -1, -1) ||| Learner1() ||| Learner2();"
            }
        ],
        "global_definition": "//Messages through the Acceptor channels are of format: proposer id(1 or 2), n, proposed value(-1 if none, 10/20 if there is a value)\nchannel A1 2;\nchannel A2 2;\nchannel A3 2;\n\n//Messages through the Proposer channels are of format: n (-1 to denote NACK), m (last accepted promise, -1 to denote none), val (last accepted value). proposers dont need to know which acceptor this response came from.\nchannel P1Ack 3;\nchannel P2Ack 3;\nvar P1Nack = 0;\nvar P2Nack = 0;\n\n// Learner channels\nchannel L1 3;\nchannel L2 3;\n\n// values that the proposers want to propose\n#define P1Val 10;\n#define P2Val 20;\n\n//Proposer 1 counter variables\nvar P1_numPromises = 0;\nvar P1_max_m = -1;\nvar P1_max_val = -1;\n\n//Proposer 2 counter variables\nvar P2_numPromises = 0;\nvar P2_max_m = -1;\nvar P2_max_val = -1;\n\nvar A1_last_n = -1; //last promise\nvar A1_last_m = -1; //last accepted\nvar A1_last_val =-1;\n\nvar A2_last_n = -1; //last promise\nvar A2_last_m = -1; //last accepted\nvar A2_last_val =-1;\n\nvar A3_last_n = -1; //last promise\nvar A3_last_m = -1; //last accepted\nvar A3_last_val =-1;\n\n// Learner variables\nvar L1_val = -1;\nvar L2_val = -1;\n\n//The consensus case, where at least 2 of the 3 acceptors must agree on the same value. The value cannot be -1 since that is the flag to denote the absence of a value.\n#define consensus (A1_last_val == A2_last_val && A1_last_val != -1) || (A1_last_val == A3_last_val && A1_last_val != -1) || (A2_last_val == A3_last_val && A2_last_val != -1);\n\n//BASIC PAXOS IN ERROR FREE SCENARIO\n\n//For the basic scenario, there is one proposer who tries to propose a value to 3 acceptors. Eventually, we just have to check if the consensus is reached where at least 2 of the 3 acceptors share a common value.\n//The proposer and 3 acceptors are running in an interleaving pattern.\n//The proposer can choose to either send a PREPARE or a ACCEPT request, in the event that the proposer has received a majority promise.\n//The acceptor must decide if the request it receives is a PREPARE or ACCEPT request, and then send either a NACK(in the event the promise is smaller than its previous promsie), or a PROMISE.",
        "path": "handwrite/Paxos.csp"
    },
    {
        "name": "Percolator(Simple)",
        "tags": [
            "Protocol",
            "Distrubued System"
        ],
        "use_non_container_lib": false,
        "description": "Percolator is a distributed transaction model proposed by Google in 2010 for processing large-scale incremental data of search engines. Percolator utilizes the single-row transaction capability provided by BigTable to implement distributed transactions at the snapshot isolation level.\n  Percolator has three roles: \n\t- The client: initiates the transaction. There are two types of transactions: read and write.\n\t- The TSO(timestamp oracle): provides a strictly monotone increasing getTimestamp\n\t- The BigTable: stores the data. Percolator defines three columns in BigTable for transactions: c:lock, c:write and c: data.",
        "pat_code": "#define N 2; // number of client\n#define M 3; // number of records\n#define NTS 16; // max time\n#define LOCKED true;\n#define NOT_LOCKED false;\n#define TRUE 1;\n#define FALSE 0;\n#define NULL 0;\n\nenum {ROW_DATA};\n\nchannel ComTSOCli[N+1] 0; // tso -> client\nchannel ComCliBT[N+1] 0; // client -> bigtable\nchannel ComBTCli[N+1] 0; // bigtable -> client\n\nvar numTxnDone = 0;\nvar timestamp = 3;\n\n/*@Process: TSO\n  The TSO(timestamp oracle) provides a strictly monotone increasing timestamp. It consists of N subprocesses handling request from each client.\n*/\nTSO() = |||i:{1..N}@TSOProxy(i);\n\n/*@Process: TSOProxy\n  TSOProxy receives timestamp request and responds with the global timestamp and increase the global timestamp by 1 atomicly.\n\tOr if the transaction done signal is received, it terminates successfully.\n*/\nTSOProxy(i) = \n\ttxnDone.i -> Skip\n\t[] \n\t(getTimestamp.i -> ComTSOCli[i]!timestamp{timestamp++;} -> TSOProxy(i));\n\n/*@Process: Client\n  The client:\n  1. It initiates the transaction\n\t2. It first requests the start timestamp from the TSO and receive the timestamp.\n\t3. It may initiates read transaction or write transaction with the timestamp and rows to be read or written.\n\t4. After the transaction is done, it increase the counter the number of completed transactions and termiantes.\n*/\nClient(i) = beginTransaction.i -> getTimestamp.i -> ComTSOCli[i]?start_ts -> (\n\t\t[i == 1](TransactionRead(i, 2, start_ts);TransactionRead(i, 1, start_ts))\n\t\t[] [i == 2](TransactionWrite(i, [2,3], start_ts, 10))\n\t\t[] [i == 3]TransactionWrite(i, [1,2], start_ts, 20)\n\t);\n\ttxnDone.i -> {numTxnDone++;} -> Skip;\n\n/*@Process: BackoffAndMaybeCleanupLock\n  Backoff:\n  It backs off for a period of time until it considers the lock is held long enough to be cleaned up, cleanup locks and termiantes.\n*/\nBackoffAndMaybeCleanupLock(i) = \n  cleanupLock.i -> Skip\n  []\n  backoff.i -> BackoffAndMaybeCleanupLock(i);\n\n/*@Process: TransactionRead\n  Read Transaction:\n  1. The read transaction begins with the start timestamp and data to be read.\n  2. Then the client queries BigTable to see if the data to be read has a lock before the start timestamp\n\t3. When a client encounters locks, it backs off for a period of time and cleanup locks. \n\t4. When no lock is present, the data is read based on the last commit record in the c:write column before the start timestamp and check the snapshot isolation.\n*/\n#alphabet TransactionRead {TRead.i, TPrewrite.i, TCommitWrite.i};\nTransactionRead(i, row, start_ts) = TRead.i -> ComCliBT[i]!row.start_ts \n\t-> ComBTCli[i]?locked.data -> if(locked == LOCKED) {\n\t\tBackoffAndMaybeCleanupLock(i);  \n\t\tTransactionRead(i, row, start_ts)\n\t} else {\n\t    checkSnapshotIsolation -> Skip\n\t};\n\n/*@Process: TransactionWrite\n  Percolator\u2019s write transaction is divided into two phases, prewrite and commit.\n\tPrewrite:\n\t1. When the write transaction begins, among all records to be written, a random record is chosen as the primary, and the rest as the secondary.\n\t2. Then, the client requests the TSO to obtain a start timestamp of the transaction.\n\t3. In the prewrite phase, the client requests the BigTable to check each record to be prewritten whether there is a conflict.\n\t\t\tIf the conflict exists, the transaction should abort. Otherwise, it enters into the commit phase.\n\tCommit:\n\t4. At the beginning of the commit phase, the client requests the TSO again for the commit timestamp. \n\t5. Then, it sends a commit request to BigTable.\n\t6. If the primary is successfully committed, the entire transaction is considered committed successfully.\n\t\t\tOtherwise, it aborts.\n\t7. After the primary is committed, Percolator commits the secondary non-transactionally, and the write transaction is complete. \n*/\n#alphabet TransactionWrite {TRead.i, TPrewrite.i, TCommitWrite.i};\nTransactionWrite(i, rows, start_ts, data) = TPrewrite.i -> ComCliBT[i]!rows.data.rows[0].start_ts \n\t-> ComBTCli[i]?success -> if(success == false) {\n\t\tabort.i -> Skip\n\t} else {\n\t\t getTimestamp.i -> ComTSOCli[i]?commit_ts \n\t\t -> TCommitWrite.i \n\t\t -> ComCliBT[i]!rows.rows[0].start_ts.commit_ts \n\t\t -> ComBTCli[i]?psuccess\n\t\t -> if(psuccess == false) {\n\t\t \tabort.i -> checkAbortedConsistency -> Skip\n\t\t } else {\n\t\t \tcheckSecondaryLocksExist -> WriteSecondary(i, rows, rows[0], commit_ts, start_ts, 0) \n\t\t }\n\t};\n\n/*@Process: WriteSecondary\n  For each rows to write, tt first write the data in the column write and erase the lock.\n\tIf all rows are complete it terminates or it continues writing the next row.\n*/\nWriteSecondary(i, rows, primary, commit_ts, start_ts, cur) = writeSecondary.i -> eraseSecondary.i\n   -> (Skip  // write done\n\t\t[] WriteSecondary(i, rows, primary, commit_ts, start_ts, cur+1)); \n\n/*@Process: BigTable\n  The BigTable processes consists of N subprocesses handling request from each client.\n*/\nBigTable() = |||i:{1..N}@BigTableProxy(i);\n\n/*@Process: BigTableProxy\n  BigTable first accepts requests from clients. It can accept three kinds of client requests, read requests, prewrite requests, and commit requests.\n\tThen \n\t- BigTable Prewrite:\n\t\t1. It first receives data from the client, including the rows, the primary and the start timestamp.\n\t\t2. It there is a commit record is locked, this prewrite operation fails. Otherwise, the prewrite operation is performed and success response is sent back to the client.\n\t- BigTable Commit:\n\t\t1. In the commit phase, it first receives commit timestamp from the client\n\t\t2. Then, it checks whether the lock on the primary still exists. If the lock still exists, operations will be executed to commit the primary. \n\t\t3. At this point, the entire transaction is considered to be successfully committed. BigTable can send a successful response to the client. \n\t\t4. The secondary lock releasing and commit message writing are performed in a non-atomic operation.\n*/\nBigTableProxy(i) = (TRead.i -> (BigTableRead(i); BigTableProxy(i))\n\t\t\t\t\t[] TPrewrite.i -> (BigTablePrewrite(i); BigTableProxy(i))\n\t\t\t\t\t[] TCommitWrite.i -> (BigTableCommitWrite(i); BigTableProxy(i))\n\t\t\t\t\t[] txnDone.i -> Skip);\n\n/*@Process: BigTableRead\n  The process of BigTable reading the data:\n\t1. It first receives data from the client, including the rows to be read and the transaction start timestamp. \n\t2. If the record the client wants to read is locked, the transaction fails and returns false to the client indicating that there is a lock exists. Otherwise, it returns true with the data.\n*/\nBigTableRead(i) = ComCliBT[i]?row.start_ts -> judgeCanRead -> (\n  ComBTCli[i]!LOCKED.NULL -> Skip \n  [] \n  ComBTCli[i]!NOT_LOCKED.ROW_DATA -> Skip\n);\n\n/*@Process: BigTablePrewrite\n  The process of BigTable prewriting the data:\n\t1. It first receives data from the client, including the rows, the primary and the start timestamp.\n\t2. It there is a commit record is locked, this prewrite operation fails. Otherwise, the prewrite operation is performed and success response is sent back to the client.\n*/\nBigTablePrewrite(i) = ComCliBT[i]?rows.data.primary.ts \n\t-> prewriteIt -> (ComBTCli[i]!true -> Skip [] ComBTCli[i]!false -> Skip);\n\n/*@Process: BigTableCommitWrite\n  The process of BigTable committing the data:\n\t1. In the commit phase, it first receives commit timestamp from the client\n\t2. Then, it checks whether the lock on the primary still exists. If the lock still exists, operations will be executed to commit the primary. \n\t3. At this point, the entire transaction is considered to be successfully committed. BigTable can send a successful response to the client. \n\t4. The secondary lock releasing and commit message writing are performed in a non-atomic operation.\n*/\nBigTableCommitWrite(i) = ComCliBT[i]?rows.primary.start_ts.commit_ts \n   -> commit -> checkSnapshotIsolation\n   -> (ComBTCli[i]!true -> Skip [] ComBTCli[i]!false -> Skip);\n\n/*@Process: Percolator\n  This overall models contains N clients and the communication between each client and TSO and BigTable is independent.\n*/\nPercolator() = TSO() || BigTable() || (|||i:{1..N}@Client(i));",
        "property_desc": [
            "The system is deadlock-free.",
            "The system is divergence-free.",
            "All transactions will complete."
        ],
        "properties": [
            "#assert Percolator() deadlockfree;",
            "#assert Percolator() divergencefree;",
            "#define AllTxnDone (numTxnDone == N);\n#assert Percolator() |= []<> AllTxnDone;"
        ],
        "processes": [
            {
                "name": "TSO",
                "description": "The TSO(timestamp oracle) provides a strictly monotone increasing timestamp. It consists of N subprocesses handling request from each client.",
                "pat_code": "TSO() = |||i:{1..N}@TSOProxy(i);"
            },
            {
                "name": "TSOProxy",
                "description": "TSOProxy receives timestamp request and responds with the global timestamp and increase the global timestamp by 1 atomicly.\n\tOr if the transaction done signal is received, it terminates successfully.",
                "pat_code": "TSOProxy(i) = \n\ttxnDone.i -> Skip\n\t[] \n\t(getTimestamp.i -> ComTSOCli[i]!timestamp{timestamp++;} -> TSOProxy(i));"
            },
            {
                "name": "Client",
                "description": "The client:\n  1. It initiates the transaction\n\t2. It first requests the start timestamp from the TSO and receive the timestamp.\n\t3. It may initiates read transaction or write transaction with the timestamp and rows to be read or written.\n\t4. After the transaction is done, it increase the counter the number of completed transactions and termiantes.",
                "pat_code": "Client(i) = beginTransaction.i -> getTimestamp.i -> ComTSOCli[i]?start_ts -> (\n\t\t[i == 1](TransactionRead(i, 2, start_ts);TransactionRead(i, 1, start_ts))\n\t\t[] [i == 2](TransactionWrite(i, [2,3], start_ts, 10))\n\t\t[] [i == 3]TransactionWrite(i, [1,2], start_ts, 20)\n\t);\n\ttxnDone.i -> {numTxnDone++;} -> Skip;"
            },
            {
                "name": "BackoffAndMaybeCleanupLock",
                "description": "Backoff:\n  It backs off for a period of time until it considers the lock is held long enough to be cleaned up, cleanup locks and termiantes.",
                "pat_code": "BackoffAndMaybeCleanupLock(i) = \n  cleanupLock.i -> Skip\n  []\n  backoff.i -> BackoffAndMaybeCleanupLock(i);"
            },
            {
                "name": "TransactionRead",
                "description": "Read Transaction:\n  1. The read transaction begins with the start timestamp and data to be read.\n  2. Then the client queries BigTable to see if the data to be read has a lock before the start timestamp\n\t3. When a client encounters locks, it backs off for a period of time and cleanup locks. \n\t4. When no lock is present, the data is read based on the last commit record in the c:write column before the start timestamp and check the snapshot isolation.",
                "pat_code": "#alphabet TransactionRead {TRead.i, TPrewrite.i, TCommitWrite.i};\nTransactionRead(i, row, start_ts) = TRead.i -> ComCliBT[i]!row.start_ts \n\t-> ComBTCli[i]?locked.data -> if(locked == LOCKED) {\n\t\tBackoffAndMaybeCleanupLock(i);  \n\t\tTransactionRead(i, row, start_ts)\n\t} else {\n\t    checkSnapshotIsolation -> Skip\n\t};"
            },
            {
                "name": "TransactionWrite",
                "description": "Percolator\u2019s write transaction is divided into two phases, prewrite and commit.\n\tPrewrite:\n\t1. When the write transaction begins, among all records to be written, a random record is chosen as the primary, and the rest as the secondary.\n\t2. Then, the client requests the TSO to obtain a start timestamp of the transaction.\n\t3. In the prewrite phase, the client requests the BigTable to check each record to be prewritten whether there is a conflict.\n\t\t\tIf the conflict exists, the transaction should abort. Otherwise, it enters into the commit phase.\n\tCommit:\n\t4. At the beginning of the commit phase, the client requests the TSO again for the commit timestamp. \n\t5. Then, it sends a commit request to BigTable.\n\t6. If the primary is successfully committed, the entire transaction is considered committed successfully.\n\t\t\tOtherwise, it aborts.\n\t7. After the primary is committed, Percolator commits the secondary non-transactionally, and the write transaction is complete.",
                "pat_code": "#alphabet TransactionWrite {TRead.i, TPrewrite.i, TCommitWrite.i};\nTransactionWrite(i, rows, start_ts, data) = TPrewrite.i -> ComCliBT[i]!rows.data.rows[0].start_ts \n\t-> ComBTCli[i]?success -> if(success == false) {\n\t\tabort.i -> Skip\n\t} else {\n\t\t getTimestamp.i -> ComTSOCli[i]?commit_ts \n\t\t -> TCommitWrite.i \n\t\t -> ComCliBT[i]!rows.rows[0].start_ts.commit_ts \n\t\t -> ComBTCli[i]?psuccess\n\t\t -> if(psuccess == false) {\n\t\t \tabort.i -> checkAbortedConsistency -> Skip\n\t\t } else {\n\t\t \tcheckSecondaryLocksExist -> WriteSecondary(i, rows, rows[0], commit_ts, start_ts, 0) \n\t\t }\n\t};"
            },
            {
                "name": "WriteSecondary",
                "description": "For each rows to write, tt first write the data in the column write and erase the lock.\n\tIf all rows are complete it terminates or it continues writing the next row.",
                "pat_code": "WriteSecondary(i, rows, primary, commit_ts, start_ts, cur) = writeSecondary.i -> eraseSecondary.i\n   -> (Skip  // write done\n\t\t[] WriteSecondary(i, rows, primary, commit_ts, start_ts, cur+1));"
            },
            {
                "name": "BigTable",
                "description": "The BigTable processes consists of N subprocesses handling request from each client.",
                "pat_code": "BigTable() = |||i:{1..N}@BigTableProxy(i);"
            },
            {
                "name": "BigTableProxy",
                "description": "BigTable first accepts requests from clients. It can accept three kinds of client requests, read requests, prewrite requests, and commit requests.\n\tThen \n\t- BigTable Prewrite:\n\t\t1. It first receives data from the client, including the rows, the primary and the start timestamp.\n\t\t2. It there is a commit record is locked, this prewrite operation fails. Otherwise, the prewrite operation is performed and success response is sent back to the client.\n\t- BigTable Commit:\n\t\t1. In the commit phase, it first receives commit timestamp from the client\n\t\t2. Then, it checks whether the lock on the primary still exists. If the lock still exists, operations will be executed to commit the primary. \n\t\t3. At this point, the entire transaction is considered to be successfully committed. BigTable can send a successful response to the client. \n\t\t4. The secondary lock releasing and commit message writing are performed in a non-atomic operation.",
                "pat_code": "BigTableProxy(i) = (TRead.i -> (BigTableRead(i); BigTableProxy(i))\n\t\t\t\t\t[] TPrewrite.i -> (BigTablePrewrite(i); BigTableProxy(i))\n\t\t\t\t\t[] TCommitWrite.i -> (BigTableCommitWrite(i); BigTableProxy(i))\n\t\t\t\t\t[] txnDone.i -> Skip);"
            },
            {
                "name": "BigTableRead",
                "description": "The process of BigTable reading the data:\n\t1. It first receives data from the client, including the rows to be read and the transaction start timestamp. \n\t2. If the record the client wants to read is locked, the transaction fails and returns false to the client indicating that there is a lock exists. Otherwise, it returns true with the data.",
                "pat_code": "BigTableRead(i) = ComCliBT[i]?row.start_ts -> judgeCanRead -> (\n  ComBTCli[i]!LOCKED.NULL -> Skip \n  [] \n  ComBTCli[i]!NOT_LOCKED.ROW_DATA -> Skip\n);"
            },
            {
                "name": "BigTablePrewrite",
                "description": "The process of BigTable prewriting the data:\n\t1. It first receives data from the client, including the rows, the primary and the start timestamp.\n\t2. It there is a commit record is locked, this prewrite operation fails. Otherwise, the prewrite operation is performed and success response is sent back to the client.",
                "pat_code": "BigTablePrewrite(i) = ComCliBT[i]?rows.data.primary.ts \n\t-> prewriteIt -> (ComBTCli[i]!true -> Skip [] ComBTCli[i]!false -> Skip);"
            },
            {
                "name": "BigTableCommitWrite",
                "description": "The process of BigTable committing the data:\n\t1. In the commit phase, it first receives commit timestamp from the client\n\t2. Then, it checks whether the lock on the primary still exists. If the lock still exists, operations will be executed to commit the primary. \n\t3. At this point, the entire transaction is considered to be successfully committed. BigTable can send a successful response to the client. \n\t4. The secondary lock releasing and commit message writing are performed in a non-atomic operation.",
                "pat_code": "BigTableCommitWrite(i) = ComCliBT[i]?rows.primary.start_ts.commit_ts \n   -> commit -> checkSnapshotIsolation\n   -> (ComBTCli[i]!true -> Skip [] ComBTCli[i]!false -> Skip);"
            },
            {
                "name": "Percolator",
                "description": "This overall models contains N clients and the communication between each client and TSO and BigTable is independent.",
                "pat_code": "Percolator() = TSO() || BigTable() || (|||i:{1..N}@Client(i));"
            }
        ],
        "global_definition": "#define N 2; // number of client\n#define M 3; // number of records\n#define NTS 16; // max time\n#define LOCKED true;\n#define NOT_LOCKED false;\n#define TRUE 1;\n#define FALSE 0;\n#define NULL 0;\n\nenum {ROW_DATA};\n\nchannel ComTSOCli[N+1] 0; // tso -> client\nchannel ComCliBT[N+1] 0; // client -> bigtable\nchannel ComBTCli[N+1] 0; // bigtable -> client\n\nvar numTxnDone = 0;\nvar timestamp = 3;",
        "path": "handwrite/Percolator.csp"
    },
    {
        "name": "Pulsar",
        "tags": [
            "Protocol"
        ],
        "use_non_container_lib": false,
        "description": "Apache Pulsar is a distributed publish-subscribe messaging system that employs a compute-storage separation architecture, which is well-suited for cloud-native environments. As a critical component in distributed system architecture, Pulsar plays a pivotal role and is an essential key infrastructure for implementing enterprise IT architectures.\n   The model contains 5 roles: Producer, Consumer, Broker, BookKeeper, and Zookeeper.",
        "pat_code": "channel ComPB 0;\nchannel ComBB 0;\nchannel ComCB 0;\nchannel ComBZ 0;\nchannel Bookie 20;//Stores messages in a topic\n\n#import \"PAT.Lib.Queue\";\n\nvar<Queue> MSG_OF_C;//The message received by the consumer\nvar tid_bro[2]= [-1,-1];//BROKERID for the subject, which BROKER is responsible for the subject\nvar c_topic[2] = [-1,-1];//The id of the subject to which the consumer cid subscribes\n\nenum {Nan1, Nan2, Nan3, Nan4, Nan5, Nan6, Nan7,Con,ConOK,PUB,PUBOK,SUB,SUBOK,REC,SEND,SENDOK};\n\n/*@Process: Producer\n   Producer: The producer sends the message to the specific topic. When there is a new message in the topic, it will be pushed to the consumer who subscribed to the topic.\n   1.Producer first submit a connect request to Broker in order to establish a connection.\n   2.It sends a publish request pub. If Producer receives the connection success message connected, it invokes the Send() process to transmit data.    \n*/\nProducer(pid,broid,msgid,tid) = \n\tComPB!pid.broid.Con->ComPB?broid.pid.ConOK->\n\tComPB!pid.broid.PUB.tid->ComPB?broid.pid.PUBOK->\n\tSend(pid,broid,msgid,tid);\n\n/*@Process: Send\n   The send process continues sending message:\n  Only when the message in the topic is not full, is sends the message to the broker with producer id, broker id, topic id and message id and waites for responses.\n*/\nSend(pid,broid,msgid,tid) = [!call(cfull,Bookie)]ComPB!pid.broid.tid.SEND.msgid->ComPB?SENDOK->Send(pid,broid,msgid,tid);\n\n/*@Process: BrokerP\n   BrokerP: The broker in Pulsar is a stateless instance that provides services to external entities. The producer will publish messages to the broker.\n   - Upon receiving a connection request connect, Broker determines whether there is an existing connection between Producer and Broker. If no connection exists, Broker establishes one connection. \n   - When Broker receives a publish command pub from Producer, it checks whether the topic exists on itself.\n   - When Broker receives a subscription request from Consumer, it first determines whether the topic belongs to Broker. If the topic belongs to Broker, Broker then checks if the topic is occupied. If it is not occupied, a successful subscription reply message success will be sent to Consumer. After receiving the command flowpermits to push data. \n*/\nBrokerP(broid) = ComPB?pid.broid.Con->ComPB!broid.pid.ConOK->Broker(broid)\n          []ComPB?pid.broid.PUB.tid->ComBZ!broid.PUB.tid->ComBZ?broid.PUBOK->ComPB!broid.pid.PUBOK->Broker(broid)\n          []ComPB?pid.broid.tid.SEND.msgid->ComBB!broid.tid.SEND.msgid->ComBB?SENDOK->ComPB!SENDOK->Broker(broid);\n          \n/*@Process: Consumer\n   Consumer: The consumer can subscribe to the specific topic. \n   1. The consumer first establishs the connection to the broker. \n   2. Upon a successful connection, Consumer sends a subscription request sub to Broker. \n   3. After a successful subscription, it porceeds to the receiving state.\n   \n*/\nConsumer(cid,broid,tid) =\n   ComCB!cid.broid.Con->ComCB?broid.cid.ConOK->\n   ComCB!cid.broid.SUB.tid->ComCB?broid.cid.SUBOK->\n   RECEIVE(cid,broid,tid);\n\n/*@Process: RECEIVE\n  The receives keeps doing:\n   1. Consumer checks if its buffer queue is full. If not full, Consumer sends a flow permits command message to the BookKeeper indicating it can receive messages. \n   2. Once Consumer receives messages pushed by Broker, it stores the retrieved data in the ReceiverQueue.\n*/\nRECEIVE(cid,broid,tid) = [!call(cempty,Bookie)]ComCB!cid.broid.REC.tid->ComCB?broid.cid.msgid{MSG_OF_C.Enqueue(msgid)}->RECEIVE(cid,broid,tid);\n\n/*@Process: BrokerC\n  BrokerC: The broker in Pulsar is a stateless instance that provides services to external entities. The consumer will obtain the messages pushed by the broker\n   - Upon receiving a connection request connect, Broker determines whether there is an existing connection between Consumer and Broker. If no connection exists, Broker establishes one connection. \n   - When Broker receives a FIN command pub from Consumer.\n     + If the FIN command is SUB, it forwards the SUB data to the Zookeeper and receives acknowledgement, then sends the acknowledgement back to the consumer.\n     + Otherwise, it sends the REC message to the BookKeeper and receives the message id and acknowledgement and sends the message id to the broker.\n\n*/\nBrokerC(broid) = ComCB?cid.broid.Con->ComCB!broid.cid.ConOK->Broker(broid)\n          []ComCB?cid.broid.FIN.tid->if(FIN == SUB){\n                                      ComBZ!cid.broid.SUB.tid->ComBZ?broid.SUBOK->ComCB!broid.cid.SUBOK->Broker(broid)}\n                                    else{\n                                    ComBB!broid.REC.tid->ComBB?broid.msgid->ComCB!broid.cid.msgid->Broker(broid)\n                                    \n                                    };\n\n/*@Process: Zookeeper\n Zookeeper: It is mainly used to store metadata. Zookeeper is responsible for storing metadata in the cluster. \n Zookeeper receives publish request or subscribe request from broker. It associates the broker id with the topic or associates the client's id with the topic id.\n Then, it response success back to the broker.\n\n*/\nZookeeper() = ComBZ?broid.PUB.tid{tid_bro[tid] = broid;}->ComBZ!broid.PUBOK->Zookeeper()\n            []ComBZ?cid.broid.SUB.tid{c_topic[cid] = tid}->ComBZ!broid.SUBOK->Zookeeper();          \n          \n\n/*@Process: BookKeeper\n  BookKeeper: BookKeeper is responsible for the persistent storage of data from Broker. \n  - If the buffer queue is full, it only receives the REC signal from the broker and then receives message and responds to it.\n  - If the buffer queue is empty, it only receives the SEND signal from the broker and then receives message from the buffer and responds to it.\n  - Otherwise, it may perform any of the above operation.\n*/\nBookKeeper() =if(call(cfull,Bookie))\n               {\n               ComBB?broid.REC.tid->Bookie?msgid->ComBB!broid.msgid->BookKeeper()\n               }\n              else if(call(cempty,Bookie)){\n               ComBB?broid.tid.SEND.msgid->Bookie!msgid->ComBB!SENDOK->BookKeeper()}\n              else{\n                  ComBB?broid.tid.SEND.msgid->Bookie!msgid->ComBB!SENDOK->BookKeeper()\n               []ComBB?broid.REC.tid->Bookie?msgid->ComBB!broid.msgid->BookKeeper()\n             };\n \n/*@Process: Broker\n  The Broker may act the broker of the producer or the broker of the consumer\n*/\nBroker(broid) =  BrokerP(broid)[]BrokerC(broid);\n\n/*@Process: System\n  The system consists of the producer with its id, the broker with its id, a consumer with its id Zookeeper and BookKeeper.\n*/\nvar PID = 0;\nvar BROID = 0;\nvar MSGID = 1;\nvar TID = 0;\nvar CID = 0;\n\nSystem() = Producer(PID,BROID,MSGID,TID)||Broker(BROID)||Consumer(CID,BROID,TID)||Zookeeper()||BookKeeper();",
        "property_desc": [
            "The system is deadlock-free."
        ],
        "properties": [],
        "processes": [
            {
                "name": "Producer",
                "description": "Producer: The producer sends the message to the specific topic. When there is a new message in the topic, it will be pushed to the consumer who subscribed to the topic.\n   1.Producer first submit a connect request to Broker in order to establish a connection.\n   2.It sends a publish request pub. If Producer receives the connection success message connected, it invokes the Send() process to transmit data.",
                "pat_code": "Producer(pid,broid,msgid,tid) = \n\tComPB!pid.broid.Con->ComPB?broid.pid.ConOK->\n\tComPB!pid.broid.PUB.tid->ComPB?broid.pid.PUBOK->\n\tSend(pid,broid,msgid,tid);"
            },
            {
                "name": "Send",
                "description": "The send process continues sending message:\n  Only when the message in the topic is not full, is sends the message to the broker with producer id, broker id, topic id and message id and waites for responses.",
                "pat_code": "Send(pid,broid,msgid,tid) = [!call(cfull,Bookie)]ComPB!pid.broid.tid.SEND.msgid->ComPB?SENDOK->Send(pid,broid,msgid,tid);"
            },
            {
                "name": "BrokerP",
                "description": "BrokerP: The broker in Pulsar is a stateless instance that provides services to external entities. The producer will publish messages to the broker.\n   - Upon receiving a connection request connect, Broker determines whether there is an existing connection between Producer and Broker. If no connection exists, Broker establishes one connection. \n   - When Broker receives a publish command pub from Producer, it checks whether the topic exists on itself.\n   - When Broker receives a subscription request from Consumer, it first determines whether the topic belongs to Broker. If the topic belongs to Broker, Broker then checks if the topic is occupied. If it is not occupied, a successful subscription reply message success will be sent to Consumer. After receiving the command flowpermits to push data.",
                "pat_code": "BrokerP(broid) = ComPB?pid.broid.Con->ComPB!broid.pid.ConOK->Broker(broid)\n          []ComPB?pid.broid.PUB.tid->ComBZ!broid.PUB.tid->ComBZ?broid.PUBOK->ComPB!broid.pid.PUBOK->Broker(broid)\n          []ComPB?pid.broid.tid.SEND.msgid->ComBB!broid.tid.SEND.msgid->ComBB?SENDOK->ComPB!SENDOK->Broker(broid);"
            },
            {
                "name": "Consumer",
                "description": "Consumer: The consumer can subscribe to the specific topic. \n   1. The consumer first establishs the connection to the broker. \n   2. Upon a successful connection, Consumer sends a subscription request sub to Broker. \n   3. After a successful subscription, it porceeds to the receiving state.",
                "pat_code": "Consumer(cid,broid,tid) =\n   ComCB!cid.broid.Con->ComCB?broid.cid.ConOK->\n   ComCB!cid.broid.SUB.tid->ComCB?broid.cid.SUBOK->\n   RECEIVE(cid,broid,tid);"
            },
            {
                "name": "RECEIVE",
                "description": "The receives keeps doing:\n   1. Consumer checks if its buffer queue is full. If not full, Consumer sends a flow permits command message to the BookKeeper indicating it can receive messages. \n   2. Once Consumer receives messages pushed by Broker, it stores the retrieved data in the ReceiverQueue.",
                "pat_code": "RECEIVE(cid,broid,tid) = [!call(cempty,Bookie)]ComCB!cid.broid.REC.tid->ComCB?broid.cid.msgid{MSG_OF_C.Enqueue(msgid)}->RECEIVE(cid,broid,tid);"
            },
            {
                "name": "BrokerC",
                "description": "BrokerC: The broker in Pulsar is a stateless instance that provides services to external entities. The consumer will obtain the messages pushed by the broker\n   - Upon receiving a connection request connect, Broker determines whether there is an existing connection between Consumer and Broker. If no connection exists, Broker establishes one connection. \n   - When Broker receives a FIN command pub from Consumer.\n     + If the FIN command is SUB, it forwards the SUB data to the Zookeeper and receives acknowledgement, then sends the acknowledgement back to the consumer.\n     + Otherwise, it sends the REC message to the BookKeeper and receives the message id and acknowledgement and sends the message id to the broker.",
                "pat_code": "BrokerC(broid) = ComCB?cid.broid.Con->ComCB!broid.cid.ConOK->Broker(broid)\n          []ComCB?cid.broid.FIN.tid->if(FIN == SUB){\n                                      ComBZ!cid.broid.SUB.tid->ComBZ?broid.SUBOK->ComCB!broid.cid.SUBOK->Broker(broid)}\n                                    else{\n                                    ComBB!broid.REC.tid->ComBB?broid.msgid->ComCB!broid.cid.msgid->Broker(broid)\n                                    \n                                    };"
            },
            {
                "name": "Zookeeper",
                "description": "Zookeeper: It is mainly used to store metadata. Zookeeper is responsible for storing metadata in the cluster. \n Zookeeper receives publish request or subscribe request from broker. It associates the broker id with the topic or associates the client's id with the topic id.\n Then, it response success back to the broker.",
                "pat_code": "Zookeeper() = ComBZ?broid.PUB.tid{tid_bro[tid] = broid;}->ComBZ!broid.PUBOK->Zookeeper()\n            []ComBZ?cid.broid.SUB.tid{c_topic[cid] = tid}->ComBZ!broid.SUBOK->Zookeeper();"
            },
            {
                "name": "BookKeeper",
                "description": "BookKeeper: BookKeeper is responsible for the persistent storage of data from Broker. \n  - If the buffer queue is full, it only receives the REC signal from the broker and then receives message and responds to it.\n  - If the buffer queue is empty, it only receives the SEND signal from the broker and then receives message from the buffer and responds to it.\n  - Otherwise, it may perform any of the above operation.",
                "pat_code": "BookKeeper() =if(call(cfull,Bookie))\n               {\n               ComBB?broid.REC.tid->Bookie?msgid->ComBB!broid.msgid->BookKeeper()\n               }\n              else if(call(cempty,Bookie)){\n               ComBB?broid.tid.SEND.msgid->Bookie!msgid->ComBB!SENDOK->BookKeeper()}\n              else{\n                  ComBB?broid.tid.SEND.msgid->Bookie!msgid->ComBB!SENDOK->BookKeeper()\n               []ComBB?broid.REC.tid->Bookie?msgid->ComBB!broid.msgid->BookKeeper()\n             };"
            },
            {
                "name": "Broker",
                "description": "The Broker may act the broker of the producer or the broker of the consumer",
                "pat_code": "Broker(broid) =  BrokerP(broid)[]BrokerC(broid);"
            },
            {
                "name": "System",
                "description": "The system consists of the producer with its id, the broker with its id, a consumer with its id Zookeeper and BookKeeper.",
                "pat_code": "var PID = 0;\nvar BROID = 0;\nvar MSGID = 1;\nvar TID = 0;\nvar CID = 0;\n\nSystem() = Producer(PID,BROID,MSGID,TID)||Broker(BROID)||Consumer(CID,BROID,TID)||Zookeeper()||BookKeeper();"
            }
        ],
        "global_definition": "channel ComPB 0;\nchannel ComBB 0;\nchannel ComCB 0;\nchannel ComBZ 0;\nchannel Bookie 20;//Stores messages in a topic\n\n#import \"PAT.Lib.Queue\";\n\nvar<Queue> MSG_OF_C;//The message received by the consumer\nvar tid_bro[2]= [-1,-1];//BROKERID for the subject, which BROKER is responsible for the subject\nvar c_topic[2] = [-1,-1];//The id of the subject to which the consumer cid subscribes\n\nenum {Nan1, Nan2, Nan3, Nan4, Nan5, Nan6, Nan7,Con,ConOK,PUB,PUBOK,SUB,SUBOK,REC,SEND,SENDOK};",
        "path": "handwrite/Pulsar.csp"
    },
    {
        "name": "Pytorch Remote Reference Protocol",
        "tags": [
            "Protocol"
        ],
        "use_non_container_lib": false,
        "description": "The CSP model simulates a distributed resource management system using Remote References (RRefs). It involves multiple nodes and procedures that interact to create, use, fork, and delete RRefs. The system aims to manage access to resources distributed across multiple nodes.",
        "pat_code": "/** Constants **/\n#define N 3; // Max number of nodes\n#define M 2; // Max number of remotes in a Procedure\n#define B 10; // Max buffer size of channels\n#define ID(n, m) n*M+m; // Get remote id used for RRef and Procedure\n#define TT(n, m) (n+1)*(m+1); // Max number of remotes globally\n/** Headers **/\nenum {REMOTE, REMOTE_ACK, DELETE, DELETE_ACK, FORK, FORK_ACK, CHILD_ACK};\n/** Channels **/\nchannel L[N+1] B;\nchannel R B;\n\n/** Tables **/\nvar T = (N+1)*(M+1);\nvar RRefHE[T+1][T+1]: {0..1}; // RRefHE[p][i] = 1: If RRef i exists in heap of Procedure p\nvar RRefHT[T+1]; // RRefHE[p] = k: There are k parameter RRefs in the heap of Procedure p\nvar RRefCE[N+1][T+1]: {0..1}; // RRefCT[n][i] = 1: If RRef i exists on Node n\nvar RRefCT[N+1][T+1]; // RRefCT[n][i] = k: The number of references of RRef i on Node n is k\nvar RRefOP[T+1]: {0..N}; // RRefOP[i] = n: The owner of RRef i is Node n\nvar RRefOE[N+1][T+1]; // RRefOE[n][i] = 1: If Node n use RRef i\nvar RRefPP[N+1][T+1]: {0..N}; // RRefPP[n][i] = m: The parent RRef of RRef i forked to Node n is that on Node m\nvar RRefPR[N+1][T+1]: {0..N}; // RRefPP[n][i] = m: Parent record for verification\nvar RRefCA[N+1][T+1]: {0..M}; // RRefCA[n][i] = k: The number of pendings of CHILD_ACK of RRef i on Node n is k\nvar RRefFA[N+1][T+1]: {0..M}; // RRefFA[n][i] = k: The number of pendings of FORK_ACK of RRef i on Node n is k\n/** Counters **/\nvar PROCS = 0;\nvar FORKS = 0;\nvar CHAKS = 0;\n\n\n\n/** System **/\n/*@Process: RRefSystem\n  The overall system comprises N number of Protocol processes running on each node and a single Procedure process.\n*/\nRRefSystem() =\n (||| n:{1..N} @ PTCLoop(n)) // Protocols\n ||| PCD(0, 1, 1, 0); // Procedure\n\n\n/*@Process: PCD\n  The PCD represents a process that performs operations on RRefs:\n  1. The PCD first creates a new procedure, incrementing the PROCS counter.\n  2. If a parameter is empty, then it goes directly to the behavior loop PCDLoop; \n     Otherwise it first add parameter RRef to the heap and then enters the behavior loop PCDLoop.\n*/\nPCD(m, n, p, rp) = // Remote has been called for m times\n P_NEW.p{ PROCS = PROCS + 1; }\n -> ifa (rp != 0) { // If parameter RRef exists\n PARM_INIT.p.rp{ RRefHE[p][rp] = 1; RRefHT[p] = 1; } // Add parameter RRef into heap\n -> PCDLoop(m, n, p) // Start behavior loop \n } else { // If no parameter RRef\n PCDLoop(m, n, p) // Start behavior loop\n };\n \n/*@Process: PCDLoop\n  PCDLoop(m, n, p) is the main loop of the procedure:\n  - If the maximum number of remote calls hasn't been reached\n    + If the heap is empty, it can only call remote procedures or end.\n    + Otherwise, the procedure can either call another remote procedure PCDRemote or delete an existing RRef from its heap. \n  - If the maximum number of remote calls has been reached, the procedure can only delete RRefs(at least one RRef in heap) or end.\n*/\nPCDLoop(m, n, p) =\n  ifa (m < M) { // New remote procedure is allowed\n    ifa (RRefHT[p] > 0) { // There exists at least one RRef in heap\n      PCDRemote(m, n, p) [] PCDDelete(m, n, p) // Call remote procedure or delete RRef in heap\n    } else {\n      PCDRemote(m, n, p) // Only Call remote procedure is allowed\n      [] P_END.p{ PROCS = PROCS - 1; } -> Skip // Procedure ends\n    } // Procedure ends\n  } else { // New remote procedure is not allowed\n    ifa (RRefHT[p] > 0) { // There exists at least one RRef in heap\n      PCDDelete(m, n, p) // Only delete local RRef is allowed\n    } else {\n      P_END.p{ PROCS = PROCS - 1; } -> Skip // Procedure ends\n    }\n  };\n \n/*@Process: PCDRemote\n  PCDRemote(m, n, p) handles a remote procedure call:\n  - For every possible node as target, for every possible local RRef as parameter, including no parameter if equals to 0\n    If RRef exists in heap, or no parameter:\n    1. It sends a REMOTE message to node n indicating a remote call with parameters including procedure ID, target node, and RRef.\n    2. And waits for a REMOTE_ACK from node n.\n    3. After that, it creates a new RRef with a unique ID, adds it to the procedure's heap, and updates the heap counter and start next loop.\n*/\nPCDRemote(m, n, p) =\n [] nt:{1..N} @ ( // For every possible node as target\n    [] rp:{0..call(TT, N, M)} @ // For every possible local RRef as parameter, including no parameter if equals to 0\n    [(rp == 0 || RRefHE[n][rp] == 1)] ( // If RRef exists in heap, or no parameter\n        L[n]!REMOTE.p.nt.rp.call(ID, n, m) // REMOTE locally\n        -> L[n]?REMOTE_ACK.p.call(ID, n, m) // REMOTE_ACK locally\n        -> P_NEW_REF.p.call(ID, n, m){ RRefHE[p][call(ID, n, m)] = 1; RRefHT[p] = RRefHT[p] + 1; } // New RRef created, update heap\n        -> PCDLoop(m + 1, n, p) // Next Loop\n    )\n );\n \n/*@Process: PCDDelete\n  PCDDelete(m, n, p) handles the deletion of an RRef from the procedure's heap:\n  1. For every possible RRef, if RRef exists in heap, it tries to delete it in heap first.\n  2. Then, it sends a DELETE message to the node owning the RRef and waits for a DELETE_ACK from the node.\n  3. Then, it removes the RRef from the procedure's heap and updates the heap counter. And begin next loop.\n*/\nPCDDelete(m, n, p) =\n [] r:{1..call(TT, N, M)} @ // For every possible RRef\n [RRefHE[p][r] == 1] ( // If RRef exists in heap\n HEAP_DEL_REF.r // Try to delete in heap\n -> L[n]!DELETE.p.r // DELETE locally\n -> L[n]?DELETE_ACK.p.r // DELETE_ACK locally\n -> P_DEL_REF.p.r{ RRefHE[p][r] = 0; RRefHT[p] = RRefHT[p] - 1; } // RRef deleted, update heap\n -> PCDLoop(m, n, p) // Next Loop\n );\n\n\n/** Protocol **/\n/*@Process: PTCLoop\n  The PTC is a process running on a node whose behavior is to continuously loop over the processing of multiple message events. \n  It handles following events:\n  - Send to remote\n  - receive from remote\n  - receive ack from remote\n  - receive fork message from remote\n  - receive fork acknowledgement from remote\n  - send delete message to remote\n  - receive delete message from remote\n  - receive delete acknowledgement from remote\n  - send child's ref acknowledgement to remote\n  - receive child's ref acknowledgement to remote\n*/\nPTCLoop(n) =\n OnSendREMOTE(n) [*] OnRecvREMOTE(n) [*] OnRecvREMOTEACK(n) [*]\n OnRecvFORK(n) [*] OnRecvFORKACK(n) [*]\n OnSendDELETE(n) [*] OnRecvDELETE(n) [*] OnRecvDELETEACK(n) [*]\n OnSendCHILDACK(n) [*] OnRecvCHILDACK(n);\n \n/*@Process: OnSendREMOTE\n  - OnSendREMOTE(n) handles sending a REMOTE message:\n    1. It Receives a REMOTE message locally with parameter p, nt, rp, rn.\n    2. If there is no parameter RRef, it sends the REMOTE message remotely. Otherwise, it creates a new pending for child RRef deletion and then sends the message remotely.\n*/\nOnSendREMOTE(n) =\n  L[n]?REMOTE.p.nt.rp.rn // REMOTE locally\n  -> ifa (rp == 0) { // No parameter RRef\n    R!REMOTE.p.n.nt.rp.rn // REMOTE remotely\n    -> PTCLoop(n)\n  } else { // There is parameter RRef\n    PEND_CHILD_ACK.n.rp{ RRefCA[n][rp] = RRefCA[n][rp] + 1; } // A new pending for child RRef deletion\n    -> R!REMOTE.p.n.nt.rp.rn // REMOTE remotely\n    -> PTCLoop(n)\n  };\n \n/*@Process: OnRecvREMOTE\n - OnRecvREMOTE(n) handles receiving a REMOTE message.\n    1. It receives a REMOTE message remotely.\n    2. Sets node n as the owner of RRef rn.\n    3. Execute OnSendREMOTEACK and OnSendFORK concurrently.\n*/\nOnRecvREMOTE(n) =\n  R?REMOTE.ps.ns.n.rp.rn // REMOTE remotely\n  -> SET_OWNER.rn.n{ RRefOP[rn] = n; } // Update Ownership\n  -> USE_REF.ns.n.rn{ RRefOE[ns][rn] = 1; } // Update Useship\n  -> (OnSendREMOTEACK(n, ps, ns, rn) ||| OnSendFORK(n, ns, rp, rn));\n\n/*@Process: OnRecvREMOTEACK\n - OnSendREMOTEACK(n, ps, ns, rn) sends a REMOTE_ACK message remotely.\n */\nOnSendREMOTEACK(n, ps, ns, rn) = R!REMOTE_ACK.ps.ns.n.rn // REMOTEACK remotely\n  -> PTCLoop(n);\n\n/*@Process: \n - OnRecvREMOTEACK(n) handles receiving a REMOTE_ACK message.\n    1. If the RRef doesn't exist on the node, create the RRef and update the counter representing a new UserRRef.\n    2. Otherwise, it replies the message REMOTE_ACK locally\n*/\nOnRecvREMOTEACK(n) =\n  R?REMOTE_ACK.p.n.nt.rn // REMOTEACK remotely\n  -> ifa (RRefCE[n][rn] == 1) {\n    L[n]!REMOTE_ACK.p.rn // REMOTEACK locally\n    -> PTCLoop(n)\n  } else {\n    NEW_REF.n.rn{ RRefCE[n][rn] = 1; RRefCT[n][rn] = RRefCT[n][rn] + 1; } // Update indicator and counter for new RRef\n    -> L[n]!REMOTE_ACK.p.rn // REMOTEACK locally\n    -> PTCLoop(n)\n  };\n \n/*@Process: OnSendFORK\n- OnSendFORK(n, ns, rp, rn) handles sending a FORK message for an existing parameter RRef.\n    1. If there is parameter RRef, it creates a new pending for forking RRef\n    2. Then it records parent node for forking RRef\n    3. Then, it sends a FORK message to the owner of the RRef.\n*/\nOnSendFORK(n, ns, rp, rn) =\n  [rp > 0] ( // There is parameter RRef\n  PEND_FORK_ACK.n.rp{ RRefFA[n][rp] = RRefFA[n][rp] + 1; } // A new pending for forking RRef\n  -> SET_PARENT.n.rp.ns{ RRefPP[n][rp] = ns; } // Record parent node for forking RRef\n  -> R!FORK.n.RRefOP[rp].rp.rn // FORK remotely\n  -> Skip\n  );\n\n/*@Process: OnRecvFORK\n- OnRecvFORK(n) handles receiving a FORK message to the remote.\n*/\nOnRecvFORK(n) =\n  R?FORK.ns.n.r.rn // FORK remotely\n  -> OnSendFORKACK(ns, n, r, rn);\n\n/*@Process: OnSendFORKACK\n- OnSendFORKACK(ns, n, r, rn) sends a FORK_ACK message remotely.\n*/\nOnSendFORKACK(ns, n, r, rn) =\n  R!FORK_ACK.ns.n.r.rn // FORKACK remotely\n  -> PTCLoop(n);\n\n/*@Process: OnRecvFORKACK\n   - OnRecvFORKACK(n) handles receiving a FORK_ACK message.\n    1. It first receives a FORK_ACK message remotely.\n    2. It then create a new RRef locally, update indicator and counter for forked RRef\n    3. After that is the decrement of ref counter, indicating a completed FORK.\n    4. It Increases the FORKS counter and records that node is using RRef r.\n    5. Concurrently execute PTCLoop and start a new procedure PCD(M, n, rn, r).\n*/\nOnRecvFORKACK(n) =\n  R?FORK_ACK.n.nt.r.rn // FORKACK remotely\n  -> NEW_REF.n.r{ RRefCE[n][r] = 1; RRefCT[n][r] = RRefCT[n][r] + 1; } // Update indicator and counter for forked RRef\n  -> RESP_FORK_ACK.n.r{ RRefFA[n][r] = RRefFA[n][r] - 1; } // The pending for forking RRef ends\n  -> FORKED.n.r { FORKS = FORKS + 1; }\n  -> USE_REF.n.nt.r{ RRefOE[n][r] = 1; } // Update Useship\n  -> (PTCLoop(n) ||| PCD(M, n, rn, r));\n\n\n/*@Process: OnSendDELETE\n- OnSendDELETE(n) handles sending a DELETE message for an RRef:\n    1. For every possible RRef, if RRef exists, but will be deleted\n    2. It marks the RRef as deleted and remove useship\n    3. If the node is the owner of the RRef, it delete the RRef on owner and continue the protocol loop. Otherwise send a delete signal to owner of the RRef remotely.\n*/\nOnSendDELETE(n) =\n  [*] r:{1..call(TT, N, M)} @ // For every possible RRef\n  [RRefCE[n][r] == 1 && RRefCT[n][r] == 0 && RRefCA[n][r] == 0 && RRefFA[n][r] == 0] ( // If RRef exists, but to be deleted\n  DEL_REF.n.r{ RRefCE[n][r] = 0; } // Deleted\n  -> REL_REF.n.r{ RRefOE[n][r] = 0; } // Release Useship\n  -> ifa (RRefOP[r] == n) {\n  OWNR_DEL_REF.r // Delete RRef on owner\n  -> PTCLoop(n)\n  } else {\n  R!DELETE.n.RRefOP[r].r\n  -> PTCLoop(n)\n  }\n  );\n\n/*@Process: OnRecvDELETE\n- OnRecvDELETE(n) handles receiving a DELETE message.\n    1. It receives a DELETE message from local or remote. \n    2. After receiving the message, update counter for deleted RRef locally or remotely.\n*/\nOnRecvDELETE(n) =\n ( // Local\n L[n]?DELETE.p.r // DELETE locally\n -> REM_CNT.n.r{ RRefCT[n][r] = RRefCT[n][r] - 1; } // Update counter for deleted RRef locally\n -> L[n]!DELETE_ACK.p.r // DELETE_ACK locally\n -> PTCLoop(n)\n ) [*] ( // Remote\n R?DELETE.ns.n.r // DELETE remotely\n -> OnSendDELETEACK(n, ns, r)\n );\n\n \n/*@Process: OnSendDELETEACK\n- OnSendDELETEACK(n, ns, r) sends a DELETE_ACK message remotely.\n    1. It first sends a DELETE_ACK message remotely.\n    2. If the node is the owner of the RRef, it deletes RRef on owner. Otherwise, it does nothing and start next loop.\n*/\nOnSendDELETEACK(n, ns, r) =\n R!DELETE_ACK.ns.n.r\n -> ifa (RRefOP[r] == n) {\n OWNR_DEL_REF.r // Delete RRef on owner\n -> PTCLoop(n) \n } else {\n PTCLoop(n)\n };\n\n \n/*@Process: OnRecvDELETEACK\n- OnRecvDELETEACK(n) handles receiving a DELETE_ACK message remotely\n*/\nOnRecvDELETEACK(n) =\n R?DELETE_ACK.ns.n.r\n -> PTCLoop(n);\n\n\n/*@Process: OnSendCHILDACK\n- OnSendCHILDACK(n):\n    1. For every possible Node, for every possible RRef, if a ChildRRef is determined to be unused, or if the ChildRRef appears to be self-ringing, the sends a CHILD_ACK to its Parent.\n*/\n// !CHILD_ACK -> ?CHILD_ACK\nOnSendCHILDACK(n) =\n [*] nt:{1..N} @ ( // For every possible Node\n [*] r:{1..call(TT, N, M)} @ // For every possible RRef\n [RRefPP[n][r] > 0 && RRefOE[n][r] == 0 || RRefPP[n][r] == n] (\n R!CHILD_ACK.n.RRefPP[n][r].r\n -> UNSET_PARENT.n.r{ RRefPR[n][r] = RRefPP[n][r]; RRefPP[n][r] = 0; } // No more parent\n -> PTCLoop(n)\n )\n );\n\n \n/*@Process: OnRecvCHILDACK\n- OnRecvCHILDACK(n):\n    1. It first receives a CHILD_ACK message remotely.\n    2. Decrements the pending child ack counter\n    3. Increment the child ack counter.\n*/\nOnRecvCHILDACK(n) =\n R?CHILD_ACK.nc.n.r\n -> RESP_CHILD_ACK.n.r{ RRefCA[n][r] = RRefCA[n][r] - 1; } // The pending for child RRef deletion ends\n -> CHILD_ACKED.n.r{ CHAKS = CHAKS + 1; }\n -> PTCLoop(n);",
        "property_desc": [
            "Procedure should be terminated",
            "Eventually, there should be no RRef",
            "Eventually, there should be no FORK_ACK pending",
            "Eventually, there should be no CHILD_ACK pending",
            "The number of FORKs should be equal to the number of CHILD_ACKs",
            "Creation and deletion of RRefs should be balanced, and creation before deletion",
            "A deletion of RRef should not be existed without Creation",
            "If RRef is deleted in heap, it will be eventually deleted on owner node, and heap deletion before owner deletion",
            "If RRef is deleted by an Owner, it must have been deleted on the heap of some Procedure before it was deleted."
        ],
        "properties": [
            "#define PROC_END (PROCS == 0);\n#assert RRefSystem() |= []<> PROC_END;",
            "#define RREF_END_NDEL_0 (RRefCE[RRefOP[2]][2] == 0);\n#define RREF_END_NDEL_1 (RRefCE[RRefOP[3]][3] == 0);\n#define RREF_END_NDEL (RREF_END_NDEL_0 && RREF_END_NDEL_1);\n#assert RRefSystem() |= []<> RREF_END_NDEL;",
            "#define RREF_END_NFKA_0 (RRefFA[1][2] == 0);\n#define RREF_END_NFKA_1 (RRefFA[1][3] == 0);\n#define RREF_END_NFKA (RREF_END_NFKA_0 && RREF_END_NFKA_1);\n#assert RRefSystem() |= []<> RREF_END_NFKA;",
            "#define RREF_END_NCHA_0 (RRefCA[1][2] == 0);\n#define RREF_END_NCHA_1 (RRefCA[1][3] == 0);\n#define RREF_END_NCHA (RREF_END_NCHA_0 && RREF_END_NDEL_1);\n#assert RRefSystem() |= []<> RREF_END_NCHA;",
            "#define RREF_FK_EQ_CHA (FORKS == CHAKS);\n#assert RRefSystem() |= []<> RREF_FK_EQ_CHA;",
            "#assert RRefSystem() |= [] ((NEW_REF.1.2 -> X <> DEL_REF.1.2) &&(NEW_REF.1.3 -> X <> DEL_REF.1.3));",
            "#assert RRefSystem() |= [] (((<> DEL_REF.1.2) -> (<> (NEW_REF.1.2 -> X <> DEL_REF.1.2))) &&((<> DEL_REF.1.3) -> (<> (NEW_REF.1.3 -> X <> DEL_REF.1.3))));",
            "#assert RRefSystem() |= [] ((HEAP_DEL_REF.2 -> X <> OWNR_DEL_REF.2) &&(HEAP_DEL_REF.3 -> X <> OWNR_DEL_REF.3));",
            "#assert RRefSystem() |= [] (((<> DEL_REF.1.2) -> (<> (HEAP_DEL_REF.2 -> X <> OWNR_DEL_REF.2))) &&((<> DEL_REF.1.3) -> (<> (HEAP_DEL_REF.3 -> X <> OWNR_DEL_REF.3))));"
        ],
        "processes": [
            {
                "name": "RRefSystem",
                "description": "The overall system comprises N number of Protocol processes running on each node and a single Procedure process.",
                "pat_code": "RRefSystem() =\n (||| n:{1..N} @ PTCLoop(n)) // Protocols\n ||| PCD(0, 1, 1, 0); // Procedure"
            },
            {
                "name": "PCD",
                "description": "The PCD represents a process that performs operations on RRefs:\n  1. The PCD first creates a new procedure, incrementing the PROCS counter.\n  2. If a parameter is empty, then it goes directly to the behavior loop PCDLoop; \n     Otherwise it first add parameter RRef to the heap and then enters the behavior loop PCDLoop.",
                "pat_code": "PCD(m, n, p, rp) = // Remote has been called for m times\n P_NEW.p{ PROCS = PROCS + 1; }\n -> ifa (rp != 0) { // If parameter RRef exists\n PARM_INIT.p.rp{ RRefHE[p][rp] = 1; RRefHT[p] = 1; } // Add parameter RRef into heap\n -> PCDLoop(m, n, p) // Start behavior loop \n } else { // If no parameter RRef\n PCDLoop(m, n, p) // Start behavior loop\n };"
            },
            {
                "name": "PCDLoop",
                "description": "PCDLoop(m, n, p) is the main loop of the procedure:\n  - If the maximum number of remote calls hasn't been reached\n    + If the heap is empty, it can only call remote procedures or end.\n    + Otherwise, the procedure can either call another remote procedure PCDRemote or delete an existing RRef from its heap. \n  - If the maximum number of remote calls has been reached, the procedure can only delete RRefs(at least one RRef in heap) or end.",
                "pat_code": "PCDLoop(m, n, p) =\n  ifa (m < M) { // New remote procedure is allowed\n    ifa (RRefHT[p] > 0) { // There exists at least one RRef in heap\n      PCDRemote(m, n, p) [] PCDDelete(m, n, p) // Call remote procedure or delete RRef in heap\n    } else {\n      PCDRemote(m, n, p) // Only Call remote procedure is allowed\n      [] P_END.p{ PROCS = PROCS - 1; } -> Skip // Procedure ends\n    } // Procedure ends\n  } else { // New remote procedure is not allowed\n    ifa (RRefHT[p] > 0) { // There exists at least one RRef in heap\n      PCDDelete(m, n, p) // Only delete local RRef is allowed\n    } else {\n      P_END.p{ PROCS = PROCS - 1; } -> Skip // Procedure ends\n    }\n  };"
            },
            {
                "name": "PCDRemote",
                "description": "PCDRemote(m, n, p) handles a remote procedure call:\n  - For every possible node as target, for every possible local RRef as parameter, including no parameter if equals to 0\n    If RRef exists in heap, or no parameter:\n    1. It sends a REMOTE message to node n indicating a remote call with parameters including procedure ID, target node, and RRef.\n    2. And waits for a REMOTE_ACK from node n.\n    3. After that, it creates a new RRef with a unique ID, adds it to the procedure's heap, and updates the heap counter and start next loop.",
                "pat_code": "PCDRemote(m, n, p) =\n [] nt:{1..N} @ ( // For every possible node as target\n    [] rp:{0..call(TT, N, M)} @ // For every possible local RRef as parameter, including no parameter if equals to 0\n    [(rp == 0 || RRefHE[n][rp] == 1)] ( // If RRef exists in heap, or no parameter\n        L[n]!REMOTE.p.nt.rp.call(ID, n, m) // REMOTE locally\n        -> L[n]?REMOTE_ACK.p.call(ID, n, m) // REMOTE_ACK locally\n        -> P_NEW_REF.p.call(ID, n, m){ RRefHE[p][call(ID, n, m)] = 1; RRefHT[p] = RRefHT[p] + 1; } // New RRef created, update heap\n        -> PCDLoop(m + 1, n, p) // Next Loop\n    )\n );"
            },
            {
                "name": "PCDDelete",
                "description": "PCDDelete(m, n, p) handles the deletion of an RRef from the procedure's heap:\n  1. For every possible RRef, if RRef exists in heap, it tries to delete it in heap first.\n  2. Then, it sends a DELETE message to the node owning the RRef and waits for a DELETE_ACK from the node.\n  3. Then, it removes the RRef from the procedure's heap and updates the heap counter. And begin next loop.",
                "pat_code": "PCDDelete(m, n, p) =\n [] r:{1..call(TT, N, M)} @ // For every possible RRef\n [RRefHE[p][r] == 1] ( // If RRef exists in heap\n HEAP_DEL_REF.r // Try to delete in heap\n -> L[n]!DELETE.p.r // DELETE locally\n -> L[n]?DELETE_ACK.p.r // DELETE_ACK locally\n -> P_DEL_REF.p.r{ RRefHE[p][r] = 0; RRefHT[p] = RRefHT[p] - 1; } // RRef deleted, update heap\n -> PCDLoop(m, n, p) // Next Loop\n );\n\n\n/** Protocol **/"
            },
            {
                "name": "PTCLoop",
                "description": "The PTC is a process running on a node whose behavior is to continuously loop over the processing of multiple message events. \n  It handles following events:\n  - Send to remote\n  - receive from remote\n  - receive ack from remote\n  - receive fork message from remote\n  - receive fork acknowledgement from remote\n  - send delete message to remote\n  - receive delete message from remote\n  - receive delete acknowledgement from remote\n  - send child's ref acknowledgement to remote\n  - receive child's ref acknowledgement to remote",
                "pat_code": "PTCLoop(n) =\n OnSendREMOTE(n) [*] OnRecvREMOTE(n) [*] OnRecvREMOTEACK(n) [*]\n OnRecvFORK(n) [*] OnRecvFORKACK(n) [*]\n OnSendDELETE(n) [*] OnRecvDELETE(n) [*] OnRecvDELETEACK(n) [*]\n OnSendCHILDACK(n) [*] OnRecvCHILDACK(n);"
            },
            {
                "name": "OnSendREMOTE",
                "description": "- OnSendREMOTE(n) handles sending a REMOTE message:\n    1. It Receives a REMOTE message locally with parameter p, nt, rp, rn.\n    2. If there is no parameter RRef, it sends the REMOTE message remotely. Otherwise, it creates a new pending for child RRef deletion and then sends the message remotely.",
                "pat_code": "OnSendREMOTE(n) =\n  L[n]?REMOTE.p.nt.rp.rn // REMOTE locally\n  -> ifa (rp == 0) { // No parameter RRef\n    R!REMOTE.p.n.nt.rp.rn // REMOTE remotely\n    -> PTCLoop(n)\n  } else { // There is parameter RRef\n    PEND_CHILD_ACK.n.rp{ RRefCA[n][rp] = RRefCA[n][rp] + 1; } // A new pending for child RRef deletion\n    -> R!REMOTE.p.n.nt.rp.rn // REMOTE remotely\n    -> PTCLoop(n)\n  };"
            },
            {
                "name": "OnRecvREMOTE",
                "description": "- OnRecvREMOTE(n) handles receiving a REMOTE message.\n    1. It receives a REMOTE message remotely.\n    2. Sets node n as the owner of RRef rn.\n    3. Execute OnSendREMOTEACK and OnSendFORK concurrently.",
                "pat_code": "OnRecvREMOTE(n) =\n  R?REMOTE.ps.ns.n.rp.rn // REMOTE remotely\n  -> SET_OWNER.rn.n{ RRefOP[rn] = n; } // Update Ownership\n  -> USE_REF.ns.n.rn{ RRefOE[ns][rn] = 1; } // Update Useship\n  -> (OnSendREMOTEACK(n, ps, ns, rn) ||| OnSendFORK(n, ns, rp, rn));"
            },
            {
                "name": "OnRecvREMOTEACK",
                "description": "- OnSendREMOTEACK(n, ps, ns, rn) sends a REMOTE_ACK message remotely.",
                "pat_code": "OnSendREMOTEACK(n, ps, ns, rn) = R!REMOTE_ACK.ps.ns.n.rn // REMOTEACK remotely\n  -> PTCLoop(n);"
            },
            {
                "name": "- OnRecvREMOTEACK(n) handles receiving a REMOTE_ACK message.",
                "description": "1. If the RRef doesn't exist on the node, create the RRef and update the counter representing a new UserRRef.\n    2. Otherwise, it replies the message REMOTE_ACK locally",
                "pat_code": "OnRecvREMOTEACK(n) =\n  R?REMOTE_ACK.p.n.nt.rn // REMOTEACK remotely\n  -> ifa (RRefCE[n][rn] == 1) {\n    L[n]!REMOTE_ACK.p.rn // REMOTEACK locally\n    -> PTCLoop(n)\n  } else {\n    NEW_REF.n.rn{ RRefCE[n][rn] = 1; RRefCT[n][rn] = RRefCT[n][rn] + 1; } // Update indicator and counter for new RRef\n    -> L[n]!REMOTE_ACK.p.rn // REMOTEACK locally\n    -> PTCLoop(n)\n  };"
            },
            {
                "name": "OnSendFORK",
                "description": "- OnSendFORK(n, ns, rp, rn) handles sending a FORK message for an existing parameter RRef.\n    1. If there is parameter RRef, it creates a new pending for forking RRef\n    2. Then it records parent node for forking RRef\n    3. Then, it sends a FORK message to the owner of the RRef.",
                "pat_code": "OnSendFORK(n, ns, rp, rn) =\n  [rp > 0] ( // There is parameter RRef\n  PEND_FORK_ACK.n.rp{ RRefFA[n][rp] = RRefFA[n][rp] + 1; } // A new pending for forking RRef\n  -> SET_PARENT.n.rp.ns{ RRefPP[n][rp] = ns; } // Record parent node for forking RRef\n  -> R!FORK.n.RRefOP[rp].rp.rn // FORK remotely\n  -> Skip\n  );"
            },
            {
                "name": "OnRecvFORK",
                "description": "- OnRecvFORK(n) handles receiving a FORK message to the remote.",
                "pat_code": "OnRecvFORK(n) =\n  R?FORK.ns.n.r.rn // FORK remotely\n  -> OnSendFORKACK(ns, n, r, rn);"
            },
            {
                "name": "OnSendFORKACK",
                "description": "- OnSendFORKACK(ns, n, r, rn) sends a FORK_ACK message remotely.",
                "pat_code": "OnSendFORKACK(ns, n, r, rn) =\n  R!FORK_ACK.ns.n.r.rn // FORKACK remotely\n  -> PTCLoop(n);"
            },
            {
                "name": "OnRecvFORKACK",
                "description": "- OnRecvFORKACK(n) handles receiving a FORK_ACK message.\n    1. It first receives a FORK_ACK message remotely.\n    2. It then create a new RRef locally, update indicator and counter for forked RRef\n    3. After that is the decrement of ref counter, indicating a completed FORK.\n    4. It Increases the FORKS counter and records that node is using RRef r.\n    5. Concurrently execute PTCLoop and start a new procedure PCD(M, n, rn, r).",
                "pat_code": "OnRecvFORKACK(n) =\n  R?FORK_ACK.n.nt.r.rn // FORKACK remotely\n  -> NEW_REF.n.r{ RRefCE[n][r] = 1; RRefCT[n][r] = RRefCT[n][r] + 1; } // Update indicator and counter for forked RRef\n  -> RESP_FORK_ACK.n.r{ RRefFA[n][r] = RRefFA[n][r] - 1; } // The pending for forking RRef ends\n  -> FORKED.n.r { FORKS = FORKS + 1; }\n  -> USE_REF.n.nt.r{ RRefOE[n][r] = 1; } // Update Useship\n  -> (PTCLoop(n) ||| PCD(M, n, rn, r));"
            },
            {
                "name": "OnSendDELETE",
                "description": "- OnSendDELETE(n) handles sending a DELETE message for an RRef:\n    1. For every possible RRef, if RRef exists, but will be deleted\n    2. It marks the RRef as deleted and remove useship\n    3. If the node is the owner of the RRef, it delete the RRef on owner and continue the protocol loop. Otherwise send a delete signal to owner of the RRef remotely.",
                "pat_code": "OnSendDELETE(n) =\n  [*] r:{1..call(TT, N, M)} @ // For every possible RRef\n  [RRefCE[n][r] == 1 && RRefCT[n][r] == 0 && RRefCA[n][r] == 0 && RRefFA[n][r] == 0] ( // If RRef exists, but to be deleted\n  DEL_REF.n.r{ RRefCE[n][r] = 0; } // Deleted\n  -> REL_REF.n.r{ RRefOE[n][r] = 0; } // Release Useship\n  -> ifa (RRefOP[r] == n) {\n  OWNR_DEL_REF.r // Delete RRef on owner\n  -> PTCLoop(n)\n  } else {\n  R!DELETE.n.RRefOP[r].r\n  -> PTCLoop(n)\n  }\n  );"
            },
            {
                "name": "OnRecvDELETE",
                "description": "- OnRecvDELETE(n) handles receiving a DELETE message.\n    1. It receives a DELETE message from local or remote. \n    2. After receiving the message, update counter for deleted RRef locally or remotely.",
                "pat_code": "OnRecvDELETE(n) =\n ( // Local\n L[n]?DELETE.p.r // DELETE locally\n -> REM_CNT.n.r{ RRefCT[n][r] = RRefCT[n][r] - 1; } // Update counter for deleted RRef locally\n -> L[n]!DELETE_ACK.p.r // DELETE_ACK locally\n -> PTCLoop(n)\n ) [*] ( // Remote\n R?DELETE.ns.n.r // DELETE remotely\n -> OnSendDELETEACK(n, ns, r)\n );"
            },
            {
                "name": "OnSendDELETEACK",
                "description": "- OnSendDELETEACK(n, ns, r) sends a DELETE_ACK message remotely.\n    1. It first sends a DELETE_ACK message remotely.\n    2. If the node is the owner of the RRef, it deletes RRef on owner. Otherwise, it does nothing and start next loop.",
                "pat_code": "OnSendDELETEACK(n, ns, r) =\n R!DELETE_ACK.ns.n.r\n -> ifa (RRefOP[r] == n) {\n OWNR_DEL_REF.r // Delete RRef on owner\n -> PTCLoop(n) \n } else {\n PTCLoop(n)\n };"
            },
            {
                "name": "OnRecvDELETEACK",
                "description": "- OnRecvDELETEACK(n) handles receiving a DELETE_ACK message remotely",
                "pat_code": "OnRecvDELETEACK(n) =\n R?DELETE_ACK.ns.n.r\n -> PTCLoop(n);"
            },
            {
                "name": "OnSendCHILDACK",
                "description": "- OnSendCHILDACK(n):\n    1. For every possible Node, for every possible RRef, if a ChildRRef is determined to be unused, or if the ChildRRef appears to be self-ringing, the sends a CHILD_ACK to its Parent.",
                "pat_code": "// !CHILD_ACK -> ?CHILD_ACK\nOnSendCHILDACK(n) =\n [*] nt:{1..N} @ ( // For every possible Node\n [*] r:{1..call(TT, N, M)} @ // For every possible RRef\n [RRefPP[n][r] > 0 && RRefOE[n][r] == 0 || RRefPP[n][r] == n] (\n R!CHILD_ACK.n.RRefPP[n][r].r\n -> UNSET_PARENT.n.r{ RRefPR[n][r] = RRefPP[n][r]; RRefPP[n][r] = 0; } // No more parent\n -> PTCLoop(n)\n )\n );"
            },
            {
                "name": "OnRecvCHILDACK",
                "description": "- OnRecvCHILDACK(n):\n    1. It first receives a CHILD_ACK message remotely.\n    2. Decrements the pending child ack counter\n    3. Increment the child ack counter.",
                "pat_code": "OnRecvCHILDACK(n) =\n R?CHILD_ACK.nc.n.r\n -> RESP_CHILD_ACK.n.r{ RRefCA[n][r] = RRefCA[n][r] - 1; } // The pending for child RRef deletion ends\n -> CHILD_ACKED.n.r{ CHAKS = CHAKS + 1; }\n -> PTCLoop(n);"
            }
        ],
        "global_definition": "/** Constants **/\n#define N 3; // Max number of nodes\n#define M 2; // Max number of remotes in a Procedure\n#define B 10; // Max buffer size of channels\n#define ID(n, m) n*M+m; // Get remote id used for RRef and Procedure\n#define TT(n, m) (n+1)*(m+1); // Max number of remotes globally\n/** Headers **/\nenum {REMOTE, REMOTE_ACK, DELETE, DELETE_ACK, FORK, FORK_ACK, CHILD_ACK};\n/** Channels **/\nchannel L[N+1] B;\nchannel R B;\n\n/** Tables **/\nvar T = (N+1)*(M+1);\nvar RRefHE[T+1][T+1]: {0..1}; // RRefHE[p][i] = 1: If RRef i exists in heap of Procedure p\nvar RRefHT[T+1]; // RRefHE[p] = k: There are k parameter RRefs in the heap of Procedure p\nvar RRefCE[N+1][T+1]: {0..1}; // RRefCT[n][i] = 1: If RRef i exists on Node n\nvar RRefCT[N+1][T+1]; // RRefCT[n][i] = k: The number of references of RRef i on Node n is k\nvar RRefOP[T+1]: {0..N}; // RRefOP[i] = n: The owner of RRef i is Node n\nvar RRefOE[N+1][T+1]; // RRefOE[n][i] = 1: If Node n use RRef i\nvar RRefPP[N+1][T+1]: {0..N}; // RRefPP[n][i] = m: The parent RRef of RRef i forked to Node n is that on Node m\nvar RRefPR[N+1][T+1]: {0..N}; // RRefPP[n][i] = m: Parent record for verification\nvar RRefCA[N+1][T+1]: {0..M}; // RRefCA[n][i] = k: The number of pendings of CHILD_ACK of RRef i on Node n is k\nvar RRefFA[N+1][T+1]: {0..M}; // RRefFA[n][i] = k: The number of pendings of FORK_ACK of RRef i on Node n is k\n/** Counters **/\nvar PROCS = 0;\nvar FORKS = 0;\nvar CHAKS = 0;\n\n\n\n/** System **/",
        "path": "handwrite/Pytorch Remote Reference Protocol.csp"
    },
    {
        "name": "Quic Communication",
        "tags": [
            "Protocol"
        ],
        "use_non_container_lib": false,
        "description": "The communication process is as follows for the client to send a message to the server.",
        "pat_code": "#define packet_num 4;\n#define frame_num 3;\n#define stream_num 5;\nchannel C2S 15;\n#define msgLen 120;\nvar packet_step= msgLen / packet_num;\nvar req0[msgLen]:{0..9}=*; \nvar requ[msgLen];\n\n/*@Process: CLIENT\nThe CLIENT process:\n  It divides the message into a defined number of packets.\n  The last packet will be padded if the message length is not divisible by the number of packets.\n*/\nCLIENT() = || x:{0..packet_num - 1} @\n\tif(x < packet_num - 1){PACKET(x, packet_step)}\n\telse{PACKET(x, packet_step + msgLen & x)};\n\n/*@Process: PACKET\n  For each packet, it further divides it into frames. The size of each frame is nearly the same.\n  The PACKET process sends each FRAME. The last packet will be padded if the message length is not divisible by the number of packets.\n*/\nPACKET(p, len)= || x:{0..frame_num - 1}@\n\tif(x < frame_num - 1) {FRAME(p,x,len / frame_num,len / frame_num)}\n\telse{FRAME(p,x,len / frame_num,len / frame_num + len % frame_num) };\n\n/*@Process: FRAME\n  Each frame is then divided into streams. The size of each stream is also nearly the same.\n  The FRAME process sends each STREAM. The last frame will be padded if the packet length is not divisible by the number of frames.\n*/\nFRAME(p,f,frame_step,len) = || x:{0..stream_num - 1} @\n\tif(x < stream_num - 1) {\n\t\tSTREAM(p * packet_step + f * frame_step + x * len / stream_num, len / stream_num)\n\t} else {\n\t\tSTREAM(p * packet_step + f * frame_step + x * len / stream_num, len / stream_num + len % stream_num) \n\t};\n\t\n/*@Process: STREAM\n  The STREAM process sends data to the server. The last stream will be padded if the frame length is not divisible by the number of streams.\n*/\nSTREAM(offset, len) = \n  ||x:{offset..offset + len - 1}@\n    C2S!x.req0[x]->Skip\n  []STREAM(offset,len);\n\n/*@Process: SERVER\n  The SERVER process:\n  1. The SERVER receives data from the client.\n  2. Upon receiving data, it writes the received value into storage .\n  3. It then loops back to receive the next piece of data.\n*/\nSERVER()= C2S?a.b -> mod{requ[a] = b}->SERVER();\n\n/*@Process: System\n  The System composes the CLIENT and SERVER running in parallel.\n*/\nSystem() = CLIENT() || SERVER();",
        "property_desc": [
            "The protocol is divergence-free."
        ],
        "properties": [
            "#assert System() divergencefree;"
        ],
        "processes": [
            {
                "name": "CLIENT",
                "description": "The CLIENT process:\n  It divides the message into a defined number of packets.\n  The last packet will be padded if the message length is not divisible by the number of packets.",
                "pat_code": "CLIENT() = || x:{0..packet_num - 1} @\n\tif(x < packet_num - 1){PACKET(x, packet_step)}\n\telse{PACKET(x, packet_step + msgLen & x)};"
            },
            {
                "name": "PACKET",
                "description": "For each packet, it further divides it into frames. The size of each frame is nearly the same.\n  The PACKET process sends each FRAME. The last packet will be padded if the message length is not divisible by the number of packets.",
                "pat_code": "PACKET(p, len)= || x:{0..frame_num - 1}@\n\tif(x < frame_num - 1) {FRAME(p,x,len / frame_num,len / frame_num)}\n\telse{FRAME(p,x,len / frame_num,len / frame_num + len % frame_num) };"
            },
            {
                "name": "FRAME",
                "description": "Each frame is then divided into streams. The size of each stream is also nearly the same.\n  The FRAME process sends each STREAM. The last frame will be padded if the packet length is not divisible by the number of frames.",
                "pat_code": "FRAME(p,f,frame_step,len) = || x:{0..stream_num - 1} @\n\tif(x < stream_num - 1) {\n\t\tSTREAM(p * packet_step + f * frame_step + x * len / stream_num, len / stream_num)\n\t} else {\n\t\tSTREAM(p * packet_step + f * frame_step + x * len / stream_num, len / stream_num + len % stream_num) \n\t};"
            },
            {
                "name": "STREAM",
                "description": "The STREAM process sends data to the server. The last stream will be padded if the frame length is not divisible by the number of streams.",
                "pat_code": "STREAM(offset, len) = \n  ||x:{offset..offset + len - 1}@\n    C2S!x.req0[x]->Skip\n  []STREAM(offset,len);"
            },
            {
                "name": "SERVER",
                "description": "The SERVER process:\n  1. The SERVER receives data from the client.\n  2. Upon receiving data, it writes the received value into storage .\n  3. It then loops back to receive the next piece of data.",
                "pat_code": "SERVER()= C2S?a.b -> mod{requ[a] = b}->SERVER();"
            },
            {
                "name": "System",
                "description": "The System composes the CLIENT and SERVER running in parallel.",
                "pat_code": "System() = CLIENT() || SERVER();"
            }
        ],
        "global_definition": "#define packet_num 4;\n#define frame_num 3;\n#define stream_num 5;\nchannel C2S 15;\n#define msgLen 120;\nvar packet_step= msgLen / packet_num;\nvar req0[msgLen]:{0..9}=*; \nvar requ[msgLen];",
        "path": "handwrite/Quic Communication.csp"
    },
    {
        "name": "Quic Connection Establishment",
        "tags": [
            "Protocol"
        ],
        "use_non_container_lib": false,
        "description": "The flow of the QUIC protocol when a connection is first established is as follows:",
        "pat_code": "channel EstabC2S 0;\nchannel EstabS2C 0;\nvar p = 17;\nvar g = 42;\nvar ks_pri = 5;\nvar ks_pub;\nvar kc_pri = 7;\nvar kc_pub;\nvar kc;\nvar ks;\n\nvar req;\n\n#define chlo 0;\n\n/*@Process: SERVER\nThe Server:\n  1. Waits for a hello request from the CLIENT.\n  2. If it receives the hello request, it generates a server's public key using the server's private key , a generator (g), and a prime number (p).  The formula for the server's public key is ks_pub = g^ks_pri % p.\n  3. Sends the prime number, generator, and server's public key  to the CLIENT .\n  4. Waits to receive the client's key component (kc) and client's public key from the CLIENT.\n  5. Generates a shared secret key by raising the client's public key using server's private key and p. The formula is ks = kc_pub ^ ks_pri % p.\n  6. Sends the shared secret key to the CLIENT.\n  7. If it receives other messages other than hello request, it waits for the connection establishment request from the CLIENT again.\n\n*/\nSERVER() =\n  EstabC2S?x1 ->\n  if (x1 == chlo){\n    gen_ks_pub{ks_pub = g^ks_pri % p} ->\n    EstabS2C!p.g.ks_pub ->\n    EstabC2S?kc1.kc_pub1{kc = kc1; kc_pub = kc_pub1;} ->\n    gen_ks{ks = kc_pub ^ ks_pri % p} ->\n    EstabS2C!ks ->\n    SERVER()\n  } else {\n    SERVER()\n  };\n\n/*@Process: CLIENT\nThe Client:\n  1. The client for the first connection to the server side first sends a client hello request.\n  2. It waits for responses with the server's public key and two prime number p,g.\n  3. The client randomly generates a private key Kc_pri of its own, and calculates the client's public key K=Kc_pub xor Ks_pri mod p.\n  4. The client uses its own private key Kc_pri and the server's public key Ks_pub read from config sent by the server to generate the key K=Ks_pub xor Kc_pri mod p. \n  5. The client encrypts the data and appends its own public key Kc_pub, both of which are passed to the server side.\n  6. Upon receiving responses from the server, the connection is established.\n*/\nCLIENT() =\n  EstabC2S!chlo ->\n  EstabS2C?p1.g1.ks_pub1 ->\n  gen_kc_pub{kc_pub = g1^kc_pri % p1} ->\n  gen_kc{kc = ks_pub1 ^ kc_pri % p1} ->\n  EstabC2S!kc.kc_pub ->\n  EstabS2C?ks1{ks = ks1;} ->\n  established ->\n  CLIENT();\n\n/*@Process: System\n  The System composes the CLIENT and SERVER running in parallel.\n*/\nSystem() = CLIENT() || SERVER();",
        "property_desc": [
            "The protocol is divergence-free."
        ],
        "properties": [
            "#assert System() divergencefree;"
        ],
        "processes": [
            {
                "name": "SERVER",
                "description": "The Server:\n  1. Waits for a hello request from the CLIENT.\n  2. If it receives the hello request, it generates a server's public key using the server's private key , a generator (g), and a prime number (p).  The formula for the server's public key is ks_pub = g^ks_pri % p.\n  3. Sends the prime number, generator, and server's public key  to the CLIENT .\n  4. Waits to receive the client's key component (kc) and client's public key from the CLIENT.\n  5. Generates a shared secret key by raising the client's public key using server's private key and p. The formula is ks = kc_pub ^ ks_pri % p.\n  6. Sends the shared secret key to the CLIENT.\n  7. If it receives other messages other than hello request, it waits for the connection establishment request from the CLIENT again.",
                "pat_code": "SERVER() =\n  EstabC2S?x1 ->\n  if (x1 == chlo){\n    gen_ks_pub{ks_pub = g^ks_pri % p} ->\n    EstabS2C!p.g.ks_pub ->\n    EstabC2S?kc1.kc_pub1{kc = kc1; kc_pub = kc_pub1;} ->\n    gen_ks{ks = kc_pub ^ ks_pri % p} ->\n    EstabS2C!ks ->\n    SERVER()\n  } else {\n    SERVER()\n  };"
            },
            {
                "name": "CLIENT",
                "description": "The Client:\n  1. The client for the first connection to the server side first sends a client hello request.\n  2. It waits for responses with the server's public key and two prime number p,g.\n  3. The client randomly generates a private key Kc_pri of its own, and calculates the client's public key K=Kc_pub xor Ks_pri mod p.\n  4. The client uses its own private key Kc_pri and the server's public key Ks_pub read from config sent by the server to generate the key K=Ks_pub xor Kc_pri mod p. \n  5. The client encrypts the data and appends its own public key Kc_pub, both of which are passed to the server side.\n  6. Upon receiving responses from the server, the connection is established.",
                "pat_code": "CLIENT() =\n  EstabC2S!chlo ->\n  EstabS2C?p1.g1.ks_pub1 ->\n  gen_kc_pub{kc_pub = g1^kc_pri % p1} ->\n  gen_kc{kc = ks_pub1 ^ kc_pri % p1} ->\n  EstabC2S!kc.kc_pub ->\n  EstabS2C?ks1{ks = ks1;} ->\n  established ->\n  CLIENT();"
            },
            {
                "name": "System",
                "description": "The System composes the CLIENT and SERVER running in parallel.",
                "pat_code": "System() = CLIENT() || SERVER();"
            }
        ],
        "global_definition": "channel EstabC2S 0;\nchannel EstabS2C 0;\nvar p = 17;\nvar g = 42;\nvar ks_pri = 5;\nvar ks_pub;\nvar kc_pri = 7;\nvar kc_pub;\nvar kc;\nvar ks;\n\nvar req;\n\n#define chlo 0;",
        "path": "handwrite/Quic Connection Establishment.csp"
    },
    {
        "name": "Raft",
        "tags": [
            "Algorithm",
            "Leader Election"
        ],
        "use_non_container_lib": false,
        "description": "This model implements a simplified version of the Raft consensus algorithm. It focuses on leader election and heartbeat mechanisms.\n\tThe model contains N processes, each processes can be in one of three states: Follower, Candidate, or Leader and each processes have a request handler to receive messages from others.",
        "pat_code": "#define N 3; // Number of nodes in the cluster (can be adjusted)\n#define timeout_max 3;\n#define sumN 2; // Quorum size for election\n\nvar curTerm[N+1];\nvar voteFor[N+1];\nvar votes[N+1];\n\nvar toFollower[N+1];\n\nchannel requestV 0; // Request Vote (Candidate -> Follower)\nchannel requestVR 0; // Request Vote Response (Follower -> Candidate) - True=Vote Granted, False = Vote Denied\nchannel heartbeat 0; // Leader Heartbeat (Leader -> Follower)\n\nvar NUM = 0; // Number of Leaders. Should always be 0 or 1\n\n/*@Process: Handler\n  Meanwhile, the handler process runs concurrently with each node and listens for incoming messages. It handles three types of messages:\n  - 1. A request for a vote from another node with a term number.\n    2. If the received term is less than the node's current term, the node denies the vote.\n    3. If the received term is greater than or equal to the node's current term, the node grants the vote.\n  - 1. A heartbeat message from a leader with a term number. \n\t  2. Upon receiving a heartbeat, the node updates its current term to match the leader's term.\n  - 1. A response of a vote request with term. \n\t  2. If the term in the response is greater than the node's current term, the node transitions to the Follower state and updates its term. \n\t\t3. If the term is not greater, and vote is true, the node increments its vote count.\n*/\nHandler(n) = \n\t\t([]from:{1..N}@(requestV?from.n.term -> (\n\t\t\t\t\t[term < curTerm[n]]requestVR!n.from.curTerm[n].false -> Handler(n) \n\t\t\t\t\t[] \n\t\t\t\t\t[term >= curTerm[n]]requestVR!n.from.curTerm[n].true -> Handler(n)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t\t[]\n\t    ([]from:{1..N}@heartbeat?from.n.term{curTerm[n] = term;} -> Handler(n))\n\t    []\n\t    ([]to:{1..N}@requestVR?to.n.term.vote -> if(term > curTerm[n]) {\n\t\t\t\t{toFollower[n] = 1; curTerm[n]=term;} -> Handler(n)\n\t\t\t} else if(vote){\n\t\t\t\t{votes[n]++} -> Handler(n)\n\t\t\t} \n\t\t);\n\t    \n\n/*@Process: Follower\n  Follower with timeout: \n\t- If a heartbeat isn't received within a timeout period, the follower becomes a candidate.\n\t- Otherwise, it simulates the time passing by descrase the timeout.\n*/\nFollower(n, timeout) =\n\t\t[timeout == 0]becomeCandicate.n{curTerm[n]++; votes[n]=1; toFollower[n]=0;} -> Candidate(n, timeout_max)\n\t\t[]\n\t\t[timeout > 0]tick -> Follower(n, timeout-1);\n\n\n/*@Process: Candidate\n  Candidate with timeout:\n  1. When become the candidate, it initiates a new election\n\t2. Sends vote requests to all other nodes.\n\t3. Becomes a leader if it receives votes from a majority of nodes.\n\t4. If any response with term is geeater than the node's current term, the node transitions to the Follower\n\t5. If timeout, it restarts the election.\n*/\nCandidate(n, timeout) = \n\t(|||to:{1..N}@requestV!n.to.curTerm[n] -> Skip);\n\tif(toFollower[n] == 1) {\n\t\tFollower(n, timeout_max)\n\t} else if(votes[n] >= sumN){\n\t\tbecomeLeader.n{NUM++;} -> Leader(n, timeout_max)\n\t} else {\n\t\ttick -> Candidate(n, timeout-1)\n\t};\n\t\n\n/*@Process: Leader\n\tLeader:\n  1. The leader sends heartbeat messages to all other nodes in the cluster to maintain its leadership.\n  2. If the leader's timeout reaches 0, it becomes a follower.\n*/\nLeader(n, timeout) = if(timeout == 0) {\n\t\tbecomeFollower.n{NUM--;} -> Follower(n, timeout_max)\n\t} else {\n\t\t(|||to:{1..N}@heartbeat!n.to.curTerm[n] -> Skip); Leader(n, timeout)\n\t};\n\t\n/*@Process: System\n  The model contains N processes, each processes begins in the Follower state and each processes have a request handler to receive messages from others.\n*/\nSystem() = ||| i:{1..N} @ (Follower(i, timeout_max) ||| Handler(i));",
        "property_desc": [
            "The system is deadlock-free.",
            "The system is divergence-free.",
            "At most one Leader will be present at any time.",
            "The leader can be elected."
        ],
        "properties": [
            "#assert System() deadlockfree;",
            "#assert System() divergencefree;",
            "#define oneleader (NUM <= 1);\n#assert System() |= oneleader;",
            "#define hasLeader (NUM == 1);\n#assert System() reaches hasLeader;"
        ],
        "processes": [
            {
                "name": "Handler",
                "description": "Meanwhile, the handler process runs concurrently with each node and listens for incoming messages. It handles three types of messages:\n  - 1. A request for a vote from another node with a term number.\n    2. If the received term is less than the node's current term, the node denies the vote.\n    3. If the received term is greater than or equal to the node's current term, the node grants the vote.\n  - 1. A heartbeat message from a leader with a term number. \n\t  2. Upon receiving a heartbeat, the node updates its current term to match the leader's term.\n  - 1. A response of a vote request with term. \n\t  2. If the term in the response is greater than the node's current term, the node transitions to the Follower state and updates its term. \n\t\t3. If the term is not greater, and vote is true, the node increments its vote count.",
                "pat_code": "Handler(n) = \n\t\t([]from:{1..N}@(requestV?from.n.term -> (\n\t\t\t\t\t[term < curTerm[n]]requestVR!n.from.curTerm[n].false -> Handler(n) \n\t\t\t\t\t[] \n\t\t\t\t\t[term >= curTerm[n]]requestVR!n.from.curTerm[n].true -> Handler(n)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t\t[]\n\t    ([]from:{1..N}@heartbeat?from.n.term{curTerm[n] = term;} -> Handler(n))\n\t    []\n\t    ([]to:{1..N}@requestVR?to.n.term.vote -> if(term > curTerm[n]) {\n\t\t\t\t{toFollower[n] = 1; curTerm[n]=term;} -> Handler(n)\n\t\t\t} else if(vote){\n\t\t\t\t{votes[n]++} -> Handler(n)\n\t\t\t} \n\t\t);"
            },
            {
                "name": "Follower",
                "description": "Follower with timeout: \n\t- If a heartbeat isn't received within a timeout period, the follower becomes a candidate.\n\t- Otherwise, it simulates the time passing by descrase the timeout.",
                "pat_code": "Follower(n, timeout) =\n\t\t[timeout == 0]becomeCandicate.n{curTerm[n]++; votes[n]=1; toFollower[n]=0;} -> Candidate(n, timeout_max)\n\t\t[]\n\t\t[timeout > 0]tick -> Follower(n, timeout-1);"
            },
            {
                "name": "Candidate",
                "description": "Candidate with timeout:\n  1. When become the candidate, it initiates a new election\n\t2. Sends vote requests to all other nodes.\n\t3. Becomes a leader if it receives votes from a majority of nodes.\n\t4. If any response with term is geeater than the node's current term, the node transitions to the Follower\n\t5. If timeout, it restarts the election.",
                "pat_code": "Candidate(n, timeout) = \n\t(|||to:{1..N}@requestV!n.to.curTerm[n] -> Skip);\n\tif(toFollower[n] == 1) {\n\t\tFollower(n, timeout_max)\n\t} else if(votes[n] >= sumN){\n\t\tbecomeLeader.n{NUM++;} -> Leader(n, timeout_max)\n\t} else {\n\t\ttick -> Candidate(n, timeout-1)\n\t};"
            },
            {
                "name": "Leader",
                "description": "Leader:\n  1. The leader sends heartbeat messages to all other nodes in the cluster to maintain its leadership.\n  2. If the leader's timeout reaches 0, it becomes a follower.",
                "pat_code": "Leader(n, timeout) = if(timeout == 0) {\n\t\tbecomeFollower.n{NUM--;} -> Follower(n, timeout_max)\n\t} else {\n\t\t(|||to:{1..N}@heartbeat!n.to.curTerm[n] -> Skip); Leader(n, timeout)\n\t};"
            },
            {
                "name": "System",
                "description": "The model contains N processes, each processes begins in the Follower state and each processes have a request handler to receive messages from others.",
                "pat_code": "System() = ||| i:{1..N} @ (Follower(i, timeout_max) ||| Handler(i));"
            }
        ],
        "global_definition": "#define N 3; // Number of nodes in the cluster (can be adjusted)\n#define timeout_max 3;\n#define sumN 2; // Quorum size for election\n\nvar curTerm[N+1];\nvar voteFor[N+1];\nvar votes[N+1];\n\nvar toFollower[N+1];\n\nchannel requestV 0; // Request Vote (Candidate -> Follower)\nchannel requestVR 0; // Request Vote Response (Follower -> Candidate) - True=Vote Granted, False = Vote Denied\nchannel heartbeat 0; // Leader Heartbeat (Leader -> Follower)\n\nvar NUM = 0; // Number of Leaders. Should always be 0 or 1",
        "path": "handwrite/Raft.csp"
    },
    {
        "name": "Redis Meet",
        "tags": [
            "Protocol",
            "Distrubued System"
        ],
        "use_non_container_lib": false,
        "description": "Redis (Remote Dictionary Server), or Remote Dictionary Service, is an open source key-value database.\n  Redis operations are completely memory-based, with good availability, and support for publish-subscribe, notification, key expiration, and other features.\n  There are the following main types of messages in a Redis cluster: Meet messages, Ping messages, Pong messages, Fail messages, Publish messages, and Update messages.\n  Redis cluster meet message communication occurs when the client initiates the CLUSTER MEET command.",
        "pat_code": "enum{nullName, nameA, nameB, randomA, randomB}; \nenum{nullFlag, HANDSHAKE, MEET}; \nenum{meet, ping, pong};\n\n#define null 0; \n#define SUM 4; \n#define NUM 2; \n\nvar b=nullName; \nvar a=nullName; \nvar aFlag[2]; \nvar bFlag[2]; \nchannel ComMeetAB 0; \nchannel ComPongBA 0; \nchannel ComPingBA 0; \nchannel ComPongAB 0; \nchannel ComMeetFail 0;  \n\n/*@Process: A_Meet_Send\n  Node A sends a Meet message to node B and then executes the A_Pong_Receive process to receive the Pong message sent by node B.\n*/\nA_Meet_Send() = {b=randomB;bFlag[0]=HANDSHAKE;bFlag[1]=MEET;}->{bFlag[1]=nullFlag;} -> ComMeetAB!nameA -> ComMeetAB!meet -> A_Pong_Receive();\n/*@Process: A_Pong_Receive\n  This process receives the Pong message sent by node B and executes the A_Judge_Pong process.\n*/\nA_Pong_Receive() = ComPongBA?BInfo -> ComPongBA?Type -> A_Judge_Pong(BInfo,Type);\n/*@Process: A_Judge_Pong\n  The process determines whether it needs to update the B-node information in its own dictionary based on the message from the B-node.\n*/\nA_Judge_Pong(BInfo,Type) = if(BInfo!=b){UpdateB(BInfo);A_Ping_Receive()}else{A_Ping_Receive()}; \n/*@Process: UpdateB\n  The process updates the B-node information in its own dictionary based on messages from the B-node.\n*/\nUpdateB(BInfo) = {b=BInfo;bFlag[0]=nullFlag;} -> Skip;\n/*@Process: A_Ping_Receive\n  Node A receives the handshake Ping message from node B and then executes the A_Pong_Send process.\n*/\nA_Ping_Receive() = ComPingBA?BInfo -> ComPingBA?Type -> A_Pong_Send(); \n/*@Process: A_Pong_Send\n  Process A sends a Pong message containing information about itself and then recursively executes the A_Meet_Send process.\n*/\nA_Pong_Send() = ComPongAB!nameA ->ComPongAB!pong -> A_Meet_Send();\n/*@Process: B_Meet_Receive\n  In the B_Meet_Receive process, node B receives the Meet message sent by node A and then executes the B_Judge_Meet process.\n*/\nB_Meet_Receive() = ComMeetAB?AInfo -> ComMeetAB?Type -> B_Judge_Meet(AInfo,Type); \n/*@Process: B_Judge_Meet\n  The B_Judge_Meet process adds node A to its own dictionary after judgment, executes the AddA process and then executes the B_Pong_Send process.\n*/\nB_Judge_Meet(AInfo,Type) = if(AInfo!=a&&Type==meet){AddA();B_Pong_Send()}else{B_Pong_Send()};\n/*@Process: AddA\n  The process adds node A to its own dictionary.\n*/ \nAddA() = {a=randomA;aFlag[0]=HANDSHAKE;} -> Skip;  \n/*@Process: B_Pong_Send\n  Process B sends a Pong message containing information about itself.\n  Then it executes the B_Ping_Send process.\n*/\nB_Pong_Send() = ComPongBA!nameB ->ComPongBA!pong -> B_Ping_Send();\n/*@Process: B_Ping_Send\n  Node B sends a handshake Ping message to node A and then executes the B_Pong_Receive process.\n*/\nB_Ping_Send() = ComPingBA!nameB ->ComPingBA!ping -> B_Pong_Receive(); \n/*@Process: B_Pong_Receive\n  The process waits for a Pong message to be returned from node A and then executes the B_Judge_Pong process.\n*/\nB_Pong_Receive() = ComPongAB?AInfo -> ComPongAB?Type -> B_Judge_Pong(AInfo); \n/*@Process: B_Judge_Pong\n  The process determines whether it needs to update the A-node information in its own dictionary based on the message from the A-node.\n*/\nB_Judge_Pong(AInfo) = if(AInfo!=a){UpdateA(AInfo);B_Meet_Receive()}else{B_Meet_Receive()};\n/*@Process: UpdateA\n  The process updates the A-node information in its own dictionary based on messages from the A-node.\n*/\nUpdateA(AInfo) = {a=AInfo;aFlag[0]=nullFlag;} -> Skip;\n/*@Process: A_Meet_Fail\n  The A_Meet_Fail and Meet_Fail processes implement a Meet message sending failure process. \n  First node A sends a Meet message and simulates a send failure by a non-responding node.\n*/\nA_Meet_Fail() = {b=randomB;bFlag[0]=HANDSHAKE;bFlag[1]=MEET;} ->{bFlag[1]=nullFlag;} -> ComMeetFail!nameA->ComMeetFail!meet -> A_Meet_Fail(); \n/*@Process: Meet_Fail\n  The Meet_Fail process receives send failure messages.\n*/\nMeet_Fail() = ComMeetFail?AInfo -> ComMeetFail?Type -> Meet_Fail();\n/*@Process: SystemMeet\n  The system consists of four processes AMeet_Send, B_Meet_Receive, A_Meet_Fail, and Meet_Fail.\n  AMeet_Send and B_Meet_Receive indicate that the message was sent normally, and A_Meet_Fail and Meet_Fail indicate that the send failed.\n*/\nSystemMeet() = (A_Meet_Send()||B_Meet_Receive())<>(A_Meet_Fail()||Meet_Fail());",
        "property_desc": [
            "The system is deadlock-free.",
            "The system is always interactive, that is two nodes have each other's node information through handshake."
        ],
        "properties": [
            "#assert SystemMeet() deadlockfree;",
            "#define sameName a==nameA&&b==nameB; \n#define noFlag aFlag[0]==nullFlag&&aFlag[1]==nullFlag&&bFlag[0]==nullFlag&&bFlag[1]==nullFlag; \n#define exchange sameName&&noFlag; \n#assert SystemMeet() |= []<> exchange;"
        ],
        "processes": [
            {
                "name": "A_Meet_Send",
                "description": "Node A sends a Meet message to node B and then executes the A_Pong_Receive process to receive the Pong message sent by node B.",
                "pat_code": "A_Meet_Send() = {b=randomB;bFlag[0]=HANDSHAKE;bFlag[1]=MEET;}->{bFlag[1]=nullFlag;} -> ComMeetAB!nameA -> ComMeetAB!meet -> A_Pong_Receive();"
            },
            {
                "name": "A_Pong_Receive",
                "description": "This process receives the Pong message sent by node B and executes the A_Judge_Pong process.",
                "pat_code": "A_Pong_Receive() = ComPongBA?BInfo -> ComPongBA?Type -> A_Judge_Pong(BInfo,Type);"
            },
            {
                "name": "A_Judge_Pong",
                "description": "The process determines whether it needs to update the B-node information in its own dictionary based on the message from the B-node.",
                "pat_code": "A_Judge_Pong(BInfo,Type) = if(BInfo!=b){UpdateB(BInfo);A_Ping_Receive()}else{A_Ping_Receive()};"
            },
            {
                "name": "UpdateB",
                "description": "The process updates the B-node information in its own dictionary based on messages from the B-node.",
                "pat_code": "UpdateB(BInfo) = {b=BInfo;bFlag[0]=nullFlag;} -> Skip;"
            },
            {
                "name": "A_Ping_Receive",
                "description": "Node A receives the handshake Ping message from node B and then executes the A_Pong_Send process.",
                "pat_code": "A_Ping_Receive() = ComPingBA?BInfo -> ComPingBA?Type -> A_Pong_Send();"
            },
            {
                "name": "A_Pong_Send",
                "description": "Process A sends a Pong message containing information about itself and then recursively executes the A_Meet_Send process.",
                "pat_code": "A_Pong_Send() = ComPongAB!nameA ->ComPongAB!pong -> A_Meet_Send();"
            },
            {
                "name": "B_Meet_Receive",
                "description": "In the B_Meet_Receive process, node B receives the Meet message sent by node A and then executes the B_Judge_Meet process.",
                "pat_code": "B_Meet_Receive() = ComMeetAB?AInfo -> ComMeetAB?Type -> B_Judge_Meet(AInfo,Type);"
            },
            {
                "name": "B_Judge_Meet",
                "description": "The B_Judge_Meet process adds node A to its own dictionary after judgment, executes the AddA process and then executes the B_Pong_Send process.",
                "pat_code": "B_Judge_Meet(AInfo,Type) = if(AInfo!=a&&Type==meet){AddA();B_Pong_Send()}else{B_Pong_Send()};"
            },
            {
                "name": "AddA",
                "description": "The process adds node A to its own dictionary.",
                "pat_code": "AddA() = {a=randomA;aFlag[0]=HANDSHAKE;} -> Skip;"
            },
            {
                "name": "B_Pong_Send",
                "description": "Process B sends a Pong message containing information about itself.\n  Then it executes the B_Ping_Send process.",
                "pat_code": "B_Pong_Send() = ComPongBA!nameB ->ComPongBA!pong -> B_Ping_Send();"
            },
            {
                "name": "B_Ping_Send",
                "description": "Node B sends a handshake Ping message to node A and then executes the B_Pong_Receive process.",
                "pat_code": "B_Ping_Send() = ComPingBA!nameB ->ComPingBA!ping -> B_Pong_Receive();"
            },
            {
                "name": "B_Pong_Receive",
                "description": "The process waits for a Pong message to be returned from node A and then executes the B_Judge_Pong process.",
                "pat_code": "B_Pong_Receive() = ComPongAB?AInfo -> ComPongAB?Type -> B_Judge_Pong(AInfo);"
            },
            {
                "name": "B_Judge_Pong",
                "description": "The process determines whether it needs to update the A-node information in its own dictionary based on the message from the A-node.",
                "pat_code": "B_Judge_Pong(AInfo) = if(AInfo!=a){UpdateA(AInfo);B_Meet_Receive()}else{B_Meet_Receive()};"
            },
            {
                "name": "UpdateA",
                "description": "The process updates the A-node information in its own dictionary based on messages from the A-node.",
                "pat_code": "UpdateA(AInfo) = {a=AInfo;aFlag[0]=nullFlag;} -> Skip;"
            },
            {
                "name": "A_Meet_Fail",
                "description": "The A_Meet_Fail and Meet_Fail processes implement a Meet message sending failure process. \n  First node A sends a Meet message and simulates a send failure by a non-responding node.",
                "pat_code": "A_Meet_Fail() = {b=randomB;bFlag[0]=HANDSHAKE;bFlag[1]=MEET;} ->{bFlag[1]=nullFlag;} -> ComMeetFail!nameA->ComMeetFail!meet -> A_Meet_Fail();"
            },
            {
                "name": "Meet_Fail",
                "description": "The Meet_Fail process receives send failure messages.",
                "pat_code": "Meet_Fail() = ComMeetFail?AInfo -> ComMeetFail?Type -> Meet_Fail();"
            },
            {
                "name": "SystemMeet",
                "description": "The system consists of four processes AMeet_Send, B_Meet_Receive, A_Meet_Fail, and Meet_Fail.\n  AMeet_Send and B_Meet_Receive indicate that the message was sent normally, and A_Meet_Fail and Meet_Fail indicate that the send failed.",
                "pat_code": "SystemMeet() = (A_Meet_Send()||B_Meet_Receive())<>(A_Meet_Fail()||Meet_Fail());"
            }
        ],
        "global_definition": "enum{nullName, nameA, nameB, randomA, randomB}; \nenum{nullFlag, HANDSHAKE, MEET}; \nenum{meet, ping, pong};\n\n#define null 0; \n#define SUM 4; \n#define NUM 2; \n\nvar b=nullName; \nvar a=nullName; \nvar aFlag[2]; \nvar bFlag[2]; \nchannel ComMeetAB 0; \nchannel ComPongBA 0; \nchannel ComPingBA 0; \nchannel ComPongAB 0; \nchannel ComMeetFail 0;",
        "path": "handwrite/Redis_Meet.csp"
    },
    {
        "name": "Redis Ping-Pong",
        "tags": [
            "Protocol",
            "Distrubued System"
        ],
        "use_non_container_lib": false,
        "description": "Redis (Remote Dictionary Server), or Remote Dictionary Service, is an open source key-value database.\n  Redis operations are completely memory-based, with good availability, and support for publish-subscribe, notification, key expiration, and other features.\n  There are the following main types of messages in a Redis cluster: Meet messages, Ping messages, Pong messages, Fail messages, Publish messages, and Update messages.",
        "pat_code": "enum{nullName, nameA, nameB, randomA, randomB}; \nenum{nullFlag, HANDSHAKE, MEET}; \nenum{meet, ping, pong};\n\n#define null 0; \n#define SUM 4; \n#define NUM 2; \nenum{invalid, valid}; \nenum{notNeed, need, end};\n\nvar AKnow = [1, 0, 0, 0]; \nvar BKnow = [0, 1, 0, 0]; \nvar CKnow = [0, 0, 1, 0]; \nvar DKnow = [0, 0, 0, 1]; \nvar a2b = need; \nvar b2c = need; \nvar c2d = need; \nvar d2a = need;\nvar ifEnd=0;\n\nchannel ComAB 0; \nchannel ComBA 0;  \nchannel ComAD 0; \nchannel ComDA 0; \nchannel ComBC 0; \nchannel ComCB 0; \nchannel ComCD 0; \nchannel ComDC 0; \n\n/*@Process: Ping_Send_AB\n  The Ping_Send_AB process indicates that node A sends a Ping message request to node B. \n  Node A first sends a Ping message containing the demand token a2b and the cognizance AKnow to node B through the channel ComAB and executes the Pong_Receive_AB process to wait for the Pong message returned by the B node.\n*/\nPing_Send_AB() = ComAB!a2b -> ComAB!AKnow -> Pong_Receive_AB(); \n/*@Process: Pong_Receive_AB\n  Node A accepts a Pong message containing the type tag ABResult and the B carry message BInfo from node B to node A through the channel ComBA and performs a message communication type determination.\n*/\nPong_Receive_AB() = ComBA?ABResult -> ComBA?BInfo -> AB_Pong_Judge(ABResult, BInfo); \n/*@Process: AB_Pong_Judge\n  The AB_Pong_Judge process determines whether the communication is a valid communication based on the type of communication. \n  If it is a valid communication, it compares the cognition of the B node with the cognition of the A node and updates those information that the B node knows but the A node does not know. \n  If node A really has update, then change the communication requirement of node A with node D to need.\n  At the same time, node A finishes the Ping-Pong message communication with node D. \n  The two nodes' messages are consistent, and change the communication requirement of node A with node D to notNeed. \n  Finally, node A performs the cluster consistency judgment.\n*/\nAB_Pong_Judge(ABResult,BInfo) = {if(ABResult==need){ \n     \t\t\t\t\t\t\t\tvar i=0; var flag=0; \n     \t\t\t\t\t\t\t\twhile(i<=SUM-1){ \n      \t\t\t\t\t\t\t\t\tif(BInfo[i]==1&&AKnow[i]==0){ \n       \t\t\t\t\t\t\t\t\t\tAKnow[i]=1; flag = 1;} \n      \t\t\t\t\t\t\t\t\ti++;} \n     \t\t\t\t\t\t\t\tif(flag==1){ \n      \t\t\t\t\t\t\t\t\td2a=need;} \n     \t\t\t\t\t\t\t\ta2b=notNeed;} \n   \t\t\t\t\t\t\t\t } -> End_Judge_AB(); \n/*@Process: End_Judge_AB\n  If the entire node is consistent, i.e., all nodes have the same knowledge of the cluster, send an end message to node B through the channel ComAB and end the Ping_Send_AB() process, otherwise resend the Ping message to node B.\n*/\nEnd_Judge_AB() = if(ifEnd==true){ComAB!end -> ComAB!null -> Skip}else{Ping_Send_AB()};\n/*@Process: Ping_Receive_DA\n  In the Ping_Receive_DA process, node A waits to get the Ping request sent by node D through the channel ComDA and performs message processing on the Ping request.\n*/\nPing_Receive_DA() = ComDA?DAResult -> ComDA?DInfo -> DA_Ping_Judge(DAResult,DInfo); \n/*@Process: DA_Ping_Judge\n  When node A receives a Ping message, it determines what kind of demand it is. \n  If it is a NEED flag, then it updates the information of node A based on the information of node D. \n  If it is a NOTNeed flag, then it returns a message that this communication is invalid.\n  And if it is an END flag, then the execution of the Ping_Receive_DA process is complete and it exits.\n*/\nDA_Ping_Judge(DAResult,DInfo) = if(DAResult==need){D_A(DInfo);Pong_Send_DA1()}else{\n\t\t\t\t\t\t\t\t\tif(DAResult==notNeed){Pong_Send_DA2()}else{Skip}};\n/*@Process: D_A\n  If it is NEED flag, then compare the perception of node D with that of node A and update those information that node D knows but node A does not. \n  If node A really has the update, then change the communication requirement between node A and node B to need, and at the same time node A finishes the Ping-Pong message communication with node D.\n*/\nD_A(DInfo) = {var i=0;var flag=0; \n  \t\t\t\twhile(i<=SUM-1){ \n   \t\t\t\t\tif(DInfo[i]==1&&AKnow[i]==0){ \n    \t\t\t\t\tAKnow[i]=1;flag=1; \n   \t\t\t\t\t} \n   \t\t\t\t\ti++; \n  \t\t\t\t} \n  \t\t\t\tif(flag==1){ \n   \t\t\t\t\ta2b=need;}\n   \t\t\t   }->Skip;\n/*@Process: Pong_Send_DA1\n  After updating the data, node A sends a Pong message to node D through the channel ComAD to indicate that the communication is valid and carries information about node A itself, and then continues to wait for a Ping message from node D. \n*/\nPong_Send_DA1() = ComAD!valid -> ComAD!AKnow -> Ping_Receive_DA();\n/*@Process: Pong_Send_DA2\n  In case of the notNeed flag, node A returns a Pong message with an invalid communication flag, and then continues to wait for a Ping message from node D.\n*/\nPong_Send_DA2() = ComAD!invalid -> ComAD!null ->Ping_Receive_DA();\n/*@Process: SystemPP\n  The system consists of 3 nodes A, B and D, where node A has a process that sends ping messages to B and a process that receives ping messages from D.\n*/\nSystemPP() = Ping_Send_AB()||Ping_Receive_DA();",
        "property_desc": [
            "The system is deadlock-free.",
            "The system will not terminate."
        ],
        "properties": [
            "#assert SystemPP() deadlockfree;",
            "#assert SystemPP() nonterminating;"
        ],
        "processes": [
            {
                "name": "Ping_Send_AB",
                "description": "The Ping_Send_AB process indicates that node A sends a Ping message request to node B. \n  Node A first sends a Ping message containing the demand token a2b and the cognizance AKnow to node B through the channel ComAB and executes the Pong_Receive_AB process to wait for the Pong message returned by the B node.",
                "pat_code": "Ping_Send_AB() = ComAB!a2b -> ComAB!AKnow -> Pong_Receive_AB();"
            },
            {
                "name": "Pong_Receive_AB",
                "description": "Node A accepts a Pong message containing the type tag ABResult and the B carry message BInfo from node B to node A through the channel ComBA and performs a message communication type determination.",
                "pat_code": "Pong_Receive_AB() = ComBA?ABResult -> ComBA?BInfo -> AB_Pong_Judge(ABResult, BInfo);"
            },
            {
                "name": "AB_Pong_Judge",
                "description": "The AB_Pong_Judge process determines whether the communication is a valid communication based on the type of communication. \n  If it is a valid communication, it compares the cognition of the B node with the cognition of the A node and updates those information that the B node knows but the A node does not know. \n  If node A really has update, then change the communication requirement of node A with node D to need.\n  At the same time, node A finishes the Ping-Pong message communication with node D. \n  The two nodes' messages are consistent, and change the communication requirement of node A with node D to notNeed. \n  Finally, node A performs the cluster consistency judgment.",
                "pat_code": "AB_Pong_Judge(ABResult,BInfo) = {if(ABResult==need){ \n     \t\t\t\t\t\t\t\tvar i=0; var flag=0; \n     \t\t\t\t\t\t\t\twhile(i<=SUM-1){ \n      \t\t\t\t\t\t\t\t\tif(BInfo[i]==1&&AKnow[i]==0){ \n       \t\t\t\t\t\t\t\t\t\tAKnow[i]=1; flag = 1;} \n      \t\t\t\t\t\t\t\t\ti++;} \n     \t\t\t\t\t\t\t\tif(flag==1){ \n      \t\t\t\t\t\t\t\t\td2a=need;} \n     \t\t\t\t\t\t\t\ta2b=notNeed;} \n   \t\t\t\t\t\t\t\t } -> End_Judge_AB();"
            },
            {
                "name": "End_Judge_AB",
                "description": "If the entire node is consistent, i.e., all nodes have the same knowledge of the cluster, send an end message to node B through the channel ComAB and end the Ping_Send_AB() process, otherwise resend the Ping message to node B.",
                "pat_code": "End_Judge_AB() = if(ifEnd==true){ComAB!end -> ComAB!null -> Skip}else{Ping_Send_AB()};"
            },
            {
                "name": "Ping_Receive_DA",
                "description": "In the Ping_Receive_DA process, node A waits to get the Ping request sent by node D through the channel ComDA and performs message processing on the Ping request.",
                "pat_code": "Ping_Receive_DA() = ComDA?DAResult -> ComDA?DInfo -> DA_Ping_Judge(DAResult,DInfo);"
            },
            {
                "name": "DA_Ping_Judge",
                "description": "When node A receives a Ping message, it determines what kind of demand it is. \n  If it is a NEED flag, then it updates the information of node A based on the information of node D. \n  If it is a NOTNeed flag, then it returns a message that this communication is invalid.\n  And if it is an END flag, then the execution of the Ping_Receive_DA process is complete and it exits.",
                "pat_code": "DA_Ping_Judge(DAResult,DInfo) = if(DAResult==need){D_A(DInfo);Pong_Send_DA1()}else{\n\t\t\t\t\t\t\t\t\tif(DAResult==notNeed){Pong_Send_DA2()}else{Skip}};"
            },
            {
                "name": "D_A",
                "description": "If it is NEED flag, then compare the perception of node D with that of node A and update those information that node D knows but node A does not. \n  If node A really has the update, then change the communication requirement between node A and node B to need, and at the same time node A finishes the Ping-Pong message communication with node D.",
                "pat_code": "D_A(DInfo) = {var i=0;var flag=0; \n  \t\t\t\twhile(i<=SUM-1){ \n   \t\t\t\t\tif(DInfo[i]==1&&AKnow[i]==0){ \n    \t\t\t\t\tAKnow[i]=1;flag=1; \n   \t\t\t\t\t} \n   \t\t\t\t\ti++; \n  \t\t\t\t} \n  \t\t\t\tif(flag==1){ \n   \t\t\t\t\ta2b=need;}\n   \t\t\t   }->Skip;"
            },
            {
                "name": "Pong_Send_DA1",
                "description": "After updating the data, node A sends a Pong message to node D through the channel ComAD to indicate that the communication is valid and carries information about node A itself, and then continues to wait for a Ping message from node D.",
                "pat_code": "Pong_Send_DA1() = ComAD!valid -> ComAD!AKnow -> Ping_Receive_DA();"
            },
            {
                "name": "Pong_Send_DA2",
                "description": "In case of the notNeed flag, node A returns a Pong message with an invalid communication flag, and then continues to wait for a Ping message from node D.",
                "pat_code": "Pong_Send_DA2() = ComAD!invalid -> ComAD!null ->Ping_Receive_DA();"
            },
            {
                "name": "SystemPP",
                "description": "The system consists of 3 nodes A, B and D, where node A has a process that sends ping messages to B and a process that receives ping messages from D.",
                "pat_code": "SystemPP() = Ping_Send_AB()||Ping_Receive_DA();"
            }
        ],
        "global_definition": "enum{nullName, nameA, nameB, randomA, randomB}; \nenum{nullFlag, HANDSHAKE, MEET}; \nenum{meet, ping, pong};\n\n#define null 0; \n#define SUM 4; \n#define NUM 2; \nenum{invalid, valid}; \nenum{notNeed, need, end};\n\nvar AKnow = [1, 0, 0, 0]; \nvar BKnow = [0, 1, 0, 0]; \nvar CKnow = [0, 0, 1, 0]; \nvar DKnow = [0, 0, 0, 1]; \nvar a2b = need; \nvar b2c = need; \nvar c2d = need; \nvar d2a = need;\nvar ifEnd=0;\n\nchannel ComAB 0; \nchannel ComBA 0;  \nchannel ComAD 0; \nchannel ComDA 0; \nchannel ComBC 0; \nchannel ComCB 0; \nchannel ComCD 0; \nchannel ComDC 0;",
        "path": "handwrite/Redis_Ping-Pong.csp"
    },
    {
        "name": "RocketMQ",
        "tags": [
            "Protocol"
        ],
        "use_non_container_lib": false,
        "description": "RocketMQ is a queue-based messaging middleware developed by Alibaba team. \n  RocketMQ messaging system uses a publish-subscribe model , including NameServer, Producer, Consumer, Broker Cluster. \n  The NameServer maintains topic routing information and the active state of the message server. \n  The Producer and Consumer groups periodically obtain topic routing information from the name server. \n  The Producer obtains the active status of the message server from the name server before sending data, and then sends data to a specific message server based on the periodically obtained topic routing information and the load balancing algorithm. \n  Messages are stored in topics on the message server. \n  Consumers subscribe to topics to consume messages.",
        "pat_code": "#import \"Pat.Lib.Queue\";\n\n#define T 1;\n#define P 1;\n#define C 2;\n#define MB 2;\n#define SB 2;\n#define MQ 2;\n#define BM 2;\n#define BS 2;\n#define Seq 2;\n\nenum {Request,Topic,Data,HeartBeat,Ack};\n\nchannel ComNP 0;\nchannel ComNC[C] 0;\nchannel ComNMB[MB] 0;\nchannel ComPMB[P*T*MB] 0;\nchannel ComMBSB[P*T*MB*SB] 0;\nchannel ComMBC[MB*C] 0;\nchannel ComSBC[MB*SB*C] 0;\nchannel Time 0;\nchannel ComMC[T*BM*C] 0;\nchannel ComSC[T*BM*BS*C] 0;\n\nvar producerACK[P] = [0];\nvar broker_live[MB];\nvar localP[MB];\nvar localC[C*MB];\nvar topic_queue[MB][MQ]=[0,0,0,0];\nvar dataSycn[MB][SB]=[0,0,0,0];\nvar MB_ack[MB]=[0,0];\nvar DataM[BM][C] = [0,0,0,0];\nvar DataS[BM][BS][C] = [0,0,0,0,0,0,0,0];\nvar DataSeq[BM][C][Seq] = [0,0,0,0,0,0,0,0];\nvar Seqdata[BM][C] = [0,0,0,0];\nvar P_ack[BM] = [0,0];\nvar state_M[T][BM][BS] = [0,0,0,0];\nvar BM_ack[BM] = [0,0];\nvar BS_ack[P][BM] = [0,0];\n\nvar totalQueue = MB * MQ;\nvar i = totalQueue- 1;\nvar cur_mbid = 0;\nvar cur_mqid = 0;\nvar j=0;\n\n#define nT 10;\n#define bT 15;\nvar clock_time = 0;\nvar MBtime[MB]=[0,0];\nvar ntime = 0;\nvar ptime = 0;\nvar ctime[C] = [0,0];\n\nvar<Queue> mq0;\nvar<Queue> mq1;\nvar<Queue> mq2;\nvar<Queue> mq3;\n\n/*@Process: intoMessageQueue\n  The process intoMessageQueue is used to select an appropriate message queue for sending messages\n*/\nintoMessageQueue(id) = case{\n \t\t\t\t\t\t\tid==0: MQ0()\n \t\t\t\t\t\t\tid==1: MQ1()\n \t\t\t\t\t\t\tid==2: MQ2()\n \t\t\t\t\t\t\tdefault : MQ3()\n \t\t\t\t\t\t\t};\n MQ0() = if(mq0.Count()==0) {enter{mq0.Enqueue(1);}->Skip}\n \t\telse{\n \t\t\tif (1 == mq0.First() && mq0.Count()==1){enter{mq0.Enqueue(2);}->Skip}\n \t\t\t};\n MQ1() = if(mq1.Count()==0){enter{mq1.Enqueue(1);}->Skip}\n \t\telse{\n \t\t\tif (1 == mq1.First() && mq1.Count()==1){enter{mq1.Enqueue(2);}->Skip}\n \t\t\t};\n MQ2() = if(mq2.Count()==0){enter{mq2.Enqueue(1);}->Skip}\n \t\t\telse{\n \t\t\t\tif (1 == mq2.First() && mq2.Count()==1){enter{mq2.Enqueue(2);}->Skip}\n \t\t\t};\n MQ3() = if(mq3.Count()==0){enter{mq3.Enqueue(1);}->Skip}\n\t\t\telse{\n\t\t\t\tif (1 == mq3.First() && mq3.Count()==1){enter{mq3.Enqueue(2);}->Skip}\n \t\t\t};\n \nNS1() = |||mbid:{0..MB-1}@NSHeart(mbid);\nNS2() = |||cid :{0.. C-1}@NSCon(cid);\nNS3() = |||mbid:{0..MB-1}@Check(mbid);\n/*@Process: NameServer\n  The NameServer process deals with communication between the nameserver and other entites, including process NSHeart(), NSPro(), NSCon() and Check().\n*/\nNameServer() = NS1() ||| NSPro() ||| NS2() ||| NS3();\n/*@Process: NSHeart\n  The NSHeart process receives heartbeat packets from the server and logs the status of the server in the local router information.\n*/\nNSHeart(mbid) = ComNMB[mbid]?heartBeat{broker_live[mbid]=1;}-> NSHeart(mbid) [] initial-> NSHeart(mbid);\n/*@Process: NSPro\n  The NameServer receives request from producers and sends routing information to them.\n*/\nNSPro() = ComNP?request-> Skip;//ComNP!broker_live-> NSPro();\n/*@Process: NSCon\n  The NameServer receives request from consumers and sends routing information to them.\n*/\nNSCon(cid) = ComNC[cid]?request-> ComNC[cid]!broker_live-> NSCon(cid);\n/*@Process: Check\n  For the Check process, the nameserver provides a heartbeat mechanism to check if a server is still active. \n  The name server periodically checks every nT when it last received a heartbeat packet. \n  Once the heartbeat mechanism detects that this time interval has been exceeded, the server is considered offline and the server is removed from the local routing information brokerAlive.\n*/\nCheck(mbid) = Time!Request -> Time?start -> if (start - ntime >= 10){\n \t\t\t\tif (start-MBtime[mbid]>=12)\n \t\t\t\t{break{broker_live[mbid]=0;} -> updatecheck{ntime=start;}-> Check(mbid)}\n \t\t\t\telse{updatecheck{ntime=start;} -> Check(mbid)}\n \t\t\t\t};\n\n/*@Process: Producer\n  The Producer process deals with communication between the producer and master broker, including process ProConnect() and ProSend().\n  Producers are primarily responsible for producing messages and sending them to the master broker.\n*/\nProducer() = ProConnect() ||| ProSend();\n/*@Process: ProConnect\n  The process ProConnect indicates that the producer periodically pulls information from the nameserver. \n  The producer can then use the nameserver to know the routing information of the entire server cluster for message delivery and consumption.\n*/\nProConnect() = Time!Request-> Time?start->\n\t\t\t\tif (start- ptime >=3){ComNP!Request-> ComNP?broker_live_info{localP[0]=\n \t\t\t\t\tbroker_live_info[0];localP[1]=broker_live_info[1];ptime=start;}->ProConnect()}\n \t\t\t\telse{ProConnect()};\n/*@Process: ProSend\n  The process ProSend is responsible for publishing the message and sending the generated message to the master broker.\n  It first select a suitable master broker based on a certain strategy.\n  Then it uses process intoMessageQueue() to select an appropriate message queue for sending messages.\n*/\n ProSend() = send.Topic{\n \t\t\t\tj = (j+1)%4; i = j;\n \t\t\t\tif (i==0){\n \t\t\t\t\tif (localP[0]==0){\n \t\t\t\t\t\tcur_mbid=1; cur_mqid=0; i=2;\n \t\t\t\t\t}\n \t\t\t\t\telse{\n \t\t\t\t\t\tcur_mbid=0;cur_mqid=0;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse{\n \t\t\t\t\tif (i==1){\n \t\t\t\t\t\tif (localP[0]==0){\n \t\t\t\t\t\t\tcur_mbid=1;cur_mqid=0;i=2;\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse{\n \t\t\t\t\t\t\tcur_mbid=0;cur_mqid=1;\n\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\telse{\n \t\t\t\t\t\tif (i==2){\n \t\t\t\t\t\t\tif (localP[1]==0){\n \t\t\t\t\t\t\t\tcur_mbid=0;cur_mqid=0;i=0;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse{\n \t\t\t\t\t\t\t\tcur_mbid=1;cur_mqid=0;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse{\n \t\t\t\t\t\t\tif (localP[1]==0){\n \t\t\t\t\t\t\t\tcur_mbid=0;cur_mqid=0;i=0;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse{\n \t\t\t\t\t\t\t\tcur_mbid=1;cur_mqid=1;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n }}-> ComPMB[cur_mbid]!Topic.cur_mqid.Data-> ComPMB[cur_mbid]?p_ack-> intoMessageQueue(i);ProSend();\n \n/*@Process: MasterBroker\n  The MasterBroker process deals with communication between the masterbroker and other entities, including process BrokerHeart() and MasterBrokerPub().\n*/\nMasterBroker(mbid) = BrokerHeart(mbid) ||| (|||sbid :{0.. SB-1}@MasterBrokerPub(mbid,sbid));\n/*@Process: BrokerHeart\n  In the BrokerHeart process, it first asks the global clock process Clock for the current time. \n  If the time interval is less than the heartbeat interval bT, it sends a request to the global clock process Clock again; \n  otherwise, it sends a heartbeat packet to the NameServer, and this process loops continuously.\n*/\nBrokerHeart(mbid) = Time!Request-> Time?t->if (t-MBtime[mbid]>=3)\n \t\t\t\t\t{ComNMB[mbid]!HeartBeat{MBtime[mbid]=t;}-> BrokerHeart(mbid)}\n \t\t\t\t\telse {BrokerHeart(mbid)};\n/*@Process: MasterBrokerPub\n  The process MasterBrokerPub portrays the process by which a producer sends a message to a master broker, which synchronizes the data to its corresponding slave server.\n  After the master broker receives the message, it writes the message content to a local file, and then its corresponding slave brokers synchronize the master broker's data and store it locally. \n  After the slave broker successfully synchronizes the message, it returns a response message to the master broker, and the master broker also returns an answer message to the producer whether the message was published successfully.\n*/\nMasterBrokerPub(mbid,sbid) = ComPMB[mbid]?topic.mqid.data-> ComPMB[mbid]!Ack-> ComMBSB[mbid*SB+sbid]?req-> ComMBSB[mbid*SB+sbid]!Data-> ComMBSB[mbid*SB+sbid]?ack-> MasterBrokerPub(mbid,sbid);\n/*@Process: MasterBrokerSub\n  The sub-process MasterBrokerSub portrays the process by which the master broker provides data consumption to the consumer when the consumer subscribes to the message.\n*/\nMasterBrokerSub(mbid,cid)= ComMBC[mbid*C +cid]?request -> ComMBC[mbid*C+cid]!Data->MasterBrokerSub(mbid,cid);\n\n/*@Process: SlaveBroker\n  The SlaveBroker process deals with communication between the slavebroker and other entities, including process SlaveBrokerSync() and SlaveBrokerSub().\n  It synchronizes data from the master broker through the ComMBSB channel and provide service to consumers through the ComSBC channel when the master broker fails.\n*/\nSlaveBroker(mbid,sbid) = SlaveBrokerSync(mbid,sbid) ||| (||| cid :{0.. C-1} @SlaveBrokerSub(mbid,sbid,cid));\n/*@Process: SlaveBrokerSync\n  After a producer publishes a message and writes it to the master broker, \n  the slave broker corresponding to that master broker sends a data synchronization request to start synchronizing the master broker's data and storing it locally.\n  After the slave broker successfully synchronizes the information, it returns a response message to the master broker.\n*/\nSlaveBrokerSync(mbid,sbid) = ComMBSB[mbid*SB+sbid]!Request-> ComMBSB[mbid*SB+sbid]?data{dataSycn[mbid][sbid]=1;}-> ComMBSB[mbid*SB+sbid]!Ack->SlaveBrokerSync(mbid,sbid);\n/*@Process: SlaveBrokerSub\n  The sub-process SlaveBrokerSub portrays the process by which the slave server provides data consumption to the consumer when the consumer subscribes to the message when the master broker fails.\n*/\nSlaveBrokerSub(mbid,sbid,cid) = ComSBC[mbid*SB*C+sbid*C+cid]?request-> ComSBC[mbid*SB*C+sbid*C+cid]!Data-> SlaveBrokerSub(mbid,sbid,cid);\n \n /*@Process: Consumer\n  In RocketMQ's transport mechanism, the consumer module consists of multiple consumer groups, each of which consists of a set of consumers with the same consumer behavior and logic. \n  Once the routing information is obtained from the NameServer, consumers within the same consumer group will consume the messages in the specified topic partition according to the load balancing algorithm.\n*/\nConsumer(tid,bmid,bsid,cid)= (ComMC[tid*T+bmid*BM+cid]!Data.Request-> ComMC[tid*T+bmid*BM+cid]?data.response{DataM[bmid][cid]=1}->Consumer(tid,bmid,bsid,cid))\n\t\t\t\t\t\t\t[](ComSC[tid*T+bmid*BM+bsid*BS+cid]!Data.Request->ComSC[tid*T+bmid*BM+bsid*BS+cid]?data.response {DataS[bmid][bsid][cid]=1}-> Consumer(tid,bmid,bsid,cid));\n\n var<Queue> c0mq0;\n var<Queue> c0mq1;\n var<Queue> c1mq0;\n var<Queue> c1mq1;\n \n/*@Process: Clock\n  This clock is used to provide information about the time in the system. \n  When other processes query the Clock for the time via the channel Time, the Clock will return the current time t, which is a positive integer.\n*/\n Clock(t) = Time?req-> Time!t{clock_time=t;}-> Clock(t) [] tick-> if(t>=bT){initial-> Clock(0)} else{Clock(t+1)};\n \n /*@Process: System\n  This overall models contains the communication between NameServer, Producer, BrokerMaster, BrokerSlave and Clock.\n*/\n System() = NameServer() || Producer() || (||| mbid:{0..MB-1}@MasterBroker(mbid)) || (|||mbid:{0,1};sbid:{0,1}@SlaveBroker(mbid,sbid)) || Clock(0) ;",
        "property_desc": [
            "The system is deadlock-free."
        ],
        "properties": [],
        "processes": [
            {
                "name": "intoMessageQueue",
                "description": "The process intoMessageQueue is used to select an appropriate message queue for sending messages",
                "pat_code": "intoMessageQueue(id) = case{\n \t\t\t\t\t\t\tid==0: MQ0()\n \t\t\t\t\t\t\tid==1: MQ1()\n \t\t\t\t\t\t\tid==2: MQ2()\n \t\t\t\t\t\t\tdefault : MQ3()\n \t\t\t\t\t\t\t};\n MQ0() = if(mq0.Count()==0) {enter{mq0.Enqueue(1);}->Skip}\n \t\telse{\n \t\t\tif (1 == mq0.First() && mq0.Count()==1){enter{mq0.Enqueue(2);}->Skip}\n \t\t\t};\n MQ1() = if(mq1.Count()==0){enter{mq1.Enqueue(1);}->Skip}\n \t\telse{\n \t\t\tif (1 == mq1.First() && mq1.Count()==1){enter{mq1.Enqueue(2);}->Skip}\n \t\t\t};\n MQ2() = if(mq2.Count()==0){enter{mq2.Enqueue(1);}->Skip}\n \t\t\telse{\n \t\t\t\tif (1 == mq2.First() && mq2.Count()==1){enter{mq2.Enqueue(2);}->Skip}\n \t\t\t};\n MQ3() = if(mq3.Count()==0){enter{mq3.Enqueue(1);}->Skip}\n\t\t\telse{\n\t\t\t\tif (1 == mq3.First() && mq3.Count()==1){enter{mq3.Enqueue(2);}->Skip}\n \t\t\t};\n \nNS1() = |||mbid:{0..MB-1}@NSHeart(mbid);\nNS2() = |||cid :{0.. C-1}@NSCon(cid);\nNS3() = |||mbid:{0..MB-1}@Check(mbid);"
            },
            {
                "name": "NameServer",
                "description": "The NameServer process deals with communication between the nameserver and other entites, including process NSHeart(), NSPro(), NSCon() and Check().",
                "pat_code": "NameServer() = NS1() ||| NSPro() ||| NS2() ||| NS3();"
            },
            {
                "name": "NSHeart",
                "description": "The NSHeart process receives heartbeat packets from the server and logs the status of the server in the local router information.",
                "pat_code": "NSHeart(mbid) = ComNMB[mbid]?heartBeat{broker_live[mbid]=1;}-> NSHeart(mbid) [] initial-> NSHeart(mbid);"
            },
            {
                "name": "NSPro",
                "description": "The NameServer receives request from producers and sends routing information to them.",
                "pat_code": "NSPro() = ComNP?request-> Skip;//ComNP!broker_live-> NSPro();"
            },
            {
                "name": "NSCon",
                "description": "The NameServer receives request from consumers and sends routing information to them.",
                "pat_code": "NSCon(cid) = ComNC[cid]?request-> ComNC[cid]!broker_live-> NSCon(cid);"
            },
            {
                "name": "Check",
                "description": "For the Check process, the nameserver provides a heartbeat mechanism to check if a server is still active. \n  The name server periodically checks every nT when it last received a heartbeat packet. \n  Once the heartbeat mechanism detects that this time interval has been exceeded, the server is considered offline and the server is removed from the local routing information brokerAlive.",
                "pat_code": "Check(mbid) = Time!Request -> Time?start -> if (start - ntime >= 10){\n \t\t\t\tif (start-MBtime[mbid]>=12)\n \t\t\t\t{break{broker_live[mbid]=0;} -> updatecheck{ntime=start;}-> Check(mbid)}\n \t\t\t\telse{updatecheck{ntime=start;} -> Check(mbid)}\n \t\t\t\t};"
            },
            {
                "name": "Producer",
                "description": "The Producer process deals with communication between the producer and master broker, including process ProConnect() and ProSend().\n  Producers are primarily responsible for producing messages and sending them to the master broker.",
                "pat_code": "Producer() = ProConnect() ||| ProSend();"
            },
            {
                "name": "ProConnect",
                "description": "The process ProConnect indicates that the producer periodically pulls information from the nameserver. \n  The producer can then use the nameserver to know the routing information of the entire server cluster for message delivery and consumption.",
                "pat_code": "ProConnect() = Time!Request-> Time?start->\n\t\t\t\tif (start- ptime >=3){ComNP!Request-> ComNP?broker_live_info{localP[0]=\n \t\t\t\t\tbroker_live_info[0];localP[1]=broker_live_info[1];ptime=start;}->ProConnect()}\n \t\t\t\telse{ProConnect()};"
            },
            {
                "name": "ProSend",
                "description": "The process ProSend is responsible for publishing the message and sending the generated message to the master broker.\n  It first select a suitable master broker based on a certain strategy.\n  Then it uses process intoMessageQueue() to select an appropriate message queue for sending messages.",
                "pat_code": "ProSend() = send.Topic{\n \t\t\t\tj = (j+1)%4; i = j;\n \t\t\t\tif (i==0){\n \t\t\t\t\tif (localP[0]==0){\n \t\t\t\t\t\tcur_mbid=1; cur_mqid=0; i=2;\n \t\t\t\t\t}\n \t\t\t\t\telse{\n \t\t\t\t\t\tcur_mbid=0;cur_mqid=0;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse{\n \t\t\t\t\tif (i==1){\n \t\t\t\t\t\tif (localP[0]==0){\n \t\t\t\t\t\t\tcur_mbid=1;cur_mqid=0;i=2;\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse{\n \t\t\t\t\t\t\tcur_mbid=0;cur_mqid=1;\n\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\telse{\n \t\t\t\t\t\tif (i==2){\n \t\t\t\t\t\t\tif (localP[1]==0){\n \t\t\t\t\t\t\t\tcur_mbid=0;cur_mqid=0;i=0;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse{\n \t\t\t\t\t\t\t\tcur_mbid=1;cur_mqid=0;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse{\n \t\t\t\t\t\t\tif (localP[1]==0){\n \t\t\t\t\t\t\t\tcur_mbid=0;cur_mqid=0;i=0;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse{\n \t\t\t\t\t\t\t\tcur_mbid=1;cur_mqid=1;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n }}-> ComPMB[cur_mbid]!Topic.cur_mqid.Data-> ComPMB[cur_mbid]?p_ack-> intoMessageQueue(i);ProSend();"
            },
            {
                "name": "MasterBroker",
                "description": "The MasterBroker process deals with communication between the masterbroker and other entities, including process BrokerHeart() and MasterBrokerPub().",
                "pat_code": "MasterBroker(mbid) = BrokerHeart(mbid) ||| (|||sbid :{0.. SB-1}@MasterBrokerPub(mbid,sbid));"
            },
            {
                "name": "BrokerHeart",
                "description": "In the BrokerHeart process, it first asks the global clock process Clock for the current time. \n  If the time interval is less than the heartbeat interval bT, it sends a request to the global clock process Clock again; \n  otherwise, it sends a heartbeat packet to the NameServer, and this process loops continuously.",
                "pat_code": "BrokerHeart(mbid) = Time!Request-> Time?t->if (t-MBtime[mbid]>=3)\n \t\t\t\t\t{ComNMB[mbid]!HeartBeat{MBtime[mbid]=t;}-> BrokerHeart(mbid)}\n \t\t\t\t\telse {BrokerHeart(mbid)};"
            },
            {
                "name": "MasterBrokerPub",
                "description": "The process MasterBrokerPub portrays the process by which a producer sends a message to a master broker, which synchronizes the data to its corresponding slave server.\n  After the master broker receives the message, it writes the message content to a local file, and then its corresponding slave brokers synchronize the master broker's data and store it locally. \n  After the slave broker successfully synchronizes the message, it returns a response message to the master broker, and the master broker also returns an answer message to the producer whether the message was published successfully.",
                "pat_code": "MasterBrokerPub(mbid,sbid) = ComPMB[mbid]?topic.mqid.data-> ComPMB[mbid]!Ack-> ComMBSB[mbid*SB+sbid]?req-> ComMBSB[mbid*SB+sbid]!Data-> ComMBSB[mbid*SB+sbid]?ack-> MasterBrokerPub(mbid,sbid);"
            },
            {
                "name": "MasterBrokerSub",
                "description": "The sub-process MasterBrokerSub portrays the process by which the master broker provides data consumption to the consumer when the consumer subscribes to the message.",
                "pat_code": "MasterBrokerSub(mbid,cid)= ComMBC[mbid*C +cid]?request -> ComMBC[mbid*C+cid]!Data->MasterBrokerSub(mbid,cid);"
            },
            {
                "name": "SlaveBroker",
                "description": "The SlaveBroker process deals with communication between the slavebroker and other entities, including process SlaveBrokerSync() and SlaveBrokerSub().\n  It synchronizes data from the master broker through the ComMBSB channel and provide service to consumers through the ComSBC channel when the master broker fails.",
                "pat_code": "SlaveBroker(mbid,sbid) = SlaveBrokerSync(mbid,sbid) ||| (||| cid :{0.. C-1} @SlaveBrokerSub(mbid,sbid,cid));"
            },
            {
                "name": "SlaveBrokerSync",
                "description": "After a producer publishes a message and writes it to the master broker, \n  the slave broker corresponding to that master broker sends a data synchronization request to start synchronizing the master broker's data and storing it locally.\n  After the slave broker successfully synchronizes the information, it returns a response message to the master broker.",
                "pat_code": "SlaveBrokerSync(mbid,sbid) = ComMBSB[mbid*SB+sbid]!Request-> ComMBSB[mbid*SB+sbid]?data{dataSycn[mbid][sbid]=1;}-> ComMBSB[mbid*SB+sbid]!Ack->SlaveBrokerSync(mbid,sbid);"
            },
            {
                "name": "SlaveBrokerSub",
                "description": "The sub-process SlaveBrokerSub portrays the process by which the slave server provides data consumption to the consumer when the consumer subscribes to the message when the master broker fails.",
                "pat_code": "SlaveBrokerSub(mbid,sbid,cid) = ComSBC[mbid*SB*C+sbid*C+cid]?request-> ComSBC[mbid*SB*C+sbid*C+cid]!Data-> SlaveBrokerSub(mbid,sbid,cid);"
            },
            {
                "name": "Consumer",
                "description": "In RocketMQ's transport mechanism, the consumer module consists of multiple consumer groups, each of which consists of a set of consumers with the same consumer behavior and logic. \n  Once the routing information is obtained from the NameServer, consumers within the same consumer group will consume the messages in the specified topic partition according to the load balancing algorithm.",
                "pat_code": "Consumer(tid,bmid,bsid,cid)= (ComMC[tid*T+bmid*BM+cid]!Data.Request-> ComMC[tid*T+bmid*BM+cid]?data.response{DataM[bmid][cid]=1}->Consumer(tid,bmid,bsid,cid))\n\t\t\t\t\t\t\t[](ComSC[tid*T+bmid*BM+bsid*BS+cid]!Data.Request->ComSC[tid*T+bmid*BM+bsid*BS+cid]?data.response {DataS[bmid][bsid][cid]=1}-> Consumer(tid,bmid,bsid,cid));\n\n var<Queue> c0mq0;\n var<Queue> c0mq1;\n var<Queue> c1mq0;\n var<Queue> c1mq1;"
            },
            {
                "name": "Clock",
                "description": "This clock is used to provide information about the time in the system. \n  When other processes query the Clock for the time via the channel Time, the Clock will return the current time t, which is a positive integer.",
                "pat_code": "Clock(t) = Time?req-> Time!t{clock_time=t;}-> Clock(t) [] tick-> if(t>=bT){initial-> Clock(0)} else{Clock(t+1)};"
            },
            {
                "name": "System",
                "description": "This overall models contains the communication between NameServer, Producer, BrokerMaster, BrokerSlave and Clock.",
                "pat_code": "System() = NameServer() || Producer() || (||| mbid:{0..MB-1}@MasterBroker(mbid)) || (|||mbid:{0,1};sbid:{0,1}@SlaveBroker(mbid,sbid)) || Clock(0) ;"
            }
        ],
        "global_definition": "#import \"Pat.Lib.Queue\";\n\n#define T 1;\n#define P 1;\n#define C 2;\n#define MB 2;\n#define SB 2;\n#define MQ 2;\n#define BM 2;\n#define BS 2;\n#define Seq 2;\n\nenum {Request,Topic,Data,HeartBeat,Ack};\n\nchannel ComNP 0;\nchannel ComNC[C] 0;\nchannel ComNMB[MB] 0;\nchannel ComPMB[P*T*MB] 0;\nchannel ComMBSB[P*T*MB*SB] 0;\nchannel ComMBC[MB*C] 0;\nchannel ComSBC[MB*SB*C] 0;\nchannel Time 0;\nchannel ComMC[T*BM*C] 0;\nchannel ComSC[T*BM*BS*C] 0;\n\nvar producerACK[P] = [0];\nvar broker_live[MB];\nvar localP[MB];\nvar localC[C*MB];\nvar topic_queue[MB][MQ]=[0,0,0,0];\nvar dataSycn[MB][SB]=[0,0,0,0];\nvar MB_ack[MB]=[0,0];\nvar DataM[BM][C] = [0,0,0,0];\nvar DataS[BM][BS][C] = [0,0,0,0,0,0,0,0];\nvar DataSeq[BM][C][Seq] = [0,0,0,0,0,0,0,0];\nvar Seqdata[BM][C] = [0,0,0,0];\nvar P_ack[BM] = [0,0];\nvar state_M[T][BM][BS] = [0,0,0,0];\nvar BM_ack[BM] = [0,0];\nvar BS_ack[P][BM] = [0,0];\n\nvar totalQueue = MB * MQ;\nvar i = totalQueue- 1;\nvar cur_mbid = 0;\nvar cur_mqid = 0;\nvar j=0;\n\n#define nT 10;\n#define bT 15;\nvar clock_time = 0;\nvar MBtime[MB]=[0,0];\nvar ntime = 0;\nvar ptime = 0;\nvar ctime[C] = [0,0];\n\nvar<Queue> mq0;\nvar<Queue> mq1;\nvar<Queue> mq2;\nvar<Queue> mq3;",
        "path": "handwrite/RocketMQ.csp"
    },
    {
        "name": "ROS Publisher Subscriber",
        "tags": [
            "Protocol"
        ],
        "use_non_container_lib": false,
        "description": "ROS's Topic publish-subscribe mechanism is a very powerful asynchronous process that allows publishers to publish messages to a specific topic, and subscribers to subscribe to that topic and receive those messages, thus enabling communication between nodes.",
        "pat_code": "#define P 1;\n#define S 2;\n\n/*@Process: Publisher\n  When the publisher node starts up, it registers to the ROS Master, declares the name and type of the topic to be published and proceeds to waiting to send the messag3.\n*/\nPublisher(i) = register_publisher -> WAIT_TO_SEND(i);\n/*@Process: WAIT_TO_SEND\n  - If the registration is confirmed from the Master, it can send message\n  - Otherwise, it waits for registration confirmation\n*/\nWAIT_TO_SEND(i) = connection_confirmed -> send_message -> Skip [] not_connection_confirmed -> WAIT_TO_SEND(i);\n\n/*@Process: Subscriber\n When the subscriber node starts up, it registers to the ROS Master, declares the name of the topic to be subscribed to, and wait for matching.\n*/\nSubscriber(i) = register_subscriber -> WAIT_TO_CONNECT(i);\n/*@Process: WAIT_TO_CONNECT\n  - If the topic is matched, it request for the connection and waits for receiving messages\n  - Otherwise, it continues to waiting for matching\n*/\nWAIT_TO_CONNECT(i) = matched -> request_connect -> WAIT_TO_RECEIVE(i) [] not_matched -> WAIT_TO_CONNECT(i);\n/*@Process: WAIT_TO_RECEIVE\n  - It waits for the connection establishment and can receive a message\n  - If not connected, it continues to waiting ofr connection\n*/\nWAIT_TO_RECEIVE(i) = connection_established -> receive_message -> Skip [] not_connection_established -> WAIT_TO_RECEIVE(i);\n\n/*@Process: Master\n  ROS Master information matching:\n  After receiving the registration information from the publisher and the subscriber, the ROS Master will do the matching, \n  and if the match succeeds, it will confirm the request and respond to the publisher. After that, the connection is established.\n*/\nMaster() = register_publisher -> match -> confirm_request -> establish_connect -> Skip;\n\n/*@Process: ROS\n  The overall system consists for P publisher, S subscribers and a master.\n*/\nROS() = (|||x:{0..P-1}@Publisher(x)) ||| (|||x:{0..S-1}@Subscriber(x)) || Master();",
        "property_desc": [
            "The system is deadlock-free",
            "The system is divergence-free"
        ],
        "properties": [
            "#assert ROS() deadlockfree;",
            "#assert ROS() divergencefree;"
        ],
        "processes": [
            {
                "name": "Publisher",
                "description": "When the publisher node starts up, it registers to the ROS Master, declares the name and type of the topic to be published and proceeds to waiting to send the messag3.",
                "pat_code": "Publisher(i) = register_publisher -> WAIT_TO_SEND(i);"
            },
            {
                "name": "WAIT_TO_SEND",
                "description": "- If the registration is confirmed from the Master, it can send message\n  - Otherwise, it waits for registration confirmation",
                "pat_code": "WAIT_TO_SEND(i) = connection_confirmed -> send_message -> Skip [] not_connection_confirmed -> WAIT_TO_SEND(i);"
            },
            {
                "name": "Subscriber",
                "description": "When the subscriber node starts up, it registers to the ROS Master, declares the name of the topic to be subscribed to, and wait for matching.",
                "pat_code": "Subscriber(i) = register_subscriber -> WAIT_TO_CONNECT(i);"
            },
            {
                "name": "WAIT_TO_CONNECT",
                "description": "- If the topic is matched, it request for the connection and waits for receiving messages\n  - Otherwise, it continues to waiting for matching",
                "pat_code": "WAIT_TO_CONNECT(i) = matched -> request_connect -> WAIT_TO_RECEIVE(i) [] not_matched -> WAIT_TO_CONNECT(i);"
            },
            {
                "name": "WAIT_TO_RECEIVE",
                "description": "- It waits for the connection establishment and can receive a message\n  - If not connected, it continues to waiting ofr connection",
                "pat_code": "WAIT_TO_RECEIVE(i) = connection_established -> receive_message -> Skip [] not_connection_established -> WAIT_TO_RECEIVE(i);"
            },
            {
                "name": "Master",
                "description": "ROS Master information matching:\n  After receiving the registration information from the publisher and the subscriber, the ROS Master will do the matching, \n  and if the match succeeds, it will confirm the request and respond to the publisher. After that, the connection is established.",
                "pat_code": "Master() = register_publisher -> match -> confirm_request -> establish_connect -> Skip;"
            },
            {
                "name": "ROS",
                "description": "The overall system consists for P publisher, S subscribers and a master.",
                "pat_code": "ROS() = (|||x:{0..P-1}@Publisher(x)) ||| (|||x:{0..S-1}@Subscriber(x)) || Master();"
            }
        ],
        "global_definition": "#define P 1;\n#define S 2;",
        "path": "handwrite/ROS PubSub.csp"
    },
    {
        "name": "SIP(Simple)",
        "tags": [
            "Protocol"
        ],
        "use_non_container_lib": false,
        "description": "SIP (Session Initiation Protocol) is a signaling protocol used to create, modify, and terminate multimedia sessions, such as voice and video calls, over IP networks.\n  A SIP session involves four main components: SIP user agent, SIP register, SIP proxy server, and SIP redirect server. SIP user agent includes user agent client and user agent server.\n  In this model, we mainly model user agent client, user agent server and register.\n  When the client wants to communicate with the server, the following sequence of actions occurs:\n  1. The client sends registration request regist to the register.\n  2. The register returns the response regresp to tell client whether its registration is successful.\n  3. After receiving successful registration, the client sends request to the server.\n  4. Finally, the server returns response to the client.",
        "pat_code": "enum {Msgregi,Msgregr,Msginvite1,Msgresp1};\nchannel ComUR 0;\nchannel ComUE 0;\n\n/*@Process: Register1\n  The Register1 process first waits for a registration message from the client and then sends a response message. Then it returns to itself.\n*/\nRegister1() = ComUR?Msgregi -> ComUR!Msgregr -> Register1();\n\n/*@Process: Client1\n  The Client1 process sends the registration message to the register \ufb01rstly, then waits a response message.\n  After the registration, the client can send request messages to the server directly. Then the client waits for the response from the server.\n  After several request messages, it returns to itself.\n*/\nClient1() = ComUR!Msgregi -> ComUR?Msgregr -> Skip;\n\t\t\tComUE!Msginvite1 -> ComUE?Msgresp1 -> (Client1()\n\ue002\t\t\t[]ComUE!Msginvite1 -> ComUE?Msgresp1 -> Client1());\n\n/*@Process: Server1\n  The Server1 process first waits for a request message from the client, then sends a response message to the client.\n  Then it returns to itself and proceeds to do actions above repeatedly.\n*/\nServer1() = ComUE?Msginvite1 -> ComUE!Msgresp1 ->Server1();\n\n/*@Process: SIP\n  The overall system process is composed of three subprocesses running in parallel through their own corresponding channels, including Register1, Server1 and Client1.\n*/\nSIP() = Register1() || Server1() || Client1();",
        "property_desc": [
            "The system is deadlock-free."
        ],
        "properties": [
            "#assert SIP() deadlockfree;"
        ],
        "processes": [
            {
                "name": "Register1",
                "description": "The Register1 process first waits for a registration message from the client and then sends a response message. Then it returns to itself.",
                "pat_code": "Register1() = ComUR?Msgregi -> ComUR!Msgregr -> Register1();"
            },
            {
                "name": "Client1",
                "description": "The Client1 process sends the registration message to the register \ufb01rstly, then waits a response message.\n  After the registration, the client can send request messages to the server directly. Then the client waits for the response from the server.\n  After several request messages, it returns to itself.",
                "pat_code": "Client1() = ComUR!Msgregi -> ComUR?Msgregr -> Skip;\n\t\t\tComUE!Msginvite1 -> ComUE?Msgresp1 -> (Client1()\n\ue002\t\t\t[]ComUE!Msginvite1 -> ComUE?Msgresp1 -> Client1());"
            },
            {
                "name": "Server1",
                "description": "The Server1 process first waits for a request message from the client, then sends a response message to the client.\n  Then it returns to itself and proceeds to do actions above repeatedly.",
                "pat_code": "Server1() = ComUE?Msginvite1 -> ComUE!Msgresp1 ->Server1();"
            },
            {
                "name": "SIP",
                "description": "The overall system process is composed of three subprocesses running in parallel through their own corresponding channels, including Register1, Server1 and Client1.",
                "pat_code": "SIP() = Register1() || Server1() || Client1();"
            }
        ],
        "global_definition": "enum {Msgregi,Msgregr,Msginvite1,Msgresp1};\nchannel ComUR 0;\nchannel ComUE 0;",
        "path": "handwrite/SIP.csp"
    },
    {
        "name": "Swift Cloud",
        "tags": [
            "Protocol",
            "Attacker"
        ],
        "use_non_container_lib": false,
        "description": "OpenStack Swift is an object storage system that adopts a fully symmetric architecture design. In the OpenStack Swift cluster, computer servers that run service processes are called nodes.\nAccording to the type of service processes, there are three kinds of nodes: proxy nodes, storage nodes, and auth nodes. Proxy node serves as the gateway for external clients, coordinating their read and write requests, and enabling access to objects on the storage nodes. Storage node provides storage services on physical devices and also runs other services to maintain data consistency. Auth node generates tokens for clients and grants or denies access permission to them. \n\nLike many other distributed systems, OpenStack Swift adopts a quorum-based protocol to balance the availability and consistency of writing and reading requests in the system.\nSubsets of replicas for read and write are denoted as Qr and Qw respectively. For a write operation, only if at least Qw of the replicas are updated successfully, is this write operation considered successful. Read operation is similar. Read and write quorums require shared replicas. In OpenStack Swift, the number of Qr is set to 1 by default, while the number of Qw is set to \u230ar/2 + 1\u230b, where r denotes the number of replicas. For instance, if there are three replicas of each object, any successful response from any node will be considered a successful read for the client. Meanwhile, only if at least two nodes respond with success will the proxy send a successful write response to the client.",
        "pat_code": "enum{Read,Write,msg,req,auth,token,identity,Readable,fake_token};\nvar Success_Num = 0;\nvar Data = 1;\nvar QuorumSuccess = false;\nvar DataWriteSuccess = false;\nvar DataReadSuccess = false;\nvar FakeDataReadSuccess = false;\nvar FakeDataWriteSuccess =  false;\nvar S1_Buffer;\nvar S2_Buffer;\nvar S3_Buffer;\nvar Proxy_Buffer;\nvar HasNo = true;\n\nchannel ComCP 0;\nchannel ComPC 0;\nchannel ComPS1 0; channel ComPS2 0; channel ComPS3 0;channel ComS1P 0;channel ComS2P 0;channel ComS3P 0;\nchannel ComCA 0; channel ComAC 0; channel ComPA 0; channel ComAP 0;\nchannel FakeCP 0; channel InterceptCP 0; channel InterceptPC 0;\nchannel InterceptCA 0; channel InterceptAC 0;\n\n/*@Process: Client\n  The Client() process represents a user interacting with the cloud storage. It has two main behaviors: writing data and reading data.\n\tWrite Operation:\n\t1. The client first sends an authentication request including identity to the Auth_Node.\n\t2. The client receives an authentication token from the Auth_Node.\n\t3. The client sends a write request to the Proxy_Node, including the data to be written and the authentication token.\n\t4. The client receives a response from the Proxy_Node.\n\t5. If the response indicates success, the DataWriteSuccess flag is set to true, indicating a successful write. Otherwise, DataWriteSuccess is set to false.\n\t6. The client loops back to the beginning to handle more requests.\n\n\tRead Operation:\n\t1. The client first sends an authentication request including identity to the Auth_Node.\n\t2. The client receives an authentication token from the Auth_Node.\n\t3. The client sends a read request to the Proxy_Node, including what data should be read and the authentication token.\n\t4. The client receives a response from the Proxy_Node.\n\t5. If the response indicates success (true), the DataReadSuccess flag is set to true, indicating a successful read. Otherwise, DataReadSuccess is set to false.\n\t6. The client loops back to the beginning to handle more requests.\n*/\nClient() = ComCA ! msg.auth.req.identity ->\n\t\t   ComAC ? msg.auth.token ->\n\t\t   ComCP ! msg.Write.Data.token ->\n\t\t   ComPC ? msg.response ->\n\t\t   if (response == true)\n\t\t   {\n\t\t   write_success{DataWriteSuccess = true;} ->\n\t\t   Client()\n\t\t   }\n\t\t   else\n\t\t   {write_fail{DataWriteSuccess = false;} ->\n\t\t   Client()\n\t\t   }\n\t\t   []\n\t\t   ComCA ! msg.auth.req.identity ->\n\t\t   ComAC ? msg.auth.token ->\n\t\t   ComCP ! msg.Read.Readable.token ->\n\t\t   ComPC ? msg.response ->\n\t\t   if (response == true)\n\t\t   {\n\t\t   Read_success{DataReadSuccess = true;} ->\n\t\t   Client()\n\t\t   }\n\t\t   else\n\t\t   {Read_fail{DataReadSuccess = false;} ->\n\t\t   Client()\n\t\t   };\n\t\t   \n\n/*@Process: Swift\n The Proxy_Node() acts as an intermediary between the client and the storage nodes. It handles both write and read requests, and may receive fake data.\n\t\n\tWrite Request Handling:\n\t1. The Proxy_Node receives a write request (data and token) from the Client.\n\t2. The proxy node stores the data to be written to the local buffer.\n  3. The proxy node sends authentication request to the authentication node.\n  4. If the authentication verification is true, the proxy node continues to send the write data to storage nodes. Otherwise, the Success_Num is reset to 0.\n  5. The Proxy_Node then sends write requests, containing the data, to each of the three Storage_Nodes via different channels, respectively.\n  6. It waits for acknowledgementsfrom each storage node, respectively. If an acknowledgement is true, it increments the Success_Num counter.\n  7. After receiving all acknowledgements, if  a quorum of storage nodes successfully wrote the data, it proceeds to Quorum_Success() to set the QuorumSuccess flag to true.\n  8. Then sends a response to the Client, indicating whether the write operation was successful based on the QuorumSuccess flag.\n  9. The proxy node loops back to the beginning to handle more requests.\n\n  Read Request Handling:\n  1. The Proxy_Node receives a read request from the Client.\n  2. The proxy node sends authentication request to the authentication node.\n  3. If the authentication verification is true, the proxy node continues to send the read request to storage nodes.\n  4. The Proxy_Node sends read requests to each of the three Storage_Nodes, respectively.\n  5. It waits for acknowledgements from each storage node respectively. If the data can be read, the proxy node responds true to the client.\n  6. The proxy node loops back to the beginning to handle more requests.\n\n\tReceive fake data:\n  1. The Proxy_Node receives a write request (data and fake token) from the Intruder.\n  2. The proxy node sends authentication request with fake token to the authentication node.\n  3. If the authentication verification is false, the proxy node continue.\n  4. The proxy node sends the response false to the Intruder.\n  5.The proxy node loops back to the beginning to handle more requests.\n*/\nProxy_Node() = ComCP ? msg.Write.data.token ->\n \t\t\t   Write_Proxy_Local{Proxy_Buffer = data} ->\n\t\t\t   ComPA ! msg.auth.token ->\n\t\t\t   ComAP ? msg.auth.verification ->\n\t\t\t   if (verification == false){ComPC!msg.false -> Proxy_Node()}\n\t\t\t   else{Skip};\n\t\t\t   Reset{Success_Num = 0} ->\n\t\t\t   ComPS1 ! msg.Write.Proxy_Buffer ->\n\t\t\t   ComS1P ? msg.ack1 ->\n\t\t\t   if (ack1 == true) { Node_Write_Success()} else {Skip};\n\t\t\t   ComPS2 ! msg.Write.Proxy_Buffer ->\n\t\t\t   ComS2P ? msg.ack2 ->\n\t\t\t   if (ack2 == true) { Node_Write_Success() } else {Skip};\n\t\t\t   ComPS3 ! msg.Write.Proxy_Buffer ->\n\t\t\t   ComS3P ? msg.ack3 ->\n\t\t\t   if (ack3 == true) { Node_Write_Success() } else {Skip};\n\t\t\t   if (Success_Num > 1 ) { Quorum_Success() } else {Skip};\n\t\t\t   ComPC ! msg.QuorumSuccess -> Proxy_Node()\n\t\t\t   [] \n\t\t\t   ComCP ? msg.Read.Readable.token ->\n\t\t\t   ComPA ! msg.auth.token ->\n\t\t\t   ComAP ? msg.auth.verification ->\n\t\t\t   if (verification == false){ComPC!msg.false -> Proxy_Node()}\n\t\t\t   else{Skip};\n\t\t\t   ComPS1 ! msg.Read.Readable ->\n\t\t\t   ComS1P ? msg.ack11.data ->\n\t\t\t   if (ack11 == true){ComPC!msg.true -> Proxy_Node()} else {\n\t\t\t\t\tComPS2 ! msg.Read.Readable ->\n\t\t\t\t\tComS2P ? msg.ack22.data2 ->\n\t\t\t\t\tif (ack22 == true){ComPC!msg.true -> Proxy_Node()} else{\n\t\t\t\t\t\tComPS3 ! msg.Read.Readable ->\n\t\t\t\t\t\tComS3P ? msg.ack33.data3 ->\n\t\t\t\t\t\tif (ack33 == true){ComPC!msg.true -> Proxy_Node()} else{\n\t\t\t\t\t\tComPC!msg.false -> Proxy_Node()}\n\t\t\t\t\t}\n\t\t\t   }\n\t\t\t   []\n\t\t\t   FakeCP? msg.Write.data.fake_token ->\n\t\t\t   ComPA! msg.fake_token ->\n\t\t\t   ComAP? msg.auth.ans ->\n\t\t\t   if (ans == false){\n\t\t\t   InterceptPC ! msg.false ->Proxy_Node()\n\t\t\t   } else{Skip}\n\t\t\t   ;\n\n/*@Process: Node_Write_Success\n  Node_Write_Success process increments the Success_Num counter by 1.\n*/\nNode_Write_Success() = {Success_Num = Success_Num + 1} -> Skip;\n/*@Process: Quorum_Success\n  Quorum_Success process sets the QuorumSuccess to true.\n*/\nQuorum_Success() = {QuorumSuccess = true} -> Skip;\n\n/*@Process: Storage_Node1\n  The storage node 1 is in the unavailable state.\n*/\nStorage_Node1() =  Storage1_UnAvailable();\n/*@Process: Storage1_Available\n  Storage1_Available State:\n  - 1. The Storage_Node1 receives a write request (data) from the Proxy_Node.\n    2. It stores the data in its local buffer.\n    3. It sends an acknowledgement to the Proxy_Node.\n    4. It loops back to the beginning to handle more requests.\n\n  - 1. Or, the Storage_Node1 receives a read request from the Proxy_Node.\n    2. It responds the local data to the Proxy_Node.\n    3. It loops back to the beginning to handle more requests.\n*/\nStorage1_Available() = ComPS1 ? msg.Write.data ->\n\t\t\t\t  \t   { S1_Buffer = data;} ->\n\t\t\t\t  \t   ComS1P ! msg.true -> Storage_Node1()\n\t\t\t\t \t   [] ComPS1 ? msg.Read.Readable ->\n\t\t\t\t       ComS1P!msg.true.S1_Buffer -> Storage_Node1();\n\n/*@Process: Storage1_UnAvailable\n\tStorage1_Unavailable State:\n\t- 1. The Storage_Node1 receives a write request (data) from the Proxy_Node.\n\t\t2. It stores a default value in its local buffer.\n\t\t3. It sets the HasNo to true.\n\t\t4. It sends an negative acknowledgement to the Proxy_Node.\n\t\t5. It loops back to the beginning to handle more requests.\n\t- 1. The Storage_Node1 receives a read request from the Proxy_Node.\n\t\t2. It sets the HasNo to true.\n\t\t3. It responds the local data to the Proxy_Node.\n\t\t4. It loops back to the beginning to handle more requests.\n*/\nStorage1_UnAvailable() = ComPS1 ? msg.Write.data ->\n\t\t\t\t\t\t { S1_Buffer = 2;} ->\n\t\t\t\t  \t\t { HasNo = true;} ->\n\t\t\t\t \t\t ComS1P ! msg.false -> Storage_Node1()\n\t\t\t\t \t\t [] ComPS1 ? msg.Read.Readable ->\n\t\t\t\t \t\t { HasNo = true;} ->\n\t\t\t\t  \t\t ComS1P!msg.false.S1_Buffer -> Storage_Node1();\n\t\t\t\t  \n/*@Process: Storage_Node2\n  Storage2 is available and behaves like storage node 1:\n  - 1. It receives a write request (data) from the Proxy_Node.\n    2. It stores the data in its local buffer.\n    3. It sends an acknowledgement to the Proxy_Node.\n    4. It loops back to the beginning to handle more requests.\n\n  - 1. Or, it receives a read request from the Proxy_Node.\n    2. It responds the local data to the Proxy_Node.\n    3. It loops back to the beginning to handle more requests.\n*/\nStorage_Node2() = ComPS2 ? msg.Write.data ->\n\t\t\t\t  { S2_Buffer = data;} ->\n\t\t\t\t  ComS2P ! msg.true -> Storage_Node2()\n\t\t\t\t  [] ComPS2 ? msg.Read.Readable ->\n\t\t\t\t  ComS2P!msg.true.S2_Buffer -> Storage_Node2();\n\t\t\t\t  \n/*@Process: Storage_Node3\n  Storage3 is available and behaves like storage node 1:\n  - 1. It receives a write request (data) from the Proxy_Node.\n    2. It stores the data in its local buffer.\n    3. It sends an acknowledgement to the Proxy_Node.\n    4. It loops back to the beginning to handle more requests.\n\n  - 1. Or, it receives a read request from the Proxy_Node.\n    2. It responds the local data to the Proxy_Node.\n    3. It loops back to the beginning to handle more requests.\n*/\nStorage_Node3() = ComPS3 ? msg.Write.data ->\n\t\t\t\t  { S3_Buffer = data;} ->\n\t\t\t\t  ComS3P ! msg.true -> Storage_Node3()\n\t\t\t\t  [] ComPS3 ? msg.Read.Readable ->\n\t\t\t\t  ComS3P!msg.true.S3_Buffer -> Storage_Node3();\n\n/*@Process: Auth_Node\n\tThe Auth_Node() handles authentication requests:\n\t- 1. The Auth_Node receives a request for authentication along with the identity from the Client.\n    2. The Auth_Node sends the authentication token back to the Client.\n  - 1. The Auth_Node receives a request for authentication along with the token from the Proxy_Node.\n    2. The Auth_Node sends the authentication verification back to the Proxy_Node.\n  - 1. The Auth_Node receives a request for authentication along with the fake token from the Proxy_Node.\n    2. The Auth_Node sends false back to the Proxy_Node.\n*/\nAuth_Node() = ComCA ? msg.auth.req.identity\t->\n\t\t\t ComAC ! msg.auth.token -> Auth_Node()\n\t\t\t [] ComPA? msg.auth.token ->\n\t\t\t ComAP! msg.auth.true -> Auth_Node()\n\t\t\t [] ComPA? msg.auth.fake_token ->\n\t\t\t ComAP! msg.auth.false -> Auth_Node();\n\n/*@Process: Intruder\n  The Intruder() process simulates a malicious actor trying to inject fake data into the system.\n\tWrite fake data:\n\t1. The Intruder sends a request for authentication along with the identity to the Auth_Node.\n  2. The Intruder receives the authentication token from the Auth_Node.\n  3. The Intruder attempts to write data using a fake token to the Proxy_Node.\n  4. The Intruder receives a response from the Proxy_Node.\n\t5. If the write succeeds, the FakeDataWriteSuccess flag is set to true. Otherwise, it is set to false.\n\n\tRead fake data:\n  1. The Intruder attempts to read data using a fake token to the Proxy_Node.\n  2. The Intruder receives a response from the Proxy_Node.\n  3. If the read succeeds, the FakeDataReadSuccess flag is set to true. Otherwise, it is set to false.\n*/\nIntruder() = InterceptCA ! msg.auth.req.identity-> \n\t\t     InterceptAC ? msg.auth.token ->\n\t\t\t FakeCP ! msg.Write.Data.fake_token ->\n\t\t     InterceptPC ? msg.ack1 ->\n\t\t     if (ack1 == true){\n\t\t     \t{FakeDataWriteSuccess = true;} -> Intruder()\n\t\t     }\n\t\t     else {\n\t\t     \t{FakeDataWriteSuccess = false;} -> Intruder()\n\t\t     }\n\t\t     [] FakeCP ! msg.Readable.fake_token ->\n\t\t     InterceptPC ? msg.ack2 ->\n\t\t     if (ack2 == true) {\n\t\t\t\t\t{FakeDataReadSuccess = true;} ->Intruder()\n\t\t     } else{\n\t\t      {FakeDataReadSuccess = false;} -> Intruder()\n\t\t     };\n\n/*@Process: SWIFT_CLOUD\n  The swift cloud model consists of a client, a proxy node, three storage nodes, an authentication node, and an intruder. \n*/\nSWIFT_CLOUD = Client() || Proxy_Node() || Storage_Node1() || Storage_Node2() || Storage_Node3() || Auth_Node() || Intruder();",
        "property_desc": [
            "The system is deadlock-free",
            "Ensures clients are able to write to and read from the Swift cluster correctly.",
            "All nodes access the same up-to-date copy of the data at any time.",
            "The ability of the system to maintain normal operation and provide the expected services even if some of the nodes fail",
            "The client can successfully read the data.",
            "The client can successfully write the data.",
            "The intruder can intercepts the data between the client and the server.",
            "The intruder can fake the data between the client and the server."
        ],
        "properties": [
            "#assert SWIFT_CLOUD deadlockfree;",
            "#define Data_Reachability DataWriteSuccess == true && DataReadSuccess == true ;\n#define Read_Success DataReadSuccess == true;\n#define Write_Success DataWriteSuccess == true;\n#define Availablity HasNo == true && DataReadSuccess == true && DataWriteSuccess == true;\n#define Data_Leakage FakeDataReadSuccess == false;\n#define Data_Faking FakeDataWriteSuccess == false;\n#define Consistency S1_Buffer == S2_Buffer && S1_Buffer == S3_Buffer;\n\n#assert SWIFT_CLOUD reaches Data_Reachability;",
            "#assert SWIFT_CLOUD |= []Consistency;",
            "#assert SWIFT_CLOUD reaches Availablity;",
            "#assert SWIFT_CLOUD reaches Read_Success;",
            "#assert SWIFT_CLOUD reaches Write_Success;",
            "#assert SWIFT_CLOUD |=[] Data_Leakage;",
            "#assert SWIFT_CLOUD |=[] Data_Faking;"
        ],
        "processes": [
            {
                "name": "Client",
                "description": "The Client() process represents a user interacting with the cloud storage. It has two main behaviors: writing data and reading data.\n\tWrite Operation:\n\t1. The client first sends an authentication request including identity to the Auth_Node.\n\t2. The client receives an authentication token from the Auth_Node.\n\t3. The client sends a write request to the Proxy_Node, including the data to be written and the authentication token.\n\t4. The client receives a response from the Proxy_Node.\n\t5. If the response indicates success, the DataWriteSuccess flag is set to true, indicating a successful write. Otherwise, DataWriteSuccess is set to false.\n\t6. The client loops back to the beginning to handle more requests.\n\n\tRead Operation:\n\t1. The client first sends an authentication request including identity to the Auth_Node.\n\t2. The client receives an authentication token from the Auth_Node.\n\t3. The client sends a read request to the Proxy_Node, including what data should be read and the authentication token.\n\t4. The client receives a response from the Proxy_Node.\n\t5. If the response indicates success (true), the DataReadSuccess flag is set to true, indicating a successful read. Otherwise, DataReadSuccess is set to false.\n\t6. The client loops back to the beginning to handle more requests.",
                "pat_code": "Client() = ComCA ! msg.auth.req.identity ->\n\t\t   ComAC ? msg.auth.token ->\n\t\t   ComCP ! msg.Write.Data.token ->\n\t\t   ComPC ? msg.response ->\n\t\t   if (response == true)\n\t\t   {\n\t\t   write_success{DataWriteSuccess = true;} ->\n\t\t   Client()\n\t\t   }\n\t\t   else\n\t\t   {write_fail{DataWriteSuccess = false;} ->\n\t\t   Client()\n\t\t   }\n\t\t   []\n\t\t   ComCA ! msg.auth.req.identity ->\n\t\t   ComAC ? msg.auth.token ->\n\t\t   ComCP ! msg.Read.Readable.token ->\n\t\t   ComPC ? msg.response ->\n\t\t   if (response == true)\n\t\t   {\n\t\t   Read_success{DataReadSuccess = true;} ->\n\t\t   Client()\n\t\t   }\n\t\t   else\n\t\t   {Read_fail{DataReadSuccess = false;} ->\n\t\t   Client()\n\t\t   };"
            },
            {
                "name": "Swift",
                "description": "The Proxy_Node() acts as an intermediary between the client and the storage nodes. It handles both write and read requests, and may receive fake data.\n\t\n\tWrite Request Handling:\n\t1. The Proxy_Node receives a write request (data and token) from the Client.\n\t2. The proxy node stores the data to be written to the local buffer.\n  3. The proxy node sends authentication request to the authentication node.\n  4. If the authentication verification is true, the proxy node continues to send the write data to storage nodes. Otherwise, the Success_Num is reset to 0.\n  5. The Proxy_Node then sends write requests, containing the data, to each of the three Storage_Nodes via different channels, respectively.\n  6. It waits for acknowledgementsfrom each storage node, respectively. If an acknowledgement is true, it increments the Success_Num counter.\n  7. After receiving all acknowledgements, if  a quorum of storage nodes successfully wrote the data, it proceeds to Quorum_Success() to set the QuorumSuccess flag to true.\n  8. Then sends a response to the Client, indicating whether the write operation was successful based on the QuorumSuccess flag.\n  9. The proxy node loops back to the beginning to handle more requests.\n\n  Read Request Handling:\n  1. The Proxy_Node receives a read request from the Client.\n  2. The proxy node sends authentication request to the authentication node.\n  3. If the authentication verification is true, the proxy node continues to send the read request to storage nodes.\n  4. The Proxy_Node sends read requests to each of the three Storage_Nodes, respectively.\n  5. It waits for acknowledgements from each storage node respectively. If the data can be read, the proxy node responds true to the client.\n  6. The proxy node loops back to the beginning to handle more requests.\n\n\tReceive fake data:\n  1. The Proxy_Node receives a write request (data and fake token) from the Intruder.\n  2. The proxy node sends authentication request with fake token to the authentication node.\n  3. If the authentication verification is false, the proxy node continue.\n  4. The proxy node sends the response false to the Intruder.\n  5.The proxy node loops back to the beginning to handle more requests.",
                "pat_code": "Proxy_Node() = ComCP ? msg.Write.data.token ->\n \t\t\t   Write_Proxy_Local{Proxy_Buffer = data} ->\n\t\t\t   ComPA ! msg.auth.token ->\n\t\t\t   ComAP ? msg.auth.verification ->\n\t\t\t   if (verification == false){ComPC!msg.false -> Proxy_Node()}\n\t\t\t   else{Skip};\n\t\t\t   Reset{Success_Num = 0} ->\n\t\t\t   ComPS1 ! msg.Write.Proxy_Buffer ->\n\t\t\t   ComS1P ? msg.ack1 ->\n\t\t\t   if (ack1 == true) { Node_Write_Success()} else {Skip};\n\t\t\t   ComPS2 ! msg.Write.Proxy_Buffer ->\n\t\t\t   ComS2P ? msg.ack2 ->\n\t\t\t   if (ack2 == true) { Node_Write_Success() } else {Skip};\n\t\t\t   ComPS3 ! msg.Write.Proxy_Buffer ->\n\t\t\t   ComS3P ? msg.ack3 ->\n\t\t\t   if (ack3 == true) { Node_Write_Success() } else {Skip};\n\t\t\t   if (Success_Num > 1 ) { Quorum_Success() } else {Skip};\n\t\t\t   ComPC ! msg.QuorumSuccess -> Proxy_Node()\n\t\t\t   [] \n\t\t\t   ComCP ? msg.Read.Readable.token ->\n\t\t\t   ComPA ! msg.auth.token ->\n\t\t\t   ComAP ? msg.auth.verification ->\n\t\t\t   if (verification == false){ComPC!msg.false -> Proxy_Node()}\n\t\t\t   else{Skip};\n\t\t\t   ComPS1 ! msg.Read.Readable ->\n\t\t\t   ComS1P ? msg.ack11.data ->\n\t\t\t   if (ack11 == true){ComPC!msg.true -> Proxy_Node()} else {\n\t\t\t\t\tComPS2 ! msg.Read.Readable ->\n\t\t\t\t\tComS2P ? msg.ack22.data2 ->\n\t\t\t\t\tif (ack22 == true){ComPC!msg.true -> Proxy_Node()} else{\n\t\t\t\t\t\tComPS3 ! msg.Read.Readable ->\n\t\t\t\t\t\tComS3P ? msg.ack33.data3 ->\n\t\t\t\t\t\tif (ack33 == true){ComPC!msg.true -> Proxy_Node()} else{\n\t\t\t\t\t\tComPC!msg.false -> Proxy_Node()}\n\t\t\t\t\t}\n\t\t\t   }\n\t\t\t   []\n\t\t\t   FakeCP? msg.Write.data.fake_token ->\n\t\t\t   ComPA! msg.fake_token ->\n\t\t\t   ComAP? msg.auth.ans ->\n\t\t\t   if (ans == false){\n\t\t\t   InterceptPC ! msg.false ->Proxy_Node()\n\t\t\t   } else{Skip}\n\t\t\t   ;"
            },
            {
                "name": "Node_Write_Success",
                "description": "Node_Write_Success process increments the Success_Num counter by 1.",
                "pat_code": "Node_Write_Success() = {Success_Num = Success_Num + 1} -> Skip;"
            },
            {
                "name": "Quorum_Success",
                "description": "Quorum_Success process sets the QuorumSuccess to true.",
                "pat_code": "Quorum_Success() = {QuorumSuccess = true} -> Skip;"
            },
            {
                "name": "Storage_Node1",
                "description": "The storage node 1 is in the unavailable state.",
                "pat_code": "Storage_Node1() =  Storage1_UnAvailable();"
            },
            {
                "name": "Storage1_Available",
                "description": "Storage1_Available State:\n  - 1. The Storage_Node1 receives a write request (data) from the Proxy_Node.\n    2. It stores the data in its local buffer.\n    3. It sends an acknowledgement to the Proxy_Node.\n    4. It loops back to the beginning to handle more requests.\n\n  - 1. Or, the Storage_Node1 receives a read request from the Proxy_Node.\n    2. It responds the local data to the Proxy_Node.\n    3. It loops back to the beginning to handle more requests.",
                "pat_code": "Storage1_Available() = ComPS1 ? msg.Write.data ->\n\t\t\t\t  \t   { S1_Buffer = data;} ->\n\t\t\t\t  \t   ComS1P ! msg.true -> Storage_Node1()\n\t\t\t\t \t   [] ComPS1 ? msg.Read.Readable ->\n\t\t\t\t       ComS1P!msg.true.S1_Buffer -> Storage_Node1();"
            },
            {
                "name": "Storage1_UnAvailable",
                "description": "Storage1_Unavailable State:\n\t- 1. The Storage_Node1 receives a write request (data) from the Proxy_Node.\n\t\t2. It stores a default value in its local buffer.\n\t\t3. It sets the HasNo to true.\n\t\t4. It sends an negative acknowledgement to the Proxy_Node.\n\t\t5. It loops back to the beginning to handle more requests.\n\t- 1. The Storage_Node1 receives a read request from the Proxy_Node.\n\t\t2. It sets the HasNo to true.\n\t\t3. It responds the local data to the Proxy_Node.\n\t\t4. It loops back to the beginning to handle more requests.",
                "pat_code": "Storage1_UnAvailable() = ComPS1 ? msg.Write.data ->\n\t\t\t\t\t\t { S1_Buffer = 2;} ->\n\t\t\t\t  \t\t { HasNo = true;} ->\n\t\t\t\t \t\t ComS1P ! msg.false -> Storage_Node1()\n\t\t\t\t \t\t [] ComPS1 ? msg.Read.Readable ->\n\t\t\t\t \t\t { HasNo = true;} ->\n\t\t\t\t  \t\t ComS1P!msg.false.S1_Buffer -> Storage_Node1();"
            },
            {
                "name": "Storage_Node2",
                "description": "Storage2 is available and behaves like storage node 1:\n  - 1. It receives a write request (data) from the Proxy_Node.\n    2. It stores the data in its local buffer.\n    3. It sends an acknowledgement to the Proxy_Node.\n    4. It loops back to the beginning to handle more requests.\n\n  - 1. Or, it receives a read request from the Proxy_Node.\n    2. It responds the local data to the Proxy_Node.\n    3. It loops back to the beginning to handle more requests.",
                "pat_code": "Storage_Node2() = ComPS2 ? msg.Write.data ->\n\t\t\t\t  { S2_Buffer = data;} ->\n\t\t\t\t  ComS2P ! msg.true -> Storage_Node2()\n\t\t\t\t  [] ComPS2 ? msg.Read.Readable ->\n\t\t\t\t  ComS2P!msg.true.S2_Buffer -> Storage_Node2();"
            },
            {
                "name": "Storage_Node3",
                "description": "Storage3 is available and behaves like storage node 1:\n  - 1. It receives a write request (data) from the Proxy_Node.\n    2. It stores the data in its local buffer.\n    3. It sends an acknowledgement to the Proxy_Node.\n    4. It loops back to the beginning to handle more requests.\n\n  - 1. Or, it receives a read request from the Proxy_Node.\n    2. It responds the local data to the Proxy_Node.\n    3. It loops back to the beginning to handle more requests.",
                "pat_code": "Storage_Node3() = ComPS3 ? msg.Write.data ->\n\t\t\t\t  { S3_Buffer = data;} ->\n\t\t\t\t  ComS3P ! msg.true -> Storage_Node3()\n\t\t\t\t  [] ComPS3 ? msg.Read.Readable ->\n\t\t\t\t  ComS3P!msg.true.S3_Buffer -> Storage_Node3();"
            },
            {
                "name": "Auth_Node",
                "description": "The Auth_Node() handles authentication requests:\n\t- 1. The Auth_Node receives a request for authentication along with the identity from the Client.\n    2. The Auth_Node sends the authentication token back to the Client.\n  - 1. The Auth_Node receives a request for authentication along with the token from the Proxy_Node.\n    2. The Auth_Node sends the authentication verification back to the Proxy_Node.\n  - 1. The Auth_Node receives a request for authentication along with the fake token from the Proxy_Node.\n    2. The Auth_Node sends false back to the Proxy_Node.",
                "pat_code": "Auth_Node() = ComCA ? msg.auth.req.identity\t->\n\t\t\t ComAC ! msg.auth.token -> Auth_Node()\n\t\t\t [] ComPA? msg.auth.token ->\n\t\t\t ComAP! msg.auth.true -> Auth_Node()\n\t\t\t [] ComPA? msg.auth.fake_token ->\n\t\t\t ComAP! msg.auth.false -> Auth_Node();"
            },
            {
                "name": "Intruder",
                "description": "The Intruder() process simulates a malicious actor trying to inject fake data into the system.\n\tWrite fake data:\n\t1. The Intruder sends a request for authentication along with the identity to the Auth_Node.\n  2. The Intruder receives the authentication token from the Auth_Node.\n  3. The Intruder attempts to write data using a fake token to the Proxy_Node.\n  4. The Intruder receives a response from the Proxy_Node.\n\t5. If the write succeeds, the FakeDataWriteSuccess flag is set to true. Otherwise, it is set to false.\n\n\tRead fake data:\n  1. The Intruder attempts to read data using a fake token to the Proxy_Node.\n  2. The Intruder receives a response from the Proxy_Node.\n  3. If the read succeeds, the FakeDataReadSuccess flag is set to true. Otherwise, it is set to false.",
                "pat_code": "Intruder() = InterceptCA ! msg.auth.req.identity-> \n\t\t     InterceptAC ? msg.auth.token ->\n\t\t\t FakeCP ! msg.Write.Data.fake_token ->\n\t\t     InterceptPC ? msg.ack1 ->\n\t\t     if (ack1 == true){\n\t\t     \t{FakeDataWriteSuccess = true;} -> Intruder()\n\t\t     }\n\t\t     else {\n\t\t     \t{FakeDataWriteSuccess = false;} -> Intruder()\n\t\t     }\n\t\t     [] FakeCP ! msg.Readable.fake_token ->\n\t\t     InterceptPC ? msg.ack2 ->\n\t\t     if (ack2 == true) {\n\t\t\t\t\t{FakeDataReadSuccess = true;} ->Intruder()\n\t\t     } else{\n\t\t      {FakeDataReadSuccess = false;} -> Intruder()\n\t\t     };"
            },
            {
                "name": "SWIFT_CLOUD",
                "description": "The swift cloud model consists of a client, a proxy node, three storage nodes, an authentication node, and an intruder.",
                "pat_code": "SWIFT_CLOUD = Client() || Proxy_Node() || Storage_Node1() || Storage_Node2() || Storage_Node3() || Auth_Node() || Intruder();"
            }
        ],
        "global_definition": "enum{Read,Write,msg,req,auth,token,identity,Readable,fake_token};\nvar Success_Num = 0;\nvar Data = 1;\nvar QuorumSuccess = false;\nvar DataWriteSuccess = false;\nvar DataReadSuccess = false;\nvar FakeDataReadSuccess = false;\nvar FakeDataWriteSuccess =  false;\nvar S1_Buffer;\nvar S2_Buffer;\nvar S3_Buffer;\nvar Proxy_Buffer;\nvar HasNo = true;\n\nchannel ComCP 0;\nchannel ComPC 0;\nchannel ComPS1 0; channel ComPS2 0; channel ComPS3 0;channel ComS1P 0;channel ComS2P 0;channel ComS3P 0;\nchannel ComCA 0; channel ComAC 0; channel ComPA 0; channel ComAP 0;\nchannel FakeCP 0; channel InterceptCP 0; channel InterceptPC 0;\nchannel InterceptCA 0; channel InterceptAC 0;",
        "path": "handwrite/Swift.csp"
    },
    {
        "name": "Swift Replication",
        "tags": [
            "Protocol"
        ],
        "use_non_container_lib": false,
        "description": "OpenStack Swift is an object storage system that adopts a fully symmetric architecture design. OpenStack Swift adopts a modified consistent hash ring to map the object data to the physical storage location. The core data structures in a Swift ring file include a list of devices and a list of replicas mapped to partitions. When a client writes an object to the cluster, the process of locating an object in the system has the following main steps:",
        "pat_code": "enum{Read,Write,msg,req,auth,token,identity,Readable,fake_token};\nenum{hash,http,sync,resp,update,partition,CONNECT,HTTP_OK,Get_Hash,Rsync};\nchannel ComR1H 0; channel ComR2H 0; channel ComR3H 0; channel ComHR1 0; channel ComHR2 0; channel ComHR3 0;\nchannel ComR1R2 0; channel ComR2R1 0; channel ComR1R3 0; channel ComR3R1 0; channel ComR2R3 0; channel ComR3R2 0;\nvar Directory = [1,1,2];\nvar local_hash_1; var local_hash_2; var local_hash_3;\n\n/*@Process: Replica1\n  Replica1 process\n  1. Initially, Replica1 sends a hash request for a partition to the HashDirectory.\n  2. It then receives the hash data for that partition from HashDirectory and stores it in local hash.\n  3. After receiving the hash data, Replica1 either initiates an update with Replica2  or listens for connections from Replica2.\n*/\nReplica1() = ComR1H!msg.hash.req.partition ->\n\t\t     ComHR1?msg.hash.resp.partition.hash_data ->\n\t\t  \t  { local_hash_1 = hash_data;} ->\n\t\t  \t (Update1_2() [] Listen1()) ;\n\n/*@Process: Update1_2\n  Update1_2 process:\n  1. Replica1 attempts to connect to Replica2 by sending an HTTP CONNECT message.\n  2. Upon receiving an HTTP_OK response from Replica2 , Replica1 requests the hash of Replica2.\n  3. Replica1 receives the remote hash from Replica2 .\n  4. If the remote hash is greater than or equal to its local hash , it continues to update.  Otherwise, it sends an update message to the HashDirectory to update entry 2 with its local hash.\n*/\nUpdate1_2() = ComR1R2!msg.http.CONNECT ->\n\t\t   ComR2R1?msg.http.HTTP_OK ->\n\t\t   ComR1R2!msg.sync.Get_Hash ->\n\t\t   ComR2R1?msg.resp.remote_hash ->\n\t\t   if (remote_hash >= local_hash_1) {Update1_2()} else{\n\t\t   ComR1H!msg.hash.update.2.local_hash_1 -> Skip()};\n\t\t   \n/*@Process: Listen1\n  Listen1 process:\n  1. Replica1 listens for a connection request from Replica2.\n  2. It responds with an HTTP_OK message.\n  3. Replica1 then waits for a request for its hash.\n  4. Replica1 sends its local hash to Replica2 and continues to listen.\n*/\nListen1() =  ComR2R1?msg.http.CONNECT ->\n\t\t\t ComR1R2!msg.http.HTTP_OK ->\n\t\t\t ComR2R1?msg.sync.Get_Hash ->\n\t\t\t ComR1R2!msg.resp.local_hash_1 -> Listen1();\n\n/*@Process: Replica2\n  Replica2 process\n  1. Initially, Replica2 sends a hash request for a partition to the HashDirectory.\n  2. It then receives the hash data for that partition from HashDirectory and stores it in its local hash\n  3. After receiving the hash data, Replica2 either initiates an update with Replica1 or listens for connections from Replica1.\n*/\nReplica2() = ComR2H!msg.hash.req.partition ->\n\t\t     ComHR2?msg.hash.resp.partition.hash_data ->\n\t\t  \t  { local_hash_2 = hash_data;} ->\n\t\t  \t  (Update2_1() [] Listen2()); \n\n/*@Process: Update2_1\n  Update2_1 process:\n  1. Replica2 attempts to connect to Replica1 by sending an HTTP CONNECT message.\n  2. Upon receiving an HTTP_OK response from Replica1 , Replica2 requests the hash of Replica1.\n  3. Replica2 receives the remote hash from Replica1 .\n  4. If the remote hash is greater than or equal to its local hash , it continues to update.  Otherwise, it sends an update message to the HashDirectory to update entry 1 with its local hash.\n*/\nUpdate2_1() = ComR2R1!msg.http.CONNECT ->\n\t\t   ComR1R2?msg.http.HTTP_OK ->\n\t\t   ComR2R1!msg.sync.Get_Hash ->\n\t\t   ComR1R2?msg.resp.remote_hash ->\n\t\t   if (remote_hash >= local_hash_2) {Update2_1()} else{\n\t\t   ComR2H!msg.hash.update.1.local_hash_2 -> Skip()};\n\n/*@Process: Listen2\n  Listen2 process:\n  1. Replica2 listens for a connection request from Replica1.\n  2. It responds with an HTTP_OK message.\n  3. Replica2 then waits for a request for its hash.\n  4. Replica2 sends its local hash to Replica1 and continues to listen.\n*/\nListen2() =  ComR1R2?msg.http.CONNECT ->\n\t\t\t ComR2R1!msg.http.HTTP_OK ->\n\t\t\t ComR1R2?msg.sync.Get_Hash ->\n\t\t\t ComR2R1!msg.resp.local_hash_2 -> Listen2();\n\n/*@Process: HashDirectory\n  HashDirectory process:\n  The HashDirectory handles requests to get and update hash values.\n  - It can receive a hash request from Replica1. It responds to the request by sending the fisrt value in the directory. The process then repeats.\n  - It can receive a hash request from Replica2. It responds to the request by sending the second value in the directory. The process then repeats.\n  - It can receive a hash update request from Replica1 It updates the directory with the received value. The process then repeats.\n  - It can receive a hash update request from Replica2. It updates the directory with the received value. The process then repeats.\n*/\nHashDirectory() = ComR1H?msg.hash.req.partition ->\n\t\t\t\tComHR1!msg.hash.resp.partition.Directory[0] ->\n\t\t\t\tHashDirectory()\n\t\t\t\t[]ComR2H?msg.hash.req.partition ->\n\t\t\t\tComHR2!msg.hash.resp.partition.Directory[1] ->\n\t\t\t\tHashDirectory()\n\t\t\t\t[]ComR1H?msg.hash.update.node.value ->\n\t\t\t\t{Directory[node-1] = value} -> HashDirectory()\n\t\t\t\t[]ComR2H?msg.hash.update.node.value ->\n\t\t\t\t{Directory[node-1] = value} -> HashDirectory();\n\t\t\t\t\n/*@Process: Replication\n  The Replication process consists of parallel execution of two replicas and one HashDirectory processes.\n*/\nReplication = Replica1() || Replica2() || HashDirectory();",
        "property_desc": [
            "The system is deadlock-free.",
            "After a series of synchronization operations, the replicas in the system will eventually reach consistency."
        ],
        "properties": [
            "#define EventuallyConsistency Directory[0] == Directory[1] && Directory[0] == Directory[2];\n#assert Replication deadlockfree;",
            "#assert Replication reaches EventuallyConsistency;"
        ],
        "processes": [
            {
                "name": "Replica1",
                "description": "Replica1 process\n  1. Initially, Replica1 sends a hash request for a partition to the HashDirectory.\n  2. It then receives the hash data for that partition from HashDirectory and stores it in local hash.\n  3. After receiving the hash data, Replica1 either initiates an update with Replica2  or listens for connections from Replica2.",
                "pat_code": "Replica1() = ComR1H!msg.hash.req.partition ->\n\t\t     ComHR1?msg.hash.resp.partition.hash_data ->\n\t\t  \t  { local_hash_1 = hash_data;} ->\n\t\t  \t (Update1_2() [] Listen1()) ;"
            },
            {
                "name": "Update1_2",
                "description": "Update1_2 process:\n  1. Replica1 attempts to connect to Replica2 by sending an HTTP CONNECT message.\n  2. Upon receiving an HTTP_OK response from Replica2 , Replica1 requests the hash of Replica2.\n  3. Replica1 receives the remote hash from Replica2 .\n  4. If the remote hash is greater than or equal to its local hash , it continues to update.  Otherwise, it sends an update message to the HashDirectory to update entry 2 with its local hash.",
                "pat_code": "Update1_2() = ComR1R2!msg.http.CONNECT ->\n\t\t   ComR2R1?msg.http.HTTP_OK ->\n\t\t   ComR1R2!msg.sync.Get_Hash ->\n\t\t   ComR2R1?msg.resp.remote_hash ->\n\t\t   if (remote_hash >= local_hash_1) {Update1_2()} else{\n\t\t   ComR1H!msg.hash.update.2.local_hash_1 -> Skip()};"
            },
            {
                "name": "Listen1",
                "description": "Listen1 process:\n  1. Replica1 listens for a connection request from Replica2.\n  2. It responds with an HTTP_OK message.\n  3. Replica1 then waits for a request for its hash.\n  4. Replica1 sends its local hash to Replica2 and continues to listen.",
                "pat_code": "Listen1() =  ComR2R1?msg.http.CONNECT ->\n\t\t\t ComR1R2!msg.http.HTTP_OK ->\n\t\t\t ComR2R1?msg.sync.Get_Hash ->\n\t\t\t ComR1R2!msg.resp.local_hash_1 -> Listen1();"
            },
            {
                "name": "Replica2",
                "description": "Replica2 process\n  1. Initially, Replica2 sends a hash request for a partition to the HashDirectory.\n  2. It then receives the hash data for that partition from HashDirectory and stores it in its local hash\n  3. After receiving the hash data, Replica2 either initiates an update with Replica1 or listens for connections from Replica1.",
                "pat_code": "Replica2() = ComR2H!msg.hash.req.partition ->\n\t\t     ComHR2?msg.hash.resp.partition.hash_data ->\n\t\t  \t  { local_hash_2 = hash_data;} ->\n\t\t  \t  (Update2_1() [] Listen2());"
            },
            {
                "name": "Update2_1",
                "description": "Update2_1 process:\n  1. Replica2 attempts to connect to Replica1 by sending an HTTP CONNECT message.\n  2. Upon receiving an HTTP_OK response from Replica1 , Replica2 requests the hash of Replica1.\n  3. Replica2 receives the remote hash from Replica1 .\n  4. If the remote hash is greater than or equal to its local hash , it continues to update.  Otherwise, it sends an update message to the HashDirectory to update entry 1 with its local hash.",
                "pat_code": "Update2_1() = ComR2R1!msg.http.CONNECT ->\n\t\t   ComR1R2?msg.http.HTTP_OK ->\n\t\t   ComR2R1!msg.sync.Get_Hash ->\n\t\t   ComR1R2?msg.resp.remote_hash ->\n\t\t   if (remote_hash >= local_hash_2) {Update2_1()} else{\n\t\t   ComR2H!msg.hash.update.1.local_hash_2 -> Skip()};"
            },
            {
                "name": "Listen2",
                "description": "Listen2 process:\n  1. Replica2 listens for a connection request from Replica1.\n  2. It responds with an HTTP_OK message.\n  3. Replica2 then waits for a request for its hash.\n  4. Replica2 sends its local hash to Replica1 and continues to listen.",
                "pat_code": "Listen2() =  ComR1R2?msg.http.CONNECT ->\n\t\t\t ComR2R1!msg.http.HTTP_OK ->\n\t\t\t ComR1R2?msg.sync.Get_Hash ->\n\t\t\t ComR2R1!msg.resp.local_hash_2 -> Listen2();"
            },
            {
                "name": "HashDirectory",
                "description": "HashDirectory process:\n  The HashDirectory handles requests to get and update hash values.\n  - It can receive a hash request from Replica1. It responds to the request by sending the fisrt value in the directory. The process then repeats.\n  - It can receive a hash request from Replica2. It responds to the request by sending the second value in the directory. The process then repeats.\n  - It can receive a hash update request from Replica1 It updates the directory with the received value. The process then repeats.\n  - It can receive a hash update request from Replica2. It updates the directory with the received value. The process then repeats.",
                "pat_code": "HashDirectory() = ComR1H?msg.hash.req.partition ->\n\t\t\t\tComHR1!msg.hash.resp.partition.Directory[0] ->\n\t\t\t\tHashDirectory()\n\t\t\t\t[]ComR2H?msg.hash.req.partition ->\n\t\t\t\tComHR2!msg.hash.resp.partition.Directory[1] ->\n\t\t\t\tHashDirectory()\n\t\t\t\t[]ComR1H?msg.hash.update.node.value ->\n\t\t\t\t{Directory[node-1] = value} -> HashDirectory()\n\t\t\t\t[]ComR2H?msg.hash.update.node.value ->\n\t\t\t\t{Directory[node-1] = value} -> HashDirectory();"
            },
            {
                "name": "Replication",
                "description": "The Replication process consists of parallel execution of two replicas and one HashDirectory processes.",
                "pat_code": "Replication = Replica1() || Replica2() || HashDirectory();"
            }
        ],
        "global_definition": "enum{Read,Write,msg,req,auth,token,identity,Readable,fake_token};\nenum{hash,http,sync,resp,update,partition,CONNECT,HTTP_OK,Get_Hash,Rsync};\nchannel ComR1H 0; channel ComR2H 0; channel ComR3H 0; channel ComHR1 0; channel ComHR2 0; channel ComHR3 0;\nchannel ComR1R2 0; channel ComR2R1 0; channel ComR1R3 0; channel ComR3R1 0; channel ComR2R3 0; channel ComR3R2 0;\nvar Directory = [1,1,2];\nvar local_hash_1; var local_hash_2; var local_hash_3;",
        "path": "handwrite/Swift2.csp"
    },
    {
        "name": "Tactical Data Link",
        "tags": [
            "Protocol"
        ],
        "use_non_container_lib": false,
        "description": "There are three roles in the system: Execution Nodes (EN), Chief Command Center (CCC), Operation Command Centers (OCC).",
        "pat_code": "#define R 2;\n#define n 5;\n#define m 2;\n#define f 2;\n\nenum{prepre, pre, com};\n\nchannel c[n*n] 0;\nchannel req 0;\nchannel rep[n] 0;\n\nvar size[n*n];\nvar curseq;\nvar bf[n];\nvar stat[n];\n\n/*@Process: EN\n  Execution Node (EN):\n  1. The EN initially waits to receive a message from CCC.\n  2. Upon receiving a message, the EN proceeds to the waiting state,\n*/\nEN() = []msg: {1..m}@req!msg -> ENW(msg, 0);\n\n/*@Process: ENW\n1. In the waiting state, the EN iteratively listens for the same message from the CCC for up to 2*f+1 times.\n 2. Each time the message is received, the counter is increased.\n3.  Once the message has been received 2*f+1 times, the EN performs a finish action and returns to its initial state.\n*/\nENW(msg, cnt) = if(cnt < 2 * f + 1) {\n  []i:{0..n-1}@rep[i]?msg -> ENW(msg, cnt + 1)\n} else {\n  finish -> EN()\n};\n\n/*@Process: CCC\n  The Chief Command Center (CCC)\n  The CCC starts by waiting to receive a message from the execution node and proceeds to next state with the message and current message sequence. \n*/\nCCC() = req?msg -> CCC1(msg,curseq);\n/*@Process: CCC1\n  In CCC1:\n  1. the sequence number is incremented by addseq. \n  2. It then sends \"prepre\" and \"pre\" messages sequentially along with the sequence number and original message msg to all other OCC nodes \n 3. Then, it proceeds to the next state.\n*/\nCCC1(msg, seq) = addseq -> \n  (|||i:{1..n-1}@(c[0 + i]!prepre.seq.msg -> Skip)); \n  (|||i:{1..n-1}@(c[0 + i]!pre.seq.msg -> Skip)); \n  CCC2(msg,seq,0);\n\n/*@Process: CCC2\n  In CCC2:\n  1. The CCC listens for prepare message from other nodes and increment the counter.\n  2. Once the message has been received 2*f+1 times, the CCC listens for com message from other nodes. \n  3. After that, the CCC moves to the CCC3 state.\n\n*/\nCCC2(msg,seq,cnt) = if(cnt < 2*f+1) {\n  []i: {0..n-1}@(c[i * n + 0]?pre.seq.msg -> CCC2(msg, seq, cnt + 1))\n} else {\n  []i: {0..n-1}@(c[i * n + 0]?com.seq.msg -> Skip); CCC3(msg,seq,0)\n};\n\n/*@Process: CCC3\n  \n   In CCC3:\n   1. the CCC listens for com or prepare message from other nodes, and if com message is received, it increase the counter, otherwise, it ignores it.\n  2. Once the com message has been received 2*f+1 times, the CCC performs an update action, sends the original msg to the Execution node, and returns to its initial state.\n\n*/\nCCC3(msg,seq,cnt) = if(cnt < 2*f+1) {\n  ([]i: {0..n - 1}@(c[i * n + 0]?com.seq.msg -> CCC3(msg, seq, cnt + 1)))\n  []\n  ([]i: {0..n - 1}@(c[i * n + 0]?pre.other1.other2 -> CCC3(msg, seq, cnt)))\n} else {\n  update -> rep[0]!msg -> CCC()\n};\n\n/*@Process: OCC\n   The process OCC of tactical data link can be described as:\n   - It may receive communication message from any CCC and ignore it\n   - 1. The OCC may receives a pre-prepare message from corresponding CCC.\n     2. It receives and match all prepare messages from all nodes and proceeds the next phase. \n*/\nOCC(id) = (\n  []i:{0..n-1}@c[i*n+id]?com.other1.other2 -> OCC(id) \n  [] \n  c[0+id]?prepre.seq.msg -> Skip\n); (|||i: {0..n - 1}@c[id*n+i]?pre.seq.msg -> OCC2(id,msg,seq,0));\n\n/*@Process: OCC2\n  In the OCC2 process:\n  1. the OCC listens for prepare message from others channels and increment the counter if receive one message.\n  2. When it receives 2f+1 prepare messages (including its own), the OCC listens for com message from other nodes. \n  3. After that, the OCC moves to the OCC3 state.\n*/\nOCC2(id,msg,seq,cnt) = if(cnt <2*f+1) {\n  [] i:{0..n- 1}@c[i * n + id]?pre.seq.msg -> OCC2(id, msg, seq, cnt + 1)\n} else {\n  (|||i : {0..n - 1}@c[id * n + i]?com.seq.msg -> Skip); OCC3(id, msg, seq, 0)\n};\n\n/*@Process: OCC3\n  In the OCC3 state:\n  1. the OCC listens for com or prepare message from others, if the com message is received, increment the counter, otherwise, ignore the message.\n  2. Once the message has been received 2*f+1 times, the OCC performs an update action, sends the original msg to the Execution node, and returns to its initial state.\n*/\nOCC3(id,msg,seq,cnt) = if(cnt < 2*f+1) {\n ([]i:{0..n - 1}@c[i * n + id]?com.seq.msg -> OCC3(id, msg, seq, cnt + 1))\n []\n ([]i:{0..n - 1}@c[i * n + id]?pre.other1.other2 ->  OCC3(id, msg, seq, cnt))\n} else {\n  update -> rep[id]!msg -> OCC(id)\n};\n\n/*@Process: OCCF\n   The model introduces the betray node OCCF, that continues to receive other channel messages but does not respond to them, indicating that the command center has been destroyed by the enemy.\n*/\nOCCF(id) = []i:{0..n - 1}@c[i * n + id]?other.other1.other2 -> OCCF(id);\n\n/*@Process: BF\n  The model consists of one execution node, one Chief Command Center, n Operation Command Centers, among the n OCC, only R of them don't betray\n*/\nBF() = EN() ||| CCC() ||| (|||i:{1..R-1}@OCC(i)) ||| (|||j:{R..n-1}@OCCF(j));",
        "property_desc": [
            "The protocol is deadlock-free",
            "Liveness: the protocol will eventually finish",
            "Data consistency: all nodes see the same and correct data"
        ],
        "properties": [
            "#assert BF deadlockfree;",
            "#assert BF |= <>finish;",
            "#define Consistency(bf[0]==bf[1] && bf[1]==bf[2]);\n#assert BF |= <>(finish -> Consistency);"
        ],
        "processes": [
            {
                "name": "EN",
                "description": "Execution Node (EN):\n  1. The EN initially waits to receive a message from CCC.\n  2. Upon receiving a message, the EN proceeds to the waiting state,",
                "pat_code": "EN() = []msg: {1..m}@req!msg -> ENW(msg, 0);"
            },
            {
                "name": "ENW",
                "description": "1. In the waiting state, the EN iteratively listens for the same message from the CCC for up to 2*f+1 times.\n 2. Each time the message is received, the counter is increased.\n3.  Once the message has been received 2*f+1 times, the EN performs a finish action and returns to its initial state.",
                "pat_code": "ENW(msg, cnt) = if(cnt < 2 * f + 1) {\n  []i:{0..n-1}@rep[i]?msg -> ENW(msg, cnt + 1)\n} else {\n  finish -> EN()\n};"
            },
            {
                "name": "CCC",
                "description": "The Chief Command Center (CCC)\n  The CCC starts by waiting to receive a message from the execution node and proceeds to next state with the message and current message sequence.",
                "pat_code": "CCC() = req?msg -> CCC1(msg,curseq);"
            },
            {
                "name": "CCC1",
                "description": "In CCC1:\n  1. the sequence number is incremented by addseq. \n  2. It then sends \"prepre\" and \"pre\" messages sequentially along with the sequence number and original message msg to all other OCC nodes \n 3. Then, it proceeds to the next state.",
                "pat_code": "CCC1(msg, seq) = addseq -> \n  (|||i:{1..n-1}@(c[0 + i]!prepre.seq.msg -> Skip)); \n  (|||i:{1..n-1}@(c[0 + i]!pre.seq.msg -> Skip)); \n  CCC2(msg,seq,0);"
            },
            {
                "name": "CCC2",
                "description": "In CCC2:\n  1. The CCC listens for prepare message from other nodes and increment the counter.\n  2. Once the message has been received 2*f+1 times, the CCC listens for com message from other nodes. \n  3. After that, the CCC moves to the CCC3 state.",
                "pat_code": "CCC2(msg,seq,cnt) = if(cnt < 2*f+1) {\n  []i: {0..n-1}@(c[i * n + 0]?pre.seq.msg -> CCC2(msg, seq, cnt + 1))\n} else {\n  []i: {0..n-1}@(c[i * n + 0]?com.seq.msg -> Skip); CCC3(msg,seq,0)\n};"
            },
            {
                "name": "CCC3",
                "description": "In CCC3:\n   1. the CCC listens for com or prepare message from other nodes, and if com message is received, it increase the counter, otherwise, it ignores it.\n  2. Once the com message has been received 2*f+1 times, the CCC performs an update action, sends the original msg to the Execution node, and returns to its initial state.",
                "pat_code": "CCC3(msg,seq,cnt) = if(cnt < 2*f+1) {\n  ([]i: {0..n - 1}@(c[i * n + 0]?com.seq.msg -> CCC3(msg, seq, cnt + 1)))\n  []\n  ([]i: {0..n - 1}@(c[i * n + 0]?pre.other1.other2 -> CCC3(msg, seq, cnt)))\n} else {\n  update -> rep[0]!msg -> CCC()\n};"
            },
            {
                "name": "OCC",
                "description": "The process OCC of tactical data link can be described as:\n   - It may receive communication message from any CCC and ignore it\n   - 1. The OCC may receives a pre-prepare message from corresponding CCC.\n     2. It receives and match all prepare messages from all nodes and proceeds the next phase.",
                "pat_code": "OCC(id) = (\n  []i:{0..n-1}@c[i*n+id]?com.other1.other2 -> OCC(id) \n  [] \n  c[0+id]?prepre.seq.msg -> Skip\n); (|||i: {0..n - 1}@c[id*n+i]?pre.seq.msg -> OCC2(id,msg,seq,0));"
            },
            {
                "name": "OCC2",
                "description": "In the OCC2 process:\n  1. the OCC listens for prepare message from others channels and increment the counter if receive one message.\n  2. When it receives 2f+1 prepare messages (including its own), the OCC listens for com message from other nodes. \n  3. After that, the OCC moves to the OCC3 state.",
                "pat_code": "OCC2(id,msg,seq,cnt) = if(cnt <2*f+1) {\n  [] i:{0..n- 1}@c[i * n + id]?pre.seq.msg -> OCC2(id, msg, seq, cnt + 1)\n} else {\n  (|||i : {0..n - 1}@c[id * n + i]?com.seq.msg -> Skip); OCC3(id, msg, seq, 0)\n};"
            },
            {
                "name": "OCC3",
                "description": "In the OCC3 state:\n  1. the OCC listens for com or prepare message from others, if the com message is received, increment the counter, otherwise, ignore the message.\n  2. Once the message has been received 2*f+1 times, the OCC performs an update action, sends the original msg to the Execution node, and returns to its initial state.",
                "pat_code": "OCC3(id,msg,seq,cnt) = if(cnt < 2*f+1) {\n ([]i:{0..n - 1}@c[i * n + id]?com.seq.msg -> OCC3(id, msg, seq, cnt + 1))\n []\n ([]i:{0..n - 1}@c[i * n + id]?pre.other1.other2 ->  OCC3(id, msg, seq, cnt))\n} else {\n  update -> rep[id]!msg -> OCC(id)\n};"
            },
            {
                "name": "OCCF",
                "description": "The model introduces the betray node OCCF, that continues to receive other channel messages but does not respond to them, indicating that the command center has been destroyed by the enemy.",
                "pat_code": "OCCF(id) = []i:{0..n - 1}@c[i * n + id]?other.other1.other2 -> OCCF(id);"
            },
            {
                "name": "BF",
                "description": "The model consists of one execution node, one Chief Command Center, n Operation Command Centers, among the n OCC, only R of them don't betray",
                "pat_code": "BF() = EN() ||| CCC() ||| (|||i:{1..R-1}@OCC(i)) ||| (|||j:{R..n-1}@OCCF(j));"
            }
        ],
        "global_definition": "#define R 2;\n#define n 5;\n#define m 2;\n#define f 2;\n\nenum{prepre, pre, com};\n\nchannel c[n*n] 0;\nchannel req 0;\nchannel rep[n] 0;\n\nvar size[n*n];\nvar curseq;\nvar bf[n];\nvar stat[n];",
        "path": "handwrite/Tactical Data Link.csp"
    },
    {
        "name": "TESAC",
        "tags": [
            "Protocol"
        ],
        "use_non_container_lib": false,
        "description": "TESAC is a data access control model that can largely reduce many of the problems that plague the security and efficiency of cloud computing.\n  TESAC is an access control model based on user's personal data, where the cloud service provider records each user's personal data to facilitate the determination of the purpose for which the user wants to access the cloud service. \n  The mechanism consists of the following three main entities:Cloud Service Provider, Data Owner and User.",
        "pat_code": "channel ComUS 0;\nchannel ComUD 0;\nchannel ComDS 0;\n\n#define s 1;\n#define c 1;\nvar s_m=0;\nvar c_m=0;\nvar n=0;\nvar completement=false;\nvar PRUSR_1;\nvar PUSP_1;\nvar PUOWN_1;\nvar PROWN_1;\nvar PUUSR_1;\nvar PRSP_1;\nvar puown_get;\nvar s_c_get;\nvar data_get;\nvar req_sc_get;\nvar certificate_get;\nvar k;\n\nenum {req_data,req_s_c,cof,ack,data};\nenum {puusr,puown,pusp,pui};\nenum {prusr,prown,prsp,pri};\n\n#define getpuown(PUUSR,PRSP,PRUSR,PUSP)\n{\n\tif(PUUSR==PRUSR&&PRSP==PUSP){\n\t\tpuown_get=true;}\n};\n\n#define getsc(PUUSR,PROWN,PRUSR,PUOWN)\n{\n\tif(PUUSR==PRUSR&&PROWN==PUOWN){\n\t\ts_c_get=true;s_m=1;c_m=1;}\n};\n\n#define getdata(PUUSR,PRSP,PRUSR,PUSP,S,S_m)\n{\n\tif(PUUSR==PRUSR&&PRSP==PUSP&&S==S_m){\n\t\tdata_get=true;}\n};\n\n#define getreqsc(PUOWN,PRUSR,PROWN,PUUSR)\n{\n\tif(PUOWN==PROWN&&PRUSR==PUUSR){\n\t\treq_sc_get=true;}\n};\n\n#define getc(PUSP,PRUSR,PRSP,PUUSR)\n{\n\tif(PUSP==PRSP&&PRUSR==PUUSR){\n\t\tcertificate_get=true;\n\t\t}\n};\n\n/*@Process: User\n  The user who wants to get the data first sends a data request message to the cloud server through the channel ComUS and then waits to receive the message back from the cloud server. \n  The cloud server encrypts the public key PUOWN of the data owner and sends it to the user through the channel ComUS.\n  After receiving the encrypted message packet, the process needs to decrypt it.\n  After knowing the public key of the data owner, a message requesting the key and authentication certificate is sent to the data owner, and then an encrypted message packet containing (s,c) is received from the data owner.\n  Then User performs the decryption. \n  After getting the key s and authentication certificate c, the user process sends c encrypted to the cloud server and waits for the requested packet to be sent.\n*/\nUser()=ComUS!req_data->ComUS?PUUSR.PRSP.PUOWN{call(getpuown,PUUSR,PRSP,PRUSR_1,PUSP_1)}->\n\t\tif(puown_get==true){ComUD!puown.prusr.req_s_c->ComUD?PUUSR.PROWN.S.C->{call(getsc,PUUSR,PROWN,PRUSR_1,PUOWN_1)}->\n\t\t\tif(s_c_get==true){ComUS!pusp.prusr.c_m->ComUS?PUUSR.PRSP.S.Data->User()}else{User()}}\n\t\telse{User()};\n/*@Process: Owner\n  When a user requests data from this data owner from the cloud server, only then does the data owner go online and perform the appropriate action.\n  When the process receives a request message from the user process for the key s and authentication certificate c, it first decrypts it. \n  Then the Owner process sends a message to the server process to authenticate the user's identity and receives a feedback message. \n  If the identity is legitimate, it replies to the user process with an encrypted (s,c) message packet.\n*/\t\t\nOwner()=ComUD?PUOWN.PRUSR.Req_s_c{call(getreqsc,PUOWN,PRUSR,PROWN_1,PUUSR_1)}->\n\t\tif(req_sc_get==true){ComDS!cof->ComDS?Ack.K->\n\t\t\tif(K==1){ComUD!puusr.prown.s.c->Owner()}else{Owner()}}\n\t\telse{Owner()};\n/*@Process: Server\n  The Server process is responsible for authorization of users, maintenance of user profiles, and authentication of user identities.\n  First, the Server process receives the data request message from the user and returns the encrypted public key of the data owner. \n  The process receives a message from the data owner confirming the user's authorization and sends the feedback to the data owner. \n  Next, the Server receives the authentication certificate encrypted message packet and, if c is a valid certificate, sends the user's requested message encrypted and processed to the user.\n*/\t\t\nServer()=Initialization{n=0;}->ComUS?Req_data->ComUS!puusr.prsp.puown{n=1;}->ComDS?Cof->\n\t\t\tif(n==1){{k=1}->ComDS!ack.k{n=2}->ComUS?PUSP.PRUSR.C{call(getc,PUSP,PRUSR,PRSP_1,PUUSR_1)}->\n\t\t\t\tif(certificate_get==true){ComUS!puusr.prsp.s.data{n=3;completement=true;}->Server()}else{ComDS!ack.k->Server()}}\n\t\t\telse{Server()};\n/*Server()=Initialization{n=0;}->ComUS?Req_data->ComUS!puusr.prsp.puown{n=1;}->ComDS?Cof->\n\t\t\tif(n==1){k=1;ComDS!ack.k{n=2}->ComUS?PUSP.PRUSR.C{call(getc,PUSP,PRUSR,PRSP_1,PUUSR_1)}->\n\t\t\t\tif(certificate_get==true){ComUS!puusr.prsp.s.data{n=3;completement=true;}->Server()}else{ComDS!ack.k->Server()}}\n\t\t\telse{Server()};*/\n/*@Process: System\n  The overall modeling is executed concurrently by three processes, User, Owner and Server.\n*/\nSystem()=User()||Owner()||Server();",
        "property_desc": [
            "The system is deadlock-free."
        ],
        "properties": [
            "#assert System() deadlockfree;"
        ],
        "processes": [
            {
                "name": "User",
                "description": "The user who wants to get the data first sends a data request message to the cloud server through the channel ComUS and then waits to receive the message back from the cloud server. \n  The cloud server encrypts the public key PUOWN of the data owner and sends it to the user through the channel ComUS.\n  After receiving the encrypted message packet, the process needs to decrypt it.\n  After knowing the public key of the data owner, a message requesting the key and authentication certificate is sent to the data owner, and then an encrypted message packet containing (s,c) is received from the data owner.\n  Then User performs the decryption. \n  After getting the key s and authentication certificate c, the user process sends c encrypted to the cloud server and waits for the requested packet to be sent.",
                "pat_code": "User()=ComUS!req_data->ComUS?PUUSR.PRSP.PUOWN{call(getpuown,PUUSR,PRSP,PRUSR_1,PUSP_1)}->\n\t\tif(puown_get==true){ComUD!puown.prusr.req_s_c->ComUD?PUUSR.PROWN.S.C->{call(getsc,PUUSR,PROWN,PRUSR_1,PUOWN_1)}->\n\t\t\tif(s_c_get==true){ComUS!pusp.prusr.c_m->ComUS?PUUSR.PRSP.S.Data->User()}else{User()}}\n\t\telse{User()};"
            },
            {
                "name": "Owner",
                "description": "When a user requests data from this data owner from the cloud server, only then does the data owner go online and perform the appropriate action.\n  When the process receives a request message from the user process for the key s and authentication certificate c, it first decrypts it. \n  Then the Owner process sends a message to the server process to authenticate the user's identity and receives a feedback message. \n  If the identity is legitimate, it replies to the user process with an encrypted (s,c) message packet.",
                "pat_code": "Owner()=ComUD?PUOWN.PRUSR.Req_s_c{call(getreqsc,PUOWN,PRUSR,PROWN_1,PUUSR_1)}->\n\t\tif(req_sc_get==true){ComDS!cof->ComDS?Ack.K->\n\t\t\tif(K==1){ComUD!puusr.prown.s.c->Owner()}else{Owner()}}\n\t\telse{Owner()};"
            },
            {
                "name": "Server",
                "description": "The Server process is responsible for authorization of users, maintenance of user profiles, and authentication of user identities.\n  First, the Server process receives the data request message from the user and returns the encrypted public key of the data owner. \n  The process receives a message from the data owner confirming the user's authorization and sends the feedback to the data owner. \n  Next, the Server receives the authentication certificate encrypted message packet and, if c is a valid certificate, sends the user's requested message encrypted and processed to the user.",
                "pat_code": "Server()=Initialization{n=0;}->ComUS?Req_data->ComUS!puusr.prsp.puown{n=1;}->ComDS?Cof->\n\t\t\tif(n==1){{k=1}->ComDS!ack.k{n=2}->ComUS?PUSP.PRUSR.C{call(getc,PUSP,PRUSR,PRSP_1,PUUSR_1)}->\n\t\t\t\tif(certificate_get==true){ComUS!puusr.prsp.s.data{n=3;completement=true;}->Server()}else{ComDS!ack.k->Server()}}\n\t\t\telse{Server()};\n/*Server()=Initialization{n=0;}->ComUS?Req_data->ComUS!puusr.prsp.puown{n=1;}->ComDS?Cof->\n\t\t\tif(n==1){k=1;ComDS!ack.k{n=2}->ComUS?PUSP.PRUSR.C{call(getc,PUSP,PRUSR,PRSP_1,PUUSR_1)}->\n\t\t\t\tif(certificate_get==true){ComUS!puusr.prsp.s.data{n=3;completement=true;}->Server()}else{ComDS!ack.k->Server()}}\n\t\t\telse{Server()};*/"
            },
            {
                "name": "System",
                "description": "The overall modeling is executed concurrently by three processes, User, Owner and Server.",
                "pat_code": "System()=User()||Owner()||Server();"
            }
        ],
        "global_definition": "channel ComUS 0;\nchannel ComUD 0;\nchannel ComDS 0;\n\n#define s 1;\n#define c 1;\nvar s_m=0;\nvar c_m=0;\nvar n=0;\nvar completement=false;\nvar PRUSR_1;\nvar PUSP_1;\nvar PUOWN_1;\nvar PROWN_1;\nvar PUUSR_1;\nvar PRSP_1;\nvar puown_get;\nvar s_c_get;\nvar data_get;\nvar req_sc_get;\nvar certificate_get;\nvar k;\n\nenum {req_data,req_s_c,cof,ack,data};\nenum {puusr,puown,pusp,pui};\nenum {prusr,prown,prsp,pri};\n\n#define getpuown(PUUSR,PRSP,PRUSR,PUSP)\n{\n\tif(PUUSR==PRUSR&&PRSP==PUSP){\n\t\tpuown_get=true;}\n};\n\n#define getsc(PUUSR,PROWN,PRUSR,PUOWN)\n{\n\tif(PUUSR==PRUSR&&PROWN==PUOWN){\n\t\ts_c_get=true;s_m=1;c_m=1;}\n};\n\n#define getdata(PUUSR,PRSP,PRUSR,PUSP,S,S_m)\n{\n\tif(PUUSR==PRUSR&&PRSP==PUSP&&S==S_m){\n\t\tdata_get=true;}\n};\n\n#define getreqsc(PUOWN,PRUSR,PROWN,PUUSR)\n{\n\tif(PUOWN==PROWN&&PRUSR==PUUSR){\n\t\treq_sc_get=true;}\n};\n\n#define getc(PUSP,PRUSR,PRSP,PUUSR)\n{\n\tif(PUSP==PRSP&&PRUSR==PUUSR){\n\t\tcertificate_get=true;\n\t\t}\n};",
        "path": "handwrite/TESAC.csp"
    },
    {
        "name": "TFTP",
        "tags": [
            "Protocol"
        ],
        "use_non_container_lib": false,
        "description": "TFTP is a simple file transfer protocol that allows clients to get files from or put files into a remote host. \n  One of its main uses is the transfer of boot files when network device nodes boot from a LAN.",
        "pat_code": "channel chan_CS 0;\nchannel chan_SR 0;\nchannel fake 0;\nchannel intercept 0;\nchannel reflect 0;\nchannel client_fake_session 0;\nchannel server_fake_session 0;\n\n#define RRQ 1;\n#define WRQ 2;\n#define WDATA 3;\n#define RDATA 3;\n#define WAck 4;\n#define RAck 4;\n#define ERR 5;\n#define Read 1;\n#define Write 2;\n#define zero 0;\n#define RDataNum 3;\n#define WDataNum 3;\n\n/*@Process: ClientIterRecv\n  The ClientIterRecv process represents the behavior of the client to receive data from the server in a loop. \n  The server sends a data request to the client, then the client sends an acknowledgement request to the server, and then the server sends the next data request to the client, so that the client loops through multiple times to receive the data sent from the server.\n*/\nClientIterRecv(x,y)=chan_CS?RDATA.x.y-> chan_CS!RAck.y-> if(x>y){ClientIterRecv (x,y+1)} else {Skip};\n/*@Process: ClientIterSend\n  When the client sends a write request to the server, the server will send a confirmation request to the client, and the client will send a data request to the server after receiving the confirmation request. \n  In general, larger files will be divided into several data blocks for sending, so the client will cycle through the data sending several times.\n*/\nClientIterSend(x,y)=chan_CS!WDATA.x.y-> chan_CS?WAck.y-> if(x>y){ClientIterSend (x,y+1)} else {Skip};\n/*@Process: Client\n  The Client process mainly portrays the client's cyclic data-receiving behavior and the client's cyclic data-sending behavior.\n  After the client sends a request to the server to read the file, if there is an error in the network, it will return to the initial state of the client.\n  Otherwise it will carry out the behavior of receiving the file in a loop, that is the ClientIterRecv process, and when the file has been received, the state returns to the initial state of the client.\n  Or, when the client sends a write file request to the server, if there is a problem with the system, the state will return to the initial state of the client.\n  Otherwise the client will receive an acknowledgement message from the server, and then the client starts to send data requests to the server in a loop, that is the ClientIterSend process, and when the data requests are sent, the state returns to the initial state of the client.\n*/\nClient()=chan_CS!RRQ->ClientIterRecv (RDataNum,1);Client() [] chan_CS!WRQ->chan_CS?WAck.zero-> ClientIterSend(WDataNum,1);Client();\n/*@Process: ResourceIterSend\n  When the server sends a read request to the resource component, the resource component sends a data request to the server, and then the server sends an acknowledgement request to the resource component, which receives the acknowledgement request and then sends the next data request to the server. \n  The resource component receives the confirmation request and sends the next data request to the server.\n*/\nResourceIterSend(x,y)=chan_SR!RDATA.x.y-> chan_SR?RAck.y-> if(x>y){ResourceIterSend(x,y+1)} else {Skip};\n/*@Process: ResourceIterRecv\n  Resource Component Receive Data represents the behavior of the server side to send file data to the resource component cyclically. \n  The server sends a data request to the resource component, then the resource component sends an acknowledgement request to the server, and then the server sends the next data request to the resource component, so that the resource component receives the data sent by the server in a loop.\n*/\nResourceIterRecv(x,y)=chan_SR?WDATA.x.y-> chan_SR!WAck.y-> if(x>y){ResourceIterRecv(x,y+1)} else {Skip};\n/*@Process: Resource\n  The overall modeling of the resource component mainly consists of sending data to the server and receiving data from the server behavior.\n  When the server sends a read request to the resource component, the resource component looks for the file being read inside the file directory.\n  If the file does not exist, it returns an error message to the server and the file transfer is terminated. If the file exists, the resource group will divide the file into multiple data blocks, and then send the file data to the server in a loop for several times until all the data blocks have been transferred, i.e. the ResourceIterSend process.\n  When the server sends a write request to the resource component, the resource component will check the local storage space.\n  If the storage space is not sufficient, the resource component will send an error request to the server and the file transfer will be terminated. If there is enough storage space, the resource component sends an acknowledgement message to the server and prepares to receive the data until all the data has been transferred to the resource component, i.e. the ResourceIterRecv process.\n*/\nResource()=chan_SR?Read->ResourceIterSend(RDataNum,1); Resource() [] chan_SR?Write->chan_SR!WAck.zero->ResourceIterRecv(WDataNum,1);Resource();\n/*@Process: ServerIterRead\n  The server receives the data request sent by the resource component and then sends the data request to the client. \n  Next the server receives the acknowledgement request sent by the client and sends the acknowledgement request to the resource component.\n*/\nServerIterRead(x,y)=chan_SR?RDATA.x.y->chan_CS!RDATA.x.y->chan_CS?RAck.y->chan_SR!RAck.y->if(x>y){ServerIterRead(x,y+1)}else{Skip};\n/*@Process: ServerIterWrite\n  The server receives the data request sent by the client and sends the data request to the resource component. \n  Next the server receives the acknowledgement request sent by the resource component and sends the acknowledgement request to the client.\n*/\nServerIterWrite(x,y)=chan_CS?WDATA.x.y->chan_SR!WDATA.x.y->chan_SR?WAck.y->chan_CS!WAck.y->if(x>y){ServerIterWrite(x,y+1)}else{Skip};\n/*@Process: Server\n  There are two main actions on the server side, reading file operations and writing file operations.\n  As for reading file operations, first the client sends a request to the server to read the file, and after the server receives the request, it sends a request to the resource component to read the file. \n  If the file exists, the process executes the ServerIterRead process, that is, the resource component will send the file data to the server, and after the server receives the file data, it will send the data request to the client.\n  As for writing file operations, first the client sends a request to the server to write the file, the server receives the request and sends a write request to the resource component, which checks whether the current conditions allow it. \n  If the conditions allow it, the resource component sends a confirmation request to the server, and then the server sends a confirmation request to the client.\n  After the client receives the confirmation request, it executes the ServerIterWrite process.\n*/\nServer()=chan_CS?RRQ->chan_SR!Read->ServerIterRead(RDataNum,1);Server() [] chan_CS?WRQ->chan_SR!Read->chan_SR?WAck.zero->chan_CS!WAck.zero->ServerIterWrite(WDataNum,1);Server();\n/*@Process: System\n  The System process consists of Client, Server and Resource.\n*/\nSystem() = Client() || Server() || Resource();",
        "property_desc": [
            "The system is deadlock-free."
        ],
        "properties": [
            "#assert System() deadlockfree;"
        ],
        "processes": [
            {
                "name": "ClientIterRecv",
                "description": "The ClientIterRecv process represents the behavior of the client to receive data from the server in a loop. \n  The server sends a data request to the client, then the client sends an acknowledgement request to the server, and then the server sends the next data request to the client, so that the client loops through multiple times to receive the data sent from the server.",
                "pat_code": "ClientIterRecv(x,y)=chan_CS?RDATA.x.y-> chan_CS!RAck.y-> if(x>y){ClientIterRecv (x,y+1)} else {Skip};"
            },
            {
                "name": "ClientIterSend",
                "description": "When the client sends a write request to the server, the server will send a confirmation request to the client, and the client will send a data request to the server after receiving the confirmation request. \n  In general, larger files will be divided into several data blocks for sending, so the client will cycle through the data sending several times.",
                "pat_code": "ClientIterSend(x,y)=chan_CS!WDATA.x.y-> chan_CS?WAck.y-> if(x>y){ClientIterSend (x,y+1)} else {Skip};"
            },
            {
                "name": "Client",
                "description": "The Client process mainly portrays the client's cyclic data-receiving behavior and the client's cyclic data-sending behavior.\n  After the client sends a request to the server to read the file, if there is an error in the network, it will return to the initial state of the client.\n  Otherwise it will carry out the behavior of receiving the file in a loop, that is the ClientIterRecv process, and when the file has been received, the state returns to the initial state of the client.\n  Or, when the client sends a write file request to the server, if there is a problem with the system, the state will return to the initial state of the client.\n  Otherwise the client will receive an acknowledgement message from the server, and then the client starts to send data requests to the server in a loop, that is the ClientIterSend process, and when the data requests are sent, the state returns to the initial state of the client.",
                "pat_code": "Client()=chan_CS!RRQ->ClientIterRecv (RDataNum,1);Client() [] chan_CS!WRQ->chan_CS?WAck.zero-> ClientIterSend(WDataNum,1);Client();"
            },
            {
                "name": "ResourceIterSend",
                "description": "When the server sends a read request to the resource component, the resource component sends a data request to the server, and then the server sends an acknowledgement request to the resource component, which receives the acknowledgement request and then sends the next data request to the server. \n  The resource component receives the confirmation request and sends the next data request to the server.",
                "pat_code": "ResourceIterSend(x,y)=chan_SR!RDATA.x.y-> chan_SR?RAck.y-> if(x>y){ResourceIterSend(x,y+1)} else {Skip};"
            },
            {
                "name": "ResourceIterRecv",
                "description": "Resource Component Receive Data represents the behavior of the server side to send file data to the resource component cyclically. \n  The server sends a data request to the resource component, then the resource component sends an acknowledgement request to the server, and then the server sends the next data request to the resource component, so that the resource component receives the data sent by the server in a loop.",
                "pat_code": "ResourceIterRecv(x,y)=chan_SR?WDATA.x.y-> chan_SR!WAck.y-> if(x>y){ResourceIterRecv(x,y+1)} else {Skip};"
            },
            {
                "name": "Resource",
                "description": "The overall modeling of the resource component mainly consists of sending data to the server and receiving data from the server behavior.\n  When the server sends a read request to the resource component, the resource component looks for the file being read inside the file directory.\n  If the file does not exist, it returns an error message to the server and the file transfer is terminated. If the file exists, the resource group will divide the file into multiple data blocks, and then send the file data to the server in a loop for several times until all the data blocks have been transferred, i.e. the ResourceIterSend process.\n  When the server sends a write request to the resource component, the resource component will check the local storage space.\n  If the storage space is not sufficient, the resource component will send an error request to the server and the file transfer will be terminated. If there is enough storage space, the resource component sends an acknowledgement message to the server and prepares to receive the data until all the data has been transferred to the resource component, i.e. the ResourceIterRecv process.",
                "pat_code": "Resource()=chan_SR?Read->ResourceIterSend(RDataNum,1); Resource() [] chan_SR?Write->chan_SR!WAck.zero->ResourceIterRecv(WDataNum,1);Resource();"
            },
            {
                "name": "ServerIterRead",
                "description": "The server receives the data request sent by the resource component and then sends the data request to the client. \n  Next the server receives the acknowledgement request sent by the client and sends the acknowledgement request to the resource component.",
                "pat_code": "ServerIterRead(x,y)=chan_SR?RDATA.x.y->chan_CS!RDATA.x.y->chan_CS?RAck.y->chan_SR!RAck.y->if(x>y){ServerIterRead(x,y+1)}else{Skip};"
            },
            {
                "name": "ServerIterWrite",
                "description": "The server receives the data request sent by the client and sends the data request to the resource component. \n  Next the server receives the acknowledgement request sent by the resource component and sends the acknowledgement request to the client.",
                "pat_code": "ServerIterWrite(x,y)=chan_CS?WDATA.x.y->chan_SR!WDATA.x.y->chan_SR?WAck.y->chan_CS!WAck.y->if(x>y){ServerIterWrite(x,y+1)}else{Skip};"
            },
            {
                "name": "Server",
                "description": "There are two main actions on the server side, reading file operations and writing file operations.\n  As for reading file operations, first the client sends a request to the server to read the file, and after the server receives the request, it sends a request to the resource component to read the file. \n  If the file exists, the process executes the ServerIterRead process, that is, the resource component will send the file data to the server, and after the server receives the file data, it will send the data request to the client.\n  As for writing file operations, first the client sends a request to the server to write the file, the server receives the request and sends a write request to the resource component, which checks whether the current conditions allow it. \n  If the conditions allow it, the resource component sends a confirmation request to the server, and then the server sends a confirmation request to the client.\n  After the client receives the confirmation request, it executes the ServerIterWrite process.",
                "pat_code": "Server()=chan_CS?RRQ->chan_SR!Read->ServerIterRead(RDataNum,1);Server() [] chan_CS?WRQ->chan_SR!Read->chan_SR?WAck.zero->chan_CS!WAck.zero->ServerIterWrite(WDataNum,1);Server();"
            },
            {
                "name": "System",
                "description": "The System process consists of Client, Server and Resource.",
                "pat_code": "System() = Client() || Server() || Resource();"
            }
        ],
        "global_definition": "channel chan_CS 0;\nchannel chan_SR 0;\nchannel fake 0;\nchannel intercept 0;\nchannel reflect 0;\nchannel client_fake_session 0;\nchannel server_fake_session 0;\n\n#define RRQ 1;\n#define WRQ 2;\n#define WDATA 3;\n#define RDATA 3;\n#define WAck 4;\n#define RAck 4;\n#define ERR 5;\n#define Read 1;\n#define Write 2;\n#define zero 0;\n#define RDataNum 3;\n#define WDataNum 3;",
        "path": "handwrite/TFTP.csp"
    },
    {
        "name": "Ticket-Based",
        "tags": [
            "IoT identity authentication solution"
        ],
        "use_non_container_lib": false,
        "description": "Ticket-Based IoT authentication solution is to establish a trust relationship between sensor devices and mobile devices used by external network users to access data by completing two-way authentication between sensor devices and mobile devices.\n  It has four roles: \n\t- Sensor Node(SN): sensor devices that provide sensor data belong to network A.\n\t- Sensor Authentication Server(SAS): the authentication server in network A manages the authentication and authorization of sensor nodes in network A.\n\t- Mobile Node(MN): mobile devices that need to access data from sensor nodes belong to Network B.\n  \t- Mobile Authentication Server(MAS): the authentication server in network B manages the authentication and authorization of mobile nodes in network B.",
        "pat_code": "channel ComMS 0;\nchannel ComMSA 0;    \nchannel ComMASA 0; \nchannel FakeM 0;\nchannel FakeS 0;\nchannel FakeMA 0; \nchannel FakeSA 0;\n\nenum {IDMN, IDMAS, IDSN, IDSAS, IDMNI}; \nenum {KSAS, KMAS, KAS, KMASI};\nenum {Request};\nenum {Data, FakeData};\n\nvar TempKSAS_SAS;\nvar TempKAS_SAS;\nvar TempKMAS_MAS; \nvar TempKAS_MAS;\n\nvar DHPbkSAS = 1;   \nvar DHPvkSAS = 1;  \nvar DHPbkMAS = 2; \nvar DHPvkMAS = 2; \nvar DHPbkI = -2;\nvar DHPvkI = -2; \nvar SkSAS = 0;\nvar SkMAS = 0;\n\nvar check_permission_result = false; \nvar data_acquisition_success = false; \nvar data_leakage_success = false;\nvar data_faking_success = false;\n\n#define CheckPermission(idmn, idsn){ \n\tif (idmn == IDMN){\n\t\tcheck_permission_result = true;\n\t} \n\telse{\n\t\tcheck_permission_result = false;\n\t} \n};\n\n#define DH_SAS(dhPbk){\n\tSkSAS = dhPbk + DHPvkSAS;\n};\n\n#define DH_MAS(dhPbk){\n\tSkMAS = dhPbk + DHPvkMAS;\n};\n\n#define UpdateDHKeyPairSAS(id){\n\tif (DHPbkSAS < 50 && DHPvkSAS < 50){\n\t\tDHPbkSAS = DHPbkSAS + 2; \n\t\tDHPvkSAS = DHPvkSAS + 2;\n\t} \n};\n\n#define UpdateDHKeyPairMAS(id){\n\tif (DHPbkMAS < 50 && DHPvkMAS < 50){\n\t\tDHPbkMAS = DHPbkMAS + 2; \n\t\tDHPvkMAS = DHPvkMAS + 2;\n\t} \n};\n\n#define RetrieveKeySAS1(id){ \n\tif (id == IDSN){\n\t\tTempKSAS_SAS = KSAS;\n\t} \n};\n\n#define RetrieveKeySAS2(id){ \n\tif (id == IDMAS){\n\t\tTempKAS_SAS = KSAS;\n\t} \n};\n\n#define RetrieveKeyMAS1(id){ \n\tif (id == IDSAS){\n\t\tTempKAS_MAS = KMAS;\n\t} \n};\n\n#define RetrieveKeyMAS2(id){ \n\tif (id == IDMN){\n\t\tTempKMAS_MAS = KMAS;\n\t} \n\tif (id == IDMNI){\n\t\tTempKMAS_MAS = KMASI;\n\t}\n};\n\n/*@Process: MN\n  The MN's behavior is as follows:\n    1.First, send the IDs of MN and MAS to SN.\n    2.After receiving the SN reply, take out idSN1 and idSAS from the message and send it to SAS.\n    3.When receiving the message with MN's Ticket from SAS, tries to decrypt the Ticket with the key KMAS.\n    4.After successfully decrypting and obtaining the session key skMAS, the data request encrypted with the session key is sent to SN and waits for a response.\n*/\nMN() =\nComMS!IDMN.IDMAS -> ComMS?idsn1.idsas ->\nComMS?ksas.idmn.idmas.idsn2.idsn3 ->   \nComMSA!ksas.idmn.idmas.idsn2.idsn3 -> \nComMSA!KMAS.idsn1.idsas.IDMN ->\nComMSA?kmas.skmas.ksas2.sksas ->\n\tif (KMAS == kmas){\n\t\tComMS!ksas2.sksas ->ComMS!skmas.Request -> ComMS?sksas2.data -> \n\t\tif (skmas == sksas2){\n\t\t\tif (data == Data){\n\t\t\t\tgetRealData{data_acquisition_success = true; data_faking_success = false} -> MN()\n\t\t\t}\n\t\t\telse{\n\t\t\t\tgetFakeData{data_acquisition_success = true; data_faking_success = true} -> MN()\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfail1 -> MN()\n\t\t}\n\t}\n\telse{\n\t\tfail1 -> MN()\n\t};\n\n/*@Process: SN\n  The SN's behavior is as follows:\n    1.When receiving MSG1 from MN, in order to authenticate the identity and ensure that MN is a trusted data transmission object, MSG2 and MSG3 are generated and sent to MN.\n    2.After receiving the MSG8 of the Ticket with the SN, try to decrypt the message using the key KSAS.\n      -If the decryption is successful, and the subsequent data request received from the MN can be decrypted with the session key skSAS received in MSG8, it can be confirmed that the identity authentication process has been completed, and the data message MSGdata encrypted with the session key is transmitted to the MN. \n*/\nSN() =\nComMS?idmn.idmas -> ComMS!IDSN.IDSAS -> ComMS!KSAS.idmn.idmas.IDSN.IDSN ->\nComMS?ksas.sksas ->\n\tif (KSAS == ksas){\n\t\tComMS?skmas. request ->\n\t\tif (skmas == sksas){\n\t\t\tComMS!sksas.Data -> SN()\n\t\t}\n\t\telse{\n\t\t\tfail2 -> SN()\n\t\t}\n\t}\n\telse{\n\t\tfail2 -> SN()\n\t};\n\n/*@Process: SAS\n  The SAS's behavior is as follows:\n    1.After receiving MSG3 and MSG4 from MN, it extracts the symmetric key TempKSAS shared with SN based on the idSN2 in the plaintext part of MSG3, and tries to use this key to decrypt the encrypted part of MSG3.\n\t2.Check whether idSN1 and idSN2 in MSG3 are consistent, and check whether the node with ID idMN1 has the authority to access SN's data.\n\t3.After all checks are passed, the symmetric key TempKAS between the authentication server MAS with ID idMAS is taken out, the DH public key DHPbKSAS and the DH private key DHPvKSAS are generated, and then MSG5 is generated and sent to MAS together with MSG4.\n\t4.After receiving the MSG6 reply from MAS, use the previously retrieved key TempKAS to decrypt the message and compare idMN 1 in MSG3 with idMN3 in MSG6.\n\t5.Finally, the received DH public key dhPbKMAS and its own DH private key DHPvKSAS are used to generate the session key SKSAS, and the message MSG7 is generated and sent to MN.\n*/\nSAS() =\nComMSA?ksas.idmn1.idmas.idsn1.idsn2{call(RetrieveKeySAS1,idsn2)} -> ComMSA?kmas.idsn3.idsas.idmn2 ->\nif (TempKSAS_SAS == ksas){\n\t{call(CheckPermission,idmn1,idsn2)} ->\n\tif (idsn1 == idsn2&&check_permission_result == true){ \n\t\t{call(RetrieveKeySAS2,idmas)} ->{call(UpdateDHKeyPairSAS,1)} -> \n\t\tComMASA!kmas.idsn3.idsas.idmn2 ->ComMASA!TempKAS_SAS.idsn2.IDSAS.idmn1.DHPbkSAS.IDSAS -> \n\t\tComMASA?kas.idmn3.kmas2.skmas.dhPbkMAS ->\n\t\tif (TempKAS_SAS == kas){ \n\t\t\tif (idmn3 == idmn1){\n\t\t\t\t{call(DH_SAS, dhPbkMAS)} ->ComMSA!kmas2.skmas.TempKSAS_SAS.SkSAS -> SAS()\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfail3 -> SAS()\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfail3 -> SAS()\n\t\t}\n\t}\n\telse{\n\t\tfail3 -> SAS()\n\t}\n}\nelse{\n\tfail3 -> SAS()\n};\n\n/*@Process: MAS\n  The MAS's behavior is as follows:\n    1.After receiving MSG4 and MSG5 from SAS, it takes out the key TempKAS between itself and the authentication server SAS whose ID is idSAS3 in MSG5.  \t\n    2.Calling the function RetrieveKeyMAS(id) returns the symmetric key shared between MAS and the entity with ID id.\n    3.Decrypt MSG5 using TempKAS and check whether the idSAS2 in the ciphertext part and the idSAS3 in the plaintext part of MSG5 are consistent.\n    4.After checking, take out the shared key TempKMAS with the entity whose ID is idMN 2 in MSG5 and use it to decrypt MSG4.\n    5.Check again to see if idSN1, idMN1 and idSAS1 in MSG4 are identical to idSN2, idMN2 and idSAS2 in MSG5.\n    6.Generate its own DH public key DHPbKMAS and DH private key DHPvKMAS, and based on the DH key exchange algorithm, use the dhPbKSAS received in MSG5 and its own DHPvKMAS to generate the session key SKMAS.\n    7.Generates message MSG6 and sends it to SAS.\n*/\nMAS() =\nComMASA?kmas.idsn1.idsas1.idmn1 ->\nComMASA?kas.idsn2.idsas2.idmn2.dhPbkSAS.idsas3 -> retrieveKeyMAS1{call(RetrieveKeyMAS1,idsas3)} ->\nif (TempKAS_MAS == kas){ \n\tif (idsas2 == idsas3){\n\t\tretrieveKeyMAS2{call(RetrieveKeyMAS2,idmn2)} -> \n\t\t\tif (TempKMAS_MAS == kmas){\n\t\t\t\tif (idsn1 == idsn2&& idmn1 == idmn2&& idsas1 == idsas2){\n\t\t\t\t\t{call(UpdateDHKeyPairMAS,1)} ->caculateSkMAS{call(DH_MAS, dhPbkSAS)} ->\n\t\t\t\t\tComMASA!TempKAS_MAS.idmn2.TempKMAS_MAS.SkMAS.DHPbkMAS -> MAS()\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfail4 -> MAS()\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfail4 -> MAS()\n\t\t\t}\n\t}\n\telse{\n\t\tfail4 -> MAS()\n\t} \n}\nelse{\n\tfail4 -> MAS()\n};\n\n\n/*@Process: System\n\tThe system comprises the following four entities: SN, MN, SAS, and MAS. \n*/\nSystem() = SN()||MN()||SAS()||MAS();",
        "property_desc": [
            "The system is deadlock-free.",
            "The system satisfies data accessibility.",
            "The system satisfies data security.",
            "The system satisfies data authenticity."
        ],
        "properties": [
            "#assert System() deadlockfree;",
            "#define Data_Accessibility data_acquisition_success == true; \n#assert\tSystem() reaches Data_Accessibility;",
            "#define Data_Leakage data_leakage_success == true; \n#assert System() |=[]!Data_Leakage;",
            "#define Data_Faking data_faking_success == true; \n#assert\t System()  |=[]!Data_Faking;"
        ],
        "processes": [
            {
                "name": "MN",
                "description": "The MN's behavior is as follows:\n    1.First, send the IDs of MN and MAS to SN.\n    2.After receiving the SN reply, take out idSN1 and idSAS from the message and send it to SAS.\n    3.When receiving the message with MN's Ticket from SAS, tries to decrypt the Ticket with the key KMAS.\n    4.After successfully decrypting and obtaining the session key skMAS, the data request encrypted with the session key is sent to SN and waits for a response.",
                "pat_code": "MN() =\nComMS!IDMN.IDMAS -> ComMS?idsn1.idsas ->\nComMS?ksas.idmn.idmas.idsn2.idsn3 ->   \nComMSA!ksas.idmn.idmas.idsn2.idsn3 -> \nComMSA!KMAS.idsn1.idsas.IDMN ->\nComMSA?kmas.skmas.ksas2.sksas ->\n\tif (KMAS == kmas){\n\t\tComMS!ksas2.sksas ->ComMS!skmas.Request -> ComMS?sksas2.data -> \n\t\tif (skmas == sksas2){\n\t\t\tif (data == Data){\n\t\t\t\tgetRealData{data_acquisition_success = true; data_faking_success = false} -> MN()\n\t\t\t}\n\t\t\telse{\n\t\t\t\tgetFakeData{data_acquisition_success = true; data_faking_success = true} -> MN()\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfail1 -> MN()\n\t\t}\n\t}\n\telse{\n\t\tfail1 -> MN()\n\t};"
            },
            {
                "name": "SN",
                "description": "The SN's behavior is as follows:\n    1.When receiving MSG1 from MN, in order to authenticate the identity and ensure that MN is a trusted data transmission object, MSG2 and MSG3 are generated and sent to MN.\n    2.After receiving the MSG8 of the Ticket with the SN, try to decrypt the message using the key KSAS.\n      -If the decryption is successful, and the subsequent data request received from the MN can be decrypted with the session key skSAS received in MSG8, it can be confirmed that the identity authentication process has been completed, and the data message MSGdata encrypted with the session key is transmitted to the MN.",
                "pat_code": "SN() =\nComMS?idmn.idmas -> ComMS!IDSN.IDSAS -> ComMS!KSAS.idmn.idmas.IDSN.IDSN ->\nComMS?ksas.sksas ->\n\tif (KSAS == ksas){\n\t\tComMS?skmas. request ->\n\t\tif (skmas == sksas){\n\t\t\tComMS!sksas.Data -> SN()\n\t\t}\n\t\telse{\n\t\t\tfail2 -> SN()\n\t\t}\n\t}\n\telse{\n\t\tfail2 -> SN()\n\t};"
            },
            {
                "name": "SAS",
                "description": "The SAS's behavior is as follows:\n    1.After receiving MSG3 and MSG4 from MN, it extracts the symmetric key TempKSAS shared with SN based on the idSN2 in the plaintext part of MSG3, and tries to use this key to decrypt the encrypted part of MSG3.\n\t2.Check whether idSN1 and idSN2 in MSG3 are consistent, and check whether the node with ID idMN1 has the authority to access SN's data.\n\t3.After all checks are passed, the symmetric key TempKAS between the authentication server MAS with ID idMAS is taken out, the DH public key DHPbKSAS and the DH private key DHPvKSAS are generated, and then MSG5 is generated and sent to MAS together with MSG4.\n\t4.After receiving the MSG6 reply from MAS, use the previously retrieved key TempKAS to decrypt the message and compare idMN 1 in MSG3 with idMN3 in MSG6.\n\t5.Finally, the received DH public key dhPbKMAS and its own DH private key DHPvKSAS are used to generate the session key SKSAS, and the message MSG7 is generated and sent to MN.",
                "pat_code": "SAS() =\nComMSA?ksas.idmn1.idmas.idsn1.idsn2{call(RetrieveKeySAS1,idsn2)} -> ComMSA?kmas.idsn3.idsas.idmn2 ->\nif (TempKSAS_SAS == ksas){\n\t{call(CheckPermission,idmn1,idsn2)} ->\n\tif (idsn1 == idsn2&&check_permission_result == true){ \n\t\t{call(RetrieveKeySAS2,idmas)} ->{call(UpdateDHKeyPairSAS,1)} -> \n\t\tComMASA!kmas.idsn3.idsas.idmn2 ->ComMASA!TempKAS_SAS.idsn2.IDSAS.idmn1.DHPbkSAS.IDSAS -> \n\t\tComMASA?kas.idmn3.kmas2.skmas.dhPbkMAS ->\n\t\tif (TempKAS_SAS == kas){ \n\t\t\tif (idmn3 == idmn1){\n\t\t\t\t{call(DH_SAS, dhPbkMAS)} ->ComMSA!kmas2.skmas.TempKSAS_SAS.SkSAS -> SAS()\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfail3 -> SAS()\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfail3 -> SAS()\n\t\t}\n\t}\n\telse{\n\t\tfail3 -> SAS()\n\t}\n}\nelse{\n\tfail3 -> SAS()\n};"
            },
            {
                "name": "MAS",
                "description": "The MAS's behavior is as follows:\n    1.After receiving MSG4 and MSG5 from SAS, it takes out the key TempKAS between itself and the authentication server SAS whose ID is idSAS3 in MSG5.  \t\n    2.Calling the function RetrieveKeyMAS(id) returns the symmetric key shared between MAS and the entity with ID id.\n    3.Decrypt MSG5 using TempKAS and check whether the idSAS2 in the ciphertext part and the idSAS3 in the plaintext part of MSG5 are consistent.\n    4.After checking, take out the shared key TempKMAS with the entity whose ID is idMN 2 in MSG5 and use it to decrypt MSG4.\n    5.Check again to see if idSN1, idMN1 and idSAS1 in MSG4 are identical to idSN2, idMN2 and idSAS2 in MSG5.\n    6.Generate its own DH public key DHPbKMAS and DH private key DHPvKMAS, and based on the DH key exchange algorithm, use the dhPbKSAS received in MSG5 and its own DHPvKMAS to generate the session key SKMAS.\n    7.Generates message MSG6 and sends it to SAS.",
                "pat_code": "MAS() =\nComMASA?kmas.idsn1.idsas1.idmn1 ->\nComMASA?kas.idsn2.idsas2.idmn2.dhPbkSAS.idsas3 -> retrieveKeyMAS1{call(RetrieveKeyMAS1,idsas3)} ->\nif (TempKAS_MAS == kas){ \n\tif (idsas2 == idsas3){\n\t\tretrieveKeyMAS2{call(RetrieveKeyMAS2,idmn2)} -> \n\t\t\tif (TempKMAS_MAS == kmas){\n\t\t\t\tif (idsn1 == idsn2&& idmn1 == idmn2&& idsas1 == idsas2){\n\t\t\t\t\t{call(UpdateDHKeyPairMAS,1)} ->caculateSkMAS{call(DH_MAS, dhPbkSAS)} ->\n\t\t\t\t\tComMASA!TempKAS_MAS.idmn2.TempKMAS_MAS.SkMAS.DHPbkMAS -> MAS()\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfail4 -> MAS()\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfail4 -> MAS()\n\t\t\t}\n\t}\n\telse{\n\t\tfail4 -> MAS()\n\t} \n}\nelse{\n\tfail4 -> MAS()\n};"
            },
            {
                "name": "System",
                "description": "The system comprises the following four entities: SN, MN, SAS, and MAS.",
                "pat_code": "System() = SN()||MN()||SAS()||MAS();"
            }
        ],
        "global_definition": "channel ComMS 0;\nchannel ComMSA 0;    \nchannel ComMASA 0; \nchannel FakeM 0;\nchannel FakeS 0;\nchannel FakeMA 0; \nchannel FakeSA 0;\n\nenum {IDMN, IDMAS, IDSN, IDSAS, IDMNI}; \nenum {KSAS, KMAS, KAS, KMASI};\nenum {Request};\nenum {Data, FakeData};\n\nvar TempKSAS_SAS;\nvar TempKAS_SAS;\nvar TempKMAS_MAS; \nvar TempKAS_MAS;\n\nvar DHPbkSAS = 1;   \nvar DHPvkSAS = 1;  \nvar DHPbkMAS = 2; \nvar DHPvkMAS = 2; \nvar DHPbkI = -2;\nvar DHPvkI = -2; \nvar SkSAS = 0;\nvar SkMAS = 0;\n\nvar check_permission_result = false; \nvar data_acquisition_success = false; \nvar data_leakage_success = false;\nvar data_faking_success = false;\n\n#define CheckPermission(idmn, idsn){ \n\tif (idmn == IDMN){\n\t\tcheck_permission_result = true;\n\t} \n\telse{\n\t\tcheck_permission_result = false;\n\t} \n};\n\n#define DH_SAS(dhPbk){\n\tSkSAS = dhPbk + DHPvkSAS;\n};\n\n#define DH_MAS(dhPbk){\n\tSkMAS = dhPbk + DHPvkMAS;\n};\n\n#define UpdateDHKeyPairSAS(id){\n\tif (DHPbkSAS < 50 && DHPvkSAS < 50){\n\t\tDHPbkSAS = DHPbkSAS + 2; \n\t\tDHPvkSAS = DHPvkSAS + 2;\n\t} \n};\n\n#define UpdateDHKeyPairMAS(id){\n\tif (DHPbkMAS < 50 && DHPvkMAS < 50){\n\t\tDHPbkMAS = DHPbkMAS + 2; \n\t\tDHPvkMAS = DHPvkMAS + 2;\n\t} \n};\n\n#define RetrieveKeySAS1(id){ \n\tif (id == IDSN){\n\t\tTempKSAS_SAS = KSAS;\n\t} \n};\n\n#define RetrieveKeySAS2(id){ \n\tif (id == IDMAS){\n\t\tTempKAS_SAS = KSAS;\n\t} \n};\n\n#define RetrieveKeyMAS1(id){ \n\tif (id == IDSAS){\n\t\tTempKAS_MAS = KMAS;\n\t} \n};\n\n#define RetrieveKeyMAS2(id){ \n\tif (id == IDMN){\n\t\tTempKMAS_MAS = KMAS;\n\t} \n\tif (id == IDMNI){\n\t\tTempKMAS_MAS = KMASI;\n\t}\n};",
        "path": "handwrite/Ticket Based.csp"
    },
    {
        "name": "Time Sharing And Paritition OS",
        "tags": [
            "Algorithm"
        ],
        "use_non_container_lib": false,
        "description": "The partition manager for the core operating system is the parallel execution of the three processes: CoreOS(), Spaces() and Partitions().",
        "pat_code": "#define OSK 3;\n#define SPACENUM 3;\n\n// core OS\n/*@Process: Processor\n  This process models a single processor core . It repeatedly performs the following atomic sequence:\n  1. The processor executes a single operation.\n  2. A clock tick occurs.\n  3. The processor finishes the operation.\n*/\nProcessor(p_i) = atomic{ Pdo.p_i -> tick -> Pdid.p_i -> Skip}; Processor(p_i);\n\n/*@Process: GlobalClock\n  GlobalClock(): This process models a global clock that increments a counter with each tick.\n  1. Repeatedly, a clock tick event occurs and the global clock counter is updated.\n*/\nvar globalClock = 0;\nGlobalClock() =  atomic{tick -> update_t{globalClock++;}-> Skip}; GlobalClock();\n\n/*@Process: CoreOS\n  The core OS consists of n processors synchronized and a global clock.\n*/\nCoreOS() = (||x:{0..OSK-1}@Processor(x)) || GlobalClock();\n\n/*@Process: Space\n  Space(s_i, p_i) performs the following:\n  1. Execute atomically:\n  1.1. The space starts an operation.\n  1.2. Increments the elapsed time counter for the space.\n  1.3. The space finishes the operation.\n  2. Then, checks if the space's elapsed time is equal to its total allotted time.\n     If it is, the processor switches to the next partition. Otherwise, it loops back to continue execution.\n*/\nvar SpaceElapsedTime[SPACENUM];\nvar SpaceTotalTime[SPACENUM] = [10(SPACENUM)];\nvar ProcessorSpace[OSK][SPACENUM];\nvar ProcessorSpaceNum[OSK] = [3(OSK)];\nSpace(s_i, p_i) = \n    atomic{\n        Sdo.s_i -> update_s{SpaceElapsedTime[s_i]++;} -> Sdid.s_i -> Skip\n    };\n    case{\n        SpaceElapsedTime[s_i] == SpaceTotalTime[s_i]:\n            switch.p_i -> Skip\n        default:\n            Space(s_i, p_i)\n    };\n\n/*@Process: SpaceOnPorcessor\n  SpaceOnPorcessor(p_i, s_n): For the processor p_i, it may choose one of the space indexed from 0 to s_n-1 to execute, if the space is chosen, it proceeds to Space corresponding process.\n*/\nSpaceOnPorcessor(p_i, s_n) = [] s_i:{0..s_n-1}@Space(ProcessorSpace[p_i][s_i], p_i); SpaceOnPorcessor(p_i, s_n);\n\n/*@Process: Spaces\n  Spaces(): This process is the interleaving composition of SpaceOnPorcessor() for all processors. It allows each processor to manage its spaces independently.\n*/\nSpaces() = ||| p_i:{0..OSK-1}@SpaceOnPorcessor(p_i, ProcessorSpaceNum[p_i]);\n#alphabet Spaces {s_i:{0..SPACENUM-1}@Sdo.s_i, s_i:{0..SPACENUM-1}@Sdid.s_i, p_i:{0..OSK-1}@switch.p_i};\n\n/*@Process: Partition\n  Partition(p_i, s_i): \n  1. It only executes the following operation atomically if the space's elapsed time is less than its total allotted time\n  1.1. The space starts an operation.\n  1.2. The processor starts an operation.\n  1.3. The processor finishes the operation.\n  1.4. The space finishes the operation.\n  2. If the space's elapsed time is not equal to its total time, it loops back to the Partition process.\n  3.1. Otherwise, the processor switches to the next partition\n  3.2. Updates states related to the partition by resetting the space's elapsed time and increasing the space's execution count by 1.\n  4. If all spaces assigned to the processor have been executed, execute following operation atomically:\n  4.1. Switch the configuration\n  4.2. Updates configuration table, execute from the first partition of the new partition configuration table  and resetting the processor's current space.\n  4.3. Proceeds to ProcessorSpaceConfSetting with p_i and current config table index to start the new configuration.\n  5. Otherwise, only resets ProcessorCurrentSpace to 0.\n  6. Loop back to start the next space.\n  \n*/\nvar SpaceExeNum[SPACENUM];\nvar ProcessorCurrentSpace[OSK];\nvar changeConfTableIndex[OSK];\nvar curConfTableIndex[OSK];\nPartition(p_i, s_i) = \n    [SpaceElapsedTime[s_i] < SpaceTotalTime[s_i]] atomic{\n        Sdo.s_i -> Pdo.p_i -> Pdid.p_i -> Sdid.s_i -> Skip\n    }; case {\n\t\tSpaceElapsedTime[s_i] == SpaceTotalTime[s_i]: atomic{\n                switch.p_i -> update_p{\n                        SpaceElapsedTime[s_i] = 0;\n                        SpaceExeNum[s_i]++;\n                } -> Skip; case {\n                    ProcessorSpace[p_i][ProcessorCurrentSpace[p_i]] == -1 && changeConfTableIndex[p_i]!=-1:\n                        atomic{\n                            switchConf.p_i -> update_p{\n                                curConfTableIndex[p_i] = changeConfTableIndex[p_i];\n                                changeConfTableIndex[p_i] = -1;\n                                ProcessorCurrentSpace[p_i] = 0;\n                            } -> Skip\n                        }; ProcessorSpaceConfSetting(p_i, curConfTableIndex[p_i])\n                    ProcessorSpace[p_i][ProcessorCurrentSpace[p_i]] == -1 && changeConfTableIndex[p_i]==-1:\n                        update_p{ProcessorCurrentSpace[p_i] = 0;} -> Skip\n                }\n            }; Partition(p_i, ProcessorSpace[p_i][ProcessorCurrentSpace[p_i]])\n        default:\n            Partition(p_i, s_i)\n\t};\n\t\n/*@Process: ProcessorSpaceConfSetting\n\n  ProcessorSpaceConfSetting(p_i, conf_i)\n  1. It first change the config of the ith processor with config index conf_i.\n  2. Update the changeConfTableIndex[p_i] with conf_i and if the changed index is the current index, reset changeConfTableIndex[p_i] to -1.\n\n*/\nProcessorSpaceConfSetting(p_i, conf_i) = atomic{\n        changeProcessorConf.p_i.conf_i -> update_psc{\n            changeConfTableIndex[p_i] = conf_i;\n            if(changeConfTableIndex[p_i] == curConfTableIndex[p_i]){\n                changeConfTableIndex[p_i] = -1;\n            }\n        } -> Skip\n    };\n\n/*@Process: Partitions\n  Partitions() process is the interlaeving composition of Partition(p_i, s_i) processes for all processors with all spaces.\n*/\nPartitions() = ||| p_i:{0..OSK-1}@Partition(p_i, ProcessorSpace[p_i][ProcessorCurrentSpace[p_i]]);\n#alphabet Partitions {s_i:{0..SPACENUM-1}@Sdo.s_i, \n                      s_i:{0..SPACENUM-1}@Sdid.s_i, \n                      p_i:{0..OSK-1}@Pdo.p_i, \n                      p_i:{0..OSK-1}@Pdid.p_i,\n                      p_i:{0..OSK-1}@switch.p_i};\n                      \n/*@Process: PartitionManager\n  The partition manager for the core operating system is the parallel execution of the three processes: CoreOS(), Spaces() and Partitions().\n*/\nPartitionManager() = Partitions() || CoreOS() || Spaces();",
        "property_desc": [
            "The system is deadlock-free.",
            "The space will be executed.",
            "The execution on space 1 will complete."
        ],
        "properties": [
            "#assert PartitionManager deadlockfree;",
            "#define SpaceWillExecute SpaceExeNum[0] == 1;\n#assert PartitionManager reaches SpaceWillExecute;",
            "#assert PartitionManager |= <>Sdid.1;"
        ],
        "processes": [
            {
                "name": "Processor",
                "description": "This process models a single processor core . It repeatedly performs the following atomic sequence:\n  1. The processor executes a single operation.\n  2. A clock tick occurs.\n  3. The processor finishes the operation.",
                "pat_code": "Processor(p_i) = atomic{ Pdo.p_i -> tick -> Pdid.p_i -> Skip}; Processor(p_i);"
            },
            {
                "name": "GlobalClock",
                "description": "GlobalClock(): This process models a global clock that increments a counter with each tick.\n  1. Repeatedly, a clock tick event occurs and the global clock counter is updated.",
                "pat_code": "var globalClock = 0;\nGlobalClock() =  atomic{tick -> update_t{globalClock++;}-> Skip}; GlobalClock();"
            },
            {
                "name": "CoreOS",
                "description": "The core OS consists of n processors synchronized and a global clock.",
                "pat_code": "CoreOS() = (||x:{0..OSK-1}@Processor(x)) || GlobalClock();"
            },
            {
                "name": "Space",
                "description": "Space(s_i, p_i) performs the following:\n  1. Execute atomically:\n  1.1. The space starts an operation.\n  1.2. Increments the elapsed time counter for the space.\n  1.3. The space finishes the operation.\n  2. Then, checks if the space's elapsed time is equal to its total allotted time.\n     If it is, the processor switches to the next partition. Otherwise, it loops back to continue execution.",
                "pat_code": "var SpaceElapsedTime[SPACENUM];\nvar SpaceTotalTime[SPACENUM] = [10(SPACENUM)];\nvar ProcessorSpace[OSK][SPACENUM];\nvar ProcessorSpaceNum[OSK] = [3(OSK)];\nSpace(s_i, p_i) = \n    atomic{\n        Sdo.s_i -> update_s{SpaceElapsedTime[s_i]++;} -> Sdid.s_i -> Skip\n    };\n    case{\n        SpaceElapsedTime[s_i] == SpaceTotalTime[s_i]:\n            switch.p_i -> Skip\n        default:\n            Space(s_i, p_i)\n    };"
            },
            {
                "name": "SpaceOnPorcessor",
                "description": "SpaceOnPorcessor(p_i, s_n): For the processor p_i, it may choose one of the space indexed from 0 to s_n-1 to execute, if the space is chosen, it proceeds to Space corresponding process.",
                "pat_code": "SpaceOnPorcessor(p_i, s_n) = [] s_i:{0..s_n-1}@Space(ProcessorSpace[p_i][s_i], p_i); SpaceOnPorcessor(p_i, s_n);"
            },
            {
                "name": "Spaces",
                "description": "Spaces(): This process is the interleaving composition of SpaceOnPorcessor() for all processors. It allows each processor to manage its spaces independently.",
                "pat_code": "Spaces() = ||| p_i:{0..OSK-1}@SpaceOnPorcessor(p_i, ProcessorSpaceNum[p_i]);\n#alphabet Spaces {s_i:{0..SPACENUM-1}@Sdo.s_i, s_i:{0..SPACENUM-1}@Sdid.s_i, p_i:{0..OSK-1}@switch.p_i};"
            },
            {
                "name": "Partition",
                "description": "Partition(p_i, s_i): \n  1. It only executes the following operation atomically if the space's elapsed time is less than its total allotted time\n  1.1. The space starts an operation.\n  1.2. The processor starts an operation.\n  1.3. The processor finishes the operation.\n  1.4. The space finishes the operation.\n  2. If the space's elapsed time is not equal to its total time, it loops back to the Partition process.\n  3.1. Otherwise, the processor switches to the next partition\n  3.2. Updates states related to the partition by resetting the space's elapsed time and increasing the space's execution count by 1.\n  4. If all spaces assigned to the processor have been executed, execute following operation atomically:\n  4.1. Switch the configuration\n  4.2. Updates configuration table, execute from the first partition of the new partition configuration table  and resetting the processor's current space.\n  4.3. Proceeds to ProcessorSpaceConfSetting with p_i and current config table index to start the new configuration.\n  5. Otherwise, only resets ProcessorCurrentSpace to 0.\n  6. Loop back to start the next space.",
                "pat_code": "var SpaceExeNum[SPACENUM];\nvar ProcessorCurrentSpace[OSK];\nvar changeConfTableIndex[OSK];\nvar curConfTableIndex[OSK];\nPartition(p_i, s_i) = \n    [SpaceElapsedTime[s_i] < SpaceTotalTime[s_i]] atomic{\n        Sdo.s_i -> Pdo.p_i -> Pdid.p_i -> Sdid.s_i -> Skip\n    }; case {\n\t\tSpaceElapsedTime[s_i] == SpaceTotalTime[s_i]: atomic{\n                switch.p_i -> update_p{\n                        SpaceElapsedTime[s_i] = 0;\n                        SpaceExeNum[s_i]++;\n                } -> Skip; case {\n                    ProcessorSpace[p_i][ProcessorCurrentSpace[p_i]] == -1 && changeConfTableIndex[p_i]!=-1:\n                        atomic{\n                            switchConf.p_i -> update_p{\n                                curConfTableIndex[p_i] = changeConfTableIndex[p_i];\n                                changeConfTableIndex[p_i] = -1;\n                                ProcessorCurrentSpace[p_i] = 0;\n                            } -> Skip\n                        }; ProcessorSpaceConfSetting(p_i, curConfTableIndex[p_i])\n                    ProcessorSpace[p_i][ProcessorCurrentSpace[p_i]] == -1 && changeConfTableIndex[p_i]==-1:\n                        update_p{ProcessorCurrentSpace[p_i] = 0;} -> Skip\n                }\n            }; Partition(p_i, ProcessorSpace[p_i][ProcessorCurrentSpace[p_i]])\n        default:\n            Partition(p_i, s_i)\n\t};"
            },
            {
                "name": "ProcessorSpaceConfSetting",
                "description": "ProcessorSpaceConfSetting(p_i, conf_i)\n  1. It first change the config of the ith processor with config index conf_i.\n  2. Update the changeConfTableIndex[p_i] with conf_i and if the changed index is the current index, reset changeConfTableIndex[p_i] to -1.",
                "pat_code": "ProcessorSpaceConfSetting(p_i, conf_i) = atomic{\n        changeProcessorConf.p_i.conf_i -> update_psc{\n            changeConfTableIndex[p_i] = conf_i;\n            if(changeConfTableIndex[p_i] == curConfTableIndex[p_i]){\n                changeConfTableIndex[p_i] = -1;\n            }\n        } -> Skip\n    };"
            },
            {
                "name": "Partitions",
                "description": "Partitions() process is the interlaeving composition of Partition(p_i, s_i) processes for all processors with all spaces.",
                "pat_code": "Partitions() = ||| p_i:{0..OSK-1}@Partition(p_i, ProcessorSpace[p_i][ProcessorCurrentSpace[p_i]]);\n#alphabet Partitions {s_i:{0..SPACENUM-1}@Sdo.s_i, \n                      s_i:{0..SPACENUM-1}@Sdid.s_i, \n                      p_i:{0..OSK-1}@Pdo.p_i, \n                      p_i:{0..OSK-1}@Pdid.p_i,\n                      p_i:{0..OSK-1}@switch.p_i};"
            },
            {
                "name": "PartitionManager",
                "description": "The partition manager for the core operating system is the parallel execution of the three processes: CoreOS(), Spaces() and Partitions().",
                "pat_code": "PartitionManager() = Partitions() || CoreOS() || Spaces();"
            }
        ],
        "global_definition": "#define OSK 3;\n#define SPACENUM 3;\n\n// core OS",
        "path": "handwrite/Time Sharing And Paritition OS.csp"
    },
    {
        "name": "TopoGuard",
        "tags": [
            "Protocol",
            "Attacker"
        ],
        "use_non_container_lib": false,
        "description": "TopoGuard is a secure OF(OpenFlow) controller, which is extended from NOX, a mainstream OF controller.\n\n  The System represents the entire TopoGuard network. It consists of the concurrently running components: Switch, Controller, Moving Host, Unmoving Host and Migration Process.\n\\",
        "pat_code": "//Constant definitions: the numbers of swithes, ports on each switch, and hosts.\n#define SNum 3;\n#define PNum 4;\n#define HNum 3;\n//Enumerations\nenum{PktOut, PktIn, PtStatus};//OpenFlow messages\nenum{ICMPEcho,LLDP,ARP};//Packets\nenum{S0,S1,S2};//Swtiches\nenum{P0,P1,P2,P3};//Ports\nenum{H0,H1,H2};//Hosts\nenum{RESERVED,ANY,HOST,SWITCH};//Port type\nenum{PtUp,PtDown};//Port State\nenum{FALSE,TRUE};\nenum{Request, Reply};//ICMPEcho type\n//==================================\nchannel SC[SNum] 0;\nchannel CS[SNum] 0;\nchannel PtChange 0;\nchannel CSend 0;\nchannel Link 0;\nchannel Host 0;\nchannel SP[SNum*(PNum-1)] 0;\nchannel SH[HNum] 0;\nchannel SendPkt[SNum*PNum] 0;//MsgHandler/PktHandler to PktSender\nchannel HandlePkt[SNum] 0;//PktReceiver to PktHandler\nchannel SendMsg[SNum] 0;//PktHandler to MsgSender\nchannel HandleMsg[SNum] 0;//MsgReciver to Msghandler\nchannel Monitor[HNum] 0;\n//==================================\nvar LinkExist[SNum][SNum]=[0,1,0,\n                           1,0,1,\n                           0,1,0];\nvar LinkTable[SNum][SNum]=[-2,P1,-2, \n                            P3,-2,P1,  \n                           -2,P3,-2];\nvar PortTable[SNum][PNum][4]=[RESERVED,FALSE,-2,-2, ANY,FALSE,-2,-2, HOST,FALSE,H0,-2,  ANY,FALSE,-2,-2,\n                             RESERVED,FALSE,-2,-2, ANY,FALSE,-2,-2, ANY,FALSE,-2,-2, ANY,FALSE,-2,-2,\n                             RESERVED,FALSE,-2,-2, ANY,FALSE,-2,-2, HOST,FALSE,H1,-2, ANY,FALSE,-2,-2];\nvar HostTable[HNum][2]=[S0,P2,\n                        S2,P2,\n                        S1,P2];\n//real locations of the hosts\nvar HostLoc[HNum][2]=[S0,P2,\n                      S2,P2,\n                      S1,P2];\n//real topology among the switches\nvar InterLink[SNum][SNum]=[-2,P1,-2, \n                            P3,-2,P1,  \n                           -2,P3,-2];\n//==================================\nvar is_new_link = FALSE;\nvar port_type1 = ANY;\nvar port_type2 = ANY;\nvar host_loc[2] = [-1,-1];\nvar port_type = ANY;\nvar mflag = FALSE;\n//special arrays to help programming\nvar CIndex[SNum][PNum-1];//SP index\nvar TIndex[HNum];//SH index\n//==================================\n\n/*@Process: Controller\n  The OpenFlow controller responsible for network management, link discovery, and host tracking.\n  The controller is the interleaving execution of receiver and sender, which parallel with the interleaving execution of the LinkManager and the HostTracker\n*/\nController = (CReceiver|||CSender)||(LinkManager|||HostTracker);\n\n/*@Process: CReceiver\n  The controller receiver:\n  - 1. It may receives messages packet from any switches.\n    2. And if the message is PacketIn, it judeges the packet type:\n    3. If is LLDP, it forwards the packet information to the Link process. \n    4. If it is ARP or ICMPEcho, it forwards the information to the Host process.\n  - 1. Or, it may receives Port Status Change message with four parameters and HandlePtChange\n    2. If a port's state is Down, it updates the PortTable to reflect that the port type becomes ANY and sets the port state TRUE.\n*/\nCReceiver = ([]x:{0..SNum-1} @ SC[x]?f0.f1.f2.f3.f4.f5->\n         ifa(f0==PktIn)\n         {             \n             ifa(f3==LLDP) { Link!f0.f1.f2.f3.f4.f5->Skip }\n             else ifa(f3==ARP||f3==ICMPEcho){ Host!f0.f1.f2.f3.f4.f5->Skip}\n         })\n            [](PtChange?f0.f1.f2.f3->ifa(f1==PtDown){setPt{PortTable[f2][f3][1]=ANY;PortTable[f2][f3][1]=TRUE;}->\n                                              Skip});\n    CReceiver;\n\n/*@Process: CSender\n\n  The controller sender:\n  - It sends messages to the certain switch after receiving instructions from the link manager or migration process with the target switch and other 5 parameters.\n*/\nCSender = CSend?x.f0.f1.f2.f3.f4->CS[x]!f0.f1.f2.f3.f4->CSender;\n\n/*@Process: LinkManager\n  \n  LinkManager is the interleaving execution of the LLDPConstructor and the LLDPHandler\n  \n*/\nLinkManager = LLDPConstructor|||LLDPHandler;\n\n/*@Process: LLDPConstructor\n  LLDPConstructor: Periodically sends LLDP packets to discover new links.\n*/\nLLDPConstructor =  CSend!2.PktOut.2.LLDP.2.2->Skip;\n\n/*@Process: LLDPHandler\n    LLDPHandler: \n  1. Receives LLDP packets through the Link channel. \n  2. It checks if the link already exists.\n  3. If the link is new: It retrieves the port types from the PortTable. If either port is connected to a host, it skips (simulating an attack prevention). Otherwise, it updates the LinkExist and LinkTable to reflect the new link and update corresponding port types in PortTable to SWITCH.\n  4. If the link exists, it skips.\n\n*/\nLLDPHandler = (Link?f0.f1.f2.f3.f4.f5->searchLink{\n                                          if(LinkExist[f4][f1]==1){is_new_link=FALSE;}\n                                          else{is_new_link=TRUE;}\n                                          }->\n              ifa(is_new_link==TRUE)\n              {\n                  getDT{port_type1=PortTable[f4][f5][0];port_type2=PortTable[f1][f2][0];}->\n                  ifa(port_type1==HOST||port_type2==HOST){attack->Skip}\n                  else{\n                      insertLink{LinkExist[f4][f1]=1;LinkTable[f4][f1]=f5;LinkTable[f1][f4]=f2;}->\n                      setDT{PortTable[f4][f5][0]=SWITCH;PortTable[f1][f2][0]=SWITCH;}->\n                      Skip}\n              }\n              else\n              {\n                  link_exists->Skip    \n              });LLDPHandler;\n              \n/*@Process: HostTracker\n  HostTracker tracks the locations of hosts:\n  1. Receives packets through the Host channel.\n  2. If the packet is the InPacket and is an ARP, proceeds to HandleARP.\n  3. If the packet is the InPacket and is an ICMPEcho, it means there is a migration attack.\n*/\nHostTracker = (Host?f0.f1.f2.f3.f4.f5->\n               ifa(f0==PktIn)\n               {\n                   ifa(f3==ARP){HandleARP(f0,f1,f2,f3,f4,f5)}\n                   else ifa(f3==ICMPEcho){migrationattack->Skip}\n               }\n               else {Skip});HostTracker;\n               \n/*@Process: HandleARP\n  HandleARP:\n  1. It searches for the host location in HostTable and retrieves the port type from PortTable.\n  2. If the host is not found and the port type is not SWITCH, it adds a new host to the HostTable. If port type is SWITCH an attack is registered and skipped.\n  3. If the host is found and its location matches the packet's source, it skips. Otherwise, it proceeds to HostMigration.\n*/\nHandleARP(f0,f1,f2,f3,f4,f5) = searchHost{host_loc[0]=HostTable[f4][0];host_loc[1]=HostTable[f4][1];}-> \n                               getDT{port_type=PortTable[f1][f2][0];}->\n                               ifa(host_loc[0]==-2&&host_loc[1]==-2)\n                               {\n                                   ifa(port_type==SWITCH){attack->Skip}\n                                   else{insertHost{HostTable[f4][0]=f1;HostTable[f4][1]=f2;}->Skip}\n                               }\n                               else\n                               {\n                                   ifa(host_loc[0]==f1&&host_loc[1]==f2){Skip}\n                                   else{HostMigration(f4,f1,f2,host_loc[0],host_loc[1])}\n                               };\n\n/*@Process: HostMigration\nHostMigration:\n  1. It first get the old port flag from the port table.\n  2. It checks if the old port is flagged as down.\n  3. If not flagged, then an attack is registered and skipped.\n  4. If flagged, the HostTable and PortTable are updated to reflect the new host location. The host is added to a host list for the new port if space is available and the old location is removed from the old port. Sends an ICMPEcho request to the old switch and port to finalize the migration.\n\n*/\nHostMigration(h,ns,np,os,op) =  getSDFlag{mflag=PortTable[os][op][1];}->\n                                ifa(mflag==TRUE)\n                                {\n                                    setLoc{HostTable[h][0]=ns;HostTable[h][1]=np;}->\n                                    setDT{PortTable[ns][np][0]=HOST;}->\n                                    addHostList{\n                                        if(PortTable[ns][np][2]==-2){PortTable[ns][np][2]=h;}\n                                        else if (PortTable[ns][np][3]==-2){PortTable[ns][np][3]=h;}\n                                        else {PortTable[ns][np][2]=-5;PortTable[ns][np][3]=-5;}}->\n                                    setSDFlag{PortTable[ns][np][1]=FALSE;}->\n                                    removeHostList{if(PortTable[os][op][2]==h){PortTable[os][op][2]=-2;}else if(PortTable[os][op][3]==h){PortTable[os][op][2]=-2;}}->\n                                    CSend!os.PktOut.op.ICMPEcho.Request.h->Skip\n                                }\n                                else{attack->Skip};\n\n//========================================================\n\n/*@Process: Switch\n  \n  Each switch in the system has an id, it may perform the following operations:\n  - receive message\n  - send message\n  - handle message\n  - receive packet\n  - send packet\n  - handle packet\n\n*/\nSwitch(x)=(|||i:{1..PNum-1} @ (PktReceiver(x,i)|||PktSender(x,i)))\n          ||(MsgReceiver(x)|||MsgSender(x))\n          || PktHandler(x)||MsgHandler(x);\n          \n/*@Process: MsgReceiver\n  MsgReceiver(x): Receives control messages from the controller and forwards message to MsgHandler.\n*/\nMsgReceiver(x) = CS[x]?msgtype.param1.param2.param3.param4\n                 ->HandleMsg[x]!msgtype.param1.param2.param3.param4->MsgReceiver(x);\n\n/*@Process: MsgSender\n  MsgSender(x): Sends messages to the controller after receiving the signal of sending message.\n*/\nMsgSender(x) = SendMsg[x]?msgtype.param1.param2.param3.param4.param5\n                 ->SC[x]!msgtype.param1.param2.param3.param4.param5\n                 ->MsgSender(x);\n\n/*@Process: MsgHandler\n  MsgHandler(x): If the message type is PktOut, it forwards the packet information to the corresponding PktSender.\n*/\nMsgHandler(x) =  HandleMsg[x]?msgtype.param1.param2.param3.param4->                    \n                    ifa(msgtype==PktOut)\n                    {\n                        SendPkt[x*PNum+param1]!param2.param3.param4->Skip\n                    };\n\n/*@Process: PktReceiver\n  PktReceiver(x, i): Receives packet on port i on switch x and forwards them to PktHandler.\n*/\nPktReceiver(x,i) = SP[x*(PNum-1)+i-1]?pkttype.f1.f2->HandlePkt[x]!i.pkttype.f1.f2->PktReceiver(x,i);\n\n/*@Process: PktSender\n  PktSender(x, i): Receives packet sending signal on port i on switch x from MsgHandler and sends packet. If the destination is a host it forwards the packet to the host via channel. Otherwise, it forwards the packet to another switch.\n  \n*/\nPktSender(x,i) = (SendPkt[x*PNum+i]?pkttype.f1.f2->\n                     ifa(CIndex[x][i-1]>=100){\n                         SH[CIndex[x][i-1]-100]!pkttype.f1.f2->Skip\n                     }else{\n                         SP[CIndex[x][i-1]]!pkttype.f1.f2->Skip\n                     });PktSender(x,i);\n\n/*@Process: PktHandler\n  PktHandler(x): Receives packets from PktReceiver and sends sending packet signal to the MsgSender.\n\n*/\nPktHandler(x) = HandlePkt[x]?port.pkttype.f1.f2->\n                SendMsg[x]!PktIn.x.port.pkttype.f1.f2->PktHandler(x);\n\n/*@Process: __IGNORE__ \n\n*/\nInit =  initCIndex{\n              var n=0; \n              while(n<SNum){\n                  var m=0;\n                  while(m<PNum-1){\n                      CIndex[n][m]=-3;\n                      m++;\n                  }\n                  n++;\n              }}->\n              searchInterLink{\n                     var n = 0;\n                     while(n<SNum){\n                           var m = 0;\n                           var portn = -1;\n                           var portm = -1;\n                           var position = -1;\n                           while(m<SNum){\n                                 if(InterLink[n][m]>0){\n                                       portn = InterLink[n][m];\n                                       portm = InterLink[m][n];\n                                       //Switch Sn (portn) is connected with switch Sm (portm). \n                                       //SP[postion] represents the receiving channel of Port portm on Switch m.\n                                       position = m*(PNum-1)+(portm-1);\n                                       CIndex[n][portn-1] = position;\n                                 }\n                                 m++;\n                           }\n                           n++;\n                     }\n               }\n             ->searchHostLoc{\n                     var n = 0;\n                     while(n<HNum){\n                           var switch1 = HostLoc[n][0];\n                           var port = HostLoc[n][1];\n                           CIndex[switch1][port-1]=100+n;\n                           //For host Hn, the switch port that is connected to it has a receiving channel SP[TIndex[n]].\n                           TIndex[n]=switch1*(PNum-1)+(port-1);\n                           n++;\n                     }\n             }\n             ->Skip;\n\n//========================================================\n/*@Process: UnmovingHost\n  The UnmovingHost process represents a host connected to switch x and port i, with host ID u.\n  1. Listens for ICMPEcho requests. \n  2. If a request is received from the host itself, it sends an ICMPEcho reply back to the host.\n  3. Loops back to listening for request.\n*/\nUnmovingHost(u,x,i) =  SH[u]?pkttype.f1.f2->\n                       ifa(pkttype==ICMPEcho&&f1==Request&&f2==u){SP[TIndex[u]]!ICMPEcho.Reply.u->Skip};\n\n/*@Process: Migration\n  Migration simulates the migration of host u from switch x, port i to switch y, port j. \n  1. It signals a port status change for the old port\n  2. And then updates the HostLoc table to reflect the new location. \n  3. Finally, it sends an ARP packet to the new switch port.\n*/\nMigration(u,x,i,y,j) = PtChange!PtStatus.PtDown.x.i->move{HostLoc[u][0]=y;HostLoc[u][1]=j;}->SP[y*(PNum-1)+j-1]!ARP.u.0->Skip;\n\n//========================================================\n/*@Process: HostAttacker\n  HostAttacker represents an attacker sending a malicious ARP packet from switch x, port i impersonating host u to target host v.\n*/\nHostAttacker(x,i,u,v) = SP[x*(PNum-1)+i-1]!ARP.v.0->Skip;\n\n/*@Process: LinkAttacker\n  LinkAttacker represents an attacker attempting to fabricate a link by sending an LLDP packet from switch x, port i. \n  Monitors the messages from unmoving host and if it sees an LLDP message, it then sends a spoofed LLDP packet to create a fake link and proceeds to next step.\n  Otherwise, it repeats receiving messages.\n*/\nLinkAttacker(x,i,u,v) = Monitor[v]?pkttype.f1.f2->\n                        ifa(pkttype==LLDP){SP[x*(PNum-1)+i-1]!pkttype.f1.f2->LinkAttacker1(x,i,u,v)}\n                        else {LinkAttacker(x,i,u,v)};\n/*@Process: LinkAttacker1\n  The next step after the link attack receiving the LLDP message is keeping monitoring the unmoving host.\n*/\nLinkAttacker1(x,i,u,v) = Monitor[v]?pkttype.f1.f2->LinkAttacker1(x,i,u,v);      \n//========================================================\n\n/*@Process: UnmovingHost\n  UnmovingHostM repeats the UnmovingHostM1. \n*/\nUnmovingHostM(u,x,i) = UnmovingHostM1(u,x,i);UnmovingHostM(u,x,i); //with attack behaviors\n\n/*@Process: UnmovingHostM1\n  UnmovingHostM1 \n  1. Listens for ICMPEcho requests and sends the request is intercepted by the attacker.\n  2. If a request is received from the host itself, it sends an ICMPEcho reply back to the host.\n  3. Loops back to listening for request.\n*/\nUnmovingHostM1(u,x,i) = SH[u]?pkttype.f1.f2->Monitor[u]!pkttype.f1.f2->\n                       ifa(pkttype==ICMPEcho&&f1==Request&&f2==u){SP[TIndex[u]]!ICMPEcho.Reply.u->Skip};\n\n/*@Process: MovingHostM\n  The MovingHostM has three behaviors:\n  - It acts as the UnmovingHost and perform migration after the UnmovingHost\n  - It listens for ICMPEcho requests and sends the request is intercepted by the attacker.\n  - It first performs the migration and then acts as the UnmovingHost\n*/\nMovingHostM(u,x,i,y,j) = (first->UnmovingHostM1(u,x,i);Migration(u,x,i,y,j))\n                      [](SH[u]?pkttype.f1.f2->Monitor[u]!pkttype.f1.f2->Migration(u,x,i,y,j))\n                      [](Migration(u,x,i,y,j);UnmovingHostM(u,y,j));\n                       \n//========================================================\n\n/*@Process: System\n  The System represents the entire TopoGuard network. It consists of the concurrently running components: Switch, Controller, Moving Host, Unmoving Host and Migration Process.\n  While the Switch has SNum subprocesses.\n*/\n//The origianl system model\nSystem = Init;(\n         (||x:{0..SNum-1}@Switch(x))||Controller\n         ||(Migration(H2,S1,P2,S2,P1);(MovingHostM(H1,S2,P2,S1,P2)|||UnmovingHost(H2,S2,P1)))\n         ||UnmovingHost(H0,S0,P2)\n         ||(HostAttacker(S0,P2,H0,H1)|||LinkAttacker(S0,P2,H0,H1)));\n         \n//========================================================",
        "property_desc": [
            "Whether the Link Fabrication Attack succeeds",
            "Whether the Host Hijacking Attack succeeds",
            "The migration can finish"
        ],
        "properties": [
            "#define Fake_Link LinkTable[S2][S0]==P2&&LinkTable[S0][S2]==P2&&LinkExist[S2][S0]==1&&LinkExist[S0][S2]==0;\n#assert System reaches Fake_Link;",
            "#define Fake_Host HostTable[H1][0]==S0&&HostTable[H1][1]==P2;\n#assert System reaches Fake_Host;",
            "#define Migration_Finish HostLoc[H1][0]==S1&&HostLoc[H1][1]==P2&&\n                          HostTable[H1][0]==S1&&HostTable[H1][1]==P2&&\n                          HostLoc[H2][0]==S2&&HostLoc[H2][1]==P1&&\n                          HostTable[H2][0]==S2&&HostTable[H2][1]==P1;                          \n#assert System |= <> Migration_Finish;"
        ],
        "processes": [
            {
                "name": "Controller",
                "description": "The OpenFlow controller responsible for network management, link discovery, and host tracking.\n  The controller is the interleaving execution of receiver and sender, which parallel with the interleaving execution of the LinkManager and the HostTracker",
                "pat_code": "Controller = (CReceiver|||CSender)||(LinkManager|||HostTracker);"
            },
            {
                "name": "CReceiver",
                "description": "The controller receiver:\n  - 1. It may receives messages packet from any switches.\n    2. And if the message is PacketIn, it judeges the packet type:\n    3. If is LLDP, it forwards the packet information to the Link process. \n    4. If it is ARP or ICMPEcho, it forwards the information to the Host process.\n  - 1. Or, it may receives Port Status Change message with four parameters and HandlePtChange\n    2. If a port's state is Down, it updates the PortTable to reflect that the port type becomes ANY and sets the port state TRUE.",
                "pat_code": "CReceiver = ([]x:{0..SNum-1} @ SC[x]?f0.f1.f2.f3.f4.f5->\n         ifa(f0==PktIn)\n         {             \n             ifa(f3==LLDP) { Link!f0.f1.f2.f3.f4.f5->Skip }\n             else ifa(f3==ARP||f3==ICMPEcho){ Host!f0.f1.f2.f3.f4.f5->Skip}\n         })\n            [](PtChange?f0.f1.f2.f3->ifa(f1==PtDown){setPt{PortTable[f2][f3][1]=ANY;PortTable[f2][f3][1]=TRUE;}->\n                                              Skip});\n    CReceiver;"
            },
            {
                "name": "CSender",
                "description": "The controller sender:\n  - It sends messages to the certain switch after receiving instructions from the link manager or migration process with the target switch and other 5 parameters.",
                "pat_code": "CSender = CSend?x.f0.f1.f2.f3.f4->CS[x]!f0.f1.f2.f3.f4->CSender;"
            },
            {
                "name": "LinkManager",
                "description": "LinkManager is the interleaving execution of the LLDPConstructor and the LLDPHandler",
                "pat_code": "LinkManager = LLDPConstructor|||LLDPHandler;"
            },
            {
                "name": "LLDPConstructor",
                "description": "LLDPConstructor: Periodically sends LLDP packets to discover new links.",
                "pat_code": "LLDPConstructor =  CSend!2.PktOut.2.LLDP.2.2->Skip;"
            },
            {
                "name": "LLDPHandler",
                "description": "LLDPHandler: \n  1. Receives LLDP packets through the Link channel. \n  2. It checks if the link already exists.\n  3. If the link is new: It retrieves the port types from the PortTable. If either port is connected to a host, it skips (simulating an attack prevention). Otherwise, it updates the LinkExist and LinkTable to reflect the new link and update corresponding port types in PortTable to SWITCH.\n  4. If the link exists, it skips.",
                "pat_code": "LLDPHandler = (Link?f0.f1.f2.f3.f4.f5->searchLink{\n                                          if(LinkExist[f4][f1]==1){is_new_link=FALSE;}\n                                          else{is_new_link=TRUE;}\n                                          }->\n              ifa(is_new_link==TRUE)\n              {\n                  getDT{port_type1=PortTable[f4][f5][0];port_type2=PortTable[f1][f2][0];}->\n                  ifa(port_type1==HOST||port_type2==HOST){attack->Skip}\n                  else{\n                      insertLink{LinkExist[f4][f1]=1;LinkTable[f4][f1]=f5;LinkTable[f1][f4]=f2;}->\n                      setDT{PortTable[f4][f5][0]=SWITCH;PortTable[f1][f2][0]=SWITCH;}->\n                      Skip}\n              }\n              else\n              {\n                  link_exists->Skip    \n              });LLDPHandler;"
            },
            {
                "name": "HostTracker",
                "description": "HostTracker tracks the locations of hosts:\n  1. Receives packets through the Host channel.\n  2. If the packet is the InPacket and is an ARP, proceeds to HandleARP.\n  3. If the packet is the InPacket and is an ICMPEcho, it means there is a migration attack.",
                "pat_code": "HostTracker = (Host?f0.f1.f2.f3.f4.f5->\n               ifa(f0==PktIn)\n               {\n                   ifa(f3==ARP){HandleARP(f0,f1,f2,f3,f4,f5)}\n                   else ifa(f3==ICMPEcho){migrationattack->Skip}\n               }\n               else {Skip});HostTracker;"
            },
            {
                "name": "HandleARP",
                "description": "HandleARP:\n  1. It searches for the host location in HostTable and retrieves the port type from PortTable.\n  2. If the host is not found and the port type is not SWITCH, it adds a new host to the HostTable. If port type is SWITCH an attack is registered and skipped.\n  3. If the host is found and its location matches the packet's source, it skips. Otherwise, it proceeds to HostMigration.",
                "pat_code": "HandleARP(f0,f1,f2,f3,f4,f5) = searchHost{host_loc[0]=HostTable[f4][0];host_loc[1]=HostTable[f4][1];}-> \n                               getDT{port_type=PortTable[f1][f2][0];}->\n                               ifa(host_loc[0]==-2&&host_loc[1]==-2)\n                               {\n                                   ifa(port_type==SWITCH){attack->Skip}\n                                   else{insertHost{HostTable[f4][0]=f1;HostTable[f4][1]=f2;}->Skip}\n                               }\n                               else\n                               {\n                                   ifa(host_loc[0]==f1&&host_loc[1]==f2){Skip}\n                                   else{HostMigration(f4,f1,f2,host_loc[0],host_loc[1])}\n                               };"
            },
            {
                "name": "HostMigration",
                "description": "HostMigration:\n  1. It first get the old port flag from the port table.\n  2. It checks if the old port is flagged as down.\n  3. If not flagged, then an attack is registered and skipped.\n  4. If flagged, the HostTable and PortTable are updated to reflect the new host location. The host is added to a host list for the new port if space is available and the old location is removed from the old port. Sends an ICMPEcho request to the old switch and port to finalize the migration.",
                "pat_code": "HostMigration(h,ns,np,os,op) =  getSDFlag{mflag=PortTable[os][op][1];}->\n                                ifa(mflag==TRUE)\n                                {\n                                    setLoc{HostTable[h][0]=ns;HostTable[h][1]=np;}->\n                                    setDT{PortTable[ns][np][0]=HOST;}->\n                                    addHostList{\n                                        if(PortTable[ns][np][2]==-2){PortTable[ns][np][2]=h;}\n                                        else if (PortTable[ns][np][3]==-2){PortTable[ns][np][3]=h;}\n                                        else {PortTable[ns][np][2]=-5;PortTable[ns][np][3]=-5;}}->\n                                    setSDFlag{PortTable[ns][np][1]=FALSE;}->\n                                    removeHostList{if(PortTable[os][op][2]==h){PortTable[os][op][2]=-2;}else if(PortTable[os][op][3]==h){PortTable[os][op][2]=-2;}}->\n                                    CSend!os.PktOut.op.ICMPEcho.Request.h->Skip\n                                }\n                                else{attack->Skip};\n\n//========================================================"
            },
            {
                "name": "Switch",
                "description": "Each switch in the system has an id, it may perform the following operations:\n  - receive message\n  - send message\n  - handle message\n  - receive packet\n  - send packet\n  - handle packet",
                "pat_code": "Switch(x)=(|||i:{1..PNum-1} @ (PktReceiver(x,i)|||PktSender(x,i)))\n          ||(MsgReceiver(x)|||MsgSender(x))\n          || PktHandler(x)||MsgHandler(x);"
            },
            {
                "name": "MsgReceiver",
                "description": "MsgReceiver(x): Receives control messages from the controller and forwards message to MsgHandler.",
                "pat_code": "MsgReceiver(x) = CS[x]?msgtype.param1.param2.param3.param4\n                 ->HandleMsg[x]!msgtype.param1.param2.param3.param4->MsgReceiver(x);"
            },
            {
                "name": "MsgSender",
                "description": "MsgSender(x): Sends messages to the controller after receiving the signal of sending message.",
                "pat_code": "MsgSender(x) = SendMsg[x]?msgtype.param1.param2.param3.param4.param5\n                 ->SC[x]!msgtype.param1.param2.param3.param4.param5\n                 ->MsgSender(x);"
            },
            {
                "name": "MsgHandler",
                "description": "MsgHandler(x): If the message type is PktOut, it forwards the packet information to the corresponding PktSender.",
                "pat_code": "MsgHandler(x) =  HandleMsg[x]?msgtype.param1.param2.param3.param4->                    \n                    ifa(msgtype==PktOut)\n                    {\n                        SendPkt[x*PNum+param1]!param2.param3.param4->Skip\n                    };"
            },
            {
                "name": "PktReceiver",
                "description": "PktReceiver(x, i): Receives packet on port i on switch x and forwards them to PktHandler.",
                "pat_code": "PktReceiver(x,i) = SP[x*(PNum-1)+i-1]?pkttype.f1.f2->HandlePkt[x]!i.pkttype.f1.f2->PktReceiver(x,i);"
            },
            {
                "name": "PktSender",
                "description": "PktSender(x, i): Receives packet sending signal on port i on switch x from MsgHandler and sends packet. If the destination is a host it forwards the packet to the host via channel. Otherwise, it forwards the packet to another switch.",
                "pat_code": "PktSender(x,i) = (SendPkt[x*PNum+i]?pkttype.f1.f2->\n                     ifa(CIndex[x][i-1]>=100){\n                         SH[CIndex[x][i-1]-100]!pkttype.f1.f2->Skip\n                     }else{\n                         SP[CIndex[x][i-1]]!pkttype.f1.f2->Skip\n                     });PktSender(x,i);"
            },
            {
                "name": "PktHandler",
                "description": "PktHandler(x): Receives packets from PktReceiver and sends sending packet signal to the MsgSender.",
                "pat_code": "PktHandler(x) = HandlePkt[x]?port.pkttype.f1.f2->\n                SendMsg[x]!PktIn.x.port.pkttype.f1.f2->PktHandler(x);"
            },
            {
                "name": "UnmovingHost",
                "description": "The UnmovingHost process represents a host connected to switch x and port i, with host ID u.\n  1. Listens for ICMPEcho requests. \n  2. If a request is received from the host itself, it sends an ICMPEcho reply back to the host.\n  3. Loops back to listening for request.",
                "pat_code": "UnmovingHost(u,x,i) =  SH[u]?pkttype.f1.f2->\n                       ifa(pkttype==ICMPEcho&&f1==Request&&f2==u){SP[TIndex[u]]!ICMPEcho.Reply.u->Skip};"
            },
            {
                "name": "Migration",
                "description": "Migration simulates the migration of host u from switch x, port i to switch y, port j. \n  1. It signals a port status change for the old port\n  2. And then updates the HostLoc table to reflect the new location. \n  3. Finally, it sends an ARP packet to the new switch port.",
                "pat_code": "Migration(u,x,i,y,j) = PtChange!PtStatus.PtDown.x.i->move{HostLoc[u][0]=y;HostLoc[u][1]=j;}->SP[y*(PNum-1)+j-1]!ARP.u.0->Skip;\n\n//========================================================"
            },
            {
                "name": "HostAttacker",
                "description": "HostAttacker represents an attacker sending a malicious ARP packet from switch x, port i impersonating host u to target host v.",
                "pat_code": "HostAttacker(x,i,u,v) = SP[x*(PNum-1)+i-1]!ARP.v.0->Skip;"
            },
            {
                "name": "LinkAttacker",
                "description": "LinkAttacker represents an attacker attempting to fabricate a link by sending an LLDP packet from switch x, port i. \n  Monitors the messages from unmoving host and if it sees an LLDP message, it then sends a spoofed LLDP packet to create a fake link and proceeds to next step.\n  Otherwise, it repeats receiving messages.",
                "pat_code": "LinkAttacker(x,i,u,v) = Monitor[v]?pkttype.f1.f2->\n                        ifa(pkttype==LLDP){SP[x*(PNum-1)+i-1]!pkttype.f1.f2->LinkAttacker1(x,i,u,v)}\n                        else {LinkAttacker(x,i,u,v)};"
            },
            {
                "name": "LinkAttacker1",
                "description": "The next step after the link attack receiving the LLDP message is keeping monitoring the unmoving host.",
                "pat_code": "LinkAttacker1(x,i,u,v) = Monitor[v]?pkttype.f1.f2->LinkAttacker1(x,i,u,v);      \n//========================================================"
            },
            {
                "name": "UnmovingHost",
                "description": "UnmovingHostM repeats the UnmovingHostM1.",
                "pat_code": "UnmovingHostM(u,x,i) = UnmovingHostM1(u,x,i);UnmovingHostM(u,x,i); //with attack behaviors"
            },
            {
                "name": "UnmovingHostM1",
                "description": "UnmovingHostM1 \n  1. Listens for ICMPEcho requests and sends the request is intercepted by the attacker.\n  2. If a request is received from the host itself, it sends an ICMPEcho reply back to the host.\n  3. Loops back to listening for request.",
                "pat_code": "UnmovingHostM1(u,x,i) = SH[u]?pkttype.f1.f2->Monitor[u]!pkttype.f1.f2->\n                       ifa(pkttype==ICMPEcho&&f1==Request&&f2==u){SP[TIndex[u]]!ICMPEcho.Reply.u->Skip};"
            },
            {
                "name": "MovingHostM",
                "description": "The MovingHostM has three behaviors:\n  - It acts as the UnmovingHost and perform migration after the UnmovingHost\n  - It listens for ICMPEcho requests and sends the request is intercepted by the attacker.\n  - It first performs the migration and then acts as the UnmovingHost",
                "pat_code": "MovingHostM(u,x,i,y,j) = (first->UnmovingHostM1(u,x,i);Migration(u,x,i,y,j))\n                      [](SH[u]?pkttype.f1.f2->Monitor[u]!pkttype.f1.f2->Migration(u,x,i,y,j))\n                      [](Migration(u,x,i,y,j);UnmovingHostM(u,y,j));\n                       \n//========================================================"
            },
            {
                "name": "System",
                "description": "The System represents the entire TopoGuard network. It consists of the concurrently running components: Switch, Controller, Moving Host, Unmoving Host and Migration Process.\n  While the Switch has SNum subprocesses.",
                "pat_code": "//The origianl system model\nSystem = Init;(\n         (||x:{0..SNum-1}@Switch(x))||Controller\n         ||(Migration(H2,S1,P2,S2,P1);(MovingHostM(H1,S2,P2,S1,P2)|||UnmovingHost(H2,S2,P1)))\n         ||UnmovingHost(H0,S0,P2)\n         ||(HostAttacker(S0,P2,H0,H1)|||LinkAttacker(S0,P2,H0,H1)));\n         \n//========================================================"
            }
        ],
        "global_definition": "//Constant definitions: the numbers of swithes, ports on each switch, and hosts.\n#define SNum 3;\n#define PNum 4;\n#define HNum 3;\n//Enumerations\nenum{PktOut, PktIn, PtStatus};//OpenFlow messages\nenum{ICMPEcho,LLDP,ARP};//Packets\nenum{S0,S1,S2};//Swtiches\nenum{P0,P1,P2,P3};//Ports\nenum{H0,H1,H2};//Hosts\nenum{RESERVED,ANY,HOST,SWITCH};//Port type\nenum{PtUp,PtDown};//Port State\nenum{FALSE,TRUE};\nenum{Request, Reply};//ICMPEcho type\n//==================================\nchannel SC[SNum] 0;\nchannel CS[SNum] 0;\nchannel PtChange 0;\nchannel CSend 0;\nchannel Link 0;\nchannel Host 0;\nchannel SP[SNum*(PNum-1)] 0;\nchannel SH[HNum] 0;\nchannel SendPkt[SNum*PNum] 0;//MsgHandler/PktHandler to PktSender\nchannel HandlePkt[SNum] 0;//PktReceiver to PktHandler\nchannel SendMsg[SNum] 0;//PktHandler to MsgSender\nchannel HandleMsg[SNum] 0;//MsgReciver to Msghandler\nchannel Monitor[HNum] 0;\n//==================================\nvar LinkExist[SNum][SNum]=[0,1,0,\n                           1,0,1,\n                           0,1,0];\nvar LinkTable[SNum][SNum]=[-2,P1,-2, \n                            P3,-2,P1,  \n                           -2,P3,-2];\nvar PortTable[SNum][PNum][4]=[RESERVED,FALSE,-2,-2, ANY,FALSE,-2,-2, HOST,FALSE,H0,-2,  ANY,FALSE,-2,-2,\n                             RESERVED,FALSE,-2,-2, ANY,FALSE,-2,-2, ANY,FALSE,-2,-2, ANY,FALSE,-2,-2,\n                             RESERVED,FALSE,-2,-2, ANY,FALSE,-2,-2, HOST,FALSE,H1,-2, ANY,FALSE,-2,-2];\nvar HostTable[HNum][2]=[S0,P2,\n                        S2,P2,\n                        S1,P2];\n//real locations of the hosts\nvar HostLoc[HNum][2]=[S0,P2,\n                      S2,P2,\n                      S1,P2];\n//real topology among the switches\nvar InterLink[SNum][SNum]=[-2,P1,-2, \n                            P3,-2,P1,  \n                           -2,P3,-2];\n//==================================\nvar is_new_link = FALSE;\nvar port_type1 = ANY;\nvar port_type2 = ANY;\nvar host_loc[2] = [-1,-1];\nvar port_type = ANY;\nvar mflag = FALSE;\n//special arrays to help programming\nvar CIndex[SNum][PNum-1];//SP index\nvar TIndex[HNum];//SH index\n//==================================",
        "path": "handwrite/TopoGuard.csp"
    },
    {
        "name": "Transactional Memory Scheduling",
        "tags": [
            "Algorithm"
        ],
        "use_non_container_lib": false,
        "description": "The scheduler architecture comprises the online scheduler S, and n worker W_i, which are assigned to n available processing elements. New transactions, from an application, are asynchronously queued at the tail of the input queue Q_in.",
        "pat_code": "#define Index 2;\n#define TNum 5;\n\nvar tnum =0;\nvar snum =0;\nvar abortTime =0;\nvar dnum =0;\nvar count =0;\nvar T[TNum];\n\nenum {ready, complete, done};\nenum {None};\n\n#import \"PAT.Lib.Queue\";\nvar <Queue> QueueIn ;\nvar <Queue> Queue1 ;\nvar <Queue> Queue2 ;\nvar Queue[Index]=[Queue1,Queue2];\n\nchannel comAS 0;\nchannel comSA 0;\nchannel comSW[Index] 0;\nchannel output 0;\n\nvar EstimatedTime;\n#define estimateTime(x) {EstimatedTime = x};\n\n/*@Process: Application\n  Application: Generates transactions and enqueues them into an input queue:\n\t1. It first checks if the number of generated transactions is less than the total number of transactions to be generated.\n\t2. If the transaction num is less than total transaction num, the application enqueues a new transaction into the input queue QueueIn and increase it. And loops back to the beginning.\n\t3. Otherwise, the application signals the scheduler that it is ready. Then, it waits for the scheduler to signal completion. Upon receiving this signal, it resets all values to 0 and then recursively restarts the application process.\n\n*/\nApplication() = ifa (tnum < TNum) {\n\t\tatomic{ enQueue{QueueIn.Enqueue(T[tnum]); tnum++} -> Skip };\n\t\tApplication() \n\t} else {\n\t\tcomAS!ready -> comSA?COMPLETE{ snum=0; count=0; dnum=0; tnum =0; abortTime =0} -> Application() \n\t};\n\n/*@Process: Scheduler\n  Scheduler1 is the Round-Robin Scheduler: \n\t1. Waits for the ready signal from the application and proceeds to the scheduler loop.\n\n\n*/\n// scheduler RR\nvar p;\nvar q;\nvar load[Index];\nScheduler1()=comAS?READY->Scheduler1_1();\n\n/*@Process: Scheduler1_1\n\tThe Scheduler1_1 is the scheduler loop:\n  1. Checks if the input queue QueueIn is empty.\n  2. If the input queue is empty, it signals all workers to get ready to execute transactions. The next step is to move to the second phase scheduler1_2().\n  3. If the input queue is not empty, it atomically:\n\t3.1. Dequeues a transaction from the input queue QueueIn. \n\t3.2. The scheduler then allocates the transaction to a worker based on a round-robin policy. The transaction is enqueued to the Queue. It calls the estimateTime function to estimate the execution time of the transaction and then updates the load of the corresponding worker.\n  4. Recursively starts the scheduler to process more transactions.\n\n*/\nScheduler1_1()=ifa(QueueIn.Count()==0){\n\t\tatomic{comSW[0]!ready->comSW[1]!ready->Skip}; Scheduler1_2()\n\t} else{\n\t\tatomic{\n\t\t\tdeQueue{\n\t\t\t\tp=count%Index;\n\t\t\t\tq=QueueIn.First(); \n\t\t\t\tQueueIn.Dequeue()\n\t\t\t} -> allocateTo{\n\t\t\t\tQueue[p].Enqueue(q);\n\t\t\t\tcount++;\n\t\t\t\tcall(estimateTime, q);\n\t\t\t\tload[p]=load[p]+EstimatedTime;\n\t\t\t}\n\t\t\t->Skip\n\t\t};\n\t\tScheduler1_1()\n\t};\n\n/*@Process: Scheduler1_2\n  scheduler1_2:\n  1. The Scheduler1_2 process firsts waits for workers to finish by receiving done signal on output channel until all workers are done.\n\t2. If all workers are done and the number of successfully completed transactions is equal to the total transaction number, the scheduler signals the application that it is complete by sending the complete signal and restarts the Scheduler1().\n  3. Otherwise, reschedules and restarts the scheduler loop.\n*/\nScheduler1_2()=atomic{\n\t\toutput?d{dnum++}->\n\t\tifa(dnum<Index){\n\t\t\tScheduler1_2()\n\t\t} else{\n\t\t\tifa(snum==TNum){comSA!complete->Scheduler1()}\n\t\t\telse{reSchedule{dnum=0}->Scheduler1_1()}\n\t\t}\n\t};\n\n/*@Process: Worker\n  Workers: Execute the transactions assigned to them.\n\t1. Initialization: Waits for the ready signal from the scheduler and proceeds to the worker loop.\n*/\n// worker\nvar currentT[TNum];\nvar currentT_Var[TNum];\nvar currentT_Time[TNum];\nvar workertime[Index];\nvar T_Var[TNum];\nWorker(i)=comSW[i]?READY->Worker_1(i);\n/*@Process: Worker_1\n  Worker_1 is the worker loop:\n  1. Checks if the worker's queue Queue is empty.\n  2. If the queue is empty, the worker signals that it is done to the output channel and restarts the worker for the next ready signal from the scheduler.\n  3. If the queue is not empty, it atomically: Dequeues a transaction from its queue, estimates the transaction's execution time using estimateTime, updates the worker's load, and stores current time and estimated execution time.\n  4. Progresses to the Working state.\n  5. Checks if the worker can successfully complete the transaction. It will succeed if no other worker is working on another transaction that shares a variable with the current transaction. \n\t6. If the transaction can be successfully committed, updates its workertime to 0, sets the current transaction variable to None, increments the number of successfully completed transactions, and returns to the initial state to process more transactions.\n\t7. Otherwise, it aborts the transaction by enqueuing it back into the input queue QueueIn, increments the abortTime counter, and returns to the initial state.\n*/\nWorker_1(i)=ifa(Queue[i].Count()==0){\n\t\toutput!done->Worker(i)\n\t} else{\n\t\tatomic{\n\t\t\tgoExecute{\n\t\t\t\tq=Queue[i].First();\n\t\t\t\tcurrentT[i]=q;\n\t\t\t\tcall(estimateTime,currentT[i]);\n\t\t\t\tQueue[i].Dequeue();\n\t\t\t\tload[i]=load[i]-EstimatedTime;\n\t\t\t\tcurrentT_Var[i]=T_Var[q];\n\t\t\t\tcurrentT_Time[i]=EstimatedTime\n\t\t\t}->Skip\n\t\t};\n\t\tWorking(i);\n\t\tifa(&&x:{0..Index-1}@(x==i||workertime[x]==0||currentT_Var[x]!=currentT_Var[i])){\n\t\t\tsuccess{\n\t\t\t\tworkertime[i]=0;\n\t\t\t\tcurrentT_Var[i]=None;\n\t\t\t\tsnum++\n\t\t\t}->Worker_1(i)\n\t\t} else{\n\t\t\tabort{QueueIn.Enqueue(currentT[i]);\n\t\t\tabortTime++;\n\t\t}->Worker_1(i)}\n\t};\n\n/*@Process: Working\n\tWorking: It keep working by increasing its workertime until the worker time reach the estimated time for transaction i.\n*/\nWorking(i)=ifa(workertime[i]<currentT_Time[i]){\n\t\tworking{workertime[i]++}->Working(i)\n\t}else{Skip};\n\n/*@Process: SYSTEM\n  The scheduler architecture comprises the online scheduler S, and n worker W_i and the application initiates transactions.\n*/\nSYSTEM() = Application() || Scheduler1() || (||i:{0..Index-1}@Worker(i));",
        "property_desc": [
            "The system is deadlock-free.",
            "Eventually, the transaction will complete."
        ],
        "properties": [
            "#assert SYSTEM() deadlockfree;",
            "#assert SYSTEM() |= []<> comSA.complete;"
        ],
        "processes": [
            {
                "name": "Application",
                "description": "Application: Generates transactions and enqueues them into an input queue:\n\t1. It first checks if the number of generated transactions is less than the total number of transactions to be generated.\n\t2. If the transaction num is less than total transaction num, the application enqueues a new transaction into the input queue QueueIn and increase it. And loops back to the beginning.\n\t3. Otherwise, the application signals the scheduler that it is ready. Then, it waits for the scheduler to signal completion. Upon receiving this signal, it resets all values to 0 and then recursively restarts the application process.",
                "pat_code": "Application() = ifa (tnum < TNum) {\n\t\tatomic{ enQueue{QueueIn.Enqueue(T[tnum]); tnum++} -> Skip };\n\t\tApplication() \n\t} else {\n\t\tcomAS!ready -> comSA?COMPLETE{ snum=0; count=0; dnum=0; tnum =0; abortTime =0} -> Application() \n\t};"
            },
            {
                "name": "Scheduler",
                "description": "Scheduler1 is the Round-Robin Scheduler: \n\t1. Waits for the ready signal from the application and proceeds to the scheduler loop.",
                "pat_code": "// scheduler RR\nvar p;\nvar q;\nvar load[Index];\nScheduler1()=comAS?READY->Scheduler1_1();"
            },
            {
                "name": "Scheduler1_1",
                "description": "The Scheduler1_1 is the scheduler loop:\n  1. Checks if the input queue QueueIn is empty.\n  2. If the input queue is empty, it signals all workers to get ready to execute transactions. The next step is to move to the second phase scheduler1_2().\n  3. If the input queue is not empty, it atomically:\n\t3.1. Dequeues a transaction from the input queue QueueIn. \n\t3.2. The scheduler then allocates the transaction to a worker based on a round-robin policy. The transaction is enqueued to the Queue. It calls the estimateTime function to estimate the execution time of the transaction and then updates the load of the corresponding worker.\n  4. Recursively starts the scheduler to process more transactions.",
                "pat_code": "Scheduler1_1()=ifa(QueueIn.Count()==0){\n\t\tatomic{comSW[0]!ready->comSW[1]!ready->Skip}; Scheduler1_2()\n\t} else{\n\t\tatomic{\n\t\t\tdeQueue{\n\t\t\t\tp=count%Index;\n\t\t\t\tq=QueueIn.First(); \n\t\t\t\tQueueIn.Dequeue()\n\t\t\t} -> allocateTo{\n\t\t\t\tQueue[p].Enqueue(q);\n\t\t\t\tcount++;\n\t\t\t\tcall(estimateTime, q);\n\t\t\t\tload[p]=load[p]+EstimatedTime;\n\t\t\t}\n\t\t\t->Skip\n\t\t};\n\t\tScheduler1_1()\n\t};"
            },
            {
                "name": "Scheduler1_2",
                "description": "scheduler1_2:\n  1. The Scheduler1_2 process firsts waits for workers to finish by receiving done signal on output channel until all workers are done.\n\t2. If all workers are done and the number of successfully completed transactions is equal to the total transaction number, the scheduler signals the application that it is complete by sending the complete signal and restarts the Scheduler1().\n  3. Otherwise, reschedules and restarts the scheduler loop.",
                "pat_code": "Scheduler1_2()=atomic{\n\t\toutput?d{dnum++}->\n\t\tifa(dnum<Index){\n\t\t\tScheduler1_2()\n\t\t} else{\n\t\t\tifa(snum==TNum){comSA!complete->Scheduler1()}\n\t\t\telse{reSchedule{dnum=0}->Scheduler1_1()}\n\t\t}\n\t};"
            },
            {
                "name": "Worker",
                "description": "Workers: Execute the transactions assigned to them.\n\t1. Initialization: Waits for the ready signal from the scheduler and proceeds to the worker loop.",
                "pat_code": "// worker\nvar currentT[TNum];\nvar currentT_Var[TNum];\nvar currentT_Time[TNum];\nvar workertime[Index];\nvar T_Var[TNum];\nWorker(i)=comSW[i]?READY->Worker_1(i);"
            },
            {
                "name": "Worker_1",
                "description": "Worker_1 is the worker loop:\n  1. Checks if the worker's queue Queue is empty.\n  2. If the queue is empty, the worker signals that it is done to the output channel and restarts the worker for the next ready signal from the scheduler.\n  3. If the queue is not empty, it atomically: Dequeues a transaction from its queue, estimates the transaction's execution time using estimateTime, updates the worker's load, and stores current time and estimated execution time.\n  4. Progresses to the Working state.\n  5. Checks if the worker can successfully complete the transaction. It will succeed if no other worker is working on another transaction that shares a variable with the current transaction. \n\t6. If the transaction can be successfully committed, updates its workertime to 0, sets the current transaction variable to None, increments the number of successfully completed transactions, and returns to the initial state to process more transactions.\n\t7. Otherwise, it aborts the transaction by enqueuing it back into the input queue QueueIn, increments the abortTime counter, and returns to the initial state.",
                "pat_code": "Worker_1(i)=ifa(Queue[i].Count()==0){\n\t\toutput!done->Worker(i)\n\t} else{\n\t\tatomic{\n\t\t\tgoExecute{\n\t\t\t\tq=Queue[i].First();\n\t\t\t\tcurrentT[i]=q;\n\t\t\t\tcall(estimateTime,currentT[i]);\n\t\t\t\tQueue[i].Dequeue();\n\t\t\t\tload[i]=load[i]-EstimatedTime;\n\t\t\t\tcurrentT_Var[i]=T_Var[q];\n\t\t\t\tcurrentT_Time[i]=EstimatedTime\n\t\t\t}->Skip\n\t\t};\n\t\tWorking(i);\n\t\tifa(&&x:{0..Index-1}@(x==i||workertime[x]==0||currentT_Var[x]!=currentT_Var[i])){\n\t\t\tsuccess{\n\t\t\t\tworkertime[i]=0;\n\t\t\t\tcurrentT_Var[i]=None;\n\t\t\t\tsnum++\n\t\t\t}->Worker_1(i)\n\t\t} else{\n\t\t\tabort{QueueIn.Enqueue(currentT[i]);\n\t\t\tabortTime++;\n\t\t}->Worker_1(i)}\n\t};"
            },
            {
                "name": "Working",
                "description": "Working: It keep working by increasing its workertime until the worker time reach the estimated time for transaction i.",
                "pat_code": "Working(i)=ifa(workertime[i]<currentT_Time[i]){\n\t\tworking{workertime[i]++}->Working(i)\n\t}else{Skip};"
            },
            {
                "name": "SYSTEM",
                "description": "The scheduler architecture comprises the online scheduler S, and n worker W_i and the application initiates transactions.",
                "pat_code": "SYSTEM() = Application() || Scheduler1() || (||i:{0..Index-1}@Worker(i));"
            }
        ],
        "global_definition": "#define Index 2;\n#define TNum 5;\n\nvar tnum =0;\nvar snum =0;\nvar abortTime =0;\nvar dnum =0;\nvar count =0;\nvar T[TNum];\n\nenum {ready, complete, done};\nenum {None};\n\n#import \"PAT.Lib.Queue\";\nvar <Queue> QueueIn ;\nvar <Queue> Queue1 ;\nvar <Queue> Queue2 ;\nvar Queue[Index]=[Queue1,Queue2];\n\nchannel comAS 0;\nchannel comSA 0;\nchannel comSW[Index] 0;\nchannel output 0;\n\nvar EstimatedTime;\n#define estimateTime(x) {EstimatedTime = x};",
        "path": "handwrite/Transactional Memory.csp"
    },
    {
        "name": "Virtio",
        "tags": [
            "Protocol"
        ],
        "use_non_container_lib": false,
        "description": "Virtio is a semi-virtualized I/O protocol used in many virtualization scenarios. Its goal is to provide an efficient and unified I/O interface for different virtualization platforms to enable device communication between Guests and hosts. \n  The virtio architecture consists of the following layers: the virtio driver in the Guest OS, the virtio device in the Hypervisor(Host Device), and the Transport layer:",
        "pat_code": "#define Max 10;\nvar guest_has_req\t= 0;\nvar request_in_guestvirtqueue = 0; \nvar request_in_hostvirtqueue = 0;\nvar guest_notify_transport = 0;\nvar transport_notify_host = 0;\nvar host_is_processing\t= 0; \nvar host_processed_req\t\t= 0;\nvar transport_notify_guest = 0; \nvar host_notify_transport = 0;\nvar guest_read_done\t= 0;\n\nvar req_count = 0;\n\n/*@Process: Virtio\n  \n  The Virtio is composed of the parallel execution of the Guest, Transport Layer and Host Device processes.\n  \n*/\nVirtio() = Guest()||Transport()||Host();\n\n/*@Process: Guest\n  The Guest() process represents the guest operating system. It has six different behaviors:\n  - Send Request: If the number of sent requests req_count is less than Max and there is no request already in the guest's virtqueue, \n    the Guest can send a new request. This increments req_count and sets guest_has_req to 1.\n  - Write to Virtqueue: If req_count equals Max and the guest's virtqueue is empty, \n    the Guest writes the request to its virtqueue, setting request_in_guestvirtqueue to 1.\n  - Notify Transport: If req_count equals Max and the Guest has not yet notified the Transport layer, \n    it notifies the Transport layer of the new request, setting guest_notify_transport to 1.\n  - Read Completion: When the Transport layer indicates that the Host has processed the request and the Guest has not yet read the result, \n    the Guest reads the completion, which clears the host virtqueue flag and sets guest_read_done to 1.\n  - Reset: After guest reading the completion, the Guest can reset its state and resets all the relevant flags and counters, allowing a new series of requests to be initiated.\n  - Receive Transport Notification: If the Host has processed a request, written the results back, and notified the transport, \n    the guest reads the transport notification using T_NotifyG, setting transport_notify_guest to 1.\n\n*/\nGuest() =\n\t[req_count < Max && request_in_guestvirtqueue == 0] G_SendRequest{\n\t\tguest_has_req = 1; req_count = req_count + 1;\n\t} -> Guest()\n\t[] \n\t[req_count == Max && request_in_guestvirtqueue == 0] G_WriteVirtqueue {\n\t\trequest_in_guestvirtqueue = 1;\n\t} -> Guest()\n\t[] \n\t[req_count == Max && guest_notify_transport == 0] G_NotifyT {\n\t\tguest_notify_transport = 1;\n\t} -> Guest()\n\t[] \n\t[transport_notify_guest == 1 && guest_read_done == 0] T_GuestReadsCompletion{\n\t\trequest_in_hostvirtqueue = 0;\n\t\tguest_read_done = 1;\n\t} -> Guest()\n\t[] [guest_read_done == 1] G_Reset {\n\t\tguest_has_req= 0;\n\t\trequest_in_hostvirtqueue = 0;\n\t\trequest_in_guestvirtqueue = 0;\n\t\ttransport_notify_guest = 0;\n\t\thost_notify_transport = 0;\n\t\tguest_notify_transport = 0;\n\t\ttransport_notify_host = 0;\n\t\thost_processed_req\t= 0;\n\t\tguest_read_done\t= 0;\n\t\treq_count = 0;\n\t} -> Guest()\n\t[]\n\t[host_processed_req == 1 && request_in_hostvirtqueue == 1 && host_notify_transport == 1]T_NotifyG{transport_notify_guest = 1} -> Guest()\n;\n\n/*@Process: Transport\n  Transport Process acts as an intermediary between the Guest and Host. Its behavior includes:\n  - Wait for Guest Write: When request count is Max and there is no request in the guest virtqueue yet, it simulates the guest writing to the queue with G_WriteVirtqueue by setting request_in_guestvirtqueue to 1.\n  - Allow Host Read: When there is a request in the guest's virtqueue and the Host is ready to process it, the Transport layer allows the Host to read from the queue, clearing request_in_guestvirtqueue.\n  - Host Writes Completion: When the Host has written the completion results and no request in the host virtqueue, the transport notes this with T_HostWritesCompletion, setting request_in_hostvirtqueue to 1.\n  - Request Consumpetion: After the guest has read the results from the host virtqueue and there is request in the virtqueue, the request can be consumed.\n  - Notify Host: If the guest has not sent a notification, and req_count is Max it notifies the host with T_NotifyH, setting transport_notify_host to 1.\n  - Host Notification to Guest: If the host has processed and notified the transport, and there exists request in the host's virtqueue. \n    The transport is notified by the host and then the transport will notify the guest by setting transport_notify_guest to 1.\n*/\nTransport() =\n[req_count\t==\tMax\t&&\trequest_in_guestvirtqueue\t==\t0] G_WriteVirtqueue{ request_in_guestvirtqueue = 1; }-> Transport()\n[]\t[request_in_guestvirtqueue\t==\t1\t&&\thost_is_processing\t==\t1] T_AllowHostRead{ request_in_guestvirtqueue = 0; }-> Transport()\n[]\t[host_processed_req\t==\t1\t&&\trequest_in_hostvirtqueue\t== 0]T_HostWritesCompletion{request_in_hostvirtqueue = 1;}-> Transport()\n[]\t[guest_read_done\t==\t1\t&&\trequest_in_hostvirtqueue\t==\t1]\nT_GuestReadsCompletion{request_in_hostvirtqueue = 0; guest_read_done = 1; } -> Transport()\n[] [req_count == Max && guest_notify_transport == 0] G_NotifyT{ guest_notify_transport = 1;}-> T_NotifyH{transport_notify_host = 1} -> Transport()\n[][host_processed_req == 1 && request_in_hostvirtqueue == 1 && host_notify_transport == 0] H_NotifyT{ host_notify_transport = 1; host_is_processing = 0; host_processed_req = 0; }-> T_NotifyG{transport_notify_guest = 1} -> Transport()\n;\n\n/*@Process: Host\n  The Host() process represents the host system. Its behavior is as follows:\n  - Receive Notification: When the Transport layer notifies the Host of a new request and the Host is not currently processing a request, the Host receives the notification and starts processing request, setting host_is_processing to 1.\n  - Synchronized read with Transport: When there is a request in the guest's virtqueue and the Host is processing, the transport allows the host to read using T_AllowHostRead and clears the request_in_guestvirtqueue flag.\n  - Process Request: When the Host is processing a request and no more requests in guest virtqueue, it reads and processes the request, setting host_processed_req to 1.\n  - Host Writes Completion: When the host has processed a request and no requests in the host virtqueue, the transport synchronises on T_HostWritesCompletion and marks that the request is in the host virtqueue.\n  - Notify Transport: When the host has completed the request and there is a request in the host queue and, the host then notifies the Transport layer, setting host_notify_transport = 1, host_is_processing = 0 and resetting host_processed_req = 0.\n  - Transport Notifies Host: If the transport has seen the guest notification and request count reaches max, it is notified by the Transport, setting transport_notify_host to 1.\n*/\nHost() =\n[transport_notify_host\t==\t1\t&&\thost_is_processing\t==\t0] H_ReceiveNotification{ host_is_processing = 1; }-> Host()\n[]\t[request_in_guestvirtqueue\t==\t1\t&&\thost_is_processing\t== 1]T_AllowHostRead{ request_in_guestvirtqueue=0}-> Host()\n[]  [host_is_processing  ==  1  &&  request_in_guestvirtqueue  ==  0] H_ProcessRequest{ host_processed_req = 1; }-> Host()\n[]\t[host_processed_req\t==\t1\t&&\trequest_in_hostvirtqueue\t== 0]T_HostWritesCompletion{request_in_hostvirtqueue = 1;}-> Host()\n[] [host_processed_req == 1 && request_in_hostvirtqueue == 1] H_NotifyTz{ host_notify_transport\n= 1; host_is_processing = 0; host_processed_req = 0; }-> Host()\n[][req_count == Max && guest_notify_transport == 1]T_NotifyH{transport_notify_host = 1} -> Host()\n;",
        "property_desc": [
            "The system is deadlock-free.",
            "The system is divergence-free.",
            "A successful request-response can be made."
        ],
        "properties": [
            "#assert Virtio() deadlockfree;",
            "#assert Virtio() divergencefree;",
            "#define goal1 (guest_read_done == 1); \n#assert Virtio() reaches goal1;"
        ],
        "processes": [
            {
                "name": "Virtio",
                "description": "The Virtio is composed of the parallel execution of the Guest, Transport Layer and Host Device processes.",
                "pat_code": "Virtio() = Guest()||Transport()||Host();"
            },
            {
                "name": "Guest",
                "description": "The Guest() process represents the guest operating system. It has six different behaviors:\n  - Send Request: If the number of sent requests req_count is less than Max and there is no request already in the guest's virtqueue, \n    the Guest can send a new request. This increments req_count and sets guest_has_req to 1.\n  - Write to Virtqueue: If req_count equals Max and the guest's virtqueue is empty, \n    the Guest writes the request to its virtqueue, setting request_in_guestvirtqueue to 1.\n  - Notify Transport: If req_count equals Max and the Guest has not yet notified the Transport layer, \n    it notifies the Transport layer of the new request, setting guest_notify_transport to 1.\n  - Read Completion: When the Transport layer indicates that the Host has processed the request and the Guest has not yet read the result, \n    the Guest reads the completion, which clears the host virtqueue flag and sets guest_read_done to 1.\n  - Reset: After guest reading the completion, the Guest can reset its state and resets all the relevant flags and counters, allowing a new series of requests to be initiated.\n  - Receive Transport Notification: If the Host has processed a request, written the results back, and notified the transport, \n    the guest reads the transport notification using T_NotifyG, setting transport_notify_guest to 1.",
                "pat_code": "Guest() =\n\t[req_count < Max && request_in_guestvirtqueue == 0] G_SendRequest{\n\t\tguest_has_req = 1; req_count = req_count + 1;\n\t} -> Guest()\n\t[] \n\t[req_count == Max && request_in_guestvirtqueue == 0] G_WriteVirtqueue {\n\t\trequest_in_guestvirtqueue = 1;\n\t} -> Guest()\n\t[] \n\t[req_count == Max && guest_notify_transport == 0] G_NotifyT {\n\t\tguest_notify_transport = 1;\n\t} -> Guest()\n\t[] \n\t[transport_notify_guest == 1 && guest_read_done == 0] T_GuestReadsCompletion{\n\t\trequest_in_hostvirtqueue = 0;\n\t\tguest_read_done = 1;\n\t} -> Guest()\n\t[] [guest_read_done == 1] G_Reset {\n\t\tguest_has_req= 0;\n\t\trequest_in_hostvirtqueue = 0;\n\t\trequest_in_guestvirtqueue = 0;\n\t\ttransport_notify_guest = 0;\n\t\thost_notify_transport = 0;\n\t\tguest_notify_transport = 0;\n\t\ttransport_notify_host = 0;\n\t\thost_processed_req\t= 0;\n\t\tguest_read_done\t= 0;\n\t\treq_count = 0;\n\t} -> Guest()\n\t[]\n\t[host_processed_req == 1 && request_in_hostvirtqueue == 1 && host_notify_transport == 1]T_NotifyG{transport_notify_guest = 1} -> Guest()\n;"
            },
            {
                "name": "Transport",
                "description": "Transport Process acts as an intermediary between the Guest and Host. Its behavior includes:\n  - Wait for Guest Write: When request count is Max and there is no request in the guest virtqueue yet, it simulates the guest writing to the queue with G_WriteVirtqueue by setting request_in_guestvirtqueue to 1.\n  - Allow Host Read: When there is a request in the guest's virtqueue and the Host is ready to process it, the Transport layer allows the Host to read from the queue, clearing request_in_guestvirtqueue.\n  - Host Writes Completion: When the Host has written the completion results and no request in the host virtqueue, the transport notes this with T_HostWritesCompletion, setting request_in_hostvirtqueue to 1.\n  - Request Consumpetion: After the guest has read the results from the host virtqueue and there is request in the virtqueue, the request can be consumed.\n  - Notify Host: If the guest has not sent a notification, and req_count is Max it notifies the host with T_NotifyH, setting transport_notify_host to 1.\n  - Host Notification to Guest: If the host has processed and notified the transport, and there exists request in the host's virtqueue. \n    The transport is notified by the host and then the transport will notify the guest by setting transport_notify_guest to 1.",
                "pat_code": "Transport() =\n[req_count\t==\tMax\t&&\trequest_in_guestvirtqueue\t==\t0] G_WriteVirtqueue{ request_in_guestvirtqueue = 1; }-> Transport()\n[]\t[request_in_guestvirtqueue\t==\t1\t&&\thost_is_processing\t==\t1] T_AllowHostRead{ request_in_guestvirtqueue = 0; }-> Transport()\n[]\t[host_processed_req\t==\t1\t&&\trequest_in_hostvirtqueue\t== 0]T_HostWritesCompletion{request_in_hostvirtqueue = 1;}-> Transport()\n[]\t[guest_read_done\t==\t1\t&&\trequest_in_hostvirtqueue\t==\t1]\nT_GuestReadsCompletion{request_in_hostvirtqueue = 0; guest_read_done = 1; } -> Transport()\n[] [req_count == Max && guest_notify_transport == 0] G_NotifyT{ guest_notify_transport = 1;}-> T_NotifyH{transport_notify_host = 1} -> Transport()\n[][host_processed_req == 1 && request_in_hostvirtqueue == 1 && host_notify_transport == 0] H_NotifyT{ host_notify_transport = 1; host_is_processing = 0; host_processed_req = 0; }-> T_NotifyG{transport_notify_guest = 1} -> Transport()\n;"
            },
            {
                "name": "Host",
                "description": "The Host() process represents the host system. Its behavior is as follows:\n  - Receive Notification: When the Transport layer notifies the Host of a new request and the Host is not currently processing a request, the Host receives the notification and starts processing request, setting host_is_processing to 1.\n  - Synchronized read with Transport: When there is a request in the guest's virtqueue and the Host is processing, the transport allows the host to read using T_AllowHostRead and clears the request_in_guestvirtqueue flag.\n  - Process Request: When the Host is processing a request and no more requests in guest virtqueue, it reads and processes the request, setting host_processed_req to 1.\n  - Host Writes Completion: When the host has processed a request and no requests in the host virtqueue, the transport synchronises on T_HostWritesCompletion and marks that the request is in the host virtqueue.\n  - Notify Transport: When the host has completed the request and there is a request in the host queue and, the host then notifies the Transport layer, setting host_notify_transport = 1, host_is_processing = 0 and resetting host_processed_req = 0.\n  - Transport Notifies Host: If the transport has seen the guest notification and request count reaches max, it is notified by the Transport, setting transport_notify_host to 1.",
                "pat_code": "Host() =\n[transport_notify_host\t==\t1\t&&\thost_is_processing\t==\t0] H_ReceiveNotification{ host_is_processing = 1; }-> Host()\n[]\t[request_in_guestvirtqueue\t==\t1\t&&\thost_is_processing\t== 1]T_AllowHostRead{ request_in_guestvirtqueue=0}-> Host()\n[]  [host_is_processing  ==  1  &&  request_in_guestvirtqueue  ==  0] H_ProcessRequest{ host_processed_req = 1; }-> Host()\n[]\t[host_processed_req\t==\t1\t&&\trequest_in_hostvirtqueue\t== 0]T_HostWritesCompletion{request_in_hostvirtqueue = 1;}-> Host()\n[] [host_processed_req == 1 && request_in_hostvirtqueue == 1] H_NotifyTz{ host_notify_transport\n= 1; host_is_processing = 0; host_processed_req = 0; }-> Host()\n[][req_count == Max && guest_notify_transport == 1]T_NotifyH{transport_notify_host = 1} -> Host()\n;"
            }
        ],
        "global_definition": "#define Max 10;\nvar guest_has_req\t= 0;\nvar request_in_guestvirtqueue = 0; \nvar request_in_hostvirtqueue = 0;\nvar guest_notify_transport = 0;\nvar transport_notify_host = 0;\nvar host_is_processing\t= 0; \nvar host_processed_req\t\t= 0;\nvar transport_notify_guest = 0; \nvar host_notify_transport = 0;\nvar guest_read_done\t= 0;\n\nvar req_count = 0;",
        "path": "handwrite/Virtio.csp"
    },
    {
        "name": "Zab",
        "tags": [
            "Protocol"
        ],
        "use_non_container_lib": false,
        "description": "ZooKeeper Atomic Broadcast (Zab) is a high-performance atomic broadcast protocol, which is a key component of Apache ZooKeeper. By ensuring strong consistency and fault tolerance, the Zab protocol plays a crucial role in building robust and resilient distributed systems.\n  Zab has four roles: \n         \u2013 Client: Clients interact with the distributed system and send update requests to the leader.\n         \u2013 Leader: Servers in the leading state are responsible for coordinating the replication of data updates across the followers. In case of failures or leader re-election, a new leader is elected among the followers.\n        \u2013 Follower: Servers in the following state replicate data updates received from the leader. They maintain a copy of the leader\u2019s log and execute the updates in the same order as the leader.\n       \u2013 Looker: Servers in the looking state actively participate in the leader election process by requesting votes from other servers, which occurs when there is no leader present in the system.\n  The Zab protocol operates in three main phases: Discovery phase, Synchronization phase and Broadcast phase. \n  Discovery Phase. In this phase, the servers in the ZooKeeper system discover each other and determine their roles. Initially, all servers start in the looking state, indicating that there is no leader. In addition, servers communicate and exchange information to elect a leader. They send election requests and respond with election requests from other servers to establish a new primary. Once a server receives votes from the majority, it switches to the leading state, indicating that it is recognized as a leader. \n  Synchronization Phase. After the leader is elected, the synchronization phase begins. In this phase, the followers synchronize data with the leader. It sends synchronization requests to the followers, which reply with their last known committed proposal. The leader then compares its own transaction log with the followers\u2019 logs and sends the missing proposals to bring them up to date. This ensures that all followers have an identical copy of the leader\u2019s log and brings them into a consistent state. \n  Broadcast Phase. Once synchronization is complete, the servers enter into the broadcast phase. During this phase, the leader receives client\u2019s requests and proposes new proposals. It orders the proposals, assigns unique identifiers, and broadcasts them to all followers. The followers replicate the proposals. Then, when the leader receives the ACK message from more than half of the followers for the transaction proposal, it will send a commit message to all the followers. This ensures durability and guarantees the consistency of transactions across the entire cluster. Figure 3 shows the workflows of this phase.",
        "pat_code": "////////////////The Model//////////////////\n#define C 1; //number of clients\n#define S 3; //number of Servers\n#define P 1; //number of Proposals\n\n\n////////////////Global Variables//////////////////\nenum{Request,Response,Data};\nenum{Election,LeaderMsg,VoteMsg,ToBeFollower,ReqProposal,RepProposal,ReadData,WriteData,SendProposalMsg,CommitProposalMsg,Faid};\nenum{syn_ack,p_ack,f_ack,join_ack};\nenum{looking,following,leading,crashing};\nchannel ComCS[C*S] 0; //channel between Client and Server\nchannel ComSS[S*S] 0; //channel between Server i and Server j\nvar Status[S] = [looking,looking,looking]; //record the status of the server i\nvar toVote[S]; // record the voting result of the server i\nvar Epoch[S]; //Server i current epoch\nvar CommitPro[S]=[-1,-1,-1]; // Server i current max zxid of proposal committed\nvar Look[S]; //number of Lookers\nvar Pro[P];\nvar Proposal[S][P];\nvar leaderCount = 0;\nvar leaderID = -1;\nvar CurrentEpoch = 0;\nvar voteNumber = 0;\nvar nextZxid = -1;\nvar F; //the number of Follower\nvar ackNumber;// the number of ack received\nvar currentZxid = 0;\nvar T=3;\nvar data_reachability = false;\n\n\n//lsid vote to sid\n#define Vote(sid,lsid){\n        if(Epoch[sid] > Epoch[lsid])\n        {toVote[lsid]=sid;}\n        if(Epoch[sid] == Epoch[lsid] && CommitPro[sid] > CommitPro[lsid])\n        {toVote[lsid]=sid;}\n        if(Epoch[sid] == Epoch[lsid] && CommitPro[sid] == CommitPro[lsid] && sid >= toVote[lsid])\n        {toVote[lsid]=sid;}\n};\n\n//count Server sid the number of votes received\n#define countVote(sid){\n        voteNumber = 0;\n        var j = 0;\n        while(j < S)\n        {if(toVote[j] == sid){voteNumber++;}\n         j++;\n        }\n};\n#define emptyVote(i){\n        var j = 0;\n        while(j < S)\n        {toVote[j]=-1;\n         j++;\n        }\n};\n#define rollback(sid,zxid){\n        var j=zxid+1;\n        while(j<P)\n        {Proposal[sid][j]=0;\n        j++;\n        }\n};\n#define findNextPro(sid,lsid){\n        var zxid1=CommitPro[sid];\n        var zxid2=CommitPro[lsid]+1;\n        var flag=0;\n        nextZxid=-1;\n        while(zxid2<=zxid1 && flag == 0)\n        {if(Proposal[sid][zxid2] == 1 && Proposal[lsid][zxid2] == 0){nextZxid=zxid2;flag=1;}\n         if(Proposal[sid][zxid2] == 1 && Proposal[lsid][zxid2] == 1){CommitPro[lsid]=zxid2;}\n         if(Proposal[sid][zxid2] == 0){Proposal[lsid][zxid2]=0;}\n         zxid2++;\n        }\n};\n#define countAck(zxid){\n        var j = 0;\n        F=0;\n        ackNumber=0;\n        while(j<S)\n        {if(Status[j] == following)\n           {F++;\n            if(Proposal[j][zxid] == 1){ackNumber++;}\n           }\n         j++;\n        }     \n};\n#define findNextCom(fsid){\n        var zxid = CommitPro[fsid]+1;\n        var flag = 0;\n        while(zxid<P && flag==0)\n        {if(Proposal[fsid][zxid] == 1){nextZxid = zxid;flag = 1;}\n         zxid++;\n        }\n        if(zxid == P){nextZxid =-1;}\n};\nvar maxZxidServer = 2;\n////////////////Rules//////////////////\n/*@Process: Looker\n  The Lookersid () process is designed to handle the status and process transitions of the servers.\n  1.Wait for all servers to be in looking state.\n  2.If the number of leaders is 0, set the leader to the server that gets the most votes.\n  3.Once the current server receives votes from the majority, it switches to the leading state, indicating that it is recognized as a leader.\n  4.Enter the synchronization phase when the current server is not in the looking state or has a leader.\n  5.The current server may crash and then enter the Faild process.\n*/\nLooker(cid,sid) = [Status[sid] == looking](\n                  \t[leaderCount == 0](\n\t                  \tset{leaderID=maxZxidServer;}->\n                    \tif(maxZxidServer == sid){\n                    \t\tatomic{\n\t                              toBeLeader{Status[sid]=leading; \n\t                                         leaderCount++; \n\t                                         leaderID=sid; \n\t                                         CurrentEpoch=Epoch[sid]+1;\n\t                                         Epoch[sid]++; \n\t                                         call(emptyVote,1); \n\t                                         call(rollback,sid,CommitPro[sid]);\n\t                                         }\n\t                                 -> Leader(cid,sid)\n\t                                }\n                    \t}\n                    \telse{Synchronization(cid,sid)})\n                    [] [leaderCount == 1](Synchronization(cid,sid)))\n                    [] (fail.sid{Status[sid]=crashing;} -> Faild(cid,sid));\n/*@Process: Synchronization\n  After the leader is elected, the synchronization phase begins.This process is responsible for synchronizing transaction logs between the followers lsid and the leaderID.\n  1.Compare Commit Logs: Checks whether the leader's commit proposal ID is greater than the follower's to decide if synchronization is needed.\n  2.Call findNextPro Function: If synchronization is required, the function is called to find the next missing proposal.\n  3.Check Proposal Identifier: If a proposal is found, synchronization continues; otherwise, it retries synchronization.\n   4.Send Synchronization Request: Sends a request to the leader to fetch the missing proposal.\n  5.Receive Proposal and Update Log: Upon receiving the proposal from the leader, the follower updates its log and continues synchronization.\n\n*/\nSynchronization(cid,lsid) =if(CommitPro[leaderID] > CommitPro[lsid]){\n\t                           {call(findNextPro,leaderID,lsid);} ->\n\t                           if(nextZxid!=-1){\n\t                               ComSS[lsid*S+leaderID]!ReqProposal.lsid ->\n\t                               ComSS[lsid*S+leaderID]?RepProposal.lsid.Data{Proposal[lsid][nextZxid]=1; CommitPro[lsid]=nextZxid} ->\n\t                               Synchronization(cid,lsid)\n\t                           }\n\t                           else{Synchronization(cid,lsid)}\n\t                          }\n                              else{\n                           \t   \t     {call(rollback,lsid,CommitPro[leaderID]); CommitPro[lsid]=CommitPro[leaderID];} -> \n                           \t   \t     toBeFollower{Status[lsid] = following; Epoch[lsid] = CurrentEpoch;} -> \n                           \t   \t     Follower(cid,lsid)\n                           \t   \n                           };\n\n/*@Process: Client\n  When a leader exists, the system is not in the looking state, and the server does not crash, the Client can send a data read request to the server, receive a response from the server, or receive an ack message from the server. new proposals can be broadcast to other clients (followers) when the current server is leading.\n*/\n                                                  \nClient(cid,sid,zxid) = [leaderCount!=0 && Status[sid]!= looking && Status[sid]!= crashing](\n                  ComCS[cid*S+sid]!ReadData.cid.sid -> Client(cid,sid,zxid)\n                  []\n                  [Status[sid]==leading] ComCS[cid*S+sid]!WriteData.cid.sid.zxid.Data{Pro[zxid]=1;} -> Client(cid,sid,zxid)\n                  []\n                  ComCS[cid*S+sid]?sid.cid.Data.Response{data_reachability=true} -> Client(cid,sid,zxid)\n                  []\n                  ComCS[cid*S+leaderID]?p_ack -> Client(cid,sid,zxid));\n\n/*@Process: Leader\n  The main function of the Leader(cid, sid) process is to monitor and process the status of the leader.\n  Steps:\n  1.Status check: The Leader(cid, sid) process first checks whether the Status[sid] of the current sid is leading, that is, whether the current node is the leader.\n  2.If the current server is the leader, enter the Leader1 process.\n  3.If a fault occurs, the system enters the looking state to enter the Faild process.\n*/                  \nLeader(cid,sid) = [Status[sid] == leading] (\n                  (|||fsid:{0..S-1} @ (Leader1(cid,sid,fsid)))\n                  [] fail.sid{Status[sid]=looking; leaderCount=0 } -> Faild(cid,sid));\n\n/*@Process: Leader1\n  As the leader, handle communication with other nodes.\n  1. Leader processing: The leader checks its Status (Status[sid] == leading) and starts communicating with other nodes (fsid). It reads data from the communication channel and sends a response.\n  2.Follower state check: If fsid is in the following state (Status[fsid] == following), the leader writes proposal data to the communication channel and updates the proposal with a new zxid value.\n  3.Sending proposal: The leader sends a proposal message (SendProposalMsg) to the follower (fsid) and waits for an acknowledgment (f_ack) from the follower.\n  4.Acknowledgment and commit: Once the leader receives enough acknowledgments (ackNumber * 2 > F), it commits the proposal by updating the commit state and sends a commit acknowledgment (p_ack) to the follower.\n  5.Retry if insufficient acknowledgment: If the leader does not receive enough acknowledgments, it recursively calls the Leader1 process, retrying until the required number of acknowledgments is received and the proposal can be committed.\n*/     \n\n\nLeader1(cid,sid,fsid) = if(Status[sid] == leading && sid != fsid){\n\t\t\t            \tComCS[cid*S+sid]?ReadData.cid.sid -> ComCS[cid*S+sid]!sid.cid.Data.Response -> Leader1(cid,sid,fsid)\n\t\t\t            \t[]\n\t\t\t                [Status[fsid] == following](\n\t\t\t                    ComCS[cid*S+sid]?WriteData.cid.sid.zxid.Data{Proposal[sid][zxid]=1; currentZxid=zxid}->\n\t\t\t                    ComSS[sid*S+fsid]!SendProposalMsg.fsid.zxid.Data -> ComSS[sid*S+fsid]?f_ack ->\n\t\t\t                \tcal{call(countAck,currentZxid)}->\n\t\t\t                \tifa(ackNumber*2>F){\n\t                            \t{CommitPro[sid]=currentZxid}->\n\t                            \t(CommitProposal(sid,fsid,currentZxid));\n\t                            \tComCS[cid*S+sid]!p_ack->\n\t                            \tLeader1(cid,sid,fsid)\n\t                        \t}else{Leader1(cid,sid,fsid)})\n                  \t\t};\n/*@Process: SendProposal\n  SendProposal process corresponds to the Broadcast Phase, where its function is for the leader to broadcast proposals to followers and wait for an acknowledgment (ACK).\n*/\nSendProposal(cid,sid,fsid,zxid) = if(sid != fsid && Status[fsid] == following){\n\t                                  ComSS[sid*S+fsid]!SendProposalMsg.fsid.zxid.Data -> ComSS[sid*S+fsid]?f_ack -> Skip\n                                  };\n\n/*@Process: CommitProposal\n  CommitProposal process also corresponds to the Broadcast Phase, where after receiving enough acknowledgments, it sends a commit message to followers, ensuring the consistency and durability of the transaction.\n*/\n\nCommitProposal(sid,fsid,zxid) = if(sid != fsid && Status[fsid] == following){\n                                    ComSS[sid*S+fsid]!CommitProposalMsg.fsid.zxid -> Skip\n                                };\n\n/*@Process: Follower\n  1.Follower in following state:Data Read: If there is a leader, the follower processes data requests through ComCS.Receive Proposal: Upon receiving proposal messages from the leader, the follower updates the proposal and sends an acknowledgment (f_ack) to the leader.Handle Commit Proposal: Upon receiving commit proposal messages, the follower checks consistency and updates its commit log.\n  2.No Leader:If no leader exists (leaderCount == 0), the follower switches to looking state and enters the election phase.\n  3.If the server crashes (Status[fsid] = crashing), the process transitions to the failure handling phase (Faild).\n\nIf no leader exists (leaderCount == 0), the follower switches to looking state and enters the election phase.\nServer Failure:\n\nIf the server crashes (Status[fsid] = crashing), the process transitions to the failure handling phase (Faild).\n*/\nFollower(cid,fsid) = [Status[fsid]==following](\n                         [leaderCount>0]ComCS[cid*S+fsid]?ReadData.cid.fsid->ComCS[cid*S+fsid]!fsid.cid.Data.Response->Follower(cid,fsid)\n                         []\n                         [leaderCount>0]ComSS[leaderID*S+fsid]?SendProposalMsg.fsid.zxid.Data{Proposal[fsid][zxid]=1} -> ComSS[leaderID*S+fsid]!f_ack -> Follower(cid,fsid)\n                         []\n                         [leaderCount>0]ComSS[leaderID*S+fsid]?CommitProposalMsg.fsid.zxid{call(findNextCom,fsid)}->ifa(nextZxid == zxid){{CommitPro[fsid]=zxid}->Follower(cid,fsid)}else{Follower(cid,fsid)}\n                         []\n                         [leaderCount==0]{Status[fsid]=looking}->Looker(cid,fsid)\n                         []\n                         fail.fsid{Status[fsid]=crashing}->Faild(cid,fsid));\n/*@Process: Faild\n  Faild(cid, sid), describes the handling of a server crash. When the server status is crashing, the process performs a revive operation, changing the server's status to looking, indicating that the server is re-entering the election phase to find a new leader.\n*/\nFaild(cid,sid) = [Status[sid] == crashing](\n                 revive.sid{Status[sid] = looking} -> Looker(cid,sid)) ;\n\n/*@Process: Servers\n  The process Servers(cid, sid) determines the operation based on the server's status. \n  1.If the server's status is looking, meaning it is in the election process, the process calls Looker(cid, sid) to enter the election state.\n  2.If the server's status is leading, meaning it is the leader, the process calls Leader(cid, sid) to enter the leader operation state.\n  3.If the server's status is following, meaning it is a follower, the process calls Follower(cid, sid) to enter the follower operation state.\n  4.If the server is in any other state (e.g., crashing), the process calls Faild(cid, sid) to handle the failure case.\n*/\nServers(cid,sid) = if(Status[sid] == looking){Looker(cid,sid)}\n               else{\n                   if(Status[sid] == leading){Leader(cid,sid)}\n                   else{\n                       if(Status[sid] == following){Follower(cid,sid)}\n                       else{Faild(cid,sid)}\n                   }\n               };\n\n/*@Process: System\nThe system consists of multiple servers and clients concurrently.\n*/\n\nSystem() = || cid:{0..C-1}; zxid:{0..P-1}; sid:{0..S-1} @ (Client(cid,sid,zxid) || Servers(cid,sid));  \n////////////////The Properties//////////////////",
        "property_desc": [
            "The system is deadlock-free.",
            "The system is divergence-free.",
            "The Zab protocol should ensure that clients can successfully obtain the requested information.",
            "According to the CAP (Consistency, Availability, Partition tolerance) theorem [6], consistency refers to ensuring that all nodes in a distributed system will see the same data at the same time. We define the array Proposal[sid][zxid] to represent proposals stored locally by each server.",
            "The Zab protocol should ensure that all write operations are broadcast and executed in the order as they are received within the system. It means that under no circumstances where Proposal[sid][1] is received before Proposal[sid][0].",
            "Atomicity means each write operation is either fully broadcast and executed across all nodes or not executed at all. Thus, we adopt Pro[zxid] to record whether proposal with number zxid is sent. To guarantee the atomicity of message broadcasts, Proposal[sid][zxid] should have the same value as Pro[zxid]."
        ],
        "properties": [
            "#assert System() deadlockfree;",
            "#assert System() divergencefree;",
            "#define DataReachability(data_reachability == true);\n#assert System() reaches DataReachability;",
            "#define DataConsistency(Proposal[0][0]==1 && Proposal[1][0]==1 && Proposal[2][0] ==1 && CommitPro[0]==0 && CommitPro[1]==0 && CommitPro[2]==0);\n#define Consistency(Proposal[0][0] == Proposal[1][0] && Proposal[2][0] == Proposal[1][0] && CommitPro[0]== CommitPro[1] && CommitPro[2]== CommitPro[1]);\n#assert System() |= Consistency;",
            "#define Sequentiality(!((Proposal[0][0]==0&&CommitPro[0]==0)||(Proposal[1][0]==0&&CommitPro[1]==0)||(Proposal[2][0]==0&&CommitPro[2]==0)));\n#assert System() |= Sequentiality;",
            "#define Atomicity((Pro[0]==0&&Proposal[0][0]==0&&Proposal[1][0]==0&&Proposal[2][0]==0)||(Pro[0]==1&&Proposal[0][0]==1&&Proposal[1][0]==1&&Proposal[2][0]==1));\n#assert System() |= Atomicity;"
        ],
        "processes": [
            {
                "name": "Looker",
                "description": "The Lookersid () process is designed to handle the status and process transitions of the servers.\n  1.Wait for all servers to be in looking state.\n  2.If the number of leaders is 0, set the leader to the server that gets the most votes.\n  3.Once the current server receives votes from the majority, it switches to the leading state, indicating that it is recognized as a leader.\n  4.Enter the synchronization phase when the current server is not in the looking state or has a leader.\n  5.The current server may crash and then enter the Faild process.",
                "pat_code": "Looker(cid,sid) = [Status[sid] == looking](\n                  \t[leaderCount == 0](\n\t                  \tset{leaderID=maxZxidServer;}->\n                    \tif(maxZxidServer == sid){\n                    \t\tatomic{\n\t                              toBeLeader{Status[sid]=leading; \n\t                                         leaderCount++; \n\t                                         leaderID=sid; \n\t                                         CurrentEpoch=Epoch[sid]+1;\n\t                                         Epoch[sid]++; \n\t                                         call(emptyVote,1); \n\t                                         call(rollback,sid,CommitPro[sid]);\n\t                                         }\n\t                                 -> Leader(cid,sid)\n\t                                }\n                    \t}\n                    \telse{Synchronization(cid,sid)})\n                    [] [leaderCount == 1](Synchronization(cid,sid)))\n                    [] (fail.sid{Status[sid]=crashing;} -> Faild(cid,sid));"
            },
            {
                "name": "Synchronization",
                "description": "After the leader is elected, the synchronization phase begins.This process is responsible for synchronizing transaction logs between the followers lsid and the leaderID.\n  1.Compare Commit Logs: Checks whether the leader's commit proposal ID is greater than the follower's to decide if synchronization is needed.\n  2.Call findNextPro Function: If synchronization is required, the function is called to find the next missing proposal.\n  3.Check Proposal Identifier: If a proposal is found, synchronization continues; otherwise, it retries synchronization.\n   4.Send Synchronization Request: Sends a request to the leader to fetch the missing proposal.\n  5.Receive Proposal and Update Log: Upon receiving the proposal from the leader, the follower updates its log and continues synchronization.",
                "pat_code": "Synchronization(cid,lsid) =if(CommitPro[leaderID] > CommitPro[lsid]){\n\t                           {call(findNextPro,leaderID,lsid);} ->\n\t                           if(nextZxid!=-1){\n\t                               ComSS[lsid*S+leaderID]!ReqProposal.lsid ->\n\t                               ComSS[lsid*S+leaderID]?RepProposal.lsid.Data{Proposal[lsid][nextZxid]=1; CommitPro[lsid]=nextZxid} ->\n\t                               Synchronization(cid,lsid)\n\t                           }\n\t                           else{Synchronization(cid,lsid)}\n\t                          }\n                              else{\n                           \t   \t     {call(rollback,lsid,CommitPro[leaderID]); CommitPro[lsid]=CommitPro[leaderID];} -> \n                           \t   \t     toBeFollower{Status[lsid] = following; Epoch[lsid] = CurrentEpoch;} -> \n                           \t   \t     Follower(cid,lsid)\n                           \t   \n                           };"
            },
            {
                "name": "Client",
                "description": "When a leader exists, the system is not in the looking state, and the server does not crash, the Client can send a data read request to the server, receive a response from the server, or receive an ack message from the server. new proposals can be broadcast to other clients (followers) when the current server is leading.",
                "pat_code": "Client(cid,sid,zxid) = [leaderCount!=0 && Status[sid]!= looking && Status[sid]!= crashing](\n                  ComCS[cid*S+sid]!ReadData.cid.sid -> Client(cid,sid,zxid)\n                  []\n                  [Status[sid]==leading] ComCS[cid*S+sid]!WriteData.cid.sid.zxid.Data{Pro[zxid]=1;} -> Client(cid,sid,zxid)\n                  []\n                  ComCS[cid*S+sid]?sid.cid.Data.Response{data_reachability=true} -> Client(cid,sid,zxid)\n                  []\n                  ComCS[cid*S+leaderID]?p_ack -> Client(cid,sid,zxid));"
            },
            {
                "name": "Leader",
                "description": "The main function of the Leader(cid, sid) process is to monitor and process the status of the leader.\n  Steps:\n  1.Status check: The Leader(cid, sid) process first checks whether the Status[sid] of the current sid is leading, that is, whether the current node is the leader.\n  2.If the current server is the leader, enter the Leader1 process.\n  3.If a fault occurs, the system enters the looking state to enter the Faild process.",
                "pat_code": "Leader(cid,sid) = [Status[sid] == leading] (\n                  (|||fsid:{0..S-1} @ (Leader1(cid,sid,fsid)))\n                  [] fail.sid{Status[sid]=looking; leaderCount=0 } -> Faild(cid,sid));"
            },
            {
                "name": "Leader1",
                "description": "As the leader, handle communication with other nodes.\n  1. Leader processing: The leader checks its Status (Status[sid] == leading) and starts communicating with other nodes (fsid). It reads data from the communication channel and sends a response.\n  2.Follower state check: If fsid is in the following state (Status[fsid] == following), the leader writes proposal data to the communication channel and updates the proposal with a new zxid value.\n  3.Sending proposal: The leader sends a proposal message (SendProposalMsg) to the follower (fsid) and waits for an acknowledgment (f_ack) from the follower.\n  4.Acknowledgment and commit: Once the leader receives enough acknowledgments (ackNumber * 2 > F), it commits the proposal by updating the commit state and sends a commit acknowledgment (p_ack) to the follower.\n  5.Retry if insufficient acknowledgment: If the leader does not receive enough acknowledgments, it recursively calls the Leader1 process, retrying until the required number of acknowledgments is received and the proposal can be committed.",
                "pat_code": "Leader1(cid,sid,fsid) = if(Status[sid] == leading && sid != fsid){\n\t\t\t            \tComCS[cid*S+sid]?ReadData.cid.sid -> ComCS[cid*S+sid]!sid.cid.Data.Response -> Leader1(cid,sid,fsid)\n\t\t\t            \t[]\n\t\t\t                [Status[fsid] == following](\n\t\t\t                    ComCS[cid*S+sid]?WriteData.cid.sid.zxid.Data{Proposal[sid][zxid]=1; currentZxid=zxid}->\n\t\t\t                    ComSS[sid*S+fsid]!SendProposalMsg.fsid.zxid.Data -> ComSS[sid*S+fsid]?f_ack ->\n\t\t\t                \tcal{call(countAck,currentZxid)}->\n\t\t\t                \tifa(ackNumber*2>F){\n\t                            \t{CommitPro[sid]=currentZxid}->\n\t                            \t(CommitProposal(sid,fsid,currentZxid));\n\t                            \tComCS[cid*S+sid]!p_ack->\n\t                            \tLeader1(cid,sid,fsid)\n\t                        \t}else{Leader1(cid,sid,fsid)})\n                  \t\t};"
            },
            {
                "name": "SendProposal",
                "description": "SendProposal process corresponds to the Broadcast Phase, where its function is for the leader to broadcast proposals to followers and wait for an acknowledgment (ACK).",
                "pat_code": "SendProposal(cid,sid,fsid,zxid) = if(sid != fsid && Status[fsid] == following){\n\t                                  ComSS[sid*S+fsid]!SendProposalMsg.fsid.zxid.Data -> ComSS[sid*S+fsid]?f_ack -> Skip\n                                  };"
            },
            {
                "name": "CommitProposal",
                "description": "CommitProposal process also corresponds to the Broadcast Phase, where after receiving enough acknowledgments, it sends a commit message to followers, ensuring the consistency and durability of the transaction.",
                "pat_code": "CommitProposal(sid,fsid,zxid) = if(sid != fsid && Status[fsid] == following){\n                                    ComSS[sid*S+fsid]!CommitProposalMsg.fsid.zxid -> Skip\n                                };"
            },
            {
                "name": "Follower",
                "description": "1.Follower in following state:Data Read: If there is a leader, the follower processes data requests through ComCS.Receive Proposal: Upon receiving proposal messages from the leader, the follower updates the proposal and sends an acknowledgment (f_ack) to the leader.Handle Commit Proposal: Upon receiving commit proposal messages, the follower checks consistency and updates its commit log.\n  2.No Leader:If no leader exists (leaderCount == 0), the follower switches to looking state and enters the election phase.\n  3.If the server crashes (Status[fsid] = crashing), the process transitions to the failure handling phase (Faild).\n\nIf no leader exists (leaderCount == 0), the follower switches to looking state and enters the election phase.\nServer Failure:\n\nIf the server crashes (Status[fsid] = crashing), the process transitions to the failure handling phase (Faild).",
                "pat_code": "Follower(cid,fsid) = [Status[fsid]==following](\n                         [leaderCount>0]ComCS[cid*S+fsid]?ReadData.cid.fsid->ComCS[cid*S+fsid]!fsid.cid.Data.Response->Follower(cid,fsid)\n                         []\n                         [leaderCount>0]ComSS[leaderID*S+fsid]?SendProposalMsg.fsid.zxid.Data{Proposal[fsid][zxid]=1} -> ComSS[leaderID*S+fsid]!f_ack -> Follower(cid,fsid)\n                         []\n                         [leaderCount>0]ComSS[leaderID*S+fsid]?CommitProposalMsg.fsid.zxid{call(findNextCom,fsid)}->ifa(nextZxid == zxid){{CommitPro[fsid]=zxid}->Follower(cid,fsid)}else{Follower(cid,fsid)}\n                         []\n                         [leaderCount==0]{Status[fsid]=looking}->Looker(cid,fsid)\n                         []\n                         fail.fsid{Status[fsid]=crashing}->Faild(cid,fsid));"
            },
            {
                "name": "Faild",
                "description": "Faild(cid, sid), describes the handling of a server crash. When the server status is crashing, the process performs a revive operation, changing the server's status to looking, indicating that the server is re-entering the election phase to find a new leader.",
                "pat_code": "Faild(cid,sid) = [Status[sid] == crashing](\n                 revive.sid{Status[sid] = looking} -> Looker(cid,sid)) ;"
            },
            {
                "name": "Servers",
                "description": "The process Servers(cid, sid) determines the operation based on the server's status. \n  1.If the server's status is looking, meaning it is in the election process, the process calls Looker(cid, sid) to enter the election state.\n  2.If the server's status is leading, meaning it is the leader, the process calls Leader(cid, sid) to enter the leader operation state.\n  3.If the server's status is following, meaning it is a follower, the process calls Follower(cid, sid) to enter the follower operation state.\n  4.If the server is in any other state (e.g., crashing), the process calls Faild(cid, sid) to handle the failure case.",
                "pat_code": "Servers(cid,sid) = if(Status[sid] == looking){Looker(cid,sid)}\n               else{\n                   if(Status[sid] == leading){Leader(cid,sid)}\n                   else{\n                       if(Status[sid] == following){Follower(cid,sid)}\n                       else{Faild(cid,sid)}\n                   }\n               };"
            },
            {
                "name": "System",
                "description": "The system consists of multiple servers and clients concurrently.",
                "pat_code": "System() = || cid:{0..C-1}; zxid:{0..P-1}; sid:{0..S-1} @ (Client(cid,sid,zxid) || Servers(cid,sid));  \n////////////////The Properties//////////////////"
            }
        ],
        "global_definition": "////////////////The Model//////////////////\n#define C 1; //number of clients\n#define S 3; //number of Servers\n#define P 1; //number of Proposals\n\n\n////////////////Global Variables//////////////////\nenum{Request,Response,Data};\nenum{Election,LeaderMsg,VoteMsg,ToBeFollower,ReqProposal,RepProposal,ReadData,WriteData,SendProposalMsg,CommitProposalMsg,Faid};\nenum{syn_ack,p_ack,f_ack,join_ack};\nenum{looking,following,leading,crashing};\nchannel ComCS[C*S] 0; //channel between Client and Server\nchannel ComSS[S*S] 0; //channel between Server i and Server j\nvar Status[S] = [looking,looking,looking]; //record the status of the server i\nvar toVote[S]; // record the voting result of the server i\nvar Epoch[S]; //Server i current epoch\nvar CommitPro[S]=[-1,-1,-1]; // Server i current max zxid of proposal committed\nvar Look[S]; //number of Lookers\nvar Pro[P];\nvar Proposal[S][P];\nvar leaderCount = 0;\nvar leaderID = -1;\nvar CurrentEpoch = 0;\nvar voteNumber = 0;\nvar nextZxid = -1;\nvar F; //the number of Follower\nvar ackNumber;// the number of ack received\nvar currentZxid = 0;\nvar T=3;\nvar data_reachability = false;\n\n\n//lsid vote to sid\n#define Vote(sid,lsid){\n        if(Epoch[sid] > Epoch[lsid])\n        {toVote[lsid]=sid;}\n        if(Epoch[sid] == Epoch[lsid] && CommitPro[sid] > CommitPro[lsid])\n        {toVote[lsid]=sid;}\n        if(Epoch[sid] == Epoch[lsid] && CommitPro[sid] == CommitPro[lsid] && sid >= toVote[lsid])\n        {toVote[lsid]=sid;}\n};\n\n//count Server sid the number of votes received\n#define countVote(sid){\n        voteNumber = 0;\n        var j = 0;\n        while(j < S)\n        {if(toVote[j] == sid){voteNumber++;}\n         j++;\n        }\n};\n#define emptyVote(i){\n        var j = 0;\n        while(j < S)\n        {toVote[j]=-1;\n         j++;\n        }\n};\n#define rollback(sid,zxid){\n        var j=zxid+1;\n        while(j<P)\n        {Proposal[sid][j]=0;\n        j++;\n        }\n};\n#define findNextPro(sid,lsid){\n        var zxid1=CommitPro[sid];\n        var zxid2=CommitPro[lsid]+1;\n        var flag=0;\n        nextZxid=-1;\n        while(zxid2<=zxid1 && flag == 0)\n        {if(Proposal[sid][zxid2] == 1 && Proposal[lsid][zxid2] == 0){nextZxid=zxid2;flag=1;}\n         if(Proposal[sid][zxid2] == 1 && Proposal[lsid][zxid2] == 1){CommitPro[lsid]=zxid2;}\n         if(Proposal[sid][zxid2] == 0){Proposal[lsid][zxid2]=0;}\n         zxid2++;\n        }\n};\n#define countAck(zxid){\n        var j = 0;\n        F=0;\n        ackNumber=0;\n        while(j<S)\n        {if(Status[j] == following)\n           {F++;\n            if(Proposal[j][zxid] == 1){ackNumber++;}\n           }\n         j++;\n        }     \n};\n#define findNextCom(fsid){\n        var zxid = CommitPro[fsid]+1;\n        var flag = 0;\n        while(zxid<P && flag==0)\n        {if(Proposal[fsid][zxid] == 1){nextZxid = zxid;flag = 1;}\n         zxid++;\n        }\n        if(zxid == P){nextZxid =-1;}\n};\nvar maxZxidServer = 2;\n////////////////Rules//////////////////",
        "path": "handwrite/ZAB.csp"
    }
]